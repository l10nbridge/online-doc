<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>Handling Touch Gestures</title>
      
</head>

<body onload="prettyPrint()" style="overflow: auto;">
	
<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#initial">Initializing Touch Gestures</a></li>
			<li><a href="#tap">Implementing Tap Gestures</a></li>
			<li><a href="#momentum">Implementing Momentum Gestures</a></li>
			<li><a href="#line">Implementing Line Gestures</a></li>
			<li><a href="#flick">Implementing Flick Gestures</a></li>
			<li><a href="#zoom">Implementing Zoom Gestures</a></li>
			<li><a href="#rotate">Implementing Rotate Gestures</a></li>
		</ul>		
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Elementary.html">Elementary API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Elm__Gesture__Layer.html">Gesture Layer API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Elementary.html">Elementary API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Elm__Gesture__Layer.html">Gesture Layer API for Wearable Native</a></li>			
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>Handling Touch Gestures</h1>
  
<p>You can implement your application to recognize and react to different types of gestures provided by the EFL library.</p>

<p>The elementary library provides a gesture layer for a wide range of touch gestures, such as tap, double tap, triple tap, long tap, momentum monitoring, line, flick, zoom, and rotate, which can be used by the application to build a dynamic user interface interaction which is simple and intuitive to use.</p>

<h2 id="initial" name="initial">Initializing Touch Gestures</h2>

<p>To initialize the touch gestures:</p>
<ol>
<li>
<p>Create a window for the application layout.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">evas_object_rectangle_add()</span> function adds a rectangle for getting user input in the same Evas with a window object.</p>
<pre class="prettyprint">
Evas_Object *win;
Evas_Object *r; /* Gesture layer transparent object */
Evas_Object *g; /* Gesture layer object */

win = elm_win_util_standard_add(&quot;gesture_layer&quot;, &quot;Gesture Layer&quot;);
elm_win_autodel_set(win, EINA_TRUE);

/* Gesture layer transparent object */
r = evas_object_rectangle_add(evas_object_evas_get(win));
evas_object_move(r, 0, 0);
evas_object_color_set(r, 0, 0, 0, 0);
elm_win_resize_object_add(win, r);
</pre>
</li>
<li>
<p>Create a new gesture layer with the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_add()</span> function.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_attach()</span> function attaches a given gesture layer to an <span style="font-family: Courier New,Courier,monospace">Evas_Object</span>. This object listens to all mouse and key events, and reports the gestures made upon it.</p>
<pre class="prettyprint">
/* Gesture layer object */
g = elm_gesture_layer_add(win);
elm_gesture_layer_attach(g, r);
evas_object_show(r);
</pre>
</li>
</ol>

<h2 id="tap" name="tap">Implementing Tap Gestures</h2>

<p>You can configure some properties of the tap gestures:</p>

<ul><li>
<p>Modify the timeout value for a long tap or double tap gesture.</p>
<p>The default values are defined in the system policy. In the Tizen SDK 2.4, they are 0.5 seconds for a long tap, and 0.33 seconds for a double tap.</p>
<pre class="prettyprint">
/* Get or set the gesture layer long tap start timeout of an object */
void elm_gesture_layer_long_tap_start_timeout_set(Evas_Object *obj, double long_tap_start_timeout);
double elm_gesture_layer_long_tap_start_timeout_get(const Evas_Object *obj);

/* Get or set the gesture layer double tap timeout of an object */
void elm_gesture_layer_double_tap_timeout_set(Evas_Object *obj, double double_tap_timeout);
double elm_gesture_layer_double_tap_timeout_get(const Evas_Object *obj);
</pre></li>

<li><p>The gesture layer uses the finger size to detect a double and triple tap. If you do not set a finger size, the gesture layer uses the default <span style="font-family: Courier New,Courier,monospace">elm_config</span> finger size defined in the system policy. In the Tizen SDK 2.4, it is 40.</p>
<p>You can also define the tolerance for each tap.</p>
<pre class="prettyprint">
/* Get or set the gesture layer finger size for taps */
void elm_gesture_layer_tap_finger_size_set(Evas_Object *obj, Evas_Coord sz);
Evas_Coord elm_gesture_layer_tap_finger_size_get(const Evas_Object *obj);
</pre></li></ul>

<p>The gesture layer supports 4 types of tap gestures and 4 gesture states:</p>
<pre class="prettyprint">
/* Gesture types */
ELM_GESTURE_N_TAPS, /* Single tap */
ELM_GESTURE_N_LONG_TAPS, /* Long tap */
ELM_GESTURE_N_DOUBLE_TAPS, /* Double tap */
ELM_GESTURE_N_TRIPLE_TAPS, /* Triple tap */

/* Gesture states */
ELM_GESTURE_STATE_START, /* Gesture started */
ELM_GESTURE_STATE_MOVE, /* Gesture ongoing */
ELM_GESTURE_STATE_END, /* Gesture completed */
ELM_GESTURE_STATE_ABORT /* Ongoing gesture aborted */
</pre>

<p>To use the various tap gestures:</p>
<ul>
<li>Single tap
<ol>
<li><p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TAPS, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_finger_tap_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TAPS, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_finger_tap_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TAPS, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_finger_tap_abort, NULL);
</pre>
</li>
<li>
<p>When a mouse down event occurs, the <span style="font-family: Courier New,Courier,monospace">n_finger_tap_start()</span> callback function is called:</p>
<pre class="prettyprint">
/* Start gesture callback */
static Evas_Event_Flags
n_finger_tap_start(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Taps_Info *p = (Elm_Gesture_Taps_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;N tap started &lt;%p&gt; x,y=&lt;%d,%d&gt; count=&lt;%d&gt; timestamp=&lt;%d&gt; \n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event_info, p-&gt;x, p-&gt;y, p-&gt;n, p-&gt;timestamp);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
<p>The function returns <span style="font-family: Courier New,Courier,monospace">EVAS_EVENT_FLAG_ON_HOLD</span>, if the component acted upon the event.</p>
 
<p>The <span style="font-family: Courier New,Courier,monospace">event_info</span> attribute contains the tap information in the <span style="font-family: Courier New,Courier,monospace">_Elm_Gesture_Taps_Info</span> data structure. If the number of fingers is bigger than 2, the <span style="font-family: Courier New,Courier,monospace">x</span> and <span style="font-family: Courier New,Courier,monospace">y</span> values get the average value of each <span style="font-family: Courier New,Courier,monospace">x</span> and <span style="font-family: Courier New,Courier,monospace">y</span> geometry values.</p>
<pre class="prettyprint">
struct _Elm_Gesture_Taps_Info {
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord x, y; /* Center point between fingers */
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int n; /* Number of fingers tapped */
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int timestamp; /* Event timestamp */
};
</pre>
</li>
<li>
<p>When a mouse up event occurs, and the current tap gesture is in the <span style="font-family: Courier New,Courier,monospace">ELM_GESTURE_STATE_START</span> state, the <span style="font-family: Courier New,Courier,monospace">n_finger_tap_end()</span> callback function is called:</p>
<pre class="prettyprint">
static Evas_Event_Flags
n_finger_tap_end(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Taps_Info *p = (Elm_Gesture_Taps_Info *)event_info;

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;N tap started &lt;%p&gt; x,y=&lt;%d,%d&gt; count=&lt;%d&gt; timestamp=&lt;%d&gt; \n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event_info, p-&gt;x, p-&gt;y, p-&gt;n, p-&gt;timestamp);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>When an unexpected event occurs after a mouse down event, the <span style="font-family: Courier New,Courier,monospace">n_finger_tap_abort()</span> callback function is called.</p>
<p>For example, if a move event occurs after a tap start callback function is called, or a down event occurs after a long-press event.</p>
<pre class="prettyprint">
static Evas_Event_Flags
n_finger_tap_abort(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Taps_Info *p = (Elm_Gesture_Taps_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;N tap abort\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
</ol>
</li>

<li>Double tap
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_DOUBLE_TAPS, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbl_click_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_DOUBLE_TAPS, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbl_click_move, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_DOUBLE_TAPS, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbl_click_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_DOUBLE_TAPS, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbl_click_abort, NULL);
</pre>
</li>
<li><p>A double tap gesture is started by calling the <span style="font-family: Courier New,Courier,monospace">dbl_click_start()</span> callback function when a mouse down event occurs.</p>

<p>After a mouse down event occurs, a mouse up event has to occur within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> time limit.</p>
<p>In this case, the <span style="font-family: Courier New,Courier,monospace">dbl_click_move()</span> callback function is called, which means a double tap gesture event is ongoing. Otherwise, the abort callback function is called.</p>
<p>If the mouse up is not called within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> value, the touch event moves out of the area defined in the down event geometry.</p>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">dbl_click_end()</span> callback function is called when the same area is clicked 2 times within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> value (meaning that the <span style="font-family: Courier New,Courier,monospace">dbl_click_move()</span> callback function has been called 2 times).</p>

<p>If any wrong gesture is detected during the double tap gesture detection, the <span style="font-family: Courier New,Courier,monospace">dbl_click_abort()</span> callback function is called.</p>
</li>
</ol>
</li>
<li>Triple tap
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TRIPLE_TAPS, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triple_click_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TRIPLE_TAPS, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triple_click_move, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TRIPLE_TAPS, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triple_click_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_TRIPLE_TAPS, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triple_click_abort, NULL);
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">triple_click_start()</span> callback function is called when a mouse down event occurs.</p>

<p>After a mouse down occurs, a mouse up event has to occur within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> value. If so, the <span style="font-family: Courier New,Courier,monospace">triple_click_move()</span> callback function is called, which means a triple tap gesture event is ongoing. Otherwise, the abort callback is called.</p>
<p>If the mouse up is not called within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> value, the touch event moves out of the area defined in the down event geometry.</p>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">triple_click_end()</span> callback function is called if the same area is clicked 3 times within the <span style="font-family: Courier New,Courier,monospace">double_tap_timeout</span> value (meaning that the <span style="font-family: Courier New,Courier,monospace">triple_click_move()</span> callback function has been called 3 times: 1 tap start and move, 2 tap move and move, and 3 tap move and end).</p>

<p>If any wrong gesture is detected during the triple tap gesture detection, the <span style="font-family: Courier New,Courier,monospace">triple_click_abort()</span> callback function is called.</p>
</li>
</ol>
</li>
<li>Long tap
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LONG_TAPS, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_long_tap_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LONG_TAPS, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_long_tap_move, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LONG_TAPS, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_long_tap_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LONG_TAPS, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_long_tap_abort, NULL);
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">n_long_tap_start()</span> callback function is called when a mouse down event occurs.</p>

<p>After a mouse down occurs, the mouse down state has to remain for a time defined in the <span style="font-family: Courier New,Courier,monospace">long_tap_timeout</span> value.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">n_long_tap_move()</span> callback function is called after the <span style="font-family: Courier New,Courier,monospace">long_tap_timeout</span> time. If the down gesture continues, the <span style="font-family: Courier New,Courier,monospace">n_long_tap_move()</span> callback function is called at the <span style="font-family: Courier New,Courier,monospace">long_tap_timeout</span> time value intervals, such as 0.5, 1.0, and 1.5.</p>
</li>
<li>
<p>After the <span style="font-family: Courier New,Courier,monospace">n_long_tap_move()</span> callback function is called, if the mouse up event occurs in the same geometry with the down event, the <span style="font-family: Courier New,Courier,monospace">n_long_tap_end()</span> callback function is called.</p>
<p>If any wrong gesture is detected during the long tap gesture detection, the <span style="font-family: Courier New,Courier,monospace">n_long_tap_abort()</span> callback function is called.</p>
</li>
</ol>
</li>
</ul>

<h2 id="momentum" name="momentum">Implementing Momentum Gestures</h2>

<p>The momentum gesture is used for detecting any move events on the gesture layer and getting event information to make a meaningful gesture action. The momentum gesture is used for detecting line, zoom, and rotate gestures as well.</p>

<p>The momentum gesture states the same as in the <a href="#tap">tap gesture</a>.</p>

<p>To implement a momentum gesture:</p>
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_MOMENTUM, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;momentum_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_MOMENTUM, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;momentum_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_MOMENTUM, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;momentum_abort, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_MOMENTUM, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;momentum_move, NULL);
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">momentum_start()</span> callback function is called when a mouse move event occurs after a mouse down event:</p>
<pre class="prettyprint">
static Evas_Event_Flags
momentum_start(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Momentum_Info *p = (Elm_Gesture_Momentum_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;momentum started x1,y1=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; n=&lt;%u&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x1, p-&gt;y1, p-&gt;tx, p-&gt;ty, p-&gt;n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">event_info</span> attribute contains the momentum information in the <span style="font-family: Courier New,Courier,monospace">Elm_Gesture_Momentum_Info</span> data structure:</p>
<pre class="prettyprint">
/* Report line ends, timestamps, and momentum computed */
struct _Elm_Gesture_Momentum_Info {
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord x1; /* Final-swipe direction with starting point on X */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord y1; /* Final-swipe direction with starting point on Y */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord x2; /* Final-swipe direction with ending point on X */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord y2; /* Final-swipe direction with ending point on Y */

&nbsp;&nbsp;&nbsp;&nbsp;unsigned int tx; /* Timestamp of the start of the final X swipe */
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int ty; /* Timestamp of the start of the final Y swipe */

&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord mx; /* Momentum on X */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord my; /* Momentum on Y */

&nbsp;&nbsp;&nbsp;&nbsp;unsigned int n; /* Number of fingers */
};
</pre>

<p>The x1 and y1 coordinates are not necessarily in sync. The x1 coordinate holds the X value of the X direction starting point, and the y1 coordinate holds the same for Y. This is noticeable when doing a V-shaped movement.</p>

</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">momentum_move()</span> callback function is called whenever mouse move events are detected:</p>
<pre class="prettyprint">
static Evas_Event_Flags
momentum_move(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Momentum_Info *p = (Elm_Gesture_Momentum_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;momentum move x1,y1=&lt;%d,%d&gt; x2,y2=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; mx=&lt;%d&gt; my=&lt;%d&gt; n=&lt;%u&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x1, p-&gt;y1, p-&gt;x2, p-&gt;y2, p-&gt;tx, p-&gt;ty, p-&gt;mx, p-&gt;my, p-&gt;n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>The mouse up event occurs after the mouse move events have been detected. The gesture layer checks the <span style="font-family: Courier New,Courier,monospace">mx</span> and <span style="font-family: Courier New,Courier,monospace">my</span> values internally. If <span style="font-family: Courier New,Courier,monospace">mx</span> and <span style="font-family: Courier New,Courier,monospace">my</span> have values, the <span style="font-family: Courier New,Courier,monospace">momentum_end()</span> callback function is called. Otherwise, <span style="font-family: Courier New,Courier,monospace">mx</span> and <span style="font-family: Courier New,Courier,monospace">my</span> have 0 values in the mouse up time, and the <span style="font-family: Courier New,Courier,monospace">momentum_abort()</span> callback function is called.</p>
<pre class="prettyprint">
static Evas_Event_Flags
momentum_end(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Momentum_Info *p = (Elm_Gesture_Momentum_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;momentum ended x1,y1=&lt;%d,%d&gt; x2,y2=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; mx=&lt;%d&gt; my=&lt;%d&gt; n=&gt;%u&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x1, p-&gt;y1, p-&gt;x2, p-&gt;y2, p-&gt;tx, p-&gt;ty, p-&gt;mx, p-&gt;my, p-&gt;n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}

static Evas_Event_Flags
momentum_abort(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;momentum abort\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
</ol>
<h2 id="line" name="line">Implementing Line Gestures</h2>

<p>The line gesture is used for detecting mouse move events. The gesture layer checks each event to determine whether to draw a line.</p>

<p>You can configure some properties of the line gestures:</p>

<ul><li>
<p>Modify the minimum length and distance tolerance of a line.</p>
<p>The default values are defined in the system policy. In the Tizen SDK 2.4, they are 40 for the minimum length, and 40 for the distance tolerance.</p>
<pre class="prettyprint">
/* Get or set the gesture layer line min length of an object */
void elm_gesture_layer_line_min_length_set(Evas_Object *obj, int line_min_length);
int elm_gesture_layer_line_min_length_get(const Evas_Object *obj);

/* Get or set the gesture layer line distance tolerance of an object */
void elm_gesture_layer_line_distance_tolerance_set(Evas_Object *obj, Evas_Coord line_distance_tolerance);
Evas_Coord elm_gesture_layer_line_distance_tolerance_get(const Evas_Object *obj);
</pre></li>

<li>
<p>Enable the continue mode to allow the line, flick, zoom, and rotate gesture to restart. The default value is <span style="font-family: Courier New,Courier,monospace">TRUE</span>.</p>
<p>For example, when drawing a line, the finger can stop moving while the finger stays on the touch screen. This action makes the line end. After the finger continues to move, the line gesture restarts. When the continue mode is disabled, the finger has to be lifted off the touch screen to end a gesture, and then touch the screen again to start a new gesture.</p>
<pre class="prettyprint">
/* Get or set the gesture layer continue mode of an object */
void elm_gesture_layer_continues_enable_set(Evas_Object *obj, Eina_Bool continues_enable);
Eina_Bool elm_gesture_layer_continues_enable_get(const Evas_Object *obj);
</pre>
</li></ul>

<p>The line gesture states are the same as in the <a href="#tap">tap gesture</a>.</p>

<p>To create a line gesture:</p>
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LINES, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LINES, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_move, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LINES, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_LINES, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_abort, NULL);
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">line_start()</span> callback function is called when a mouse move event occurs after a mouse down event:</p>
<pre class="prettyprint">
static Evas_Event_Flags
line_start(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Line_Info *p = (Elm_Gesture_Line_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;line started angle=&lt;%lf&gt; x1,y1=&lt;%d,%d&gt; x2,y2=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; n=&lt;%u&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;angle, p-&gt;momentum.x1, p-&gt;momentum.y1, p-&gt;momentum.x2, p-&gt;momentum.y2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;momentum.tx, p-&gt;momentum.ty, p-&gt;momentum.n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">event_info</span> attribute contains the line information in the <span style="font-family: Courier New,Courier,monospace">Elm_Gesture_Line_Info</span> data structure:</p>
<pre class="prettyprint">
struct _Elm_Gesture_Line_Info {
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Momentum_Info momentum; /* Line momentum info */
&nbsp;&nbsp;&nbsp;&nbsp;double angle; /* Angle (direction) of the lines */
};
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">line_move()</span> callback function is called on every mouse move event detected except when the line distance is outside the tolerance distance value.</p>
<p>If the continue mode is enabled and the momentum value is 0, the callback is not called.</p>
<pre class="prettyprint">
static Evas_Event_Flags
line_move(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Line_Info *p = (Elm_Gesture_Line_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;line move angle=&lt;%lf&gt; x1,y1=&lt;%d,%d&gt; x2,y2=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; n=&lt;%u&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;angle, p-&gt;momentum.x1, p-&gt;momentum.y1, p-&gt;momentum.x2, p-&gt;momentum.y2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;momentum.tx, p-&gt;momentum.ty, p-&gt;momentum.n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">line_end</span> callback function is called when a mouse up event occurs with a gesture that is longer than the line minimum length value. If the continue mode is enabled, the callback is called when the user stops drawing a line and the timing is started again. (Pause after the timing restart; either the end callback is called, or if the mouse up does not happen, the start callback is called again).</p>
<pre class="prettyprint">
static Evas_Event_Flags
line_end(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Line_Info *p = (Elm_Gesture_Line_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;line end angle=&lt;%lf&gt; x1,y1=&lt;%d,%d&gt; x2,y2=&lt;%d,%d&gt; tx,ty=&lt;%u,%u&gt; n=&lt;%u&gt;,\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;angle, p-&gt;momentum.x1, p-&gt;momentum.y1, p-&gt;momentum.x2, p-&gt;momentum.y2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;momentum.tx, p-&gt;momentum.ty, p-&gt;momentum.n);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">line_abort()</span> callback function is called when a mouse move event occurs and the geometry angle is outside the tolerance angle value and the line is shorter than the line minimum length value:</p>
<pre class="prettyprint">
static Evas_Event_Flags
line_abort(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Line_Info *p = (Elm_Gesture_Line_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;line abort\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
</ol>

<h2 id="flick" name="flick">Implementing Flick Gestures</h2>

<p>You can modify the flick time limit of the flick gesture.</p>
<p>The default value is defined in the system policy. In the Tizen SDK 2.4, it is 250 ms.</p>
<pre class="prettyprint">
/* Get or set the gesture layer flick time limit (in milliseconds) of an object */
void elm_gesture_layer_flick_time_limit_ms_set(Evas_Object *obj, unsigned int flick_time_limit_ms);
unsigned int elm_gesture_layer_flick_time_limit_ms_get(const Evas_Object *obj);
</pre>

<p>The flick gesture states and the gesture info data structures are the same as in the <a href="#line">line gesture</a>.</p>

<p>To create a flick gesture:</p>
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_FLICKS, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flick_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_FLICKS, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flick_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_N_FLICKS, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flick_abort, NULL);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">flick_move()</span> callback function works the same way as the <span style="font-family: Courier New,Courier,monospace">line_move()</span> callback.</p>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">flick_start()</span> callback function is called when a mouse move event occurs after a mouse down event.</p>
<p>After calling the <span style="font-family: Courier New,Courier,monospace">flick_start()</span> callback function, the gesture layer detects a line gesture on it. If so, it checks the flick time limit, and if the line event occurs within the limit, the <span style="font-family: Courier New,Courier,monospace">flick_end()</span> callback function is called. Otherwise, the <span style="font-family: Courier New,Courier,monospace">flick_abort()</span> callback function is called.</p>
</li>
</ol>


<h2 id="zoom" name="zoom">Implementing Zoom Gestures</h2>

<p>You can modify various zoom values, such as zoom step and distance tolerance.</p>
<p>The default values are defined in the system policy. In the Tizen SDK 2.4, they are:</p>
<ul>
	<li><span style="font-family: Courier New,Courier,monospace">zoom_step</span>: 0.0</li>
	<li><span style="font-family: Courier New,Courier,monospace">zoom_finger_factor</span>: 1.0</li>
	<li><span style="font-family: Courier New,Courier,monospace">zoom_wheel_factor</span>: 0.05</li>
	<li><span style="font-family: Courier New,Courier,monospace">zoom_distance_tolerance</span>: 1.0</li>
</ul>

<pre class="prettyprint">
/* Get or set the step value for zoom action */
void elm_gesture_layer_zoom_step_set(Evas_Object *obj, double step);
double elm_gesture_layer_zoom_step_get(const Evas_Object *obj);

/* Get or set the gesture layer zoom distance tolerance of an object */
void elm_gesture_layer_zoom_distance_tolerance_set(Evas_Object *obj, Evas_Coord zoom_distance_tolerance);
Evas_Coord elm_gesture_layer_zoom_distance_tolerance_get(const Evas_Object *obj);

/* Get or set the gesture layer zoom wheel factor of an object */
void elm_gesture_layer_zoom_wheel_factor_set(Evas_Object *obj, double zoom_wheel_factor);
double elm_gesture_layer_zoom_wheel_factor_get(const Evas_Object *obj);

/* Get or set the gesture layer zoom finger factor of an object */
void elm_gesture_layer_zoom_finger_factor_set(Evas_Object *obj, double zoom_finger_factor);
double elm_gesture_layer_zoom_finger_factor_get(const Evas_Object *obj);
</pre>

<p>The zoom gesture states are the same as in the <a href="#tap">tap gesture</a>.</p>

<p>When using zoom gestures, pay attention to the following:</p>
<ul><li>
<p>The default zoom value is 1, when the zoom gesture starts. After every zoom gesture, the value is increased or decreased according to the internal calculation logic. The radius value is used for the calculation.</p></li>
<li><p>If the mouse wheel events are sent with the <strong>Ctrl</strong> key on the gesture layer, the <span style="font-family: Courier New,Courier,monospace">zoom_start()</span> callback function is called with the default zoom value (1) and the zoom value (<span style="font-family: Courier New,Courier,monospace">zoom_finger_factor * zoom _wheel_factor</span>) is increased or decreased on every step to follow the wheel up or down.</p></li>
<li><p>If a 2-finger down event points closer than the zoom distance tolerance value, the zoom gesture is not started. After the gap is bigger than the <span style="font-family: Courier New,Courier,monospace">zoom_distance_tolerance</span> value, the zoom gesture is started with the default value 1 and the event info gets a radius value and the gesture&#39;s momentum value.</p></li></ul>

<p>To create a zoom gesture:</p>
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_ZOOM, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ZOOM, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ZOOM, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom_abort, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ZOOM, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoom_move, NULL);
</pre>
</li>
<li>
<p>When 2 mouse down events occur, the <span style="font-family: Courier New,Courier,monospace">zoom_start()</span> callback function is called with the zoom value (1), and the calculated radius and momentum for the current zoom gesture:</p>
<pre class="prettyprint">
static Evas_Event_Flags
zoom_start(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Zoom_Info *p = (Elm_Gesture_Zoom_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;zoom started &lt;%d,%d&gt; zoom=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;zoom, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">event_info</span> attribute contains the zoom information in the <span style="font-family: Courier New,Courier,monospace">Elm_Gesture_Zoom_Info</span> data structure:</p>
<pre class="prettyprint">
struct _Elm_Gesture_Zoom_Info {
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord x, y; /* Zoom center point reported to the user */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord radius; /* Radius between fingers reported to the user */
&nbsp;&nbsp;&nbsp;&nbsp;double zoom; /* Zoom value: 1.0 means no zoom */
&nbsp;&nbsp;&nbsp;&nbsp;double momentum; /* Zoom momentum: zoom growth per second (NOT YET SUPPORTED) */
};
</pre>

</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">zoom_move()</span> callback function is called when the user moves 2 mouse down events, except that the gap of each mouse down point is smaller than the <span style="font-family: Courier New,Courier,monospace">zoom_distance_tolerance</span> value.</p>

<p>The normal zoom gesture detecting logic:</p>
<ol type="a">
	<li>The gesture layer remembers the gap of each touched geometry.</li>
	<li>When the user moves each touched point, the gesture layer calculates the gap of each touched geometry for each move event.</li>
	<li>If the values (gap + <span style="font-family: Courier New,Courier,monospace">zoom_distance_tolerance</span>, gap – <span style="font-family: Courier New,Courier,monospace">zoom_distance_tolerance</span>) are bigger or smaller than the first calculated gap values, the gesture layer calls the <span style="font-family: Courier New,Courier,monospace">zoom_move()</span> callback function with the calculated result.</li>
</ol>
<pre class="prettyprint">
static Evas_Event_Flags
zoom_move(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Zoom_Info *p = (Elm_Gesture_Zoom_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;zoom move &lt;%d,%d&gt; zoom=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;zoom, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>When the mouse up event occurs and the <strong>Ctrl</strong> key up signal is detected (in case of zooming with a mouse wheel and <strong>Ctrl</strong> key), the <span style="font-family: Courier New,Courier,monospace">zoom_end()</span> callback function is called:</p>
<pre class="prettyprint">
static Evas_Event_Flags
zoom_end(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Zoom_Info *p = (Elm_Gesture_Zoom_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;zoom end &lt;%d,%d&gt; zoom=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;zoom, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>When the down event count is bigger than 3, the <span style="font-family: Courier New,Courier,monospace">zoom_abort()</span> callback function is called.</p>
<pre class="prettyprint">
static Evas_Event_Flags
zoom_abort(void *data, void *event_info EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;zoom abort\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
</ol>

<h2 id="rotate" name="rotate">Implementing Rotate Gestures</h2>

<p>You can modify the rotate step and tolerance.</p>
<p>The default values are defined in the system policy. In the Tizen SDK 2.4, they are 0.0 for the rotate step, and 0.0349 for the angular tolerance.</p>
<pre class="prettyprint">
/* Get or set the step value for rotate action */
void elm_gesture_layer_rotate_step_set(Evas_Object *obj, double step);
double elm_gesture_layer_rotate_step_get(const Evas_Object *obj);

/* Get or set the gesture layer rotate angular tolerance of an object */
void elm_gesture_layer_rotate_angular_tolerance_set(Evas_Object *obj, double rotate_angular_tolerance);
double elm_gesture_layer_rotate_angular_tolerance_get(const Evas_Object *obj);
</pre>

<p>The rotate gesture states are the same as in the <a href="#tap">tap gesture</a>.</p>

<p>When using rotate gestures, pay attention to the following:</p>
<ul><li>
<p>When the gesture layer has detected 2 mouse down events, calculate the angle between the 2 points.</p>
<p>Then the gesture layer detects every mouse move event for calculating the angle between the 2 points. If the angle value is bigger than the sum of the first calculated angle and <span style="font-family: Courier New,Courier,monospace">rotate_angular_tolerance</span>, the <span style="font-family: Courier New,Courier,monospace">rotate_move()</span> callback function is called with the result.</p></li>
<li><p>If the step for the rotate gesture is set, the <span style="font-family: Courier New,Courier,monospace">rotate_move()</span> callback function is called on every step.</p></li></ul>

<p>To create a rotate gesture:</p>
<ol>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">elm_gesture_layer_cb_set()</span> function to set callbacks to be notified about the change of the gesture state:</p>
<pre class="prettyprint">
elm_gesture_layer_cb_set(g, ELM_GESTURE_ROTATE, ELM_GESTURE_STATE_START,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate_start, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ROTATE, ELM_GESTURE_STATE_END,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate_end, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ROTATE, ELM_GESTURE_STATE_ABORT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate_abort, NULL);
elm_gesture_layer_cb_set(g, ELM_GESTURE_ROTATE, ELM_GESTURE_STATE_MOVE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate_move, NULL);
</pre>
</li>
<li>
<p>When 2 points of the gesture layer are tapped on, the <span style="font-family: Courier New,Courier,monospace">rotate_start()</span> callback function is called:</p>
<pre class="prettyprint">
static Evas_Event_Flags
rotate_start(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Rotate_Info *p = (Elm_Gesture_Rotate_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;rotate started &lt;%d,%d&gt; base=&lt;%f&gt; angle=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;base_angle, p-&gt;angle, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">event_info</span> attribute contains the rotation information in the <span style="font-family: Courier New,Courier,monospace">Elm_Gesture_Rotate_Info</span> data structure:</p>
<pre class="prettyprint">
struct _Elm_Gesture_Rotate_Info {
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord x, y; /* Zoom center point reported to the user */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord radius; /* Radius between fingers reported to the user */
&nbsp;&nbsp;&nbsp;&nbsp;double base_angle; /* Holds the start angle */
&nbsp;&nbsp;&nbsp;&nbsp;double angle; /* Rotation value: 0.0 means no rotation */
&nbsp;&nbsp;&nbsp;&nbsp;double momentum; /* Rotation momentum: rotation done per second (NOT YET SUPPORTED) */
};
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">rotate_move()</span> function is called for each detected point when a mouse move event occurs and its angle is bigger than the sum of the base angle and the angular tolerance:</p>
<pre class="prettyprint">
static Evas_Event_Flags
rotate_move(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Rotate_Info *p = (Elm_Gesture_Rotate_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;rotate move &lt;%d,%d&gt; base=&lt;%f&gt; angle=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;base_angle, p-&gt;angle, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>When a mouse up event occurs, the <span style="font-family: Courier New,Courier,monospace">rotate_end()</span> callback function is called:</p>
<pre class="prettyprint">
static Evas_Event_Flags
rotate_end(void *data, void *event_info)
{
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Gesture_Rotate_Info *p = (Elm_Gesture_Rotate_Info *)event_info;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;rotate end &lt;%d,%d&gt; base=&lt;%f&gt; angle=&lt;%f&gt; radius=&lt;%d&gt; momentum=&lt;%f&gt;\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;x, p-&gt;y, p-&gt;base_angle, p-&gt;angle, p-&gt;radius, p-&gt;momentum);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
<li>
<p>If a mouse down event count is higher than 3, the <span style="font-family: Courier New,Courier,monospace">rotate_abort()</span> callback function is called:</p>
<pre class="prettyprint">
static Evas_Event_Flags
rotate_abort(void *data, void *event_info EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;rotate abort\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;return EVAS_EVENT_FLAG_ON_HOLD;
}
</pre>
</li>
</ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>	

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Evas Map Effects</title> 
 </head> 
 <body onload="prettyPrint()" style="overflow: auto;">
 
 <div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	
	<div id="toc_border"><div id="toc">
	<p class="toc-title">Content</p>
		<ul class="toc">
				<li><a href="#Map_Points">Map Points</a></li>
				<li><a href="#Utility_Functions">Utility Functions</a></li>
				<li><a href="#Zoom">Zoom</a></li>
				<li><a href="#threeD_Maps">3D Maps</a></li>
				<li><a href="#threeD_Rotation">3D Rotation and Perspective</a></li>
				<li><a href="#Color_Light">Color and Lighting</a></li>
				<li><a href="#Mapping">Mapping</a></li>
				<li><a href="#Lighting">Lighting</a></li>
				<li><a href="#Alpha_Channel">Alpha Channel</a></li>
				<li><a href="#Smoothing">Smoothing</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Evas.html">Evas API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Evas.html">Evas API for Mobile Wearable</a></li>	
			</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">

  <h1>Evas Map Effects</h1> 

<p>Evas Map animations allow you to apply transformations to all types of objects by way of UV mapping.</p>

<p>In UV mapping, you map points in the source object to 3D space positions in the target object. This allows for rotation, perspective, scale, and other transformation effects, depending on the map. In addition, each map point can carry a multiplier color, which, if properly calculated, can be used to apply 3D shading effects on the target object.</p>

<p>Evas provides both raw and easy-to-use functions for UV mapping. The raw functions allow you to create UV maps outside Evas and import them into your application, for example by loading them from an external file. The easy-to-use functions allow you to create UV maps directly in Evas by calculating the map points based on high-level parameters, such as rotation angle and ambient light.</p>

<h2 id="Map_Points" name="Map_Points">Map Points</h2>

<p>A map consists of a set of points. (Currently, only 4 points are supported.) Each point contains X and Y canvas coordinates that can be used to alter the geometry of the mapped object, and a Z coordinate that indicates the depth of the point. The Z coordinate does not normally affect the map, but several utility functions use it to calculate the right position of the point given the other parameters.</p>

<p>First, create an <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> object using the <span style="font-family: Courier New,Courier,monospace;">evas_map_new()</span> function. This function creates the specified number of map points (currently only up to 4 points). Each point is empty and ready to be modified with <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> functions.</p>

<pre class="prettyprint">Evas_Map *m = evas_map_new(4);</pre>

<p>If you want to get the size (number of points) of an existing map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_count_get()</span> function.</p>

<p>To set the coordinates for each point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_coord_set()</span> function:</p>

<pre class="prettyprint">evas_map_point_coord_set(Evas_Map *m, int idx, Evas_Coord x, Evas_Coord y, Evas_Coord z)</pre>

<p>The following example shows a common way to define a map that matches the geometry of a rectangle (a square in this case):</p>

<pre class="prettyprint">
evas_map_point_coord_set(m, 0, 100, 100, 0);
evas_map_point_coord_set(m, 1, 300, 100, 0);
evas_map_point_coord_set(m, 2, 300, 300, 0);
evas_map_point_coord_set(m, 3, 100, 300, 0);
</pre>

<p class="figure">Figure: Map</p>
<p align="center"><img alt="Map" src="../../images/evas_map_1.png" /></p>

<p>The following examples all produce the same result as the above example, but with simpler code:</p>

<ul>
    <li>
        <p>To create a rectangle map using the starting X and Y coordinates combined with width and height, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_geometry()</span> function:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_geometry(Evas_Map *m, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Evas_Coord z)</pre>
        <p>The following example creates the same map as above:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_geometry(m, 100, 100, 200, 200, 0);</pre>
    </li>
    <li>
        <p>To create a map based on the geometry of a given object, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_object()</span> or <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_object_full()</span> function. The former sets the Z coordinate of all points to 0, whereas the latter allows you to define the same custom Z coordinate for all points:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_object(Evas_Map *m, const Evas_Object *obj)</pre>
        <pre class="prettyprint">evas_map_util_points_populate_from_object_full(Evas_Map *m, const Evas_Object *obj, Evas_Coord z)</pre>
        <p>The following example creates the same map as above:</p>
        <pre class="prettyprint">
Evas_Object *o;
evas_object_move(o, 100, 100);
evas_object_resize(o, 200, 200);
evas_map_util_points_populate_from_object(m, o);
// OR
evas_map_util_points_populate_from_object_full(m, o, 0);</pre>
    </li>
</ul>

<p>You can apply several effects to an object by simply setting each point of the map to the appropriate coordinates. The following example shows how to create a simulated perspective:</p>

<p class="figure">Figure: Simulated perspective</p>
<p align="center"><img alt="Simulated perspective" src="../../images/evas_map_2.png" /></p>

<pre class="prettyprint">
evas_map_point_coord_set(m, 0, 100, 100, 0);
evas_map_point_coord_set(m, 1, 250, 120, 0);
evas_map_point_coord_set(m, 2, 250, 280, 0);
evas_map_point_coord_set(m, 0, 100, 300, 0);
</pre>

<p>In the above example, the Z coordinate is unused: when setting points by hand, the Z coordinate is irrelevant.</p>

<p>If you want to get the actual coordinates of a map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_coord_get()</span> function:</p>

<pre class="prettyprint">evas_map_point_coord_get(const Evas_Map *m, int idx, Evas_Coord *x, Evas_Coord *y, Evas_Coord *z)</pre>

<p>After you have defined the map points, apply them to your map for transformation:</p>

<pre class="prettyprint">
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
</pre>

<p>Finally, after you are done with the map, release the memory allocated to it using the <span style="font-family: Courier New,Courier,monospace;">evas_map_free()</span> function:</p>

<pre class="prettyprint">evas_map_free(m);</pre>

<p>The utility functions described in the next section allow you to perform the above tasks with less coding work.</p>

<h2 id="Utility_Functions" name="Utility_Functions">Utility Functions</h2>

<p>Utility functions take an already configured map and allow you to easily modify it to produce specific effects. For example, to rotate an object around its center, you need the rotation angle and the coordinates of each corner of the object to perform the math required to get the new set of coordinates that needs to be set for the map. Evas provides a utility function that does the math for you:</p>

<pre class="prettyprint">evas_map_util_rotate(Evas_Map *m, double degrees, Evas_Coord cx, Evas_Coord cy)</pre>

<p>This function rotates the map based on the angle and the center coordinates of the rotation provided as arguments. A positive angle rotates the map clockwise, while a negative angle rotates the map counter-clockwise.</p>

<p>The following example shows how to rotate an object around its center point by 45 degrees clockwise. In the following figure, the center of rotation is the red dot.</p>

<pre class="prettyprint">
evas_object_geometry_get(o, &amp;x, &amp;y, &amp;w, &amp;h);
m = evas_map_new(4);
evas_map_util_points_populate_from_object(m, o);
evas_map_util_rotate(m, 45, x + (w / 2), y + (h / 2));
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
evas_map_free(m);
</pre>

<p class="figure">Figure: Rotating around the center point</p>
<p align="center"><img alt="Rotating around the center point" src="../../images/evas_map_3.png" /></p>

<p>You can rotate the object around any other point simply by setting the last 2 arguments of the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_rotate()</span> function to the appropriate values:</p>

<pre class="prettyprint">evas_map_util_rotate(m, 45, x + w - 20, y + h - 20);</pre>

<p class="figure">Figure: Rotating around other points</p>
<p align="center"><img alt="Rotating around other points" src="../../images/evas_map_4.png" /></p>

<p>You can also set the center of the window as the center of the rotation using the appropriate coordinates of the Evas canvas:</p>

<pre class="prettyprint">
evas_output_size_get(evas, &amp;w, &amp;h);
m = evas_map_new(4);
evas_map_util_points_populate_from_object(m, o);
evas_map_util_rotate(m, 45, w, h);
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
evas_map_free(m);
</pre>

<h2 id="Zoom" name="Zoom">Zoom</h2>

<p>The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_zoom()</span> function zooms the points of the map from a center point, defined by <span style="font-family: Courier New,Courier,monospace;">cx</span> and <span style="font-family: Courier New,Courier,monospace;">cy</span>. The <span style="font-family: Courier New,Courier,monospace;">zoomx</span> and <span style="font-family: Courier New,Courier,monospace;">zoomy</span> arguments specify how much to zoom in on the X and Y axes. A value of 1.0 means no zoom, 2.0 means double the size, 0.5 means half the size, and so on. All the coordinates are global canvas coordinates.</p>

<pre class="prettyprint">
evas_map_util_zoom(Evas_Map *m, double zoomx, double zoomy, Evas_Coord cx, Evas_Coord cy)
</pre>

<h2 id="threeD_Maps" name="threeD_Maps">3D Maps</h2>

<p>Maps can also be used to achieve a 3D effect. In a 3D effect, the Z coordinate of each point is meaningful: the higher the value, the further back the point is located. Smaller values (usually negative) mean that the point is closer to the user.</p>

<p>3D also introduces the concept of the back face of an object. An object is said to be facing the user when all its points are placed in a clockwise formation, as shown in the left map in the following figure. Rotating the map around its Y axis swaps the order of the points into a counter-clockwise formation, making the object face away from the user, as shown in the right map in the following figure. The back face is especially relevant in lighting (see below).</p>

<p class="figure">Figure: Rotating around the Y axis</p>
<p align="center"><img alt="Rotating around the Y axis" src="../../images/evas_map_5.png" /></p>

<p>To determine whether a map is facing the user, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_clockwise_get()</span> function. This function returns <span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span> if the map is facing the user and <span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span> if the map is facing away from the user. This is normally done after all the other operations are applied to the map.</p>

<pre class="prettyprint">evas_map_util_clockwise_get(Evas_Map *m)</pre>

<h2 id="threeD_Rotation" name="threeD_Rotation">3D Rotation and Perspective</h2>

<p>The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_rotate()</span> function transforms a map to apply a 3D rotation to the mapped object. You can apply the rotation around any point in the canvas (including a Z coordinate). You can also apply the rotation around any of the 3 axes.</p>

<pre class="prettyprint">evas_map_util_3d_rotate(Evas_Map *m, double dx, double dy, double dz, Evas_Coord cx, Evas_Coord cy, Evas_Coord cz)</pre>

<p>Starting from this simple setup, and setting the maps so that the blue square rotates around the Y axis, we get the following:</p>

<p class="figure">Figure: 3D rotation</p>
<p align="center"><img alt="3D rotation" src="../../images/evas_map_6.png" /></p>

<p>A simple overlay over the image shows the original geometry of each object and the axis around which they are being rotated. The Z axis is not shown, since it is orthogonal to the screen. To show the Z axis, that is, to add 3D perspective to the transformation, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_perspective()</span> function on the map after its position has been set:</p>

<pre class="prettyprint">evas_map_util_3d_perspective(Evas_Map *m, Evas_Coord px, Evas_Coord py, Evas_Coord z0, Evas_Coord foc)</pre>

<p>The result makes the vanishing point the center of each object:</p>

<p class="figure">Figure: Adding perspective</p>
<p align="center"><img alt="Adding perspective" src="../../images/evas_map_7.png" /></p>

<h2 id="Color_Light" name="Color_Light">Color and Lighting</h2>

<p>Each point in a map can be set to a color, which will be multiplied with the object’s own color and linearly interpolated between adjacent points. To set the color separately for each point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_color_set()</span> function:</p>

<pre class="prettyprint">evas_map_point_color_set(Evas_Map *m, int idx, int r, int g, int b, int a)</pre>

<p>To set the same color for every point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_color_set()</span> function:</p>

<pre class="prettyprint">evas_map_util_points_color_set(Evas_Map *m, int r, int g, int b, int a)</pre>

<p>When using a 3D effect, colors can be used to improve its look by simulating a light source. The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_lighting()</span> function makes this task easier by taking the coordinates of the light source and its color, along with the color of the ambient light. Evas then sets the color of each point based on its distance to the light source, the angle at which the object is facing the light source, and the ambient light. Here, the orientation of each point is important.</p>

<pre class="prettyprint">evas_map_util_3d_lighting(Evas_Map *m, Evas_Coord lx, Evas_Coord ly, Evas_Coord lz, int lr, int lg, int lb, int ar, int ag, int ab)</pre>

<p>If the map points are defined counter-clockwise, the object faces away from the user and is therefore obscured, since no light is reflecting back from it.</p>

<p class="figure">Figure: Obscured object</p>
<p align="center"><img alt="Obscured object" src="../../images/evas_map_8.png" /></p>

<h2 id="Mapping" name="Mapping">Mapping</h2>

<p>Images need special handling when mapped. While Evas can easily handle objects, it is completely oblivious to the contents of images. This means that each point in a map needs to be mapped to a specific pixel in the source image. Failing to do this can result in unexpected behavior.</p>

<p>Let&#39;s get started with the following 3 images, each sized at 200 × 200 pixels:</p>

<p class="figure">Figure: Starting point</p>
<p align="center"><img alt="Starting point" src="../../images/evas_map_9.png" /></p>

<p>The following 3 images illustrate the case where a map is set to an image object without setting the right UV mapping for each map point. The objects themselves are mapped properly to their new geometries, but the images are not displayed correctly within the mapped objects.</p>

<p class="figure">Figure: Questionable result</p>
<p align="center"><img alt="Questionable result" src="../../images/evas_map_10.png" /></p>

<p>To transform an image correctly, Evas needs to know how to handle the image within the map. You can do this using the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_image_uv_set()</span> function, which allows you to map a given point in a map to a given pixel in a source image:</p>

<pre class="prettyprint">
evas_map_point_image_uv_set(Evas_Map *m, int idx, double u, double v)
</pre>

<p>To match our example images to the maps above, all we need is the size of each image, which we can get using the <span style="font-family: Courier New,Courier,monospace;">evas_object_image_size_get()</span> function.</p>

<pre class="prettyprint">
// Tux 1: Some cropping and stretch up
evas_map_point_image_uv_set(m, 0, 0, 20);
evas_map_point_image_uv_set(m, 1, 200, 20);
evas_map_point_image_uv_set(m, 2, 200, 180);
evas_map_point_image_uv_set(m, 3, 0, 180);
evas_object_map_set(tux1, m);
evas_object_map_enable_set(tux1, EINA_TRUE);

// Inverted texture for shadow:
evas_map_point_image_uv_set(m, 0, 0, 180);
evas_map_point_image_uv_set(m, 1, 200, 180);
evas_map_point_image_uv_set(m, 2, 200, 20);
evas_map_point_image_uv_set(m, 3, 0, 20);
evas_object_map_set(tux1_shadow, m);
evas_object_map_enable_set(tux1_shadow, EINA_TRUE);

// Tux 2: Make it fit to the map:
evas_map_point_image_uv_set(m, 0, 0, 0);
evas_map_point_image_uv_set(m, 1, 200, 0);
evas_map_point_image_uv_set(m, 2, 200, 200);
evas_map_point_image_uv_set(m, 3, 0, 200);
evas_object_map_set(tux2, m);
evas_object_map_enable_set(tux2, EINA_TRUE);

// Tux 3: Zoom and fit relatively to image size
evas_object_image_size_get(evas_object_image_source_get(tux3), &amp;w, &amp;h);
evas_map_point_image_uv_set(m, 0, 0.1 * w, 0.1 * h);
evas_map_point_image_uv_set(m, 1, 0.9 * w, 0.1 * h);
evas_map_point_image_uv_set(m, 2, 0.9 * w, 0.9 * h);
evas_map_point_image_uv_set(m, 3, 0.1 * w, 0.9 * h);
evas_object_map_set(tux3, m);
evas_object_map_enable_set(tux3, EINA_TRUE);
</pre>

<p class="figure">Figure: Correct result</p>
<p align="center"><img alt="Correct result" src="../../images/evas_map_11.png" /></p>

<p>You can also set a map to use only part of an image, or you can even map the points in inverted order. Combined with the <span style="font-family: Courier New,Courier,monospace;">evas_object_image_source_set()</span> function, you can achieve more interesting results still.</p>

<h2 id="Lighting" name="Lighting">Lighting</h2>

<p><span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> allows you to define an ambient light and a light source within the scene. Both of these light sources have their own colors.</p>

<pre class="prettyprint">evas_map_util_3d_lighting(Evas_Map *m, Evas_Coord lx, Evas_Coord ly, Evas_Coord lz, int lr, int lg, int lb, int ar, int ag, int ab)</pre>

<p>The above function is used to apply lighting calculations (from a single light source) to a given map. The red, green, and blue values of each vertex will be modified to reflect the lighting based on the light source coordinates, its color, the ambient color, and the angle at which the map faces the light source. The points of a surface should be defined in a clockwise formation if the surface is facing the user, since faces have a logical side for lighting.</p>

<p>To get the reflections (gradient) in the shadow of our previous example, you have to define a source of light close enough to the user and a very bright ambient light, for example:</p>

<pre class="prettyprint">
evas_map_util_3d_lighting(m, // Evas_Map object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250/2, 150/2, -100, // Spot light coordinates
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255, 255, 255, // Spot light color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200, 200, 200); // Ambient light color
</pre>

<h2 id="Alpha_Channel" name="Alpha_Channel">Alpha Channel</h2>

<p>You can also use an alpha channel on your map by enabling the alpha channel feature:</p>

<pre class="prettyprint">evas_map_alpha_set(Evas_Map *m, Eina_Bool enabled)</pre>

<p>Next, set the alpha value separately for each map point:</p>

<pre class="prettyprint">evas_map_point_color_set(Evas_Map *m, int idx, int r, int g, int b, int a)</pre>

<p>Alternatively, you can set the same alpha value to all map points:</p>

<pre class="prettyprint">evas_map_util_points_color_set(Evas_Map *m, int r, int g, int b, int a)</pre>

<p>The following code sets the shadow transparency for the first image in the above 3-image example:</p>

<pre class="prettyprint">
// Set object transparency to 50%:
evas_map_util_points_color_set(m, 255, 255, 255, 127);

// Tux&#39;s head is almost invisible in the shadow:
evas_map_point_color_set(m, 3, 255, 255, 255, 15);
evas_map_point_color_set(m, 4, 255, 255, 255, 15);
</pre>

<h2 id="Smoothing" name="Smoothing">Smoothing</h2>

<p>To enable smoothing when rendering a map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_smooth_set()</span> function:</p>

<pre class="prettyprint">evas_map_smooth_set(Evas_Map *m, Eina_Bool enabled)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> object to apply smoothing to. The second argument sets whether to enable the smoothing:</p>

<ul>
    <li><span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span>: Enable smoothing.</li>
    <li><span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span>: Disable smoothing.</li>
</ul>

<p>If the object is of a type that has its own smoothing settings, the smoothing settings must be disabled for both the object and the map. Map smoothing is enabled by default. To check whether map smoothing is enabled, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_smooth_get()</span> function.</p>
  
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">Except as noted, this content is licensed under <a href="http://opensource.org/licenses/LGPL-2.1" target="_blank">LGPLv2.1+</a>.</td>
        </tr>
    </tbody>
</table>  
  
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
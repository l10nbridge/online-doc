<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Evas</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
        <p class="toc-title">Content</p>
        <ul class="toc">
            <li><a href="#render">Rendering Concept and Method in Evas</a></li>
            <li><a href="#evas">Evas Object</a></li>
			<li><a href="#engine">Evas Engines Concept</a></li>
			<li><a href="#ui_rendering">UI Rendering Mode</a></li>
        </ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.tutorials/html/native/ui/evas_tutorial_n.htm">Evas Tutorial</a></li>	
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Evas.html">Evas API</a></li>			
		</ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">

 <h1>Evas</h1>
  
<p>Evas is a clean display canvas API for several target display systems that can draw anti-aliased text, smooth super and sub-sampled scaled images, alpha-blend objects and much more.</p>
<p>It abstracts any need to know much about what the characteristics of your display system are, what graphics calls are used to draw them, and how. It deals on an object level where all you do is create and manipulate objects in a canvas and set their properties.</p>
<p>Evas optimizes the rendering pipeline to minimize effort in redrawing changes made to the canvas and so takes this work out of the programmers hand, saving a lot of time and energy.</p>
<p>It is designed to work on embedded systems all the way to large and powerful multi-cpu workstations. It can be compiled to only have the features you need for your target platform if you so wish. It has several display back-ends, allowing it display on several display systems, making it portable for cross-device and cross-platform development.</p>

<p>Evas is not a widget set or a widget toolkit, but it is their base. See Elementary for a toolkit based on Evas, Edje, Ecore and other Enlightenment technologies.</p>
<p>It is not dependent or aware of main loops, input or output systems. Input must be polled from various sources and fed to Evas. It does not create windows or report windows updates to your system, but draws the pixels and reports to the user the areas that are changed. These operations are ready to be used in Ecore, particularly in Ecore_Evas wrapper/helper set of functions.</p>

<h2 id="render" name="render">Rendering Concept and Method in Evas </h2>
<p>Evas is a canvas display library. It is markedly different from most display and windowing systems as the canvas is structural and is also a state engine, whereas most display and windowing systems are immediate mode display targets. Evas handles the logic between a structural display via its state engine, and controls the target windowing system in order to produce rendered results of the current canvas&#39; state on the display.</p>
<p>Immediate mode display systems retain very little or no state. A program executes a series of commands, as in the following pseudo code.</p>
<pre class="prettyprint">
draw line from position (0, 0) to position (100, 200);

draw rectangle from position (10, 30) to position (50, 500);

bitmap_handle = create_bitmap();
scale bitmap_handle to size 100 x 100;
draw image bitmap_handle at position (10, 30);
</pre>
<p>The series of commands is executed by the windowing system and the results are typically displayed on the screen. Once the commands are executed, the display system does not know how to reproduce this image again, and has to be instructed by the application on how to redraw sections of the screen if needed. Each successive command is executed as instructed by the application and either emulated by software or sent to the graphics hardware on the device to be performed.</p>
<p>The advantage of such a system is that it is simple and gives a program tight control over how something looks and is drawn. Given the increasing complexity of displays and demands by users to have better looking interfaces, more work needs to be done at this level by the internals of widget sets, custom display widgets and other programs. This means that more logic and display rendering code needs to be written again each time the application needs to figure out how to minimize redraws so that display is fast and interactive, and keep track of redraw logic.</p>
<p>For example, if in the scene below, the windowing system requires the application to redraw the area from 0, 0 to 50, 50 (also referred to as the &quot;expose event&quot;). Then the programmer calculates manually the updates and repaints it again.</p>
<pre class="prettyprint">
Redraw from position (0, 0) to position (50, 50):

// What was in area (0, 0, 50, 50)?

// 1. intersection part of line (0, 0) to (100, 200)?
&nbsp;&nbsp;&nbsp;draw line from position (0, 0) to position (25, 50);

// 2. intersection part of rectangle (10, 30) to (50, 500)?
&nbsp;&nbsp;&nbsp;draw rectangle from position (10, 30) to position (50, 50)

// 3. intersection part of image at (10, 30), size 100 x 100?
&nbsp;&nbsp;&nbsp;bitmap_subimage = subregion from position (0, 0) to position (40, 20)
&nbsp;&nbsp;&nbsp;draw image bitmap_subimage at position (10, 30);
</pre>

<p>If all elements in the above scene are opaque, the system is doing useless paints: part of the line is behind the rectangle, and part of the rectangle is behind the image. These useless paints tend to be very costly.</p>
<p>Evas is a structural system in which the programmer creates and manages display objects and their properties, and as a result of this higher level state management, the canvas is able to redraw the set of objects when needed to represent the current state of the canvas.</p>
<p>For example, see the following pseudo code.</p>
<pre class="prettyprint">
line_handle = create_line();
set line_handle from position (0, 0) to position (100, 200);
show line_handle;

rectangle_handle = create_rectangle();
move rectangle_handle to position (10, 30);
resize rectangle_handle to size 40 x 470;
show rectangle_handle;

bitmap_handle = create_bitmap();
scale bitmap_handle to size 100 x 100;
move bitmap_handle to position (10, 30);
show bitmap_handle;

render scene;
</pre>

<p>This looks longer, but when the display needs to be refreshed or updated, the programmer only moves, resizes, shows, hides etc. the objects that need to change. The programmer thinks at the object logic level, and the canvas software does the rest of the work, figuring out what changed in the canvas since it was last drawn, how to most efficiently redraw the canvas and its contents to reflect the current state, and doing the actual drawing of the canvas.</p>
<p>This allows the programmer think in a more natural way when dealing with a display, and saves time and effort of working out how to load and display images, to render given the current display system etc. Since Evas is portable across different display systems, this gives the programmer the ability to port and display the code on different display systems with little work.</p>
<p>Evas is a display system somewhere between a widget set and an immediate mode display system. It retains basic display logic, but does little high-level logic such as scrollbars, sliders, push buttons etc.</p>

<p>For more information on the UI rendering modes (immediate and retained), see <a href="#ui_rendering">UI Rendering Mode</a>.</p>

<h2 id="evas" name="evas">Evas Object </h2>
<p>An Evas object is the most basic visual entity used in Evas. Everything, be it a single line or a complex list of widgets, is an Evas object.</p>

<h3 id="renderable" name="renderable">Primitive Renderable Objects</h3>
<p>Primitive objects are the base upon which to build a complex interface: rectangles, lines, polygons, <a href="#image">images</a>, <a href="#block">textblocks</a>, and texts.</p>
<h4>Rectangle</h4>
<p>There is only one function to deal with rectangle objects. However, the rectangle is manipulated using the generic evas object functions.</p>
<p>The evas rectangle serves a number of key functions when working on Evas programs.</p>
<ul>
<li>background</li>
<li>debugging</li>
<li>clipper</li>
</ul>

<h5>Background</h5>
<p>A common requirement of Evas programs is to have a solid color background, which can be accomplished with the following code.</p>
<pre class="prettyprint">Evas_Object *bg = evas_object_rectangle_add(evas_canvas);

//Here we set the rectangles red, green, blue and opacity levels
evas_object_color_set(bg, 255, 255, 255, 255); // opaque white background
evas_object_resize(bg, WIDTH, HEIGHT); // covers full canvas
evas_object_show(bg);
</pre>

<h5>Debugging</h5>
<p>When debugging visual issues with evas programs, the rectangle is a useful tool. The rectangle&#39;s simplicity means that it is easier to pinpoint issues with it than with more complex objects. A common technique to use when writing an evas program and not getting the desired visual result is to replace an object for a solid color rectangle and seeing how it interacts with the other elements. This often allows us to notice clipping, parenting or positioning issues. Once the issues are identified and corrected, the rectangle can be replaced for the original object, and in all likelihood any remaining issues are specific to that object&#39;s type.</p>

<h5>Clipping</h5>
<p><a href="#clip">Clipping</a> serves two main functions:</p>
<ul>
<li>limiting visibility</li>
<li>applying a layer of color to an object</li>
</ul>


<h4>Text</h4>
<p>An Evas text object shows a basic single-line single-style text.</p>
<pre class="prettyprint">Evas_Object *text = evas_object_text_add(evas_canvas);
evas_object_text_text_set(text, &quot;some text&quot;);
evas_object_color_set(text, 127, 0, 0, 127);
evas_object_show(text);
</pre>

<p>To set the text, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_text_set(text, some_text)</span>. You can set the current text with <span style="font-family: Courier New,Courier,monospace">evas_object_text_text_get(text)</span>.</p>
<p>To set the font, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_font_set(text, font, size)</span>:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">text</span>: The text object</li>
<li><span style="font-family: Courier New,Courier,monospace">font</span>: The font name you want to use</li>
<li><span style="font-family: Courier New,Courier,monospace">size</span>: The font size you want to use. To query the current font, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_font_set(text, font, size)</span>.</li>
</ul>
<p>To set the text style, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_style_set(text, style)</span>. The following styles are supported:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_PLAIN</span>: Plain, standard text</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW</span>: Text with shadow underneath</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_OUTLINE</span>: Text with an outline</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SOFT_OUTLINE</span>: Text with a soft outline</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_GLOW</span>: Text with a glow effect</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_OUTLINE_SHADOW</span>: Text with both outline and shadow effects</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_FAR_SHADOW</span>: Text with (far) shadow underneath</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW</span>: Text with outline and soft shadow effects combined</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SOFT_SHADOW</span>: Text with (soft) shadow underneath</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_FAR_SOFT_SHADOW</span>: Text with (far soft) shadow underneath</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_BOTTOM_RIGHT</span>: Shadow growing to bottom right</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_BOTTOM</span>: Shadow growing to the bottom</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_BOTTOM_LEFT</span>: Shadow growing to bottom left</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_LEFT</span>: Shadow growing to the left</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_TOP_LEFT</span>: Shadow growing to top left</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_TOP</span>: Shadow growing to the top</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_TOP_RIGHT</span>: Shadow growing to top right</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_TEXT_STYLE_SHADOW_DIRECTION_RIGHT</span>: Shadow growing to the right. To query the current style, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_style_get(text)</span>.</li>
</ul>
<p>If the text does not fit, make an ellipsis on it by using <span style="font-family: Courier New,Courier,monospace">evas_object_text_ellipsis_set(text, ellipsis)</span>. The (float) value specifies, which part of the text is shown.</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">0.0</span>: The beginning is shown and the end trimmed.</li>
<li><span style="font-family: Courier New,Courier,monospace">1.0</span>: The beginning is trimmed and the end shown.</li>
<li>Any value in between means that both ends of the text have ellipsis and the set part is shown.</li>
<li><span style="font-family: Courier New,Courier,monospace">-1.0</span>: Ellipsis is disabled. To query the current ellipsis value, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_ellipsis_get(text)</span>.</li>
</ul>
<p>When the text style is set to glow, set the glow color using <span style="font-family: Courier New,Courier,monospace">evas_object_text_glow_color_set(text, r, g, b, a)</span>, where <span style="font-family: Courier New,Courier,monospace">r</span>, <span style="font-family: Courier New,Courier,monospace">g</span>, <span style="font-family: Courier New,Courier,monospace">b</span>, and <span style="font-family: Courier New,Courier,monospace">a</span> are respectively the red, green, blue, and alpha values. The effect is placed at a short distance from the text but not touching it. For glows set right at the text, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_glow2_color_set(text, r, g, b, a)</span>. To query the current color, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_glow_color_get(text, r, g, b, a)</span>, respectively <span style="font-family: Courier New,Courier,monospace">evas_object_text_glow2_color_get(text, r, g, b, a)</span>.</p>
<p>If your text style is set to display a shadow, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_shadow_color_set(text, r, g, b, a)</span>, where <span style="font-family: Courier New,Courier,monospace">r</span>, <span style="font-family: Courier New,Courier,monospace">g</span>, <span style="font-family: Courier New,Courier,monospace">b</span>, and <span style="font-family: Courier New,Courier,monospace">a</span> are respectively the red, green, blue, and alpha values. To query the current color, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_shadow_color_get(text, r, g, b, a)</span></p>
<p>If your text style is set to display an outline, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_outline_color_set(text, r, g, b, a)</span>, where <span style="font-family: Courier New,Courier,monospace">r</span>, <span style="font-family: Courier New,Courier,monospace">g</span>, <span style="font-family: Courier New,Courier,monospace">b</span>, and <span style="font-family: Courier New,Courier,monospace">a</span> are respectively the red, green, blue, and alpha values. To query the current color, use <span style="font-family: Courier New,Courier,monospace">evas_object_text_outline_color_get(text, r, g, b, a)</span></p>


<h3 id="smart" name="smart">Primitive Smart Objects</h3>
<p>A smart object is a special Evas object that provides custom functions to handle automatically clipping, hiding, moving, resizing color setting and more on child elements, for the smart object&#39;s user. They could be, for example, a group of objects that move together, or implementations of whole complex UI widgets, providing some intelligence and extension to simple Evas objects.</p>

<h3 id="container_objects" name="container_objects">Primitive Container Objects</h3>
<p>A container is a Smart object that holds children Evas objects in a specific fashion.</p>
<h4>Table</h4>
<p>A table is a smart object that packs children using a tabular layout.</p>
<pre class="prettyprint">table = evas_object_table_add(evas);
evas_object_table_homogeneous_set(table, EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE);
evas_object_table_padding_set(table, 0, 0);
evas_object_resize(table, WIDTH, HEIGHT);
evas_object_show(table);

rect = evas_object_rectangle_add(evas);
evas_object_color_set(rect, 255, 0, 0, 255);
evas_object_size_hint_min_set(rect, 100, 50);
evas_object_show(rect);
evas_object_table_pack(table, rect, 1, 1, 2, 1);

rect = evas_object_rectangle_add(d.evas);
evas_object_color_set(rect, 0, 255, 0, 255);
evas_object_size_hint_min_set(rect, 50, 100);
evas_object_show(rect);
evas_object_table_pack(table, rect, 1, 2, 1, 2);

rect = evas_object_rectangle_add(d.evas);
evas_object_color_set(rect, 0, 0, 255, 255);
evas_object_size_hint_min_set(rect, 50, 50);
evas_object_show(rect);
evas_object_table_pack(table, rect, 2, 2, 1, 1);

rect = evas_object_rectangle_add(d.evas);
evas_object_color_set(rect, 255, 255, 0, 255);
evas_object_size_hint_min_set(rect, 50, 50);
evas_object_show(rect);
evas_object_table_pack(table, rect, 2, 3, 1, 1);
</pre>

<p>In this example, we add a non-homogeneous table to the canvas with its padding set to 0.</p>
<p>We then add four different colored rectangles with different properties.</p>
<ul>
<li>the first one, at the first column and first line, spans two columns and one line</li>
<li>the second one, at the first column and second line, spans one columns and two lines</li>
<li>the third one, at the second column and second line, fits in one cell</li>
<li>the fourth one, at the second column and third line, also fits in one cell</li>
</ul>
<p>To create a table, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_add(evas)</span>.</p>
<p>To set the table layout (the cells), use <span style="font-family: Courier New,Courier,monospace">evas_object_table_homogeneous_set(table, homogeneous)</span>. The following values can be homogeneous:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE</span>: This default value has columns and rows calculated based on hints of individual cells. This is flexible, but much heavier on computations.</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE</span>: The table size is divided equally among children, filling the whole table area. If the children have a minimum size that is larger than this (including padding), then the table overflows and is aligned respecting the alignment hint, possibly overlapping sibling cells.</li>
<li><span style="font-family: Courier New,Courier,monospace">EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM</span>: The greatest minimum cell size is used: if no element is set to expand, the contents of the table are the minimum size and the bounding box of all the children is aligned relatively to the table object using <span style="font-family: Courier New,Courier,monospace">evas_object_table_align_get()</span>. If the table area is too small to hold this minimum bounding box, then the objects keep their size and the bounding box overflows the box area, still respecting the alignment. To set the current mode, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_homogeneous_get(table)</span>.</li>
</ul>
<p>The table&#39;s content alignment is set using <span style="font-family: Courier New,Courier,monospace">evas_object_table_align_set(table, horizontal, vertical)</span>, where <span style="font-family: Courier New,Courier,monospace">horizontal</span> and <span style="font-family: Courier New,Courier,monospace">vertical</span> are floating values. To see them, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_align_get(table, horizontal, vertical)</span>.</p>
<p>To set the padding, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_padding_set(table, horizontal, vertical)</span>. To see the current value, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_padding_get(table, horizontal, vertical)</span>.</p>
<p>_To see the current column and row count, use <span style="font-family: Courier New,Courier,monospace">evas_object_table_col_row_size_get(table, columns, rows)</span>.</p>

<h4>Grid</h4>
<p>A grid is a smart object that packs its children as with a regular grid layout.</p>
<p>Grids are added to the canvas with <span style="font-family: Courier New,Courier,monospace">evas_object_grid_add(evas)</span>.</p>
<p>To change a grid&#39;s virtual resolution, use <span style="font-family: Courier New,Courier,monospace">evas_object_grid_size_set(grid, width, height)</span>, to see it, use <span style="font-family: Courier New,Courier,monospace">evas_object_grid_size_get(grid, width, height)</span>.</p>
<p>To add an object, use <span style="font-family: Courier New,Courier,monospace">evas_object_grid_pack(grid, child, x, y, w, h)</span>, where</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">x</span> is the virtual X coordinate of the child</li>
<li><span style="font-family: Courier New,Courier,monospace">y</span> is the virtual y coordinate of the child</li>
<li><span style="font-family: Courier New,Courier,monospace">w</span> is the virtual width of the child</li>
<li><span style="font-family: Courier New,Courier,monospace">h</span> is the virtual height of the child</li>
</ul>
<h4>Box</h4>
<p>A box is a simple container that sets its children objects linearly.</p>
<p>To add a box to your canvas, use <span style="font-family: Courier New,Courier,monospace">evas_object_box_add(evas)</span>.</p>
<p>To add a child to the box, use</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_append(box, child)</span>: The child is appended.</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_insert_after(box, child, reference)</span>: The child is added after <span style="font-family: Courier New,Courier,monospace">reference</span>.</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_insert_before(box, child, reference)</span>: The child is added before <span style="font-family: Courier New,Courier,monospace">reference</span>.</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_insert_at(box, child, pos)</span>: The child is added at the specified position.</li>
</ul>
<p>To set the alignment, use <span style="font-family: Courier New,Courier,monospace">evas_object_box_align_set(box, horizontal, vertical)</span>.</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">horizontal</span>: 0.0 means aligned to the left, 1.0 means to the right;</li>
<li><span style="font-family: Courier New,Courier,monospace">vertical</span>: 0.0 means aligned to the top, 1.0 means to the bottom.</li>
</ul>
<p>Evas has predefined box layouts available:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_horizontal()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_vertical()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_homogeneous_horizontal()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_homogeneous_vertical()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_homogeneous_max_size_horizontal()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_homogeneous_max_size_vertical()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_flow_horizontal()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_flow_vertical()</span>;</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_object_box_layout_stack()</span>.</li>
</ul>

<h3 id="image" name="image">Image Objects</h3> 


<p>Using Evas, you can create and manipulate image objects. Evas supports image loaders of various formats as plug-in modules.</p>
<p>The image formats that Evas supports include <span style="font-family: Courier New,Courier,monospace">bmp</span>, <span style="font-family: Courier New,Courier,monospace">edj</span>, <span style="font-family: Courier New,Courier,monospace">gif</span>, <span style="font-family: Courier New,Courier,monospace">ico</span>, <span style="font-family: Courier New,Courier,monospace">jpeg</span>, <span style="font-family: Courier New,Courier,monospace">pmaps</span>, <span style="font-family: Courier New,Courier,monospace">png</span>, <span style="font-family: Courier New,Courier,monospace">psd</span>, <span style="font-family: Courier New,Courier,monospace">svg</span>, <span style="font-family: Courier New,Courier,monospace">tga</span>, <span style="font-family: Courier New,Courier,monospace">tiff</span>, <span style="font-family: Courier New,Courier,monospace">wbmp</span>, <span style="font-family: Courier New,Courier,monospace">webp</span>, and <span style="font-family: Courier New,Courier,monospace">xpm</span>.</p>

	<p class="figure">Figure: Evas image loader</p> 
	<p style="text-align:center;"><img alt="Evas image loader" src="../../images/evas_image_loader.png" /></p>  

<h4>Evas Object Image Functions</h4>

<p>Evas has over 70 image object functions. The following functions are discussed in this document:</p>
<pre class="prettyprint">
Evas_Object *evas_object_image_add(Evas *e);
void evas_object_image_file_set(Evas_Object *obj, const char *file, const char *key);
void evas_object_image_fill_set(Evas_Object *obj, int x, int y, int w, int h);
void evas_object_image_filled_set(Evas *e, Eina_Bool setting);
Evas_Object *evas_object_image_filled_add(Evas *e);
void evas_object_image_smooth_scale_set(Evas_Object *obj, Eina_Bool smoothscale);
void evas_object_image_load_size_set(Evas_Object *obj, int w, int h);
void evas_object_image_data_set(Evas_Object *obj, void *data);
void *evas_object_image_data_get(const Evas_Object *obj, Eina_Bool for_writing);
void evas_object_image_size_set(Evas_Object *obj, int w, int h);
void evas_object_image_data_update_add(Evas_Object *obj, int x, int y, int w, int h);
Eina_Bool evas_object_image_save(const Evas_Object *obj, const char *file, const char *key, const char *flags);
</pre>

<h4>Creating an Image Object and Setting the Image Data Source</h4>
<p>A common use case of an image object is to set a file as the image data source. The process has 3 steps and each one involves the following API calls:</p>
	<ul>
	 <li>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_add()</span> function creates an image object and returns the pointer.
	 <pre class="prettyprint">Evas_Object *evas_object_image_add(Evas *e);</pre>
	 </li>
	 <li>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_file_set()</span> function sets a source file on the image object. The object fetches the image pixel data from the source file.
	 <pre class="prettyprint">void evas_object_image_file_set(Evas_Object *obj, const char *file, const char *key);</pre>
	 </li>
	 <li>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set()</span> sets how to fill the image object's area with the given pixel data.
	 <pre class="prettyprint">void evas_object_image_fill_set(Evas_Object *obj, int x, int y, int w, int h);</pre>
	 </li>
	</ul>

<p>In the following code example, the <span style="font-family: Courier New,Courier,monospace">main()</span> function creates an image object and displays it on a window. The image object size is 300x300 and the source image resolution is 100x127. The image is scaled into 300 by 300 to fill the image object area using the <span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set()</span> function.</p>
<pre class="prettyprint">
#include &lt;Elementary.h&gt;

int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;elm_init(argc, argv);

&nbsp;&nbsp;&nbsp;// Create a window object
&nbsp;&nbsp;&nbsp;Evas_Object *win = elm_win_add(NULL, &quot;main&quot;, ELM_WIN_BASIC);
&nbsp;&nbsp;&nbsp;evas_object_resize(win, 400, 400);
&nbsp;&nbsp;&nbsp;evas_object_show(win);

&nbsp;&nbsp;&nbsp;// Return Evas handle from window
&nbsp;&nbsp;&nbsp;Evas *e = evas_object_evas_get(win);

&nbsp;&nbsp;&nbsp;// Create an image object
&nbsp;&nbsp;&nbsp;Evas_Object *img = evas_object_image_add(e);

&nbsp;&nbsp;&nbsp;// Set a source file to fetch pixel data
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img, &quot;./logo.png&quot;, NULL);

&nbsp;&nbsp;&nbsp;// Set the size and position of the image on the image object area
&nbsp;&nbsp;&nbsp;evas_object_image_fill_set(img, 0, 0, 300, 300);

&nbsp;&nbsp;&nbsp;evas_object_move(img, 50, 50);
&nbsp;&nbsp;&nbsp;evas_object_resize(img, 300, 300);
&nbsp;&nbsp;&nbsp;evas_object_show(img);

&nbsp;&nbsp;&nbsp;elm_run();

&nbsp;&nbsp;&nbsp;elm_shutdown();

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
	<p class="figure">Figure: Image object display</p> 
	<p style="text-align:center;"><img alt="Image object display" src="../../images/evas_object_display.png" /></p>  
  
<h4>Image Scaling</h4>
<p>Users can decide how to fill the image object area with the given image pixel data by setting the position, width, and height of the image using the <span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set()</span> function. Without setting this information, the image is not displayed. If the size of the image is bigger than the image object area, only a sub-region of the original image is displayed. If the image is smaller than the area, images are tiled repeatedly to fill the object area.</p>

	<p class="figure">Figure: Image scaling</p> 
	<p style="text-align:center;"><img alt="Image scaling" src="../../images/evas_image_scaling.png" /></p>  

	<table>
	<tbody>
	<tr>
	 <td><p style="text-align:center;"><img alt="" src="../../images/evas_scaling1.png" /></p></td>
	 <td><p style="text-align:center;"><img alt="" src="../../images/evas_scaling2.png" /></p></td>
	 <td><p style="text-align:center;"><img alt="" src="../../images/evas_scaling3.png" /></p></td>
	</tr>
	<tr>
     <td style="text-align:center;"><span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set(obj, 50, 0, 300, 300)</span></td>
	 <td style="text-align:center;"><span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set(obj, 0, 0, 200, 200)</span></td>
	 <td style="text-align:center;"><span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set(obj, 0, 0, 100, 127)</span></td>
	</tr>
	</tbody>
	</table>  
 	
<p>the <span style="font-family: Courier New,Courier,monospace">evas_object_image_filled_set()</span> function scales the image to fit the object area. Resizing the image object automatically triggers an internal call to the <span style="font-family: Courier New,Courier,monospace">evas_object_image_fill_set()</span> function.</p>
<pre class="prettyprint">
void evas_object_image_filled_set(Evas *e, Eina_Bool setting);</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_filled_add()</span> function creates a new image object that automatically scales its bound image to the object area. This is a helper function around the <span style="font-family: Courier New,Courier,monospace">evas_object_image_add()</span> and <span style="font-family: Courier New,Courier,monospace">evas_object_image_filled_set()</span> functions.</p>

<pre class="prettyprint">Evas_Object *evas_object_image_filled_add(Evas *e);</pre>

<p>Scaled images&#39; quality can differ according to scaling algorithms. Smooth scaling improves the image quality in the process of size reducing or enlarging. Evas runs its own smooth scaling algorithm by default and provides an API so users can disable the function.</p>

<pre class="prettyprint">
void evas_object_image_smooth_scale_set(Evas_Object *obj, Eina_Bool smoothscale);</pre>

<p>The algorithm is implemented using the SIMD (Single Instruction Multiple Data) vectorization in case of software rendering. It is optimized on Intel and ARM CPU through MMX and NEON command respectively.</p>

<p>There is a trade-off between image smoothness and rendering performance. The load gets bigger as the image gets bigger. Users can avoid such scaling overload by using the same size of the image object and the source image.</p>

<p>In the following code, 2 image objects are created to show the effects of smooth scaling. The one with smooth scaling applied appears softer on the screen.</p>

<pre class="prettyprint">
#include &lt;Elementary.h&gt;

int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;elm_init(argc, argv);

&nbsp;&nbsp;&nbsp;// Create a window object
&nbsp;&nbsp;&nbsp;Evas_Object *win = elm_win_add(NULL, &quot;main&quot;, ELM_WIN_BASIC);
&nbsp;&nbsp;&nbsp;evas_object_resize(win, 400, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(win);

&nbsp;&nbsp;&nbsp;// Return Evas handle from window
&nbsp;&nbsp;&nbsp;Evas *e = evas_object_evas_get(win);

&nbsp;&nbsp;&nbsp;// Create an image object
&nbsp;&nbsp;&nbsp;Evas_Object *img = evas_object_image_filled_add(e);
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img, &quot;./logo.png&quot;, NULL);
&nbsp;&nbsp;&nbsp;evas_object_move(img, 0, 0);
&nbsp;&nbsp;&nbsp;evas_object_resize(img, 200, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(img);

&nbsp;&nbsp;&nbsp;// Create another image object
&nbsp;&nbsp;&nbsp;Evas_Object *img2 = evas_object_image_filled_add(e);
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img2, &quot;./logo.png&quot;, NULL);

&nbsp;&nbsp;&nbsp;// Disable smooth scaling
&nbsp;&nbsp;&nbsp;evas_object_image_smooth_scale_set(img2, EINA_FALSE);
&nbsp;&nbsp;&nbsp;evas_object_move(img2, 200, 0);
&nbsp;&nbsp;&nbsp;evas_object_resize(img2, 200, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(img2);

&nbsp;&nbsp;&nbsp;elm_run();

&nbsp;&nbsp;&nbsp;elm_shutdown();

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

  <table>
  <caption>Figure: Smooth scaling effects</caption>
  <tbody>
  <tr>
   <td><p style="text-align:center;"><img alt="" src="../../images/evas_smooth_enabled.png" /></p></td>
   <td><p style="text-align:center;"><img alt="" src="../../images/evas_smooth_disabled.png" /></p></td>
  </tr>
  <tr>
   <td style="text-align:center;">Smooth scaling enabled</td>
   <td style="text-align:center;">Smooth scaling disabled</td>
  </tr>
  </tbody></table>


<p>Evas caches scaled image data and reuses them. Users can save the memory by loading the image in the scaled size to the memory at the beginning. This option is available only for <span style="font-family: Courier New,Courier,monospace">jpeg</span> format at the moment.</p>
<pre class="prettyprint">
void evas_object_image_load_size_set(Evas_Object *obj, int w, int h);</pre>

<p>An example code is as follows.</p>
<pre class="prettyprint">
#include &lt;Elementary.h&gt;
 
int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;elm_init(argc, argv);
 
&nbsp;&nbsp;&nbsp;// Create a window object
&nbsp;&nbsp;&nbsp;Evas_Object *win = elm_win_add(NULL, &quot;main&quot;, ELM_WIN_BASIC);
&nbsp;&nbsp;&nbsp;evas_object_resize(win, 400, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(win);
 
&nbsp;&nbsp;&nbsp;// Return Evas handle from window
&nbsp;&nbsp;&nbsp;Evas *e = evas_object_evas_get(win);
 
&nbsp;&nbsp;&nbsp;// Create an image object
&nbsp;&nbsp;&nbsp;Evas_Object *img = evas_object_image_filled_add(e); 
 
&nbsp;&nbsp;&nbsp;// Load the image scaled into the object size 
&nbsp;&nbsp;&nbsp;// before evas_object_image_file_set() is called
&nbsp;&nbsp;&nbsp;evas_object_image_load_size_set(img, 300, 300);
 
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img, &quot;./logo.png&quot;, NULL); 
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;evas_object_move(img, 50, 50);
&nbsp;&nbsp;&nbsp;evas_object_resize(img, 300, 300);
&nbsp;&nbsp;&nbsp;evas_object_show(img); 
 
&nbsp;&nbsp;&nbsp;elm_run();
 
&nbsp;&nbsp;&nbsp;elm_shutdown();

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<h4>Setting Raw Data to Image Object</h4>
<p>Users can set raw data to the image object manually using  the <span style="font-family: Courier New,Courier,monospace">evas_object_image_data_set()</span> function instead of setting an image file as the data source. The image data should be in raw data form. In case of an 200x200 sized image with alpha channel enabled (32 bits per pixel), the size of the image data is 14000 (=200*200*4) bytes.</p>

<pre class="prettyprint">void evas_object_image_data_set(Evas_Object *obj, void *data);</pre>

<p>Image objects fetch metadata such as width or height from the header of the image files. Since the raw data does not have the metadata, users must set the size of the image using the <span style="font-family: Courier New,Courier,monospace">evas_object_image_size_set()</span> function.</p>

<pre class="prettyprint">void evas_object_image_size_set(Evas_Object *obj, int w, int h);</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_data_get()</span> function returns the data pointer of an image object and requires a parameter to determine whether the data is modified or not. If users pass <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> for <span style="font-family: Courier New,Courier,monospace">for_writing</span>, Evas updates the image pixels in the next rendering cycle.</p>

<pre class="prettyprint">void *evas_object_image_data_get(const Evas_Object *obj, Eina_Bool for_writing);</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">evas_object_image_data_update_add()</span> helps to mark the updated area for rendering efficiency.</p>

<pre class="prettyprint">void evas_object_image_data_update_add(Evas_Object *obj, int x, int y, int w, int h);</pre>

<p>The following example code and figure show how to specify the area to update.</p>
<pre class="prettyprint">
evas_object_image_data_update_add(image, 100, 100, 50, 50);
evas_object_image_data_update_add(image, 180, 100, 50, 50);
evas_object_image_data_update_add(image, 85, 200, 160, 80);
</pre>
 
 	        <p class="figure">Figure: Partial image update</p> 
  <p style="text-align:center;"><img alt="Partial image update" src="../../images/evas_partial_update.png" /></p>  

<p>The following code creates an image object and sets a source file on it. Then it implements the blur effect to the pixel data and saves them using the <span style="font-family: Courier New,Courier,monospace">evas_object_image_save()</span> function.</p>

<pre class="prettyprint">Eina_Bool evas_object_image_save(const Evas_Object *obj, const char *file, const char *key, const char *flags);</pre>

<pre class="prettyprint">
#include &lt;Elementary.h&gt;

void image_blur(Evas_Object *img)
{
&nbsp;&nbsp;&nbsp;unsigned char *img_src = evas_object_image_data_get(img, EINA_TRUE);

&nbsp;&nbsp;&nbsp;int w, h;
&nbsp;&nbsp;&nbsp;evas_object_image_size_get(img, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;int blur_size = 4;
&nbsp;&nbsp;&nbsp;int x, y, xx, yy;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; h; y++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; w; x++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int avg_color[3] = {0, 0, 0};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blur_pixel_cnt = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (xx = x; (xx &lt; x + blur_size) &amp;&amp; (xx &lt; w); xx++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (yy = y; (yy &lt; y + blur_size) &amp;&amp; (yy &lt; h); yy++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int idx = (yy * w * 4) + (xx * 4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[0] += img_src[idx + 0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[1] += img_src[idx + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[2] += img_src[idx + 2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++blur_pixel_cnt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[0] /= blur_pixel_cnt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[1] /= blur_pixel_cnt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_color[2] /= blur_pixel_cnt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (xx = x; (xx &lt; x + blur_size) &amp;&amp; (xx &lt; w); xx++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (yy = y; (yy &lt; y + blur_size) &amp;&amp; (yy &lt; h); yy++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int idx = (yy * w * 4) + (xx * 4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img_src[idx + 0] = avg_color[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img_src[idx + 1] = avg_color[1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img_src[idx + 2] = avg_color[2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;evas_object_image_data_update_add(img, 0, 0, w, h);
}

int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;elm_init(argc, argv);

&nbsp;&nbsp;&nbsp;Evas_Object *win = elm_win_add(NULL, &quot;main&quot;, ELM_WIN_BASIC);
&nbsp;&nbsp;&nbsp;evas_object_resize(win, 200, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(win);

&nbsp;&nbsp;&nbsp;Evas *e = evas_object_evas_get(win);

&nbsp;&nbsp;&nbsp;Evas_Object *img = evas_object_image_filled_add(e);
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img, &quot;./logo.png&quot;, NULL);
&nbsp;&nbsp;&nbsp;evas_object_resize(img, 200, 200);
&nbsp;&nbsp;&nbsp;evas_object_show(img);

&nbsp;&nbsp;&nbsp;image_blur(img);

&nbsp;&nbsp;&nbsp;evas_object_image_save(img, &quot;logo2.png&quot;, NULL, &quot;quality=100 compress=8&quot;);

&nbsp;&nbsp;&nbsp;elm_run();

&nbsp;&nbsp;&nbsp;elm_shutdown();

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

  <table>
  <caption>Figure: Blur effect</caption>
  <tbody>
  <tr>
   <td><p style="text-align:center;"><img alt="" src="../../images/evas_blur1.png" /></p></td>
   <td><p style="text-align:center;"><img alt="" src="../../images/evas_blur2.png" /></p></td>
  </tr>
  <tr>
   <td style="text-align:center;">Before</td>
   <td style="text-align:center;">After</td>
  </tr>
  </tbody></table>  


 <h3 id="block" name="block">Textblock Objects</h3>

<p>Unlike basic text objects, a textblock handles complex text, managing multiple styles and multiline text based on HTML-like tags. However, these extra features are heavier on memory and processing cost.</p>
<p>The textblock objects is an object that shows big chunks of text. Textblock supports many features, including text formatting, automatic and manual text alignment, embedding items (icons, for example). Textblock has three important parts: the text paragraphs, the format nodes and the cursors.</p>
<p>To set markup to format text, use for example <span style="font-family: Courier New,Courier,monospace">&lt;font_size=50&gt;Big!&lt;/font_size&gt;</span>. Set more than one style directive in one tag with <span style="font-family: Courier New,Courier,monospace">&lt;font_size=50 color=#F00&gt;Big and Red!&lt;/font_size&gt;</span>. Please note that we used <span style="font-family: Courier New,Courier,monospace">&lt;/font_size&gt;</span> although the format also included color. This is because the first format determines the matching closing tag&#39;s name. You can use anonymous tags, such as <span style="font-family: Courier New,Courier,monospace">&lt;font_size=30&gt;Big&lt;/&gt;</span>, which pop any type of format, but it is advisable to use the named alternatives instead.</p>
<p>Textblock supports the following formats:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">font</span>: Font description in fontconfig such as format, for example &quot;Sans:style=Italic:lang=hi&quot;. or &quot;Serif:style=Bold&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_weight</span>: Overrides the weight defined in &quot;font&quot;. For example, &quot;font_weight=Bold&quot; is the same as &quot;font=:style=Bold&quot;. The supported weights are &quot;normal&quot;, &quot;thin&quot;, &quot;ultralight&quot;, &quot;light&quot;, &quot;book&quot;, &quot;medium&quot;, &quot;semibold&quot;, &quot;bold&quot;, &quot;ultrabold&quot;, &quot;black&quot;, and &quot;extrablack&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_style</span>: Overrides the style defined in &quot;font&quot;. For example, &quot;font_style=Italic&quot; is the same as &quot;font=:style=Italic&quot;. The supported styles are &quot;normal&quot;, &quot;oblique&quot;, and &quot;italic&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_width</span>: Overrides the width defined in &quot;font&quot;. For example, &quot;font_width=Condensed&quot; is the same as &quot;font=:style=Condensed&quot;. The supported widths are &quot;normal&quot;, &quot;ultracondensed&quot;, &quot;extracondensed&quot;, &quot;condensed&quot;, &quot;semicondensed&quot;, &quot;semiexpanded&quot;, &quot;expanded&quot;, &quot;extraexpanded&quot;, and &quot;ultraexpanded&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">lang</span>: Overrides the language defined in &quot;font&quot;. For example, &quot;lang=he&quot; is the same as &quot;font=:lang=he&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_fallbacks</span>: A comma delimited list of fonts to try if finding the main font fails.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_size</span>: The font size in points.</li>
<li><span style="font-family: Courier New,Courier,monospace">font_source</span>: The source of the font, for example an eet file.</li>
<li><span style="font-family: Courier New,Courier,monospace">color</span>: The text color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">underline_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">underline2_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">outline_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">shadow_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">glow_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">glow2_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">strikethrough_color</span>: The color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">align</span>: The text alignment in one of the following formats: &quot;auto&quot; (according to text direction), &quot;left&quot;, &quot;right&quot;, &quot;center&quot; or &quot;middle&quot;, which take a value between 0.0 and 1.0 or a value between 0% to 100%.</li>
<li><span style="font-family: Courier New,Courier,monospace">valign</span>: The vertical text alignment in one of the following formats: &quot;top&quot;, &quot;bottom&quot;, &quot;middle&quot;, &quot;center&quot;, &quot;baseline&quot; or &quot;base&quot;, which take a value between 0.0 and 1.0 or a value between 0% to 100%.</li>
<li><span style="font-family: Courier New,Courier,monospace">wrap</span>: The text wrap in one of the following formats: &quot;word&quot;, &quot;char&quot;, &quot;mixed&quot;, or &quot;none&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">left_margin</span>: Either &quot;reset&quot; or a pixel value indicating the margin.</li>
<li><span style="font-family: Courier New,Courier,monospace">right_margin</span>: Either &quot;reset&quot; or a pixel value indicating the margin.</li>
<li><span style="font-family: Courier New,Courier,monospace">underline</span>: The style of underlining in one of the following formats: &quot;on&quot;, &quot;off&quot;, &quot;single&quot;, or &quot;double&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">strikethrough</span>: The style of text that is either &quot;on&quot; or &quot;off&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">backing_color</span>: The background color in one of the following formats: &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;, &quot;#RGB&quot;, or &quot;#RGBA&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">backing</span>: The background color enabled or disabled: &quot;on&quot; or &quot;off&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">style</span>: The style of the text in one of the following formats: &quot;off&quot;, &quot;none&quot;, &quot;plain&quot;, &quot;shadow&quot;, &quot;outline&quot;, &quot;soft_outline&quot;, &quot;outline_shadow&quot;, &quot;outline_soft_shadow&quot;, &quot;glow&quot;, &quot;far_shadow&quot;, &quot;soft_shadow&quot; or &quot;far_soft_shadow&quot;. The direction is selected by adding &quot;bottom_right&quot;, &quot;bottom&quot;, &quot;bottom_left&quot;, &quot;left&quot;, &quot;top_left&quot;, &quot;top&quot;, &quot;top_right&quot; or &quot;right&quot;. For example, &quot;style=shadow,bottom_right&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace">tabstops</span>: The pixel value for tab width.</li>
<li><span style="font-family: Courier New,Courier,monospace">linesize</span>: To force a line size in pixels.</li>
<li><span style="font-family: Courier New,Courier,monospace">linerelsize</span>: Either a floating point value or a percentage indicating the wanted size of the line relative to the calculated size.</li>
<li><span style="font-family: Courier New,Courier,monospace">linegap</span>: To force a line gap in pixels.</li>
<li><span style="font-family: Courier New,Courier,monospace">linerelgap</span>: Either a floating point value or a percentage indicating the wanted size of the line relative to the calculated size.</li>
<li><span style="font-family: Courier New,Courier,monospace">item</span>: Creates an empty space that is filled by an upper layer. Use &quot;size&quot;, &quot;abssize&quot;, or &quot;relsize&quot; to define the item&quot;s size, and an optional vsize = full/ascent to define the item&#39;s position in the line.</li>
<li><span style="font-family: Courier New,Courier,monospace">linefill</span>: Either a float value or percentage indicating how much to fill the line.</li>
<li><span style="font-family: Courier New,Courier,monospace">ellipsis</span>: A value between 0.0 and 1.0 to indicate the type of ellipsis, or -1.0 to indicate that an ellipsis is not wanted.</li>
<li><span style="font-family: Courier New,Courier,monospace">password</span>: Either &quot;on&quot; or &quot;off&quot;, this is used to specifically turn replacing chars with the password mode (that is, replacement char) on and off. </li>
</ul>


<h3 id="clip" name="clip">Clipping Objects</h3>

<h4>Limiting Visibility </h4>
<p>An Evas object can be clipped – in other words, its visible area is restricted with the clipper object.</p>

<p>It is often necessary to show only parts of an object, and while it may be possible to create an object that corresponds only to the part that must be shown (which is not always possible), it is usually easier to use a clipper. A clipper is a rectangle that defines what is visible and what is not. The way to do this is to create a solid white rectangle (by default, so you need not use <span style="font-family: Courier New,Courier,monospace">evas_object_color_set()</span>) and give it a position and size of what is wanted visible. The following code exemplifies showing the center half of my_evas_object: </p>
<pre class="prettyprint">Evas_Object *clipper = evas_object_rectangle_add(evas_canvas);
evas_object_move(clipper, my_evas_object_x / 4, my_evas_object_y / 4);
evas_object_resize(clipper, my_evas_object_width / 2, my_evas_object_height / 2);
evas_object_clip_set(my_evas_object, clipper);
evas_object_show(clipper);
</pre>

<h4>Layer of Color </h4>
<p>A solid white clipper does not produce a change in the color of the clipped object, only hides what is outside the clipper&#39;s area.  Changing the color of an object is accomplished by using a colored clipper. Clippers with color function by multiplying the colors of the clipped object. The following code shows how to remove all the red from an object.</p>
<pre class="prettyprint">Evas_Object *clipper = evas_object_rectangle_add(evas);
evas_object_move(clipper, my_evas_object_x, my_evas_object_y);
evas_object_resize(clipper, my_evas_object_width, my_evas_object_height);
evas_object_color_set(clipper, 0, 255, 255, 255);
evas_object_clip_set(obj, clipper);
evas_object_show(clipper);
</pre> 


<h3 id="map" name="map">Mapping Objects</h3>

<p>Evas allows different transformations to be applied to all kinds of objects. These are applied by means of UV mapping. With UV mapping, one map points in the source object to a 3D space positioning at target. This allows rotation, perspective, scale, and many other effects depending on the map that is used.</p>

<h4>Creating a Map </h4>
<p>A map consists of a set of points, but currently only four are supported. Each of these points contains a set of canvas coordinates x and y that are used to alter the geometry of the mapped object, and a z coordinate that indicates the depth of that point. This last coordinate does not normally affect the map, but is used by several of the utility functions to calculate the right position of the point given other parameters.</p>
<p>The coordinates for each point are set with <span style="font-family: Courier New,Courier,monospace">evas_map_point_coord_set(map, index, x, y, z)</span>. In the example below, there is a rectangle whose coordinates are (100, 100) and (300, 300).</p>
<pre class="prettyprint">Evas_Object *object = evas_object_rectangle_add(evas);
evas_object_move(object, 100, 100);
evas_object_resize(object, 200, 200);
Evas_Map map = evas_map_new(4);
evas_map_point_coord_set(map, 0, 100, 100, 0);
evas_map_point_coord_set(map, 1, 300, 100, 0);
evas_map_point_coord_set(map, 2, 300, 300, 0);
evas_map_point_coord_set(map, 3, 100, 300, 0);
</pre>
<p>There are functions to ease the process.</p>
<p>Use <span style="font-family: Courier New,Courier,monospace">evas_map_util_points_populate_from_geometry(map, x, y, w, h, z)</span>, where the map coordinates are set to the given rectangle, and <span style="font-family: Courier New,Courier,monospace">z</span> is the coordinate in the Z axis, which is the same for all points.</p>
<pre class="prettyprint">Evas_Object *object = evas_object_rectangle_add(evas);
evas_object_move(object, 100, 100);
evas_object_resize(object, 200, 200);
Evas_Map map = evas_map_new(4);
evas_map_util_points_populate_from_geometry(map, 100, 100, 200, 200, 0);
</pre>

<p>You can also use <span style="font-family: Courier New,Courier,monospace">evas_map_util_points_populate_from_object(map, object)</span>. </p>
<pre class="prettyprint">Evas_Object *object = evas_object_rectangle_add(evas);
evas_object_move(object, 100, 100);
evas_object_resize(object, 200, 200);
Evas_Map map = evas_map_new(4);
evas_map_util_points_populate_from_object(map, object);
</pre>

<p>You can also use <span style="font-family: Courier New,Courier,monospace">evas_map_util_points_populate_from_object_full(map, object, z)</span>, where <span style="font-family: Courier New,Courier,monospace">z</span> is the coordinate in the Z axis, which is the same for all points. </p>
<pre class="prettyprint">Evas_Object *object = evas_object_rectangle_add(evas);
evas_object_move(object, 100, 100);
evas_object_resize(object, 200, 200);
Evas_Map map = evas_map_new(4);
evas_map_util_points_populate_from_object_full(map, object, 0);
</pre>

<h4>Manual Point Setting</h4>
<p>Several effects are applied to an object by setting each point of the map to the right coordinates. For example, a simulated perspective is achieved as follows.</p>
<pre class="prettyprint">evas_map_point_coord_set(map, 0, 300, 100, 0);
evas_map_point_coord_set(map, 1, 450, 120, 0);
evas_map_point_coord_set(map, 2, 450, 260, 0);
evas_map_point_coord_set(map, 3, 300, 300, 0);
</pre>

<p>The Z coordinate is not used when setting points by hand; thus its value is not important.</p>

<h4>Applying a Map </h4>
<p>Regardless of the specific way you create a map, to apply it to a specific object, use</p>
<pre class="prettyprint">evas_object_map_set(object, map);
evas_object_map_enable_set(object, EINA_TRUE);
</pre>

<h4>Basic Utility Functions </h4>
<p>Evas provides utility functions for common transformations:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">evas_map_util_rotate(map, angle, cx, cy)</span>: This performs a rotation of the <span style="font-family: Courier New,Courier,monospace">angle</span> degrees around the center point with the coordinates (cx, cy).</li>
<li><span style="font-family: Courier New,Courier,monospace">evas_map_util_zoom(map, zoomx, zoomy, cx, cy)</span>: This performs a <span style="font-family: Courier New,Courier,monospace">zoomx</span> and <span style="font-family: Courier New,Courier,monospace">zoomy</span> zoom in the X and Y directions respectively, with the center point with the coordinates (cx, cy).</li>
</ul>

<p>For example, the following code rotates an object around its center.</p>
<pre class="prettyprint">int x, y, w, h;
evas_object_geometry_get(object, &amp;x, &amp;y, &amp;w, &amp;h);
Evas_Map *map = evas_map_new(4);
evas_map_util_points_populate_from_object(map, object);
evas_map_util_rotate(map, 45, x + (w / 2), y + (h / 2));
evas_object_map_set(object, map);
evas_object_map_enable_set(object, EINA_TRUE);
evas_map_free(m);
</pre>

<p>The following code rotates an object around the center of the window.</p>
<pre class="prettyprint">int w, h;
evas_output_size_get(evas, &amp;w, &amp;h);
Evas_Map *map = evas_map_new(4);
evas_map_util_points_populate_from_object(map, object);
evas_map_util_rotate(map, 45, w / 2, h / 2);
evas_object_map_set(object, map);
evas_object_map_enable_set(object, EINA_TRUE);
evas_map_free(m);
</pre>

<h4>3D Utility Functions </h4>
<p>Evas provides utility functions for 3D transformations.</p>
<p>To make a 3D rotation, use <span style="font-family: Courier New,Courier,monospace">evas_map_util_3d_rotate(map, anglex, angley, anglez, cx, cy, cz)</span>. With this code, you can set the Z coordinate of the rotation center, and the angles to rotate through around all axes.</p>
<p>Rotating in the 3D space does not look natural. A more natural look becomes by adding perspective to the transformation, which is done with <span style="font-family: Courier New,Courier,monospace">evas_map_util_3d_perspective(map, px, py, z0, focal)</span> on the map after its position has been set.</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace">px</span> and <span style="font-family: Courier New,Courier,monospace">py</span> specify the &quot;infinite distance&quot; point in the 3D conversion, where all lines converge to.</li>
<li><span style="font-family: Courier New,Courier,monospace">z0</span> specifies the Z value at which there is a 1:1 mapping between spatial coordinates and screen coordinates: any points on this Z value do not have their X and Y coordinates modified in the transform, while those further away (Z value higher) shrink into the distance, and those less than this value expand.</li>
<li><span style="font-family: Courier New,Courier,monospace">focal</span> determines the &quot;focal length&quot; of the camera: this is the distance in reality between the camera lens plane (the rendering results are undefined at or closer than this) and the <span style="font-family: Courier New,Courier,monospace">z0</span> value; this function allows for some &quot;depth&quot; control.</li>
</ul>
<h4>Color and Lighting </h4>
<p>Each point in a map can be set to a color, which is multiplied with the object&#39;s own color and linearly interpolated in between adjacent points. To do this, use <span style="font-family: Courier New,Courier,monospace">evas_map_point_color_set(map, index, r, g, b, a)</span> for each point of the map, or <span style="font-family: Courier New,Courier,monospace">evas_map_util_points_color_set(map, r, g, b, a)</span> to set every point into the same color.</p>
<p>To add lighting for the objects, which is useful with 3D transforms, use <span style="font-family: Courier New,Courier,monospace">evas_map_util_3d_lighting(map, lightx, lighty, lightz, lightr, lightg, lightb, ambientr, ambientg, ambientb)</span>:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">lightx</span>, <span style="font-family: Courier New,Courier,monospace">lighty</span> and <span style="font-family: Courier New,Courier,monospace">lightz</span> are the local light source coordinates;</li>
<li><span style="font-family: Courier New,Courier,monospace">lightr</span>, <span style="font-family: Courier New,Courier,monospace">lightg</span> and <span style="font-family: Courier New,Courier,monospace">lightb</span> are the local light source colors;</li>
<li><span style="font-family: Courier New,Courier,monospace">ambientr</span>, <span style="font-family: Courier New,Courier,monospace">ambientg</span> and <span style="font-family: Courier New,Courier,monospace">ambientb</span> are the ambient light colors. Evas sets the color of each point based on the distance to the light source, the angle with which the object is facing the light and the ambient light. The orientation of each point is important. If the map is defined counter-clockwise, the object faces away from the user and becomes obscured, since no light does not reflect from it.</li>
</ul>

<h2 id="engine" name="engine">Evas Engines Concept </h2>
<p>Evas delegates most of the actual rendering work to its engines. Engines are the backends that Evas uses to render (primitive) objects on a canvas. The canvas can be the screen, or a buffer in the memory.</p>
<p>Evas can work with and provides multiple engines, such as (this list is non-exhaustive):</p>
<ul>
<li>buffer: all the rendering takes place in a buffer</li>
<li>fb: the rendering takes place in the system&#39;s framebuffer</li>
<li>software_x11: this is the most used, using X11</li>
<li>gl_x11: this also renders to an X11 window, except that it uses OpenGL</li>
</ul>
<p>These implement the rendering of all the basic objects by themselves, because they often can be accelerated by the hardware or backend software libraries to provide fast rendering.</p>
<p>If a particular engine does not have the provision for a certain primitive object, it reverts back to using a default software version. </p> 

<h2 id="ui_rendering" name="ui_rendering">UI Rendering Mode</h2> 

<p>Evas removes the need to know about the characteristics of your display system or what graphics calls are used to draw them and how. It deals on an object level where all you do is create and manipulate objects in a canvas, set their properties, and the rest is done for you. This rendering method is called the retained mode, whereas the immediate mode is an alternative rendering method.</p>

<h3 id="immediate" name="immediate">Immediate Mode</h3>

<p>The immediate mode is the most commonly used in graphics toolkit libraries, such as GTK+, GDI, and GDI+. The application is responsible for repainting the portion of the client area that is invalidated.</p>

<p class="figure">Figure: Immediate mode</p> 
<p style="text-align:center;"><img alt="Immediate mode" src="../../images/immediate_mode.png" /></p> 

<p>The application commands any drawing issues as it needs, and the display system draws some GUIs. After the drawing is done, it appears in the destination. This mode allows you to have a exact control over the render cycles. However, if the draw commands are misused, unnecessary drawing can be performed or drawing never happen at all.</p> 
<p>The following example explains the common usage of the immediate mode:</p> 

<pre class="prettyprint">
void update()
{
&nbsp;&nbsp;&nbsp;Image *img = load_image(NEW_IMG);

&nbsp;&nbsp;&nbsp;// Switch button image to new one
&nbsp;&nbsp;&nbsp;update_button_image(img);

&nbsp;&nbsp;&nbsp;// Issue the invalidate area (button area) to be redrawn on the screen
&nbsp;&nbsp;&nbsp;invalidate_area(button_x, button_y, button_w, button_h);

&nbsp;&nbsp;&nbsp;// Move rectangle from (200, 200) to (300, 300)
&nbsp;&nbsp;&nbsp;int rect_prev_x = rect_x;
&nbsp;&nbsp;&nbsp;int rect_prev_y = rect_y;
&nbsp;&nbsp;&nbsp;rectangle_x = 300;
&nbsp;&nbsp;&nbsp;rectangle_y = 300;
&nbsp;&nbsp;&nbsp;set_rect_position(rect_x, rect_y);
   
&nbsp;&nbsp;&nbsp;// Issue the invalidate area (changed area) to be redrawn on the screen
&nbsp;&nbsp;&nbsp;int diff_x = rect_x – rect_prev_x;
&nbsp;&nbsp;&nbsp;int diff_y = rect_y – rect_prev_y;
&nbsp;&nbsp;&nbsp;invalidate_area(rect_prev_x, rect_prev_y, (rect_w + diff_x), (rect_h + diff_y));


&nbsp;&nbsp;&nbsp;// After setting the invalidate area, request rendering to update the screen
&nbsp;&nbsp;&nbsp;render();

&nbsp;&nbsp;&nbsp;// Now you can see how the button image and rectangle position are changed
}
</pre>

<h3 id="retained" name="retained">Retained Mode</h3>

<p>A graphics system adopting the retained mode is basically responsible for responding to all repaint requests for rendering the application objects. Clients do not directly cause actual rendering, but objects are redrawn when parts of them are updated.</p>

<p class="figure">Figure: Retained mode</p> 
<p style="text-align:center;"><img alt="Retained mode" src="../../images/retained_mode.png" /></p> 

<p>Since Evas works with the retained mode, there is no need to command any drawings. The following example shows how to write a GUI code with Evas for your application:</p>

<pre class="prettyprint">
void create_image()
{
&nbsp;&nbsp;&nbsp;// Initialize an image object to be displayed on the screen
&nbsp;&nbsp;&nbsp;Evas_Object *img = evas_object_image_add(e);

&nbsp;&nbsp;&nbsp;// Set image resource
&nbsp;&nbsp;&nbsp;evas_object_image_file_set(img, IMG, NULL);

&nbsp;&nbsp;&nbsp;// Set image position 
&nbsp;&nbsp;&nbsp;evas_object_move(img, 100, 100);

&nbsp;&nbsp;&nbsp;// Set image size
&nbsp;&nbsp;&nbsp;evas_object_resize(img, 200, 200);

&nbsp;&nbsp;&nbsp;// Set image visibility (show or hide)
&nbsp;&nbsp;&nbsp;evas_object_show(img);
}

void create_rectangle()
{
&nbsp;&nbsp;&nbsp;// Initialize an rectangle object to be displayed on the screen
&nbsp;&nbsp;&nbsp;Evas_Object *rect = evas_object_rectangle_add(e);

&nbsp;&nbsp;&nbsp;// Set rectangle color
&nbsp;&nbsp;&nbsp;evas_object_color_set(rect, 255, 0, 0, 255);

&nbsp;&nbsp;&nbsp;// Set rectangle position
&nbsp;&nbsp;&nbsp;evas_object_move(rect, 200, 200);

&nbsp;&nbsp;&nbsp;// Set rectangle size
&nbsp;&nbsp;&nbsp;evas_object_resize(rect, 200, 200);

&nbsp;&nbsp;&nbsp;// Set rectangle visibility (show or hide)
&nbsp;&nbsp;&nbsp;evas_object_show(rect);
}
</pre>

<p>A few main loops later you can replace the image with another one and move the rectangle. You only need to set a new image file to the image object and move the rectangle object. Evas computes the invalidate area and redraws the image and rectangle behind the application when it&#39;s on rendering time.</p>

<pre class="prettyprint">
void update()
{
&nbsp;&nbsp;&nbsp;// Set new image resource
&nbsp;&nbsp;&nbsp;elm_image_file_set(img, NEW_IMG, NULL);

&nbsp;&nbsp;&nbsp;// Set new rectangle position
&nbsp;&nbsp;&nbsp;evas_object_move(rect, 300, 300);
}
</pre>

<h3 id="evas_rendering" name="evas_rendering">Evas Rendering</h3>

<p>Tizen Native applications work on the ecore main loop, and the loop goes on a few steps for every frame. Evas redraws some changes in the objects when the main loop goes to the idle enterer step. If there are no changes, Evas rendering is skipped. Otherwise, Evas calculates any changed portions of all display objects and redraws them.</p>

<p class="figure">Figure: Evas rendering in the main loop</p> 
<p style="text-align:center;"><img alt="Evas rendering in the main loop" src="../../images/rendering1.png" /></p> 

<p>To minimize the rendering, Evas tracks the states of all display objects, such as position, size, visibility, and color. Even if some of these states are changed but the object is hidden by other obscured objects, it is not redrawn. In other words, Evas draws only the necessary changes in the screen.</p>

<p>The following figures illustrate how Evas redraws the changed area:</p>

<ul><li><p>In the first example, there is a blue-color background object (a sky-blue color rectangle) and a partially hidden cloud image object. Above them, there are a red and green rectangle, and the &quot;Hello out there&quot; text is printed on the green rectangle.</p>

<p class="figure">Figure: Evas redrawing example 1</p> 
<p style="text-align:center;"><img alt="Evas redrawing example 1" src="../../images/redrawing01.png" /></p> </li>

<li><p>In the second example, some of the objects have moved (the cloud image is moved to right and the green rectangle is moved downwards).</p>

<p class="figure">Figure: Evas redrawing example 2</p> 
<p style="text-align:center;"><img alt="Evas redrawing example 2" src="../../images/redrawing02.png" /></p> </li>

<li><p>As a result, the third example illustrates some regions that require updates.</p>

<p class="figure">Figure: Evas redrawing example 3</p> 
<p style="text-align:center;"><img alt="Evas redrawing example 3" src="../../images/redrawing03.png" /></p> </li>

<li><p>Evas decides which portions are invalid and to be redrawn. The fourth example shows the cleaned portion of the screen, which is the redrawn area.</p>
<p>Evas redraws the content only in the redrawn portions.</p> 
<p class="figure">Figure: Evas redrawing example 4</p> 
<p style="text-align:center;"><img alt="Evas redrawing example 4" src="../../images/redrawing04.png" /></p></li> 

<li><p>Finally, the fifth example shows how the screen is updated and the result is visible.</p> 

<p class="figure">Figure: Evas redrawing example 5</p> 
<p style="text-align:center;"><img alt="Evas redrawing example 5" src="../../images/redrawing05.png" /></p>

<p>If Evas worked in an immediate mode style, the application would need to calculate the changed areas themselves, adding extra work. With Evas, you can let Evas figure out the updates and you can yourself concentrate on the application and UI core and logic.</p></li></ul>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer"> 
<p class="footer">Except as noted, this content is licensed under <a href="http://opensource.org/licenses/LGPL-2.1" target="_blank">LGPLv2.1+</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p> 
</div> 

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
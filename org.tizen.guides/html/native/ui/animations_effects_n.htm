<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Animation and Effect Types</title> 
 </head> 
 <body onload="prettyPrint()" style="overflow: auto;">
 
 <div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
	</div>
	
	<div id="toc_border"><div id="toc">
	<p class="toc-title">Content</p>
		<ul class="toc">
				<li><a href="#ecore_animation">Ecore Animator</a></li>
				<li><a href="#edje_animation">Edje Animation</a></li>
				<li><a href="#elm_transit">Elementary Animations</a></li>
				<li><a href="#evas_map_animation">Evas Map Effects</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.tutorials/html/native/ui/events_effects_tutorials_n.htm">Event and Effect Tutorials</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Ecore.html">Ecore API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Edje.html">Edje API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Eina.html">Eina API for Mobile Native</a></li>	
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Elementary.html">Elementary API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Evas.html">Evas API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Ecore.html">Ecore API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Edje.html">Edje API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Eina.html">Eina API for Wearable Native</a></li>	
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Elementary.html">Elementary API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Evas.html">Evas API for Wearable Native</a></li>			
			</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">

  <h1>Animation and Effect Types</h1> 

		<h2 id="ecore_animation" name="ecore_animation">Ecore Animator</h2>

<p>Ecore provides a facility for animations called <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span>. Ecore animators use the Ecore main loop for creating animations, running a specific action on each tick of a timer in the main loop.</p>

<p>To create an Ecore animation:</p>
<ol>
    <li>Determine the duration of the animation.</li>
    <li>Define a callback function that performs the animation with that duration.</li>
</ol>

<p>To use Ecore animators in your application, you must include the <span style="font-family: Courier New,Courier,monospace;">&lt;Ecore.h&gt;</span> file. This file is included by default if you are already using the <span style="font-family: Courier New,Courier,monospace;">&lt;Elementary.h&gt;</span> file in your application. You then declare an <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator*</span> variable and use the variable in the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_*</span> functions.</p>

<p>The following example shows how to create a simple animation with a finite duration:</p>

<pre class="prettyprint">
static Eina_Bool
_do_animation(void *data, double pos)
{
&nbsp;&nbsp;&nbsp;evas_object_move(data, 100 * pos, 100 * pos);
&nbsp;&nbsp;&nbsp;// Do some more animating...
}
ecore_animator_timeline_add(2, _do_animation, my_evas_object);
</pre>

<p>In the above example, we create a linear transition to move <span style="font-family: Courier New,Courier,monospace;">my_evas_object</span> from position (0,0) to position (100,100) in 2 seconds.</p>

<h3>Creating an Animation with a Finite Duration</h3>

<p>Most of the time, you will want to create animations that last for a predefined time.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">ecore_animator_timeline_add()</span> function allows you to define an animator that is automatically deleted after the animation is finished:</p>

<pre class="prettyprint">ecore_animator_timeline_add(double runtime, Ecore_Timeline_Cb func, const void *data)</pre>

<ul>
<li>The first argument is the duration of the animation in seconds. The duration is not affected by frame rate.</li>
<li>The second argument is the callback function that performs the animation.</li>
<li>The third argument is the parameter passed to the callback function. This is usually the Evas object to animate.</li>
</ul>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">The callback function can return <span style="font-family: Courier New,Courier,monospace;">ECORE_CALLBACK_RENEW</span> to keep the animator running or <span style="font-family: Courier New,Courier,monospace;">ECORE_CALLBACK_CANCEL</span> to stop the animator and have it be deleted automatically at any time. The callback function is also passed a timeline position parameter with a value between 0.0 (start) to 1.0 (end) to indicate where along the timeline the animator is running.</td>
</tr>
</tbody>
</table>

<p>The following example performs a linear horizontal translation of 500 pixels in 8 seconds:</p>
<pre class="prettyprint">
static Eina_Bool
_my_animation(void *data, double pos)
{
&nbsp;&nbsp;&nbsp;Evas_Object *obj = data; // Get the target object
&nbsp;&nbsp;&nbsp;int x, y, w, h; // Target object geometry
&nbsp;&nbsp;&nbsp;evas_object_geometry_get(obj, &amp;x, &amp;y, &amp;w, &amp;h); // Get current object position and size attributes
&nbsp;&nbsp;&nbsp;evas_object_move(obj, 500 * pos, y); // Linear translation of the Evas object
}
ecore_animator_timeline_add(8, _my_animation, my_evas_object);
</pre>

<h3>Position Mappings</h3>

<p>The <span style="font-family: Courier New,Courier,monospace;">Ecore_Pos_Map</span> position mappings are used to define the evolution of a given position in accordance with the desired effects. The value ranges from 0.0 to 1.0 on a given timeline. This position variation allows you to apply dynamic changes to any attribute of your Evas object, such as position, width, height, scale, angle, and color.</p>

<p>Ecore supports the following position mappings (with the listed v1 and v2 parameters):</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_LINEAR</span>: linear 0.0 - 1.0
    <ul>
        <li>v1: not used</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_ACCELERATE</span>: start slow, then speed up
    <ul>
        <li>v1: not used</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_DECELERATE</span>: start fast, then slow down
    <ul>
        <li>v1: not used</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_SINUSOIDAL</span>: start slow, speed up, then slow down at the end
    <ul>
        <li>v1: not used</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_ACCELERATE_FACTOR</span>: start slow, then speed up
    <ul>
        <li>v1: power factor: 0.0 is linear, 1.0 is standard acceleration, 2.0 is a much more pronounced acceleration (squared), 4.0 is cubed, and so on</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_DECELERATE_FACTOR</span>: start fast, then slow down
    <ul>
        <li>v1: power factor: 0.0 is linear, 1.0 is standard deceleration, 2.0 is a much more pronounced deceleration (squared), 3.0 is cubed, and so on</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_SINUSOIDAL_FACTOR</span>: start slow, speed up, then slow down at the end
    <ul>
        <li>v1: power factor: 0.0 is linear, 1.0 is a standard sinusoidal, 2.1 is a much more pronounced sinusoidal (squared), 3.0 is cubed, and so on</li>
        <li>v2: not used</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_DIVISOR_INTERP</span>: start at gradient * v1, interpolated via power of v2 curve
    <ul>
        <li>v1: multiplication factor for gradient</li>
        <li>v2: curve value</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_BOUNCE</span>: start at 0.0, then &quot;drop&quot; like a ball bouncing to the ground at 1.0, and bounce v2 times, with a decay factor of v1
    <ul>
        <li>v1: bounce decay factor</li>
        <li>v2: number of bounces</li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_SPRING</span>: start at 0.0, then &quot;wobble&quot; like a spring until rest position at 1.0, and wobble v2 times, with a decay factor of v1
    <ul>
        <li>v1: wobble decay factor</li>
        <li>v2: number of wobbles</li>
    </ul>
</li>
</ul>

<p class="figure">Figure: Position mappings</p>
<p align="center"><img alt="Position mappings" src="../../images/pos_map_all.png" /></p>

<h3>Using Position Mappings</h3>
<p>When using the animation callback function, the animator passes a timeline position parameter with a value between 0.0 (start) and 1.0 (end) to indicate where along the timeline the animator is running.</p>

<p>If you want to create a non-linear animation, map the position value to one of several curves and mappings:</p>
<pre class="prettyprint">ecore_animator_pos_map(double pos, Ecore_Pos_Map map, double v1, double v2)</pre>
<ul>
<li>The first argument is the current position value, which ranges from 0.0 to 1.0.</li>
<li>The second argument is the position mapping you want to apply.</li>
<li>The third argument is the first parameter (v1) to pass to the position mapping.</li>
<li>The fourth argument is the second parameter (v2) to pass to the position mapping.</li>
</ul>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">The v1 and v2 arguments are specific to the chosen position mapping. For example, if you are using <span style="font-family: Courier New,Courier,monospace;">ECORE_POS_MAP_BOUNCE</span>, v1 represents the bouncing level and v2 the number of bounces.</td>
</tr>
</tbody>
</table>

<p>The following example performs a transition that bounces 7 times, diminishing by a factor of 1.8 over 5 seconds:</p>

<pre class="prettyprint">static Eina_Bool
_my_animation_callback(void *data, double pos)
{
&nbsp;&nbsp;&nbsp;Evas_Object *obj = data; // Get the target object
&nbsp;&nbsp;&nbsp;int x, y, w, h; // Target object geometry
&nbsp;&nbsp;&nbsp;double frame = pos; // Actual position variation
&nbsp;&nbsp;&nbsp;// Get frame relative position depending on desired effect
&nbsp;&nbsp;&nbsp;frame = ecore_animator_pos_map(pos, ECORE_POS_MAP_BOUNCE, 1.8, 7);
&nbsp;&nbsp;&nbsp;evas_object_geometry_get(obj, &amp;x, &amp;y, &amp;w, &amp;h); // Get current object position and size attributes
&nbsp;&nbsp;&nbsp;evas_object_move(obj, x, 600 * frame); // Move the Evas object according to desired effect

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
ecore_animator_timeline_add(5, _my_animation_callback, my_evas_object);</pre>

<h3>Creating an Infinite Animation</h3>

<p>If you want the animation to run for an unspecified amount of time, use the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_add()</span> function. This function works the same way as the <span style="font-family: Courier New,Courier,monospace;">ecore_animation_timeline_add()</span> function, except its interval is based on frame rate. Using frame rate as the basis benefits performance, especially if you define multiple animations, since you may want to have a different timer for each callback function.</p>

<pre class="prettyprint">
ecore_animator_add(Ecore_Task_Cb func, const void *data)
</pre>

<ul>
<li>The first argument is the callback function that performs the animation.</li>
<li>The second argument is the parameter passed to the callback function. This is usually the Evas object to animate.</li>
</ul>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">The function returns a pointer to an <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span> object, which you can use to adjust the animation.</td>
</tr>
</tbody>
</table>

<p>The following example creates a rectangle sliding from left to right and back again. When the rectangle hits one edge of the screen, it changes direction.</p>

<pre class="prettyprint">static Eina_Bool
_slide_back_and_forth(void *data)
{
&nbsp;&nbsp;&nbsp;typedef enum {LEFT, RIGHT} direction_t; // Direction datatype
&nbsp;&nbsp;&nbsp;static int x = 0; // Initial position
&nbsp;&nbsp;&nbsp;static direction_t direction = RIGHT; // Initial direction
&nbsp;&nbsp;&nbsp;if (x &gt;= 250)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = LEFT; // Change direction
&nbsp;&nbsp;&nbsp;else if (x &lt;= 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction = RIGHT; // Change direction
&nbsp;&nbsp;&nbsp;if (direction == RIGHT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_move(data, ++x, 350); // Slide to right
&nbsp;&nbsp;&nbsp;else if (direction == LEFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_move(data, --x, 350); // Slide to left

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
int
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;// Declarations

&nbsp;&nbsp;&nbsp;// Ecore Evas init

&nbsp;&nbsp;&nbsp;// Draw Evas objects

&nbsp;&nbsp;&nbsp;// Animations go here
&nbsp;&nbsp;&nbsp;anim = ecore_animator_add(_slide_back_and_forth, rectangle);
&nbsp;&nbsp;&nbsp;// Ecore main loop

&nbsp;&nbsp;&nbsp;// Free memory
}</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">To use this code, you have to merge it with the Ecore transition example above.</td>
</tr>
</tbody>
</table>

<h3>Chaining Animations</h3>

<p>You may sometimes want to delay animating an object. This can be useful if, for example, you want to start an animation only after another one has finished.</p>

<p>You can simply set a delay to the second animation equal to the duration of the first animation:</p>

<pre class="prettyprint">
static int runtime = 5;
static int delay = runtime;
static Eina_Bool
_start_fold_animation(void *data)
{
&nbsp;&nbsp;&nbsp;ecore_animator_timeline_add(runtime, _fold_animation, data);

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}
static Eina_Bool
_start_unfold_animation(void *data)
{
&nbsp;&nbsp;&nbsp;ecore_animator_timeline_add(runtime, _unfold_animation, data);

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}
_start_fold_animation(my_evas_object);
ecore_timer_add(delay, _start_unfold_animation, my_evas_object);
</pre>

<h3>Pausing and Resuming Animations</h3>

<p>You can pause and resume Ecore animations. To pause a running animation, use the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_freeze()</span> function:</p>

<pre class="prettyprint">ecore_animator_freeze(Ecore_Animator *animator)</pre>

<p>The parameter is the <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span> to pause.</p>

<p>To resume the paused animation, use the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_thaw()</span> function:</p>

<pre class="prettyprint">ecore_animation_thaw(Ecore_Animator *animator)</pre>

<p>The parameter is the <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span> to resume.</p>

<p>The following example pauses a transition after 5 seconds and resumes it after 5 more seconds:</p>

<pre class="prettyprint">
static Eina_Bool
_freeze_animation(void *data)
{
&nbsp;&nbsp;&nbsp;ecore_animator_freeze(data);

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}
static Eina_Bool
_thaw_animation(void *data)
{
&nbsp;&nbsp;&nbsp;ecore_animator_thaw(data);

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}
ecore_timer_add(5, _freeze_animation, animator);
ecore_timer_add(10, _thaw_animation, animator);
</pre>

<h3>Freeing Up Memory</h3>

<p>When you create an animation that does not have a timeout, you will have to manually free up the memory allocated to the <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span> object. By comparison, if the animation has a timeout, Ecore implements the mechanisms to automatically delete the animator from the list of pointers: When your animation callback returns 0 or <span style="font-family: Courier New,Courier,monospace;">ECORE_CALLBACK_CANCEL</span>, the animator manager takes care of freeing up the allocated memory.</p>

<p>To manually free up the memory, delete the pointer by using the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_del()</span> function:</p>

<pre class="prettyprint">ecore_animator_del(Ecore_Animator *animator)</pre>

<p>The argument is the <span style="font-family: Courier New,Courier,monospace;">Ecore_Animator</span> whose memory allocation to free up.</p>

<p>Regardless of the type of animation, it is good practice to always ensure that the allocated memory is freed up before the program exits:</p>

<pre class="prettyprint">if (animator != NULL)
&nbsp;&nbsp;&nbsp;ecore_animator_del(animator);</pre>

<h3>Frametime</h3>
<p>In most cases, you will want to use the default timer <span style="font-family: Courier New,Courier,monospace;">ECORE_ANIMATOR_SOURCE_TIMER</span>. This timer ticks every &quot;frametime&quot; seconds and allows you to perform transitions within a predefined timeline. The timer uses the system clock to tick over every Nth second, with the default being 1/30th of a second.</p>

<p>To tweak performance, you can change the frametime value:</p>

<pre class="prettyprint">ecore_animator_frametime_set(double frametime)</pre>

<p>The argument is the new frametime value.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Too small a value can cause performance issues, whereas too high a value can cause your animation to seem jerky.</td>
</tr>
</tbody>
</table>

<p>If you want to get the current frametime value, use the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_frametime_get()</span> function.</p>

<h3>Custom Timer</h3>

<p>You may want to specify a custom timer to match your animation to third-party events. For example, the filling speed of a progress bar will mainly depend on the time it takes for a task to complete and the velocity at which the remaining time estimation evolves. This kind of animation requires you to use a custom timer.</p>

<p>To use a custom timer, first set <span style="font-family: Courier New,Courier,monospace;">ECORE_ANIMATOR_SOURCE_CUSTOM</span> as the timer source, and then drive the timer based on an input tick source (such as another application via IPC or a vertical blanking interrupt):</p>

<pre class="prettyprint">ecore_animator_custom_source_tick_begin_callback_set(Ecore_Cb func, const void *data)</pre>

<p>The first argument is the callback function to call on the tick start. The second argument is the data to pass to the callback function.</p>

<pre class="prettyprint">ecore_animator_custom_source_tick_end_callback_set(Ecore_Cb func, const void *data)</pre>

<p>The first argument is the callback function to call on the tick end. The second argument is the data to pass to the callback function to set the functions that will be called to start and stop the ticking source.</p>

<p>Next, trigger a tick over one frame:</p>

<pre class="prettyprint">ecore_animator_custom_tick(void)</pre>

<p>The following example supposes a progress bar that will be refreshed every time some progress occurs:</p>

<pre class="prettyprint">ecore_animator_source_set(ECORE_ANIMATOR_SOURCE_CUSTOM);
void _on_progress_update()
{
&nbsp;&nbsp;&nbsp;// Called when some progress occurs
&nbsp;&nbsp;&nbsp;ecore_animator_custom_tick(); // Tick (next frame in progress bar animation)
}</pre>

<p>Finally, to get the current animator source, use the <span style="font-family: Courier New,Courier,monospace;">ecore_animator_source_get()</span> function.</p>
  
  
  
  <h2 id="edje_animation" name="edje_animation">Edje Animation</h2>

<p>The Edje animations are based on a very simple principle: going from one state to another. If you want to animate something with Edje, you must define two states and move from the first state to the second.</p>

<h3 id="Animating_Rectangle" name="Animating_Rectangle">Animating a Rectangle</h3>

<p>This example shows how to animate a rectangle. It is positioned in the top left corner of the window and is moved to the bottom right corner in five seconds. To do that with Edje, define a <span style="font-family: Courier New,Courier,monospace;">part</span> called &quot;rectangle&quot; with the <span style="font-family: Courier New,Courier,monospace;">type RECT:</span> this part has two descriptions (or states). In the first state, the rectangle is in is the top left corner. In the second state, it is in is the bottom right corner. To create the transition, set this EDC code for Edje to switch the object from its current state to another.</p>

<pre class="prettyprint">
collections 
{
&nbsp;&nbsp;&nbsp;group 
&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;main&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;align: 0.0 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.0 0.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 0.3 0.1;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 255 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;align: 0.0 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.7 0.9;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 1.0 1.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 255 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;programs 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;animation,state1&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: &quot;&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: &quot;load&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition: LINEAR 5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>The &quot;rectangle&quot; part has two descriptions that share the same name, but have a different &quot;version&quot;.</p>

<pre class="prettyprint">
part 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.5;
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>The program defines when and how to move from one state to another. A program is called upon reception of a signal from a source. Here the program is called when the signal load is received from any source.</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;animation,state1&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;load&quot;;
}
</pre>

<p>An action is performed upon the signal reception. In this example, the state is changed.</p>

<pre class="prettyprint">
action: STATE_SET &quot;default&quot; 0.5;
</pre>

<p>The program has a target, here the &quot;rectangle&quot;.</p>

<pre class="prettyprint">
target: &quot;rectangle&quot;;
</pre>

<p>The program uses a transition to perform the action.</p>

<pre class="prettyprint">
transition: LINEAR 5;
</pre>

<p>This example produces a blue rectangle that moves from the upper left to the lower right corner with a linear transition in five seconds.</p>

<h3 id="Actions" name="Actions">Actions</h3>

<p>The Edje programs are not only for animations. There are different actions, for example <span style="font-family: Courier New,Courier,monospace;">STATE_SET</span> and <span style="font-family: Courier New,Courier,monospace;">ACTION_STOP</span>. You may also send signals with <span style="font-family: Courier New,Courier,monospace;">SIGNAL_EMIT</span>.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">STATE_SET</span> action changes the state of the &quot;target&quot;.</p>

<p>In the following example, the state of the part named &quot;image&quot; changes to &quot;default&quot; &quot;0.0&quot;.</p>

<pre class="prettyprint">
program 
{
&nbsp;&nbsp;&nbsp;name: &quot;animate&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;animate&quot;;
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;transition: LINEAR 3.0;
&nbsp;&nbsp;&nbsp;target: &quot;image&quot;;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">ACTION_STOP</span> stops the program specified by &quot;target&quot;.</p>

<pre class="prettyprint">
program 
{
&nbsp;&nbsp;&nbsp;name: &quot;animate_stop&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;animate_stop&quot;;
&nbsp;&nbsp;&nbsp;action: ACTION_STOP;
&nbsp;&nbsp;&nbsp;target: &quot;animate_loop&quot;;
}
</pre>

<p>The previous example stops the program defined as &quot;target&quot; named <span style="font-family: Courier New,Courier,monospace;">animate_loop</span>. This program runs on the <span style="font-family: Courier New,Courier,monospace;">animate_stop</span> signal.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">SIGNAL_EMIT</span> emits a signal that is used to communicate with the application directly from the theme.</p>

<p>The following example emits a signal <span style="font-family: Courier New,Courier,monospace;">frame_move</span> &quot;start&quot; when it receives the signal <span style="font-family: Courier New,Courier,monospace;">mouse,down,*</span> from the <span style="font-family: Courier New,Courier,monospace;">video_over</span> part. In other words, it sends the signal <span style="font-family: Courier New,Courier,monospace;">frame_move</span> &quot;start&quot; when the mouse is pressed in the <span style="font-family: Courier New,Courier,monospace;">video_over</span> part.</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;video_move_start&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;mouse,down,*&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;video_mover&quot;;
&nbsp;&nbsp;&nbsp;action: SIGNAL_EMIT &quot;frame_move&quot; &quot;start&quot;;
}
</pre>

<h3 id="Transitions" name="Transitions">Transitions</h3>

<p>The transitions available are:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">LIN</span> or <span style="font-family: Courier New,Courier,monospace;">LINEAR</span>: makes a linear transition and takes the duration in seconds as the parameter</li>
<li><span style="font-family: Courier New,Courier,monospace;">SIN</span> or <span style="font-family: Courier New,Courier,monospace;">SINUSOIDAL</span>: makes a sinusoidal transition and takes the duration in seconds as the parameter</li>
<li><span style="font-family: Courier New,Courier,monospace;">ACCEL</span> or <span style="font-family: Courier New,Courier,monospace;">ACCELERATE</span>: makes an accelerated transition and takes the duration in seconds as the parameter</li>
<li><span style="font-family: Courier New,Courier,monospace;">DECEL</span> or <span style="font-family: Courier New,Courier,monospace;">DECELERATE</span>: makes a decelerated transition and takes the duration in seconds as the parameter</li>
<li><span style="font-family: Courier New,Courier,monospace;">ACCEL_FAC</span> or <span style="font-family: Courier New,Courier,monospace;">ACCELERATE_FACTOR</span>: makes an accelerated transition and takes the duration and the factor as the parameters</li>
<li><span style="font-family: Courier New,Courier,monospace;">DECEL_FAC</span> or <span style="font-family: Courier New,Courier,monospace;">DECELERATE_FACTOR</span>: makes a decelerated transition and takes the duration and the factor as the parameters</li>
<li><span style="font-family: Courier New,Courier,monospace;">SIN_FAC</span> or <span style="font-family: Courier New,Courier,monospace;">SINUSOIDAL_FACTOR</span>: makes a sinusoidal transition and takes the duration and the factor as the parameters</li>
<li><span style="font-family: Courier New,Courier,monospace;">DIVIS</span> or <span style="font-family: Courier New,Courier,monospace;">DIVISOR_INTERP</span>: takes 3 parameters:
	<ul>
		<li>the duration</li>
        <li>the initial gradient start (0.0 is horizontal, 1.0 is diagonal (linear), 2.0 is twice the gradient of linear, and so on)</li>
        <li>an integer factor that defines how much the value swings outside the gradient to come back to the final resting spot at the end. 0.0 for the third parameter is equivalent to linear interpolation. Note that DIVIS may exceed 1.0.</li>
	</ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">BOUNCE</span>: makes a bounce transition and takes 3 parameters:
	<ul>
        <li>the duration</li>
        <li>how much the bounce decays, with 0.0 giving linear decay per bounce, and higher values giving more decay</li>
        <li>the number of bounces (rounded down to the nearest integer value)</li>
	</ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">SPRING</span>: makes a spring transition and takes 3 parameters:
	<ul>
        <li>the duration</li>
        <li>the decay, with the level exceeding 1.0 on the outer swings</li>
        <li>the number of spring swings</li>
	</ul>
</li>
</ul>

<p>There are graphical representations of these effects in the <span style="font-family: Courier New,Courier,monospace;">Ecore_Evas</span> section above.</p>

<h3 id="Chaining" name="Chaining">Chaining Edje Programs</h3>

<p>To define a couple of Edje programs and chain them, we can, for example, create a program to make the rectangle return to its initial state with another transition (such as <span style="font-family: Courier New,Courier,monospace;">BOUNCE</span>).</p>

<p>Use the statement <span style="font-family: Courier New,Courier,monospace;">after</span> in the first <span style="font-family: Courier New,Courier,monospace;">program</span>. <span style="font-family: Courier New,Courier,monospace;">after</span> takes the name of the transition to run when the program is done.</p>

<pre class="prettyprint">
after: &quot;animation,state0&quot;;
</pre>

<p>This is how to add the bounce animation. To return the blue rectangle to its initial position with a <span style="font-family: Courier New,Courier,monospace;">BOUNCE</span> transition: it bounces with a factor of 1.8, six times. This program is only to be used at the end of the first one, so it does not have any signal statement.</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;animation,state0&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;&quot;;
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;transition: BOUNCE 5 1.8 6;
}
</pre>

<h3 id="Playing_Signals" name="Playing_Signals">Playing on Signals</h3>

<p>The programs start when they receive a signal from a source. Edje handles many kind of signals, including mouse events.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">To show the signals, use <span style="font-family: Courier New,Courier,monospace;">edje_player -p myfile.edj</span>.</td>
</tr>
</tbody>
</table> 

<p>For example, in another transition the rectangle is left clicked. The corresponding signal name is <span style="font-family: Courier New,Courier,monospace;">mouse,clicked,1</span>.</p>

<p>For this transition, define a new state. This state changes the color and the position of the rectangle.</p>

<pre class="prettyprint">
// To be placed in the &quot;part&quot; definition
description 
{ 
&nbsp;&nbsp;&nbsp;state: &quot;color&quot; 0.0;
&nbsp;&nbsp;&nbsp;rel1 {relative: 0.3 0.3;}
&nbsp;&nbsp;&nbsp;rel2 {relative: 0.7 0.4;}
&nbsp;&nbsp;&nbsp;color: 255 0 0 255;
}
</pre>

<p>The program is as follows:</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;animation,color&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;mouse,clicked,1&quot;;
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;color&quot; 0.0;
&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;transition: SIN 2;
}
</pre>

<p>This starts when the rectangle is left clicked.</p>

<p>If you want to send a signal from your application when you use signals to start transitions, create a program waiting for your own special signal. For example:</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;animation,menu_side,hide&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;MenuButton&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;hide,sidemenu&quot;;
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 1.0;
&nbsp;&nbsp;&nbsp;target: &quot;menu/side&quot;;
&nbsp;&nbsp;&nbsp;transition: LINEAR 0.2;
}
</pre>

<p>This program changes the state of the target named <span style="font-family: Courier New,Courier,monospace;">animation,menu_side,hide</span> to <span style="font-family: Courier New,Courier,monospace;">&quot;default&quot; 1.0</span>. It waits for the <span style="font-family: Courier New,Courier,monospace;">hide,sidemenu</span> signal emitted by a source called <span style="font-family: Courier New,Courier,monospace;">MenuButton</span>.</p>

<pre class="prettyprint">
edje_object_signal_emit(layout, &quot;hide,sidemenu&quot;, &quot;MenuButton&quot;);
</pre>

<p>This statement sends a signal named <span style="font-family: Courier New,Courier,monospace;">hide,sidemenu</span> with a source named <span style="font-family: Courier New,Courier,monospace;">MenuButton</span> to the object called <span style="font-family: Courier New,Courier,monospace;">layout</span>.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">edje_object_signal_emit</span> function emits a signal on an <span style="font-family: Courier New,Courier,monospace;">Evas_Object</span> part of the application.</p>

<pre class="prettyprint">
edje_object_signal_emit(Evas_Object *obj,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *emission,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *source)
</pre>

<ul>
<li>The first parameter is the <span style="font-family: Courier New,Courier,monospace;">Evas_Object</span>, which emits the signal (<span style="font-family: Courier New,Courier,monospace;">layout</span> in the example).</li>
<li>The second parameter is the <span style="font-family: Courier New,Courier,monospace;">emission</span> string (the name of the signal <span style="font-family: Courier New,Courier,monospace;">hide,sidemenu</span> in the example).</li>
<li>The third parameter is the <span style="font-family: Courier New,Courier,monospace;">source</span> of the signal (the name of the source, <span style="font-family: Courier New,Courier,monospace;">MenuButton</span> in the example).</li>
</ul>

<p>If you use the Elementary in the application, you can use <span style="font-family: Courier New,Courier,monospace;">elm_object_signal_emit</span>. It functions exactly the same way as <span style="font-family: Courier New,Courier,monospace;">edje_object_signal_emit</span> and takes the same parameters.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">To find a complete example, use <span style="font-family: Courier New,Courier,monospace;">elm_object_signal_emit</span> in the <a href="../../../../org.tizen.tutorials/html/native/ui/menu_tutorial_mn.htm">Menu Tutorial</a>.</td>
</tr>
</tbody>
</table> 

<h3 id="Rotate" name="Rotate">Rotate with Edje</h3>

<p>The Edje library allows you to rotate objects, using the <span style="font-family: Courier New,Courier,monospace;">map</span> statement. For example, if you want to rotate the blue rectangle on a right click, you must define a new rotate state. To enable the <span style="font-family: Courier New,Courier,monospace;">map</span> on you object you must add a <span style="font-family: Courier New,Courier,monospace;">map</span> part to your default state.</p>

<pre class="prettyprint">
map 
{
&nbsp;&nbsp;&nbsp;on: 1;
&nbsp;&nbsp;&nbsp;smooth: 1;
&nbsp;&nbsp;&nbsp;perspective_on: 1;
&nbsp;&nbsp;&nbsp;rotation.x: 0;
&nbsp;&nbsp;&nbsp;rotation.y: 0;
&nbsp;&nbsp;&nbsp;rotation.z: 0;
}
</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">on</span>: 1; enables the map on the object</li>
<li><span style="font-family: Courier New,Courier,monospace;">perspective_on</span>: 1, enables the perspective when rotating, even without a perspective point object</li>
<li><span style="font-family: Courier New,Courier,monospace;">smooth</span>: 1; enables a smooth map rendering</li>
<li>The rotation statements define the default rotation of the object on x, y, and z axes.</li>
</ul>

<p>To add a new rotate state with a rotation around any axis, do the following.</p>

<pre class="prettyprint">
description 
{ 
&nbsp;&nbsp;&nbsp;state: &quot;rotate&quot; 0.0;
&nbsp;&nbsp;&nbsp;inherit: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;map.rotation.z: 120;
}
</pre>

<p>This rotate state inherits all the default state properties, but changes the value of <span style="font-family: Courier New,Courier,monospace;">map.rotation.z</span> from 0&deg; to 120&deg;.</p>

<p>To set a program to run the rotate state, do the following.</p>

<pre class="prettyprint">
program 
{ 
&nbsp;&nbsp;&nbsp;name: &quot;animation,rotate&quot;;
&nbsp;&nbsp;&nbsp;source: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;signal: &quot;mouse,clicked,3&quot;;
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;rotate&quot; 0.0;
&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;transition: LIN 5;
}
</pre>

<p>This program runs on a right click on the rectangle object.</p>

<p>The complete code of this example is as follows.</p>

<pre class="prettyprint">
collections 
{
&nbsp;&nbsp;&nbsp;group 
&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;main&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;align: 0.0 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.0 0.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 0.3 0.1;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smooth: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perspective_on: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotation 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z: 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x: 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y: 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 255 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;align: 0.0 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.7 0.9;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 1.0 1.0;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 255 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;color&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.3 0.3;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 0.7 0.4;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 255 0 0 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;rotate&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.rotation.z: 120;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;programs 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;animation,state1&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: &quot;&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: &quot;load&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition: LINEAR 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after: &quot;animation,state0&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;animation,state0&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: &quot;&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: &quot;&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition: BOUNCE 2 1.8 26;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;animation,color&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: &quot;mouse,clicked,1&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;color&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition: SIN 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;program 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;animation,rotate&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: &quot;mouse,clicked,3&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;rotate&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: &quot;rectangle&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition: LIN 5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>
<h2 id="elm_transit" name="elm_transit">Elementary Animations</h2>

<p>Elementary transitions (<span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span>) allow you to apply various transition effects, such as translation and rotation, to Evas objects. Elementary transitions are mostly based on Ecore animators, but provide some transition methods at a higher level of abstraction. Elementary transitions provide a simpler way of animating objects than Ecore animators or Edje animations.</p>

<p>To use Elementary transitions, you must create an <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> object and define the desired transitions using the methods of this object. After the transitions are registered, they will be automatically managed: their callback functions will be called for the set duration, and they will be deleted upon completion.</p>

<p>Use Elementary transitions only when Edje animations are not sufficient. Edje animations are better at handling transitions, have more flexibility, and can be manipulated inside themes. The only drawback is that Edje animations have their own definition language. If you want to code with the C language, use Elementary transitions.</p>

<h3 id="Getting_Started" name="Getting_Started">Getting Started</h3>
<p>The first thing you need to do when creating an transition with <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> is to build your transit object using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_add()</span> function:</p>

<pre class="prettyprint">Elm_Transit *transit = elm_transit_add();</pre>

<p>You now have an <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that will allow you to perform transitions on one or more objects. The transit object holds the information about the target objects and the transition effects that will be used. The transit object also contains information about animation duration, number of repetitions, auto-reverse, and so on. The transit object starts playing as soon as the application enters the main loop.</p>

<h3 id="Adding_Objects" name="Adding_Objects">Adding Objects to an Animation</h3>

<p>You can add your Evas objects to your transition using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_object_add()</span> function:</p>

<pre class="prettyprint">elm_transit_object_add(Elm_Transit *transit, Evas_Object *obj)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that handles the transition. The second argument is the Evas object to animate.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note"><p>The Evas object can be a low-level component, such as a rectangle, but also a UI component, such as a button, image, or calendar.</p>
<p>If you want to animate an Evas object handled by a container, such as a box, you need to either unpack the object before the animation or animate the whole container.</p></td>
</tr>
</tbody>
</table>

<p>If you want to know which objects are currently in your transition, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_objects_get()</span> function. You will get a list of all the objects that are subject to the transition.</p>

<p>At any time, you can remove objects from the transition:</p>

<pre class="prettyprint">elm_transit_object_remove(Elm_Transit *transit, Evas_Object *obj)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that handles the transition. The second argument is the Evas object to remove from the transition.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">After you have added at least one Evas object to your transition, if the list of objects gets emptied somehow, be it because the transition has been terminated or all objects have been deleted, the transition will be automatically deleted. Otherwise, you will have to delete the transition by yourself using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_del()</span> function. If you delete the transit while the transition is running, the transition will stop.</td>
</tr>
</tbody>
</table>

<h4>Adding Images to an Animation</h4>

<p>If you do not want to manage UI components for animating images, <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> provides a helper function for directly manipulating images:</p>

<pre class="prettyprint">
elm_transit_effect_image_animation_add(Elm_Transit *transit, Eina_List *images)
</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that handles the transition. The second argument is a list of the image paths.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">This list and its contents will be deleted after the effect ends by the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_image_animation_context_free()</span> function.</td>
</tr>
</tbody>
</table>

<p>You can now define your image transitions exactly the same way as with any Evas object.</p>

<p>The following example shows how to use <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> with images:</p>

<pre class="prettyprint">char buf[PATH_MAX];
Eina_List *images = NULL;
Elm_Transit *transit = elm_transit_add();
snprintf(buf, sizeof(buf), &quot;%s/images/btn_default.png&quot;, PACKAGE_DATA_DIR);
images = eina_list_append(images, eina_stringshare_add(buf));
snprintf(buf, sizeof(buf), &quot;%s/images/btn_hover.png&quot;, PACKAGE_DATA_DIR);
images = eina_list_append(images, eina_stringshare_add(buf));
elm_transit_effect_image_animation_add(transit, images);</pre>

<h3 id="Animation_Duration" name="Animation_Duration">Animation Duration</h3>

<p>With <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span>, setting the transition duration is mandatory. To set the duration, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_duration_set()</span> function:</p>

<pre class="prettyprint">elm_transit_duration_set(Elm_Transit *transit, double duration)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that handles the transition. The second argument is the duration in seconds.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">The purpose of <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> is to abstract the low-level details of object interpolation, so you cannot create an infinite transition by specifying the duration. However, you can make your transition last forever using the repeat function.</td>
</tr>
</tbody>
</table>

<p>The following example shows how to make a complete revolution of the target Evas object in 2 seconds:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_rotation_add(transit, 0.0, 360);
elm_transit_duration_set(transit, 2.0);
elm_transit_go(transit);
</pre>

<p>To get the duration of the transition, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_duration_get()</span> function.</p>

<h3 id="Acceleration_Mode" name="Acceleration_Mode">Animation Acceleration Mode ("Tween Mode")</h3>

<p><span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> supports a number of built-in interpolation methods. By default, all interpolations are linear. If you want to change the animation&#39;s dynamics, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_tween_mode_set()</span> function:</p>

<pre class="prettyprint">elm_transit_tween_mode_set(Elm_Transit *transit, Elm_Transit_Tween_Mode tween_mode)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance that handles the transition. The second argument is the tween mode of the transition, which can be one of the following:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_TWEEN_MODE_LINEAR</span>: The default mode.</li>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_TWEEN_MODE_SINUSOIDAL</span>: The transition starts with acceleration and ends with deceleration.</li>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_TWEEN_MODE_DECELERATE</span>: The transition decelerates over time.</li>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_TWEEN_MODE_ACCELERATE</span>: The transition accelerates over time.</li>
</ul>

<p>To get the current tween mode, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_tween_mode_get()</span> function.</p>

<h3 id="Animation_Repeat" name="Animation_Repeat">Animation Repeat</h3>

<p>To set a transition to repeat, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_repeat_times_set()</span> function:</p>

<pre class="prettyprint">elm_transit_repeat_times_set(Elm_Transit *transit, int repeat)</pre>

<p>The function takes the following arguments:</p>
<ul>
<li>The transition you want to repeat.</li>
<li>The number of times the transition repeats.</li>
</ul>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">If the <span style="font-family: Courier New,Courier,monospace;">repeat</span> argument is set to 0, the transition will not loop at all. If set to 1, the transition will run twice. If set to a negative value, the transition will repeat forever.</td>
</tr>
</tbody>
</table>

<p>To get the repeat value, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_repeat_times_get()</span> function. The default value is 0.</p>

<p>The following example shows how to make an Evas object spin for 3 complete revolutions in 6 seconds:</p>

<pre class="prettyprint">Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_rotation_add(transit, 0.0, 360);
elm_transit_duration_set(transit, 2.0);
elm_transit_repeat_set(transit, 3.0);
elm_transit_go(transit);</pre>

<h3 id="Auto_Reverse" name="Auto_Reverse">Animation Auto-reverse</h3>

<p><span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> provides a helper function for automatically reversing the transition once it finishes:</p>

<pre class="prettyprint">elm_transit_auto_reverse_set(Elm_Transit *transit, Eina_Bool reverse)</pre>

<p>The first argument is the transition you want to reverse. The second argument is the reverse state. If the reverse state is set to <span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span>, this function will perform the same transition backwards as soon as the first transition is complete.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">
    <p>Reversing the transition doubles the duration of the transition. Moreover, if the transition is set to repeat, the transition will run back and forth until the repeat count is finished.</p>
    <p>You can calculate the duration as follows if both auto-reverse and repeat are set: 2 * duration * repeat.</p>
</td>
</tr>
</tbody>
</table>

<p>The following example shows how to make an object perform half a turn and then reverse the animation to its original position in 4 seconds:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_rotation_add(transit, 0.0, 360);
elm_transit_duration_set(transit, 2.0);
elm_transit_auto_reverse_set(transit, EINA_TRUE);
elm_transit_go(transit);
</pre>

<p>To determine whether the auto-reverse mode is enabled, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_auto_reverse_get()</span> function.</p>

<h3 id="Transitions2" name="Transitions2">Transitions</h3>

<p>We distinguish two main transition types:</p>
<ul>
<li>Transitions that are applied to the properties of objects, such as position, size, angle, and color.</li>
<li>Transitions from one object to another, where the first object is hidden to let the second one appear.</li>
</ul>
<p>All transitions are based on the same principle: we set the starting and the ending values for the properties we want to animate, we then set the lifespan of the animation, and finally we inquire the preferred interpolation method (such as linear, acceleration, or bounce).</p>

<p>You must declare the transitions after the parent window has been created, since the transition effects make use of the geometric properties of the parent window. If the parent window does not yet exist when calculating the interpolation, the interpolation may end up being based on wrong information.</p>

<h3 id="Built-in_Transitions" name="Built-in_Transitions">Built-in Transitions</h3>

<p><span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> provides several built-in transition definitions that are useful for the most common cases, so you that will not have to code them from scratch.</p>

<p>All these built-in effects are implemented as follows:</p>

<pre class="prettyprint">Elm_Transit *transit = elm_transit_add();
elm_transit_effect_add(transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_transit_effect_translation_op,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_transit_effect_translation_context_new(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_transit_effect_translation_context_free);</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">transit</span>: The <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> object that contains the target Evas objects and all the information needed to setup the transition.</li>
<li><span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_translation_op</span>: The callback function that performs the transition (resizing interpolation in this example).</li>
<li><span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_translation_context_new()</span>: The callback function that returns the context used in the transition for calculations. In this example, the context is the coordinates of the before and after objects.</li>
<li><span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_translation_context_free</span>: The callback function that frees up the memory once the transition is complete.</li>
</ul>

<p>All the definitions above can be rewritten as follows:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_effect_translation_add(transit, from_x, from_y, to_x, to_y);
</pre>

<h4>Translation</h4>
<p>To perform a translation on an Evas object, use the following method:</p>

<pre class="prettyprint">
elm_transit_effect_translation_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord from_dx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord from_dy,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord to_dx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord to_dy)
</pre>

<ul>
<li>The first argument is the transit object that contains (among other things) all the Evas objects subject to the translation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_dx</span>: The starting X coordinate (source).</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_dy</span>: The starting Y coordinate (source).</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_dx</span>: The ending X coordinate (destination).</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_dy</span>: The ending Y coordinate (destination).</li>
</ul>

<p>The following example shows how to slide an Evas object (a rectangle) on a 45-degree diagonal, from bottom-left to top-right, at a constant speed, and in 1 second:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, rectangle);
elm_transit_effect_translation_add(transit, 0, 0, 280, 280);
elm_transit_duration_set(transit, 1);
elm_transit_go(transit);
</pre>

<h4>Color Transition</h4>

<p>Color transitions allow you to dynamically change the color of Evas objects. The first argument is the transit object, while the other arguments will be used to define the color transition using RGB colors. There is also an alpha channel that controls the opacity of the color (the background of the object, not the object itself).</p>

<pre class="prettyprint">
elm_transit_effect_color_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int from_r,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int from_g,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int from_b,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int from_a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int to_r,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int to_g,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int to_b,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int to_a)
</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">transit</span>: The transit object that contains (among other things) all the Evas objects subject to the translation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_r</span>: The start value for &quot;Red&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_g</span>: The start value for &quot;Green&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_b</span>: The start value for &quot;Blue&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_a</span>: The start value for &quot;Alpha&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_r</span>: The end value for &quot;Red&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_g</span>: The end value for &quot;Green&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_b</span>: The end value for &quot;Blue&quot;.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_a</span>: The end value for &quot;Alpha&quot;.</li>
</ul>

<p>The following example shows how to transit a rectangle from red to blue in 3 seconds:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, rectangle);
elm_transit_effect_color_add(transit, // Target object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255, 0, 0, 255, // From color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, 0, 255, 255); // To color
elm_transit_duration_set(transit, 3);
elm_transit_go(transit);
</pre>

<h4>Rotation</h4>

<pre class="prettyprint">elm_transit_effect_rotation_add(Elm_Transit *transit, float from_degree, float to_degree)</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">transit</span>: The transit object that contains (among other things) all the Evas objects subject to the translation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_degree</span>: The start degree of rotation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_degree</span>: The end degree of rotation.</li>
</ul>

<p>This function can be used to perform a rotation on any Evas object. It works the same way as the other transit effects and takes two arguments for the starting and ending angles. Note that if you apply a rotation on multiple objects, they will individually mill around and not act as a group. If you want several objects to revolve around a common point, you must encapsulate the objects into a single parent object and apply the rotation to the parent object. The following example shows how to achieve this:</p>

<pre class="prettyprint">
// Parent container
Evas_Object *parent = elm_box_add(my_window);
evas_object_show(parent);
elm_box_horizontal_set(parent, EINA_TRUE);
elm_box_homogeneous_set(parent, EINA_TRUE);

// Button 1
Evas_Object *btn1 = elm_button_add(parent);
elm_object_text_set(btn1, &quot;Btn1&quot;);
elm_box_pack_start(parent, btn1);
evas_object_show(btn1);

// Button 2
Evas_Object *btn2 = elm_button_add(parent);
elm_object_text_set(btn2, &quot;Btn2&quot;);
elm_box_pack_end(parent, btn2);
evas_object_show(btn2);

// Make the parent container do a 360 degrees spin
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, parent);
elm_transit_effect_rotation_add(transit, 0.0, 360);
elm_transit_duration_set(transit, 2.0);
elm_transit_go(transit);
</pre>

<h4>Wipe Effect</h4>

<p>The wipe effect is designed to dynamically hide or show any element on the scene.</p>

<pre class="prettyprint">
elm_transit_effect_wipe_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_Wipe_Type type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_Wipe_Dir dir)
</pre>

<p>In addition to the <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> instance passed as the first argument, the function takes the following arguments:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">type</span>: The wipe type <span style="font-family: Courier New,Courier,monospace;">Elm_Transit_Effect_Wipe_Type</span> defines whether to show or hide the target elements. The value can be one of the following:
    <ul>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_TYPE_HIDE</span></li>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_TYPE_SHOW</span></li>
    </ul>
</li>
<li><span style="font-family: Courier New,Courier,monospace;">dir</span>: The wipe direction <span style="font-family: Courier New,Courier,monospace;">Elm_Transit_Effect_Wipe_Dir</span> defines in which direction the target will progressively appear or disappear. The value can be one of the following:
    <ul>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_DIR_LEFT</span></li>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_DIR_RIGHT</span></li>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_DIR_UP</span></li>
        <li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_WIPE_DIR_DOWN</span></li>
    </ul>
</li>
</ul>

<p>The following example shows how to make an object disappear progressively from left to right:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_wipe_add(transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_TRANSIT_EFFECT_TYPE_HIDE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_TRANSIT_EFFECT_WIPE_DIR_RIGHT);
elm_transit_duration_set(transit, 2.0);
elm_transit_go(transit);
</pre>

<h4>Zoom Effect</h4>
<p><span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> provides a zoom function.</p>

<pre class="prettyprint">
elm_transit_effect_zoom_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float from_rate,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float to_rate)
</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">transit</span>: The transit object that contains (among other things) all the Evas objects subject to the translation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_rate</span>: The starting level of the zoom.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_rate</span>: The ending level of the zoom.</li>
</ul>

<p>The <span style="font-family: Courier New,Courier,monospace;">from_rate</span> argument defines the scale of the target objects at the beginning of the animation. A value of 1 represents the initial scale of the objects.</p>

<p>Setting the value of the <span style="font-family: Courier New,Courier,monospace;">to_rate</span> argument to 2 will double the size of the target objects (double the width and double the height). When using this effect, the width and height of a target object will remain proportional to one another. If you want to customize the zoom effect, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_resizing_add()</span> function.</p>

<p>The following example shows how to implement a zoom-out transition. At the end of the 2-secondstransition, the animated object will be half its original size.</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_zoom_add(transit, 1, 0.5);
elm_transit_duration_set(transit, 2.0);
elm_transit_go(transit);
</pre>

<h4>Resizing Effect</h4>

<p>The resizing effect allows you to design an interpolation of the width and height attributes of one or more target elements.</p>

<pre class="prettyprint">
elm_transit_effect_resizing_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord from_w,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord from_h,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord to_w,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord to_h)
</pre>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">transit</span>: The transit object that contains (among other things) all the Evas objects subject to the translation.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_w</span>: The starting width.</li>
<li><span style="font-family: Courier New,Courier,monospace;">from_h</span>: The starting height.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_w</span>: The ending width.</li>
<li><span style="font-family: Courier New,Courier,monospace;">to_h</span>: The ending height.</li>
</ul>

<p>The <span style="font-family: Courier New,Courier,monospace;">from_w</span> and <span style="font-family: Courier New,Courier,monospace;">from_h</span> arguments define the size at the beginning of the animation. The <span style="font-family: Courier New,Courier,monospace;">to_w</span> and <span style="font-family: Courier New,Courier,monospace;">to_h</span> arguments define the size at the end.</p>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">If you are planning to use this method to hide an Evas object by setting one of the length attributes to zero, consider using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_wipe_add()</span> function instead.</td>
</tr>
</tbody>
</table>

<p>The following example shows how to make a rectangle exchange its width and height properties in a 2-second transition:</p>

<pre class="prettyprint">
Evas_Coord w, h;
evas_object_geometry_get(my_evas_object, NULL, NULL, &amp;w, &amp;h);

Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, my_evas_object);
elm_transit_effect_resize_add(transit, // Transition object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w, h, // Original sizing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h, w); // Target sizing
elm_transit_duration_set(transit, 2.0);
elm_transit_go(transit);
</pre>

<h4>Flip Effect</h4>
<p>This transition combines the target Evas objects in pairs, so that one object will show up while the other one disappears. This association relates the even objects in the transit list of objects with the odd ones. The even objects are shown at the beginning of the animation, and the odd objects shown when the transition is complete. In other words, the effect applies to each pair of objects in the order in which they are listed in the transit list of objects.</p>

<p>The flip effect itself is a pseudo-3D effect where the first object in the pair is the front object and the second one is the back object. When the transition launches, the front object rotates around a preferred axis in order to let the back object take its place.</p>

<pre class="prettyprint">
elm_transit_effect_flip_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_Flip_Axis axis,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool cw)
</pre>

<p>The first argument is the transit object. The second argument is the preferred axis of rotation:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_FLIP_AXIS_X</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_FLIP_AXIS_Y</span></li>
</ul>

<p>The third argument is the direction of the rotation:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span> is clockwise.</li>
<li><span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span> is counter-clockwise.</li>
</ul>

<p>The following example shows how to create a coin that flips indefinitely. Note that we use images as Elementary UI components for demonstration purposes. You can use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_image_animation_add()</span> function if you do not want to bother creating UI components.</p>

<pre class="prettyprint">
// Coin Heads
Evas_Object *coin_heads = elm_image_add(ad-&gt;win);
if (!elm_image_file_set(coin_heads, IMG_DIR&quot;/coin_heads.png&quot;, NULL))
&nbsp;&nbsp;&nbsp;printf(&quot;error: could not load image&quot;);
elm_win_resize_object_add(ad-&gt;win, coin_heads);

// Coin Tails
Evas_Object *coin_tails = elm_image_add(ad-&gt;win);
if (!elm_image_file_set(coin_tails, IMG_DIR&quot;/coin_tails.png&quot;, NULL))
&nbsp;&nbsp;&nbsp;printf(&quot;error: could not load image&quot;);
elm_win_resize_object_add(ad-&gt;win, coin_tails);

// Transition definition
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, coin_heads);
elm_transit_object_add(transit, coin_tails);
elm_transit_duration_set(transit, 2.0);
elm_transit_auto_reverse_set(transit, EINA_TRUE);
elm_transit_repeat_times_set(transit, -1);
elm_transit_effect_flip_add(transit, ELM_TRANSIT_EFFECT_FLIP_AXIS_X, EINA_TRUE);
elm_transit_go(transit);
</pre>

<p class="figure">Figure: Coin flip</p>
<p align="center"><img alt="Coin flip" src="../../images/coin_flip_effect.png" /></p>

<h4>Resizable Flip Effect</h4>
<p>In the flip example above, we used two objects that have the same size. However, you may sometimes want to flip from one object to another object with different size attributes. The most common example would be using buttons with dimensions that depend on their contents (such as labels). If you decide to use the classic <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_flip_add()</span> function, the size of the object will change at the moment one object becomes completely hidden and the other one begins to show up. If you wish to interpolate the size attributes as well, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_resizable_flip_add()</span> function:</p>

<pre class="prettyprint">
elm_transit_effect_resizable_flip_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_Flip_Axis axis,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool cw)
</pre>

<p>The first argument is the transit object. The second argument is the preferred axis of rotation:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_FLIP_AXIS_X</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">ELM_TRANSIT_EFFECT_FLIP_AXIS_Y</span></li>
</ul>

<p>The third argument is the direction of the rotation:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span> is clockwise.</li>
<li><span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span> is counter-clockwise.</li>
</ul>

<p>This function works the exact same way as the standard flip effect function.</p>

<h4>Fade Effect</h4>

<p>This effect is used to transition from one Evas object to another one using a fading effect: the first object will slowly disappear to let the second object take its place.</p>

<pre class="prettyprint">elm_transit_effect_fade_add(Elm_Transit *transit)</pre>

<p>This effect is applied to each pair of objects in the order in which they are listed in the transit list of objects. The first object in the pair will be the before object and the second one will be the after object.</p>

<p>Building on the coin flip example, the following example shows how to fade out one face of the coin while fading in the other face:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, coin_heads);
elm_transit_object_add(transit, coin_tails);
elm_transit_duration_set(transit, 2.0);
elm_transit_effect_fade_add(transit);
elm_transit_go(transit);
</pre>

<p>If you simply want to hide an object with a fade transition, consider using a transparent after object.</p>

<h4>Blend Effect</h4>

<p>Another transition involving at least two Evas objects is the blend effect. This transition makes the before object blurry before the after object appears.</p>

<pre class="prettyprint">elm_transit_effect_blend_add(Elm_Transit *transit)</pre>

<p>The argument is the transition target of the blend effect.</p>

<p>Building on the coin flip example, the following example shows how to blur out one face of the coin while blurring in the other face:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, coin_heads);
elm_transit_object_add(transit, coin_tails);
elm_transit_duration_set(transit, 2.0);
elm_transit_effect_blend_add(transit);
elm_transit_go(transit);
</pre>

<p>If you simply want to hide an object with a blur transition, consider using a transparent after object.</p>

<h3 id="Combine_Transitions" name="Combine_Transitions">Combining Transitions</h3>

<p>To use multiple transitions at the same time on the same objects, simply declare the transitions one after the other.</p>

<p>Building on the coin flip example, the following example shows how to roll the coin on the ground using a rotation and a translation effect:</p>

<pre class="prettyprint">
Evas_Object *coin_heads = elm_image_add(ad-&gt;win);
if (!elm_image_file_set(coin_heads, IMG_DIR&quot;/coin_heads.png&quot;, NULL))
&nbsp;&nbsp;&nbsp;printf(&quot;error: could not load image&quot;);
evas_object_resize(coin_heads, 100, 100);
evas_object_show(coin_heads);

Elm_Transit *transit = elm_transit_add();
elm_transit_object_add(transit, coin_heads);
elm_transit_duration_set(transit, 5.0);
elm_transit_effect_translation_add(transit, 0, 0, 3.1415 * 2 * 100, 0);
elm_transit_effect_rotation_add(transit, 0, 360);
elm_transit_go(transit);
</pre>

<h3 id="Animation_Chain" name="Animation_Chain">Animation Chain</h3>

<p>Now that we have listed all the effects that can be implemented using <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span>, we will see how to chain transitions into sequences. To create complex, chained animations without worrying about synchronization between the transitions, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_chain_transit_add()</span> function. This function takes as arguments two <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> objects and will automatically take care of the chaining for you: the second transition will start as soon as the first transition is finished.</p>

<p>The following example shows how to move a datetime component on a square trajectory:</p>

<pre class="prettyprint">
Evas_Object *dt = elm_datetime_add(ad-&gt;win);
evas_object_resize(dt, 350, 50);
evas_object_show(dt);

// The first transition
Elm_Transit *t1 = elm_transit_add();
elm_transit_object_add(t1, dt);
elm_transit_duration_set(t1, 2);
elm_transit_effect_translation_add(t1, 0, 0, 100, 0);

// The second transition
Elm_Transit *t2 = elm_transit_add();
elm_transit_object_add(t2, dt);
elm_transit_duration_set(t2, 2);
elm_transit_effect_translation_add(t2, 100, 0, 100, 100);

// The third transition
Elm_Transit *t3 = elm_transit_add();
elm_transit_object_add(t3, dt);
elm_transit_duration_set(t3, 2);
elm_transit_effect_translation_add(t3, 100, 100, 0, 100);

// The fourth transition
Elm_Transit *t4 = elm_transit_add();
elm_transit_object_add(t4, dt);
elm_transit_duration_set(t4, 2);
elm_transit_effect_translation_add(t4, 0, 100, 0, 0);

// Chaining the transitions
elm_transit_chain_transit_add(t1, t2);
elm_transit_chain_transit_add(t2, t3);
elm_transit_chain_transit_add(t3, t4);

// Starting the transitions
elm_transit_go(t1);
</pre>

<p>Note that we cannot use transition chaining to make a loop animation, since the transit object is automatically destroyed as soon as the transition completes. Therefore, you cannot do something like this:</p>

<pre class="prettyprint">elm_transit_chain_transit_add(t4, t1);</pre>

<p>To create a looped animation chain, you have to use low-level components provided by the Ecore and Evas transition libraries, or you can use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_del_cb_set()</span> function to define a callback function for when a transition gets deleted. This way, you could recreate your objects and reiterate the transition chain as soon as the last transition ends.</p>

<pre class="prettyprint">
elm_transit_del_cb_set(Elm_Transit *transit, Elm_Transit_Del_Cb cb, void *data)
</pre>

<p>The first argument is the transition object. The second argument is the callback function to run on transition delete. The third argument is the data to pass to the callback function.</p>

<p>You can severe the chain relationship between two transits by using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_chain_transit_del()</span> function:</p>

<pre class="prettyprint">elm_transit_chain_transit_del(Elm_Transit *transit, Elm_Transit *chain_transit)</pre>

<p>The first argument is the first transition in the chain. The second argument is the second transition in the chain.</p>

<p>To get the current chain transit list, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_chain_transits_get()</span> function.</p>

<h3 id="Animation_Timeline" name="Animation_Timeline">Animation Timeline</h3>

<p>After you have defined all the properties that define your transition, start the transition with the <span style="font-family: Courier New,Courier,monospace;">elm_transit_go()</span> function:</p>

<pre class="prettyprint">elm_transit_go(Elm_Transit *transit)</pre>

<p>You can maintain full control over the execution process even after the transition has started. You can pause the transition by setting the paused argument to <span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span>:</p>

<pre class="prettyprint">elm_transit_paused_set(Elm_Transit *transit, Eina_Bool paused)</pre>

<p>You can resume the transition by using the same method but setting the paused argument to <span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span>. If you want to know whether the transition is currently paused, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_paused_get()</span> function.</p>

<p>You can remain informed about the present transition flow and get the current frame by using the <span style="font-family: Courier New,Courier,monospace;">elm_transit_progress_value_get()</span> function. This function will return the timeline position of the animation, ranging between 0.0 (start) and 1.0 (end).</p>

<h3 id="Custom_Transition" name="Custom_Transition">Custom Transition</h3>

<p><span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> provides a standard function for defining any effect of your choosing that will be applied to some context data:</p>

<pre class="prettyprint">
elm_transit_effect_add(Elm_Transit *transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_Transition_Cb transition_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect *effect,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Transit_Effect_End_Cb end_cb)
</pre>

<p>The first argument is the transition target of the new effect. The second argument is the transition callback function. The third argument is the new effect. The fourth argument is the callback function to call at the end of the effect.</p>

<p>As described earlier in this programming guide, this function embraces three callbacks that will allow you to define every aspects of your transition from its creation to its deletion. The following is an example of how to build a custom resizing animation.</p>

<p>First, we define a structure capable of holding the context information about resizing an Evas object:</p>

<pre class="prettyprint">
typedef struct
{
&nbsp;&nbsp;&nbsp;struct _size
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Coord w, h;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;from, to;
}
Custom_Effect;
</pre>

<p>We can now implement our custom resizing callback function. This function takes the following arguments:</p>

<ul>
<li>The context data that holds the custom properties of our transition, which are used as parameters to calculate the interpolation.</li>
<li>The transit object that contains the list of our Evas objects to animate and all the information about duration, auto-reverse, looping, and so on.</li>
<li>The progress (position along the animation timeline) that ranges from 0.0 to 1.0 and allows us to calculate the desired interpolation for each frame.</li>
</ul>

<pre class="prettyprint">
static void
_custom_op(void *data, Elm_Transit *transit, double progress)
{
&nbsp;&nbsp;&nbsp;if (!data) return;
&nbsp;&nbsp;&nbsp;Evas_Coord w, h;
&nbsp;&nbsp;&nbsp;Evas_Object *obj;
&nbsp;&nbsp;&nbsp;const Eina_List *elist;
&nbsp;&nbsp;&nbsp;Custom_Effect *custom_effect = data;
&nbsp;&nbsp;&nbsp;const Eina_List *objs = elm_transit_objects_get(transit);
&nbsp;&nbsp;&nbsp;if (progress &lt; 0.5)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = custom_effect-&gt;from.h + (custom_effect-&gt;to.h * progress * 2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = custom_effect-&gt;from.w;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = custom_effect-&gt;from.h + custom_effect-&gt;to.h;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = custom_effect-&gt;from.w + (custom_effect-&gt;to.w * (progress - 0.5) * 2);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;EINA_LIST_FOREACH(objs, elist, obj)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_resize(obj, w, h);
}
</pre>

<p>The callback function above resizes our Evas objects in two steps. During the first half of the transition, only the height changes, while the width remains the same. During the second half, it is the other way around until we get to the desired size.</p>

<p>You must then define the context used by your animation:</p>

<pre class="prettyprint">
static void*
_custom_context_new(Evas_Coord from_w, Evas_Coord from_h, Evas_Coord to_w, Evas_Coord to_h)
{
&nbsp;&nbsp;&nbsp;Custom_Effect *custom_effect;

&nbsp;&nbsp;&nbsp;custom_effect = calloc(1, sizeof(Custom_Effect));
&nbsp;&nbsp;&nbsp;if (!custom_effect) return NULL;

&nbsp;&nbsp;&nbsp;custom_effect-&gt;from.w = from_w;
&nbsp;&nbsp;&nbsp;custom_effect-&gt;from.h = from_h;
&nbsp;&nbsp;&nbsp;custom_effect-&gt;to.w = to_w - from_w;
&nbsp;&nbsp;&nbsp;custom_effect-&gt;to.h = to_h - from_h;

&nbsp;&nbsp;&nbsp;return custom_effect;
}
</pre>

<p>You must define the function that will take care of deleting all the context objects used by your custom transition and free up the allocated memory:</p>

<pre class="prettyprint">
static void
_custom_context_free(void *data, Elm_Transit *transit __UNUSED__)
{
&nbsp;&nbsp;&nbsp;free(data);
}
</pre>

<p>Finally, apply your custom transition to your <span style="font-family: Courier New,Courier,monospace;">Elm_Transit</span> object:</p>

<pre class="prettyprint">
Elm_Transit *transit = elm_transit_add();
elm_transit_effect_add(transit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_custom_op,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_custom_context_new(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_custom_context_free);
</pre>

<p>If you want to delete an effect from your effects list, use the <span style="font-family: Courier New,Courier,monospace;">elm_transit_effect_del()</span> function.</p>
  
  
  

		<h2 id="evas_map_animation" name="evas_map_animation">Evas Map Effects</h2>

<p>Evas Map animations allow you to apply transformations to all types of objects by way of UV mapping.</p>

<p>In UV mapping, you map points in the source object to 3D space positions in the target object. This allows for rotation, perspective, scale, and other transformation effects, depending on the map. In addition, each map point can carry a multiplier color, which, if properly calculated, can be used to apply 3D shading effects on the target object.</p>

<p>Evas provides both raw and easy-to-use functions for UV mapping. The raw functions allow you to create UV maps outside Evas and import them into your application, for example by loading them from an external file. The easy-to-use functions allow you to create UV maps directly in Evas by calculating the map points based on high-level parameters, such as rotation angle and ambient light.</p>

<h3 id="Map_Points" name="Map_Points">Map Points</h3>

<p>A map consists of a set of points. (Currently, only four points are supported.) Each point contains X and Y canvas coordinates that can be used to alter the geometry of the mapped object, and a Z coordinate that indicates the depth of the point. The Z coordinate does not normally affect the map, but several utility functions use it to calculate the right position of the point given the other parameters.</p>

<p>First, create an <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> object using the <span style="font-family: Courier New,Courier,monospace;">evas_map_new()</span> function. This function creates the specified number of map points (currently only up to four points). Each point is empty and ready to be modified with <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> functions.</p>

<pre class="prettyprint">Evas_Map *m = evas_map_new(4);</pre>

<p>If you want to get the size (number of points) of an existing map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_count_get()</span> function.</p>

<p>To set the coordinates for each point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_coord_set()</span> function:</p>

<pre class="prettyprint">evas_map_point_coord_set(Evas_Map *m, int idx, Evas_Coord x, Evas_Coord y, Evas_Coord z)</pre>

<p>The following example shows a common way to define a map that matches the geometry of a rectangle (a square in this case):</p>

<pre class="prettyprint">
evas_map_point_coord_set(m, 0, 100, 100, 0);
evas_map_point_coord_set(m, 1, 300, 100, 0);
evas_map_point_coord_set(m, 2, 300, 300, 0);
evas_map_point_coord_set(m, 3, 100, 300, 0);
</pre>

<p class="figure">Figure: Map</p>
<p align="center"><img alt="Map" src="../../images/evas_map_1.png" /></p>

<p>The following examples all produce the same result as the above example, but with simpler code:</p>

<ul>
    <li>
        <p>To create a rectangle map using the starting X and Y coordinates combined with width and height, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_geometry()</span> function:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_geometry(Evas_Map *m, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Evas_Coord z)</pre>
        <p>The following example creates the same map as above:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_geometry(m, 100, 100, 200, 200, 0);</pre>
    </li>
    <li>
        <p>To create a map based on the geometry of a given object, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_object()</span> or <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_populate_from_object_full()</span> function. The former sets the Z coordinate of all points to 0, whereas the latter allows you to define the same custom Z coordinate for all points:</p>
        <pre class="prettyprint">evas_map_util_points_populate_from_object(Evas_Map *m, const Evas_Object *obj)</pre>
        <pre class="prettyprint">evas_map_util_points_populate_from_object_full(Evas_Map *m, const Evas_Object *obj, Evas_Coord z)</pre>
        <p>The following example creates the same map as above:</p>
        <pre class="prettyprint">
Evas_Object *o;
evas_object_move(o, 100, 100);
evas_object_resize(o, 200, 200);
evas_map_util_points_populate_from_object(m, o);
// OR
evas_map_util_points_populate_from_object_full(m, o, 0);</pre>
    </li>
</ul>

<p>You can apply several effects to an object by simply setting each point of the map to the appropriate coordinates. The following example shows how to create a simulated perspective:</p>

<p class="figure">Figure: Simulated perspective</p>
<p align="center"><img alt="Simulated perspective" src="../../images/evas_map_2.png" /></p>

<pre class="prettyprint">
evas_map_point_coord_set(m, 0, 100, 100, 0);
evas_map_point_coord_set(m, 1, 250, 120, 0);
evas_map_point_coord_set(m, 2, 250, 280, 0);
evas_map_point_coord_set(m, 0, 100, 300, 0);
</pre>

<p>In the above example, the Z coordinate is unused: when setting points by hand, the Z coordinate is irrelevant.</p>

<p>If you want to get the actual coordinates of a map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_coord_get()</span> function:</p>

<pre class="prettyprint">evas_map_point_coord_get(const Evas_Map *m, int idx, Evas_Coord *x, Evas_Coord *y, Evas_Coord *z)</pre>

<p>After you have defined the map points, apply them to your map for transformation:</p>

<pre class="prettyprint">
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
</pre>

<p>Finally, after you are done with the map, release the memory allocated to it using the <span style="font-family: Courier New,Courier,monospace;">evas_map_free()</span> function:</p>

<pre class="prettyprint">evas_map_free(m);</pre>

<p>The utility functions described in the next section allow you to perform the above tasks with less coding work.</p>

<h3 id="Utility_Functions" name="Utility_Functions">Utility Functions</h3>

<p>Utility functions take an already configured map and allow you to easily modify it to produce specific effects. For example, to rotate an object around its center, you need the rotation angle and the coordinates of each corner of the object to perform the math required to get the new set of coordinates that needs to be set for the map. Evas provides a utility function that does the math for you:</p>

<pre class="prettyprint">evas_map_util_rotate(Evas_Map *m, double degrees, Evas_Coord cx, Evas_Coord cy)</pre>

<p>This function rotates the map based on the angle and the center coordinates of the rotation provided as arguments. A positive angle rotates the map clockwise, while a negative angle rotates the map counter-clockwise.</p>

<p>The following example shows how to rotate an object around its center point by 45 degrees clockwise. In the following figure, the center of rotation is the red dot.</p>

<pre class="prettyprint">
evas_object_geometry_get(o, &amp;x, &amp;y, &amp;w, &amp;h);
m = evas_map_new(4);
evas_map_util_points_populate_from_object(m, o);
evas_map_util_rotate(m, 45, x + (w / 2), y + (h / 2));
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
evas_map_free(m);
</pre>

<p class="figure">Figure: Rotating around the center point</p>
<p align="center"><img alt="Rotating around the center point" src="../../images/evas_map_3.png" /></p>

<p>You can rotate the object around any other point simply by setting the last two arguments of the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_rotate()</span> function to the appropriate values:</p>

<pre class="prettyprint">evas_map_util_rotate(m, 45, x + w - 20, y + h - 20);</pre>

<p class="figure">Figure: Rotating around other points</p>
<p align="center"><img alt="Rotating around other points" src="../../images/evas_map_4.png" /></p>

<p>You can also set the center of the window as the center of the rotation using the appropriate coordinates of the Evas canvas:</p>

<pre class="prettyprint">
evas_output_size_get(evas, &amp;w, &amp;h);
m = evas_map_new(4);
evas_map_util_points_populate_from_object(m, o);
evas_map_util_rotate(m, 45, w, h);
evas_object_map_set(o, m);
evas_object_map_enable_set(o, EINA_TRUE);
evas_map_free(m);
</pre>

<h3 id="Zoom" name="Zoom">Zoom</h3>

<p>The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_zoom()</span> function zooms the points of the map from a center point, defined by <span style="font-family: Courier New,Courier,monospace;">cx</span> and <span style="font-family: Courier New,Courier,monospace;">cy</span>. The <span style="font-family: Courier New,Courier,monospace;">zoomx</span> and <span style="font-family: Courier New,Courier,monospace;">zoomy</span> arguments specify how much to zoom in on the X and Y axes. A value of 1.0 means no zoom, 2.0 means double the size, 0.5 means half the size, and so on. All the coordinates are global canvas coordinates.</p>

<pre class="prettyprint">
evas_map_util_zoom(Evas_Map *m, double zoomx, double zoomy, Evas_Coord cx, Evas_Coord cy)
</pre>

<h3 id="threeD_Maps" name="threeD_Maps">3D Maps</h3>

<p>Maps can also be used to achieve a 3D effect. In a 3D effect, the Z coordinate of each point is meaningful: the higher the value, the further back the point is located. Smaller values (usually negative) mean that the point is closer to the user.</p>

<p>3D also introduces the concept of the back face of an object. An object is said to be facing the user when all its points are placed in a clockwise formation, as shown in the left map in the following figure. Rotating the map around its Y axis swaps the order of the points into a counter-clockwise formation, making the object face away from the user, as shown in the right map in the following figure. The back face is especially relevant in lighting (see below).</p>

<p class="figure">Figure: Rotating around the Y axis</p>
<p align="center"><img alt="Rotating around the Y axis" src="../../images/evas_map_5.png" /></p>

<p>To determine whether a map is facing the user, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_clockwise_get()</span> function. This function returns <span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span> if the map is facing the user and <span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span> if the map is facing away from the user. This is normally done after all the other operations are applied to the map.</p>

<pre class="prettyprint">evas_map_util_clockwise_get(Evas_Map *m)</pre>

<h3 id="threeD_Rotation" name="threeD_Rotation">3D Rotation and Perspective</h3>

<p>The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_rotate()</span> function transforms a map to apply a 3D rotation to the mapped object. You can apply the rotation around any point in the canvas (including a Z coordinate). You can also apply the rotation around any of the three axes.</p>

<pre class="prettyprint">evas_map_util_3d_rotate(Evas_Map *m, double dx, double dy, double dz, Evas_Coord cx, Evas_Coord cy, Evas_Coord cz)</pre>

<p>Starting from this simple setup, and setting the maps so that the blue square rotates around the Y axis, we get the following:</p>

<p class="figure">Figure: 3D rotation</p>
<p align="center"><img alt="3D rotation" src="../../images/evas_map_6.png" /></p>

<p>A simple overlay over the image shows the original geometry of each object and the axis around which they are being rotated. The Z axis is not shown, since it is orthogonal to the screen. To show the Z axis, that is, to add 3D perspective to the transformation, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_perspective()</span> function on the map after its position has been set:</p>

<pre class="prettyprint">evas_map_util_3d_perspective(Evas_Map *m, Evas_Coord px, Evas_Coord py, Evas_Coord z0, Evas_Coord foc)</pre>

<p>The result makes the vanishing point the center of each object:</p>

<p class="figure">Figure: Adding perspective</p>
<p align="center"><img alt="Adding perspective" src="../../images/evas_map_7.png" /></p>

<h3 id="Color_Light" name="Color_Light">Color and Lighting</h3>

<p>Each point in a map can be set to a color, which will be multiplied with the object’s own color and linearly interpolated between adjacent points. To set the color separately for each point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_color_set()</span> function:</p>

<pre class="prettyprint">evas_map_point_color_set(Evas_Map *m, int idx, int r, int g, int b, int a)</pre>

<p>To set the same color for every point, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_util_points_color_set()</span> function:</p>

<pre class="prettyprint">evas_map_util_points_color_set(Evas_Map *m, int r, int g, int b, int a)</pre>

<p>When using a 3D effect, colors can be used to improve its look by simulating a light source. The <span style="font-family: Courier New,Courier,monospace;">evas_map_util_3d_lighting()</span> function makes this task easier by taking the coordinates of the light source and its color, along with the color of the ambient light. Evas then sets the color of each point based on its distance to the light source, the angle at which the object is facing the light source, and the ambient light. Here, the orientation of each point is important.</p>

<pre class="prettyprint">evas_map_util_3d_lighting(Evas_Map *m, Evas_Coord lx, Evas_Coord ly, Evas_Coord lz, int lr, int lg, int lb, int ar, int ag, int ab)</pre>

<p>If the map points are defined counter-clockwise, the object faces away from the user and is therefore obscured, since no light is reflecting back from it.</p>

<p class="figure">Figure: Obscured object</p>
<p align="center"><img alt="Obscured object" src="../../images/evas_map_8.png" /></p>

<h3 id="Mapping" name="Mapping">Mapping</h3>

<p>Images need special handling when mapped. While Evas can easily handle objects, it is completely oblivious to the contents of images. This means that each point in a map needs to be mapped to a specific pixel in the source image. Failing to do this can result in unexpected behavior.</p>

<p>Let's get started with the following three images, each sized at 200 × 200 pixels:</p>

<p class="figure">Figure: Starting point</p>
<p align="center"><img alt="Starting point" src="../../images/evas_map_9.png" /></p>

<p>The following three images illustrate the case where a map is set to an image object without setting the right UV mapping for each map point. The objects themselves are mapped properly to their new geometries, but the images are not displayed correctly within the mapped objects.</p>

<p class="figure">Figure: Questionable result</p>
<p align="center"><img alt="Questionable result" src="../../images/evas_map_10.png" /></p>

<p>To transform an image correctly, Evas needs to know how to handle the image within the map. You can do this using the <span style="font-family: Courier New,Courier,monospace;">evas_map_point_image_uv_set()</span> function, which allows you to map a given point in a map to a given pixel in a source image:</p>

<pre class="prettyprint">
evas_map_point_image_uv_set(Evas_Map *m, int idx, double u, double v)
</pre>

<p>To match our example images to the maps above, all we need is the size of each image, which we can get using the <span style="font-family: Courier New,Courier,monospace;">evas_object_image_size_get()</span> function.</p>

<pre class="prettyprint">
// Tux 1: Some cropping and stretch up
evas_map_point_image_uv_set(m, 0, 0, 20);
evas_map_point_image_uv_set(m, 1, 200, 20);
evas_map_point_image_uv_set(m, 2, 200, 180);
evas_map_point_image_uv_set(m, 3, 0, 180);
evas_object_map_set(tux1, m);
evas_object_map_enable_set(tux1, EINA_TRUE);

// Inverted texture for shadow:
evas_map_point_image_uv_set(m, 0, 0, 180);
evas_map_point_image_uv_set(m, 1, 200, 180);
evas_map_point_image_uv_set(m, 2, 200, 20);
evas_map_point_image_uv_set(m, 3, 0, 20);
evas_object_map_set(tux1_shadow, m);
evas_object_map_enable_set(tux1_shadow, EINA_TRUE);

// Tux 2: Make it fit to the map:
evas_map_point_image_uv_set(m, 0, 0, 0);
evas_map_point_image_uv_set(m, 1, 200, 0);
evas_map_point_image_uv_set(m, 2, 200, 200);
evas_map_point_image_uv_set(m, 3, 0, 200);
evas_object_map_set(tux2, m);
evas_object_map_enable_set(tux2, EINA_TRUE);

// Tux 3: Zoom and fit relatively to image size
evas_object_image_size_get(evas_object_image_source_get(tux3), &amp;w, &amp;h);
evas_map_point_image_uv_set(m, 0, 0.1 * w, 0.1 * h);
evas_map_point_image_uv_set(m, 1, 0.9 * w, 0.1 * h);
evas_map_point_image_uv_set(m, 2, 0.9 * w, 0.9 * h);
evas_map_point_image_uv_set(m, 3, 0.1 * w, 0.9 * h);
evas_object_map_set(tux3, m);
evas_object_map_enable_set(tux3, EINA_TRUE);
</pre>

<p class="figure">Figure: Correct result</p>
<p align="center"><img alt="Correct result" src="../../images/evas_map_11.png" /></p>

<p>You can also set a map to use only part of an image, or you can even map the points in inverted order. Combined with the <span style="font-family: Courier New,Courier,monospace;">evas_object_image_source_set()</span> function, you can achieve more interesting results still.</p>

<h3 id="Lighting" name="Lighting">Lighting</h3>

<p><span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> allows you to define an ambient light and a light source within the scene. Both of these light sources have their own colors.</p>

<pre class="prettyprint">evas_map_util_3d_lighting(Evas_Map *m, Evas_Coord lx, Evas_Coord ly, Evas_Coord lz, int lr, int lg, int lb, int ar, int ag, int ab)</pre>

<p>The above function is used to apply lighting calculations (from a single light source) to a given map. The red, green, and blue values of each vertex will be modified to reflect the lighting based on the light source coordinates, its color, the ambient color, and the angle at which the map faces the light source. The points of a surface should be defined in a clockwise formation if the surface is facing the user, since faces have a logical side for lighting.</p>

<p>To get the reflections (gradient) in the shadow of our previous example, you have to define a source of light close enough to the user and a very bright ambient light, for example:</p>

<pre class="prettyprint">
evas_map_util_3d_lighting(m, // Evas_Map object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250/2, 150/2, -100, // Spot light coordinates
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255, 255, 255, // Spot light color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200, 200, 200); // Ambient light color
</pre>

<h3 id="Alpha_Channel" name="Alpha_Channel">Alpha Channel</h3>

<p>You can also use an alpha channel on your map by enabling the alpha channel feature:</p>

<pre class="prettyprint">evas_map_alpha_set(Evas_Map *m, Eina_Bool enabled)</pre>

<p>Next, set the alpha value separately for each map point:</p>

<pre class="prettyprint">evas_map_point_color_set(Evas_Map *m, int idx, int r, int g, int b, int a)</pre>

<p>Alternatively, you can set the same alpha value to all map points:</p>

<pre class="prettyprint">evas_map_util_points_color_set(Evas_Map *m, int r, int g, int b, int a)</pre>

<p>The following code sets the shadow transparency for the first image in the above three-image example:</p>

<pre class="prettyprint">
// Set object transparency to 50%:
evas_map_util_points_color_set(m, 255, 255, 255, 127);

// Tux&#39;s head is almost invisible in the shadow:
evas_map_point_color_set(m, 3, 255, 255, 255, 15);
evas_map_point_color_set(m, 4, 255, 255, 255, 15);
</pre>

<h3 id="Smoothing" name="Smoothing">Smoothing</h3>

<p>To enable smoothing when rendering a map, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_smooth_set()</span> function:</p>

<pre class="prettyprint">evas_map_smooth_set(Evas_Map *m, Eina_Bool enabled)</pre>

<p>The first argument is the <span style="font-family: Courier New,Courier,monospace;">Evas_Map</span> object to apply smoothing to. The second argument sets whether to enable the smoothing:</p>

<ul>
    <li><span style="font-family: Courier New,Courier,monospace;">EINA_TRUE</span>: Enable smoothing.</li>
    <li><span style="font-family: Courier New,Courier,monospace;">EINA_FALSE</span>: Disable smoothing.</li>
</ul>

<p>If the object is of a type that has its own smoothing settings, the smoothing settings must be disabled for both the object and the map. Map smoothing is enabled by default. To check whether map smoothing is enabled, use the <span style="font-family: Courier New,Courier,monospace;">evas_map_smooth_get()</span> function.</p>
  
  
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer"> 
<p class="footer">Except as noted, this content is licensed under <a href="http://opensource.org/licenses/LGPL-2.1" target="_blank">LGPLv2.1+</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p> 
</div> 

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../../css/snippet.css" />
    <script type="text/javascript" src="../../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../scripts/search.js" charset="utf-8"></script>
  <title>Data Types</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../../images/wearable_s_n.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
		<p class="toc-title">Dependencies</p>
		<ul class="toc">
			<li>Tizen Platform 2.4 and Higher for Mobile</li>
			<li>Tizen Platform 2.3.1 and Higher for Wearable</li>
		</ul>
        <p class="toc-title">Content</p>
        <ul class="toc">      
			 <li><a href="#iterate">Iterator Functions</a></li>
			 <li><a href="#string">Strings</a></li>
			 <li><a href="#array">Arrays</a></li>
			 <li><a href="#hash">Hash Tables</a></li>
			 <li><a href="#list">Lists</a></li>
			 <li><a href="#generic">Generic Value</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
        <ul class="toc">
			<li><a href="../../../../../org.tizen.native.mobile.apireference/group__Eina.html">Eina API for Mobile Native</a></li>
			<li><a href="../../../../../org.tizen.native.wearable.apireference/group__Eina__Group.html">Eina API for Wearable Native</a></li>
		</ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">

  <h1>Data Types</h1>

  <p>The Eina library is a central part of the EFL. It implements an API for data types, and allows you to create and manipulate several data types:</p>

<ul>
<li><a href="#inline">Inline Array</a>: Standard array of inlined members</li>
<li><a href="#array">Array</a>: Standard array of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#hash">Hash Table</a>: Standard hash of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#inlist">Inline List</a>: List with nodes inlined into the user type</li>
<li>Compact List</li>
<li><a href="#list">List</a>: Standard list of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#iterate">Iterator Functions</a></li>
<li>Sparse Matrix: Sparse matrix of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li>Red-Black tree: Red-black tree with nodes inlined into the user type</li>
<li><a href="#buffer">String Buffer</a>: Mutable string to prepend, insert, or append strings to a buffer</li>
<li><a href="#share">Stringshare</a>: Shares read-only string references</li>
<li>Tiler split: Merges and navigates into 2D tiled regions</li>
<li>Trash: Container of unused but allocated data</li>
<li><a href="#generic">Generic Value Storage</a>: Container for generic value storage and access</li>
<li>Data Model API: Container for data with a user-defined hierarchy or structure</li>
</ul>

  
<h2 id="iterate" name="iterate">Iterator Functions</h2>
<p>Eina provides a set of iterator functions to manipulate data types, such as arrays.</p>
<p>These functions allow access to container elements in a generic way, without knowing which container is used (similar to iterators in the C++ STL). Iterators only allow sequential access (that is, from one element to the next one). For random access, Eina provides accessor functions.</p>
<p>Getting an iterator to access elements of a given container is done through the functions of that particular container. There is no function to create a generic iterator as iterators absolutely depend on the container. Note that all iterators, regardless of the container type, are always deleted with the same <span style="font-family: Courier New,Courier,monospace">eina_iterator_free()</span> function.</p>
<p>To get the data and iterate, use the <span style="font-family: Courier New,Courier,monospace">eina_iterator_next()</span> function. To call a function on every single element of a container, use the <span style="font-family: Courier New,Courier,monospace">eina_iterator_foreach()</span> function.</p>
<p>In addition to iterator functions, each data type also owns a set of macros that provide the iterators, such as <span style="font-family: Courier New,Courier,monospace">FOREACH</span> or <span style="font-family: Courier New,Courier,monospace">REVERSE_FOREACH</span>.</p>

<h2 id="string" name="string">Strings</h2>

<h3 id="share" name="share">Stringshare</h3>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Stringshare</span> data type functions allow you to store a single copy of a string and use it in multiple places throughout your program. This way you can save a lot of strings with less memory. It improves string creation and destruction speed, reduces memory use, and decreases memory fragmentation.</p>
<p>With this data type you can reduce the number of duplicated strings kept in memory. It is common for the same strings to be dynamically allocated repeatedly between applications and libraries, especially in circumstances where you can have multiple copies of a structure that allocates the string. Rather than duplicating and freeing these strings, request a read-only pointer to an existing string and only incur the overhead of a hash lookup. This can sound like micro-optimizing, but profiling has shown that this can have a significant impact as the number of copies grows.</p>

<p>To manage stringshares:</p>
<ol>
<li>To create a stringshare, declare a string variable and call the <span style="font-family: Courier New,Courier,monospace">eina_stringshare_add()</span> function:
<pre class="prettyprint">
const char *mystr;
const char *prologue = &quot;Enlightenment is not just a window manager for Linux/X11 and others&quot;;

mystr = eina_stringshare_add(prologue);
</pre></li>

<li>To retrieve or modify the string data:
<ul>
<li>Retrieve a string for use in a program from a format string using the <span style="font-family: Courier New,Courier,monospace">eina_stringshare_printf()</span> function. If you have a &quot;format&quot; string to pass to a function like <span style="font-family: Courier New,Courier,monospace">printf</span>, you can store it as a stringshare as well.
<p>The following example produces &quot;1 desktop manager to rule them all&quot;.</p>
<pre class="prettyprint">
const char *myfmtstr = &quot;%d desktop manager to rule them all&quot;;
const char *str;

str = eina_stringshare_printf(myfmtstr, 1);

print(str);
</pre>
</li>

<li>Replace the value of a stringshare with the <span style="font-family: Courier New,Courier,monospace">eina_stringshare_replace()</span> function. Pass the pointer address and the new value to the function.
<pre class="prettyprint">
eina_stringshare_replace(&amp;str,&quot;One desktop manager to rule them all&quot;);
</pre>
</li>

<li>Retrieve the length of the stringshare value with the <span style="font-family: Courier New,Courier,monospace">eina_stringshare_strlen()</span> function.
<pre class="prettyprint">
printf(&quot;length: %d\n&quot;, eina_stringshare_strlen(str));
</pre>
</li>
</ul>
</li>
<li>When the string is no longer needed, delete it using the <span style="font-family: Courier New,Courier,monospace">eina_stringshare_del()</span> function:
<pre class="prettyprint">
eina_stringshare_del(mystr);
</pre>
</li>
</ol>



<h3 id="buffer" name="buffer">String Buffer</h3>
<p>The string buffer data type is designed to be a mutable string, allowing you to append, prepend or insert a string to a buffer. It allows easy handling of buffers in your applications.</p>
<p>To manage string buffers:</p>
<ol>
<li>Initialize the <span style="font-family: Courier New,Courier,monospace">Eina_Strbuf</span> instance and create the buffer:
<pre class="prettyprint">
Eina_Strbuf *buf;
mybuffer = eina_strbuf_new();
</pre>
</li>
<li>Manage the buffer content:
<ul>
<li>To append characters to the buffer:
<ul>
<li>
<p>For basic strings, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append()</span> function:</p>
<pre class="prettyprint">
eina_strbuf_append(mybuffer, &quot;This is my string.&quot;);
</pre>
</li>
<li>To append 1 character to your buffer, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_char()</span> function. You can also append a sized string to the buffer using the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_length()</span> function.
<pre class="prettyprint">
eina_strbuf_append_length(mybuffer, &quot;Buffe&quot;, 5);
eina_strbuf_append_char(mybuffer, &#39;r&#39;);
</pre>
</li>
<li>To handle &quot;printf&quot; format strings, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_printf()</span> function to add formatted strings to the buffer:
<pre class="prettyprint">
eina_strbuf_append_printf(buf, &quot;%s%c&quot;, &quot;buffe&quot;, &#39;r&#39;);
</pre>
</li>
</ul>
</li>

<li>To remove characters from one position to another, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_remove()</span> function. The first parameter is the buffer, the second is the start position of the characters you want to delete, and the last the end position.
<p>This example removes the first 19 characters of the buffer:</p>
<pre class="prettyprint">
eina_strbuf_remove(buf, 0, 18);
</pre>
</li>

<li>To replace characters: 

<ul><li>
<span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace()</span> replaces a specific occurrence of a given string in the buffer with another string.</li>
<li>
<span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace_all()</span> replaces all occurrences of a given string in the buffer with another string.
</li>
</ul>
<pre class="prettyprint">
eina_strbuf_append(mybuffer, &quot;buffer buffer buffer&quot;);

/* Replacing 1 occurrence of &quot;buffer&quot; by &quot;B-U-F-F-E-R&quot; */
eina_strbuf_replace(mybuffer, &quot;buffer&quot;, &quot;B-U-F-F-E-R&quot;, 1);

/* Replacing all the occurrences of &quot;buffer&quot; by &quot;B-U-F-F-E-R&quot; */
eina_strbuf_replace_all(mybuffer, &quot;buffer&quot;, &quot;B-U-F-F-E-R&quot;);

/* Replacing all the occurrences of &quot;B-U-F-F-E-R&quot; by &quot;Buffer&quot; */
eina_strbuf_replace_all(mybuffer, &quot;B-U-F-F-E-R&quot;, &quot;Buffer&quot;);
</pre>
</li>
<li>To insert a string at the specified position, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_insert()</span> function. Use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_insert_printf()</span> function with formatted strings.
<pre class="prettyprint">
eina_strbuf_insert(mybuffer, &quot;More buffer&quot;, 10);

/* Using eina_strbuf_length_get to get the buffer length */
eina_strbuf_insert_printf(buf, &quot;%s: %d&quot;, 6, &quot;length&quot;, eina_strbuf_length_get(buf));
</pre>
</li>

<li>To get the complete length of the string and the buffer, use the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_string_get()</span> and <span style="font-family: Courier New,Courier,monospace">eina_strbuf_length_get()</span> functions:
<pre class="prettyprint">
printf(&quot;%s: %d\n&quot;, eina_strbuf_string_get(mybuffer), eina_strbuf_length_get(buf));
</pre>
</li>
</ul>
</li>

<li>When no longer needed, free the buffer with the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_free()</span> function. You can also free the content of <span style="font-family: Courier New,Courier,monospace">Eina_Strbuf</span> without freeing the buffer itself using the <span style="font-family: Courier New,Courier,monospace">eina_strbuf_string_free()</span> function.
<pre class="prettyprint">
eina_strbuf_free(mybuffer);
</pre>
</li>
</ol>

<h2 id="array" name="array">Arrays</h2>
<p>An array is a data type which describes an ordered collection of values. The values are accessed by their index. </p>
<pre class="prettyprint">
INDEX | VALUE
--------------
0     | value0
1     | value1
2     | value2
3     | value3
4     | value4
5     | value5
6     | value6
7     | value7
</pre>
<p>Eina provides 2 array types: the classic array and an inline array.</p>

<h3>Creating and Destroying a Classic Array</h3>

<p>The <span style="font-family: Courier New,Courier,monospace">eina_array_new()</span> function creates a new array. You can store strings or objects in the created array. The function returns a new array, or if memory allocation fails, <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>
<p>The first parameter of the <span style="font-family: Courier New,Courier,monospace">eina_array_new()</span> function defines the size of the array allocation step. For example, if you set it to 4, the function returns an array of 4 elements and the next time you grow the array it grows by 4 elements. Unless you have pushed 4 elements inside, it does not grow. But once you add the fifth element, it grows again and becomes an array of 8 elements. The allocation step feature is very useful for optimizing performance, and it also reduces memory fragmentation by having a size that fits the array usage. If you set the step to 0, the function sets a default safe value.</p>

<p>To create an array to store strings:</p>
<ol>
<li>Create the array:
<pre class="prettyprint">
/* Strings to store in the array */
const char*
strings[] =
{
&nbsp;&nbsp;&nbsp;&nbsp;&quot;helo&quot;, &quot;hera&quot;, &quot;starbuck&quot;, &quot;kat&quot;, &quot;boomer&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;hotdog&quot;, &quot;longshot&quot;, &quot;jammer&quot;, &quot;crashdown&quot;, &quot;hardball&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;duck&quot;, &quot;racetrack&quot;, &quot;apolo&quot;, &quot;husker&quot;, &quot;freaker&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&quot;skulls&quot;, &quot;bulldog&quot;, &quot;flat top&quot;, &quot;hammerhead&quot;, &quot;gonzo&quot;
};
/* Declaring the array (type Eina_Array) */
Eina_Array *array;
unsigned int i;

/* Creating the array */
array = eina_array_new(20);

/* Inserting elements in the array */
for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;&nbsp;eina_array_push(array, strdup(strings[i]));
</pre>
</li>
<li>To change the allocation step, use the <span style="font-family: Courier New,Courier,monospace">eina_array_step_set()</span> function:
<ul><li>The first parameter is the array you want to change.</li>
<li>The second parameter is the size of that specific array (retrieved with the <span style="font-family: Courier New,Courier,monospace">sizeof()</span> function).</li>
<li>The last parameter is the new step size.</li></ul>
<p>In this example, the array step changes from 20 to 30.</p>
<pre class="prettyprint">
eina_array_step_set(array, sizeof(*array), 30);
</pre>
</li>
<li>When no longer used, use the <span style="font-family: Courier New,Courier,monospace">eina_array_free()</span> function to free the array. It first calls the <span style="font-family: Courier New,Courier,monospace">eina_array_flush()</span> function and frees the memory of the pointer. It does not free the memory allocated for the elements of the array. To free them, use a <span style="font-family: Courier New,Courier,monospace">while</span> statement with the <span style="font-family: Courier New,Courier,monospace">eina_array_pop()</span> function.
<pre class="prettyprint">
/* Freeing the array elements */
while (eina_array_count(array))
&nbsp;&nbsp;&nbsp;&nbsp;free(eina_array_pop(array));

/* Freeing the array itself */
eina_array_free(array);
</pre>
</li>
</ol>

<h3>Modifying Classic Array Content</h3>

<p>To modify classic array content:</p>
<ul>
<li>To set the data of an element, use the <span style="font-family: Courier New,Courier,monospace">eina_array_data_set()</span> function. The first parameter is the array, the second is the index of the element you want to set, and the last one is the data. You must first get the related pointer if you need to free it, as this function replaces the previously held data. Be careful, as there is no array or index check. If the value is <span style="font-family: Courier New,Courier,monospace">NULL</span> or invalid, the application can crash.
<pre class="prettyprint">
free(eina_array_data_get(array, 0));
eina_array_data_set(array, 0, strdup(strings[3]);
</pre>
</li>
<li>To add elements to the end of the array, use the <span style="font-family: Courier New,Courier,monospace">eina_array_push()</span> function. The function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> on success, and <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> on failure. The first parameter is the array to store the element, the second one is the data you want to store. If you store strings, remember to allocate the memory first. The example uses the <span style="font-family: Courier New,Courier,monospace">strdup()</span> function to duplicate the string contained in <span style="font-family: Courier New,Courier,monospace">strings[]</span>. This function allocates the memory of the returned string, so you do not have to do it yourself.
<pre class="prettyprint">
for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;&nbsp;eina_array_push(array, strdup(strings[i]));
</pre>
</li>

<li>To remove the last element of an array, use the <span style="font-family: Courier New,Courier,monospace">eina_array_pop()</span> function. It takes the array as a parameter, and if the operation is successful, returns a pointer to the data of the removed element.
<pre class="prettyprint">
while (eina_array_count(array))
&nbsp;&nbsp;&nbsp;&nbsp;free(eina_array_pop(array));
</pre>
</li>

<li>To rebuild the array by specifying the data to be kept, use the <span style="font-family: Courier New,Courier,monospace">eina_array_remove()</span> function:
<ul><li>The first parameter is the array to be changed.</li>
<li>The second parameter is the function which selects the data to keep in the rebuilt array.</li>
<li>The last parameter is the data to pass to the selector function defined as the second parameter.</li></ul>
<p>The selector function has to return an <span style="font-family: Courier New,Courier,monospace">Eina_Bool</span>, <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> if the element stays, and <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> if it has to be removed.</p>
<p>The following example shows how to remove all the elements of the array that are longer than 5.</p>
<pre class="prettyprint">
/* Selector function */
Eina_Bool
keep(void *data, void *gdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;if (strlen((const char*)data) &lt;= 5)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int
remove_array()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Array_Iterator iterator;
&nbsp;&nbsp;&nbsp;&nbsp;const char *item;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int i;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating an array */

&nbsp;&nbsp;&nbsp;&nbsp;/* Removing the undesired elements */
&nbsp;&nbsp;&nbsp;&nbsp;eina_array_remove(array, keep, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;/* Flushing and freeing the array */

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>
<li>To completely wipe an array out, use the <span style="font-family: Courier New,Courier,monospace">eina_array_flush()</span> function. This function sets the count and total members of an array to 0, and frees and sets its data members to <span style="font-family: Courier New,Courier,monospace">NULL</span>. For performance reasons, there is no array check. If the value is <span style="font-family: Courier New,Courier,monospace">NULL</span> or invalid, the program can crash. The only parameter of this function is a pointer to the <span style="font-family: Courier New,Courier,monospace">Eina_Array</span> array you want to flush.
<pre class="prettyprint">
eina_array_flush(array);
</pre>
</li>
<li>To empty an array quickly, use the <span style="font-family: Courier New,Courier,monospace">eina_array_clean()</span> function. This function sets the counting of members in the array to 0. It does not free any space so you have to use it carefully. For performance reasons, there is no array check. If the value is <span style="font-family: Courier New,Courier,monospace">NULL</span> or invalid, the program can crash.
<pre class="prettyprint">
eina_array_clean(array);
</pre>
</li>
</ul>

<h3>Accessing Classic Array Data</h3>

<p>To access classic array data:</p>
<ul>
<li>To access the data in the array, use the <span style="font-family: Courier New,Courier,monospace">eina_array_data_get()</span> function with the array and the index of the element you want to get. The function returns a pointer to the data.
<pre class="prettyprint">
/* Getting the data of the first element */
char *mydata;
mydata = eina_array_data_get(array, 0);
</pre>
</li>


<li>To get the number of elements in an array, use the <span style="font-family: Courier New,Courier,monospace">eina_array_count()</span> function. The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_array_new()</span> function.
<p>The function returns the number of elements.</p>
<pre class="prettyprint">
unsigned int nb_elm;
nb_elm = eina_array_count(array);
</pre>
</li>

<li>To iterate through an array, you can use various methods:
<ul>
<li>Use the <span style="font-family: Courier New,Courier,monospace">Eina_Array</span> iterator called <span style="font-family: Courier New,Courier,monospace">ITER_NEXT</span>.
<p>You can use the iterator by calling the macro <span style="font-family: Courier New,Courier,monospace">EINA_ARRAY_ITER_NEXT()</span>. It takes the array to iterate as the first parameter, a counter for the current index during the iteration, and a variable of the same type as the item data and an <span style="font-family: Courier New,Courier,monospace">Eina_Iterator</span>. To use it, declare an <span style="font-family: Courier New,Courier,monospace">Eina_Iterator</span>, an <span style="font-family: Courier New,Courier,monospace">int</span> counter, and, for example, a <span style="font-family: Courier New,Courier,monospace">char *</span> item if your array contains any strings.</p>
<pre class="prettyprint">
Eina_Array_Iterator iterator;
const char *item;
unsigned int i;

EINA_ARRAY_ITER_NEXT(array, i, item, iterator)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;item #%d: %s\n&quot;, i, item);
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace">eina_array_foreach()</span> function to iterate over the array.
<p>The first parameter is the array to iterate, the second is a callback function which determines whether the iteration can continue, and the last is the data passed to the callback function.</p>
<p>To iterate over the array and to print the data of each array element:</p>
<pre class="prettyprint">
/* Callback function */
static Eina_Bool
elm_print(const void *container, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char *)data);

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int
iterating_array()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned int i;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating an array */

&nbsp;&nbsp;&nbsp;&nbsp;/* Iterating over the array and calling elm_print on each element */
&nbsp;&nbsp;&nbsp;&nbsp;eina_array_foreach(array, elm_print, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;/* Freeing the element data and array */

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>

<li>Use the <span style="font-family: Courier New,Courier,monospace">eina_array_iterator_new()</span> function to create an iterator for the array. <p>The function returns a newly allocated iterator associated with the array. If the array is <span style="font-family: Courier New,Courier,monospace">NULL</span> or the count of the array members is less than or equal to 0, the function returns <span style="font-family: Courier New,Courier,monospace">NULL</span>. If the memory cannot be allocated, <span style="font-family: Courier New,Courier,monospace">NULL</span> is returned and <span style="font-family: Courier New,Courier,monospace">EINA_ERROR_OUT_OF_MEMORY</span> is thrown. Otherwise, a valid iterator is returned.</p>
<p>Pass to this function the array for which you want to create a new iterator. The iterator is used to run a sequential walk through the array, just like the <span style="font-family: Courier New,Courier,monospace">eina_array_foreach()</span> function.</p>
<p>To create an iterator and use it to print the data of each array element:</p>
<pre class="prettyprint">
static Eina_Bool
print_one(const void *container, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)data);

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int
new_iterator()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Iterator *it;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned short int i;
&nbsp;&nbsp;&nbsp;&nbsp;void *uninteresting;
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool rt;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating an array */

&nbsp;&nbsp;&nbsp;&nbsp;it = eina_array_iterator_new(array);

&nbsp;&nbsp;&nbsp;&nbsp;it = eina_iterator_next(it, &amp;uninteresting);
&nbsp;&nbsp;&nbsp;&nbsp;eina_iterator_foreach(it, print_one, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;eina_iterator_free(it);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace">eina_array_accessor_new()</span> function to get random access to the array elements. 
<p>The function returns a newly allocated accessor associated with the array. If the array is <span style="font-family: Courier New,Courier,monospace">NULL</span> or the counting of array members is less than or equal to 0, this function returns <span style="font-family: Courier New,Courier,monospace">NULL</span>. If the memory cannot be allocated, <span style="font-family: Courier New,Courier,monospace">NULL</span> is returned and <span style="font-family: Courier New,Courier,monospace">EINA_ERROR_OUT_OF_MEMORY</span> is thrown. Otherwise, a valid accessor is returned.</p>
<p>To use the accessor to retrieve and print the data of every other array element:</p>
<pre class="prettyprint">
int
random_access()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Declaration of the array */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;&nbsp;/* Declaration of the accessor */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Accessor *acc;

&nbsp;&nbsp;&nbsp;&nbsp;/* Generic counter */
&nbsp;&nbsp;&nbsp;&nbsp;unsigned short int i;

&nbsp;&nbsp;&nbsp;&nbsp;/* Variable to put the data retrieved from an array element */
&nbsp;&nbsp;&nbsp;&nbsp;void *data;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating an array */

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating the array accessor */
&nbsp;&nbsp;&nbsp;&nbsp;acc = eina_array_accessor_new(array);

&nbsp;&nbsp;&nbsp;&nbsp;/* Random access to the data of the array elements */
&nbsp;&nbsp;&nbsp;&nbsp;for (i = 1; i &lt; 10; i += 2) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Putting the data in the variable &#39;data&#39; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_accessor_data_get(acc, i, &amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (const char *)data);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/* Freeing the accessor */
&nbsp;&nbsp;&nbsp;&nbsp;eina_accessor_free(acc);

&nbsp;&nbsp;&nbsp;&nbsp;/* Freeing the array */

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>
</ul>
</li>
</ul>


<h3 id="inline" name="inline">Creating and Destroying an Inline Array</h3>

<p>An inline array is a container that stores the data itself, not the pointers to the data. This means there is no memory fragmentation, and for small data types, such as char, short, and int, it is more memory-efficient. This is because the data is stored in the cache and is faster to access. The bigger the data gets, however, the less likely it is and the less interesting it becomes.</p>
<p>To create an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function:</p>
<ul><li>The first parameter is the size of the value. In this example, only the characters are stored, and because of that, only <span style="font-family: Courier New,Courier,monospace">sizeof(char)</span> is passed to the function.</li>
<li>The second parameter defines the size of the array allocation step. For example, if you set it to 4, the function returns an inline array of 4 elements, and the next time you grow the inline array, it grows by 4 elements and becomes an array of 8 elements. If you set the step to 0, the function sets a default safe value. 
<p>The step can be changed later on using the <span style="font-family: Courier New,Courier,monospace">eina_inarray_step_set()</span> function.</p></li></ul>

<p>The <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function returns a pointer to the new <span style="font-family: Courier New,Courier,monospace">Eina_Inarray</span> variable.</p>
<pre class="prettyprint">
int
inline_array()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Declare an inline array variable of the type Eina_Inarray */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;

&nbsp;&nbsp;&nbsp;&nbsp;/* Create an inline array of &quot;char&quot; */
&nbsp;&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 0);

&nbsp;&nbsp;&nbsp;&nbsp;/* When no longer needed, free the array memory */
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<h3>Modifying Inline Array Content</h3>

<p>To modify inline array content:</p>
<ul>
<li>
<p>To add data as the last element of the inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_push()</span> function. The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. The second parameter is the data you want to push to the inline array.</p>
<p>If everything runs fine, the function returns the index of the new element. If something goes wrong, it returns <span style="font-family: Courier New,Courier,monospace">-1</span>.</p>
<pre class="prettyprint">
ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
</pre>
</li>
<li>
<p>To insert data to a given position of the inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_at()</span> function:</p>
<ul><li>The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The second parameter is the index of the element you want to add to the inline array.</li>
<li>The last parameter is a pointer to the content to be added.</li></ul>
<p>The content of the pointer is copied to the given position in the inline array. All the members from the position to the end of the array are shifted towards the end. If the position is equal to the end of the array, the member is appended. If the position is bigger than the array length, the function fails.</p>
<pre class="prettyprint">
ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;d&#39;;
eina_inarray_push(iarr, &amp;ch);

/* Adding data on position 3 */
ch = &#39;c&#39;;
eina_inarray_insert_at(iarr, 2, &amp;ch);
</pre>
</li>
<li>
<p>To insert data with your own position criteria, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert()</span> or <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted()</span> function. The only difference between these functions is that the <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted()</span> function assumes that the array is already sorted and consequently optimizes the insertion position by doing a binary search.</p>
<p>In both functions:</p>
<ul><li>The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The second parameter is the data you want to push to the inline array.</li>
<li>The last parameter is the callback comparison function. 
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> callback function compares data1 and data2. data1 is the value contained in the inline array and data2 is the data you pass to the <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert()</span> or <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted()</span> function as the second parameter. If data1 is less than data2, -1 must be returned, if it is greater, 1 must be returned, and if they are equal, 0 must be returned.</p></li></ul>
<p>The following example shows how to insert a value before a greater value:</p>
<pre class="prettyprint">
/* Defining the comparison function with the position criteria */
Eina_Compare_Cb
cmp(const void *a, const void *b)
{
&nbsp;&nbsp;&nbsp;&nbsp;return *(int*)a &gt; *(int*)b;
}

int
inline_insert()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;&nbsp;char ch;
&nbsp;&nbsp;&nbsp;&nbsp;char *ch3;
&nbsp;&nbsp;&nbsp;&nbsp;int a;
&nbsp;&nbsp;&nbsp;&nbsp;int *b;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating an inline array */

&nbsp;&nbsp;&nbsp;&nbsp;/* Adding data to the inline array */
&nbsp;&nbsp;&nbsp;&nbsp;a = 97;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);
&nbsp;&nbsp;&nbsp;&nbsp;a = 98;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);
&nbsp;&nbsp;&nbsp;&nbsp;a = 100;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);

&nbsp;&nbsp;&nbsp;&nbsp;/* Inserting data with the criteria */
&nbsp;&nbsp;&nbsp;&nbsp;a = 99;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_insert_sorted(iarr, &amp;a, cmp);

&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);
}
</pre>
</li>
<li>
<p>To remove the last element of the inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_pop()</span> function. The only parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. This function returns the data removed from the inline array.</p>
<pre class="prettyprint">
eina_inarray_pop(iarr);
</pre>
</li>
<li>
<p>To remove specific data from an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove()</span> function. The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. The second parameter is the data you want to remove from the inline array.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove()</span> function finds the data and removes the matching members from the array. The data can be an existing member of an inline array for optimized usage. In other cases, the content is matched using the <span style="font-family: Courier New,Courier,monospace">memcmp()</span> function.</p>


<p>The <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove()</span> function returns the index of the removed member, or -1 if failed.</p>
<pre class="prettyprint">
iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);

/* Removing data from the array */
eina_inarray_remove(iarr, &amp;ch);
</pre>
</li>

<li>
<p>To remove data from a defined position in an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove_at()</span> function. The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. The second parameter is the index of the element you want to remove from the inline array.</p>
<p>The function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> on success and <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> if something goes wrong. The member is removed from the inline array and any members after it are moved towards the array&#39;s head.</p>
<pre class="prettyprint">
/* Removing data from position 2 */
eina_inarray_remove_at(iarr, 2);
</pre>
</li>
<li><p>To remove all the elements of the array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_flush()</span> function. The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. The function removes every member from the array.</p>
<pre class="prettyprint">
eina_inarray_flush(iarr);
</pre>
</li>

<li>
<p>To replace values in the inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_replace_at()</span> function, which copies the data over the given position:</p>
<ul><li>The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The second parameter is the index of the element you want to remove from the inline array.</li>
<li>The last parameter is the data you want to copy in place of the current data.</li></ul>
<p>The function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> on success, and <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> on failure. The given pointer content is copied to the given position in the array. The pointer is not referenced, instead its contents are copied to the member&#39;s array using the previously defined <span style="font-family: Courier New,Courier,monospace">member_size</span>. If the position does not exist, the function fails.</p>
<pre class="prettyprint">
/* Replacing the member at position 3 */
ch = &#39;d&#39;;
eina_inarray_replace_at(iarr, 3, &amp;ch);
</pre>
</li>

<li>
<p>To sort an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_sort()</span> function, which applies a quick sorting algorithm to the inline array:</p>
<ul><li>The first parameter is a pointer to the array returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The last parameter is the <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> callback comparison function, which compares data1 and data2. 
<p>data1 and data2 are values contained in the inline array. If the data matches, the function must return 0, if data1 is less than data2, -1 must be returned and if it is greater, 1 must be returned.</p></li></ul>
<pre class="prettyprint">
static int
short_cmp(const void *pa, const void *pb)
{
&nbsp;&nbsp;&nbsp;&nbsp;const short *a = pa, *b = pb;

&nbsp;&nbsp;&nbsp;&nbsp;return *a - *b;
}

int
sorting_inline_array()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *array;
&nbsp;&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating the inline array */

&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_sort(array, short_cmp);
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(array);
}
</pre>

<p>Be careful, the data given to the compare function is the pointer to the member memory itself. Do not change it.</p>
</li>
</ul> 

<h3>Accessing Inline Array Data</h3>

<p>To access inline array data:</p>
<ul>
<li>
<p>To search a member in an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_search()</span> function that runs a linear walk looking for the given data:</p>

<ul><li>The first parameter is a pointer to the array variable returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The second parameter is the data used by the callback function to run the comparison.</li>
<li>The last parameter is the <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> callback comparison function, which compares data1 and data2.
<p>data1 is the value contained in the inline array and data2 is the data you pass to the <span style="font-family: Courier New,Courier,monospace">eina_inarray_search()</span> function as the second parameter. If the data matches, the function must return 0, if data1 is less than data2, -1 must be returned and if it is greater, 1 must be returned.</p></li></ul>
<p>The function returns the member index, or -1 if not found.</p>
<pre class="prettyprint">
Eina_Compare_Cb
compare(const void *pa, const void *pb)
{
&nbsp;&nbsp;&nbsp;&nbsp;const short *a = pa, *b = pb;
&nbsp;&nbsp;&nbsp;&nbsp;if (*a == *b)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int
search_inline_array()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *array;
&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;int elm_index;
&nbsp;&nbsp;&nbsp;&nbsp;int to_search = 3;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating and populating the inline array */

&nbsp;&nbsp;&nbsp;&nbsp;elm_index = eina_inarray_search(array, &amp;to_search, compare);
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(array);
}
</pre>

<p>Be careful, the data given to the compare function is the pointer to the member memory itself. Do not change it.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_inarray_search_sorted()</span> function does exactly the same as <span style="font-family: Courier New,Courier,monospace">eina_inarray_search()</span>, but uses a binary search for the given data.</p>
</li>

<li>
<p>To get the number of elements in an inline array, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_count()</span>. The first parameter is a pointer to the array returned by the <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function. The function returns an unsigned <span style="font-family: Courier New,Courier,monospace">int</span>, the number of elements.</p>
<pre class="prettyprint">
printf(&quot;Inline array of integers with %d elements:\n&quot;, eina_inarray_count(iarr));
</pre>
</li>

<li>To iterate through an inline array, you can use various methods:
<ul>
<li><p>You can use the iterator macros for the inline arrays: <span style="font-family: Courier New,Courier,monospace">FOREACH</span> and <span style="font-family: Courier New,Courier,monospace">REVERSE_FOREACH</span>.</p></li>
<li>
<p>To run a linear walk over an array of elements, use the <span style="font-family: Courier New,Courier,monospace">EINA_INARRAY_FOREACH()</span> macro. The first parameter is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span>, and the second parameter is the variable into which the current value is put during the walk. The <span style="font-family: Courier New,Courier,monospace">EINA_INARRAY_REVERSE_FOREACH()</span> macro does the same thing but starts from the last element.</p>

<p>The following example illustrates the printing of each element and its pointer:</p>
<pre class="prettyprint">
iarr = eina_inarray_new(sizeof(char), 0);
int a;
int *b;

a = 97;
eina_inarray_push(iarr, &amp;a);
a = 98;
eina_inarray_push(iarr, &amp;a);
a = 99;
eina_inarray_push(iarr, &amp;a);

EINA_INARRAY_FOREACH(iarr, b)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;int: %d(pointer: %p)\n&quot;, *b, b);
</pre>
</li>
<li>To process the array data, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach()</span> function, which invokes the given function on each element of the array with the given data:
<ul><li>The first parameter is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span>.</li>
<li>The second parameter is the function to run on each element.
<p>The function must return <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> as long as you want to continue iterating. By returning <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span>, you stop the iteration and make the <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach()</span> function return <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span>.</p>
<p>The data given to the function is the pointer to the member itself.</p></li>
<li>The last parameter is the data passed to the function called on each element.</li></ul>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach()</span> function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> if it successfully iterates through all items of the array. Call the function for every given data in the array. This is a safe way to iterate over an array.</p>
<pre class="prettyprint">
static Eina_Bool
array_foreach(const void *array __UNUSED__, void *p, void *user_data __UNUSED__)
{
&nbsp;&nbsp;&nbsp;&nbsp;short *member = p;
&nbsp;&nbsp;&nbsp;&nbsp;int *i = user_data;
&nbsp;&nbsp;&nbsp;&nbsp;(*p)++;
&nbsp;&nbsp;&nbsp;&nbsp;(*i)++;

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int
inline_array_foreach()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 1);
&nbsp;&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numbers_count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;val);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_foreach(iarr, array_foreach, &amp;i);

&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>

<li>To remove some elements based on your own criteria, use the <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach_remove()</span> function, which walks through the array and, if the value matches in the callback function, removes the element:
<ul><li>The first parameter is a pointer to the array returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new()</span> function.</li>
<li>The second parameter is the callback function to run on each element.
<p>The callback function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> if the value matches, or <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> if it does not match.</p></li>
<li>The last parameter is the data passed to the callback function.</li></ul>
<p>The function returns the number of removed entries or -1 if something goes wrong.</p>
<pre class="prettyprint">
static Eina_Bool
array_foreach(const void *array __UNUSED__, void *p, void *user_data __UNUSED__)
{
&nbsp;&nbsp;&nbsp;&nbsp;short *member = p;
&nbsp;&nbsp;&nbsp;&nbsp;int *i = user_data;
&nbsp;&nbsp;&nbsp;&nbsp;if (*i == *p)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;

&nbsp;&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int
inline_array_foreach_remove()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 1);
&nbsp;&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numbers_count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;val);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;i = 6;
&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_foreach_remove(iarr, array_foreach, &amp;i);

&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

</li>
</ul>
</li>
</ul>


<h2 id="hash" name="hash">Hash Tables</h2>
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> provides a way to store values in association with a key. For example, if you want to store some tuples into a table, you can do it using the <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span>.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> is implemented using an array of &quot;buckets&quot; where each bucket is a pointer to a structure that is the head of a red-black tree. This implementation makes it very robust against week keys as in the worst case scenario, you can still depend on an efficient binary tree implementation.</p>

<h3 id="hash_create" name="hash_create">Creating a Hash Table</h3>

<p>To create the hash table, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_new()</span> function:</p>
<ul>
<li>The first parameter is the function called when getting the size of the key.</li>
<li>The second parameter is the function called when comparing the keys.</li>
<li>The third parameter is the function called when getting the values.</li>
<li>The fourth parameter is the function called on each value when the hash table is freed, or when an item is deleted from it. <span style="font-family: Courier New,Courier,monospace">NULL</span> can be passed as the callback.</li>
<li>The last parameter is the size of the buckets.</li>
</ul>
<p>When you create an <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> instance, you have to create 4 potentially long callback functions. To make the functions shorter, <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> offers some predefined functions to create the following kinds of hash tables:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_djb2_new()</span> creates a new hash table using the djb2 algorithm for strings.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_superfast_new()</span> creates a new hash table for use with strings (better with long strings).</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_small_new()</span> creates a new hash table for use with strings with a small bucket size.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_int32_new()</span> and <span style="font-family: Courier New,Courier,monospace">eina_hash_int64_new()</span> create a new hash table for use with 32-bit and 64-bit integers.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_pointer_new()</span> creates a new hash table for use with pointers.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_stringshared_new()</span> creates a new hash table for use with shared strings.</li>
</ul>
<p>All these predefined functions require only 1 parameter, which is the function to free the data you store in the hash table.</p>
<p>The following example shows how to manage a small phone book using the <span style="font-family: Courier New,Courier,monospace">eina_hash_string_superfast_new()</span> function to create the hash table.</p>
<ol>
<li><p>Create the phone book structure and some static data:</p>
<pre class="prettyprint">
struct _Phone_Entry {
&nbsp;&nbsp;&nbsp;&nbsp;const char *name; /* Full name */
&nbsp;&nbsp;&nbsp;&nbsp;const char *number; /* Phone number */
};

typedef struct _Phone_Entry Phone_Entry;

static Phone_Entry
_start_entries[] =
{
&nbsp;&nbsp;&nbsp;&nbsp;{&quot;Wolfgang Amadeus Mozart&quot;, &quot;+01 23 456-78910&quot;},
&nbsp;&nbsp;&nbsp;&nbsp;{&quot;Ludwig van Beethoven&quot;, &quot;+12 34 567-89101&quot;},
&nbsp;&nbsp;&nbsp;&nbsp;{&quot;Richard Georg Strauss&quot;, &quot;+23 45 678-91012&quot;},
&nbsp;&nbsp;&nbsp;&nbsp;{&quot;Heitor Villa-Lobos&quot;, &quot;+34 56 789-10123&quot;},
&nbsp;&nbsp;&nbsp;&nbsp;{NULL, NULL}
};
</pre>
</li>

<li><p>Create the callback to free the data:</p>
<pre class="prettyprint">
static void
_phone_entry_free_cb(void *data)
{
&nbsp;&nbsp;&nbsp;&nbsp;free(data);
}
</pre>
<p>The free callback can be changed later using the <span style="font-family: Courier New,Courier,monospace">eina_hash_free_cb_set()</span> function. You need to pass the hash and the new callback function.</p>
</li>

<li><p>Create and destroy the hash table.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_hash_free_buckets()</span> function frees all hash table buckets. It empties the hash but does not destroy it, and you can still use it for another purpose. When <span style="font-family: Courier New,Courier,monospace">eina_hash_free()</span> is called, the space allocated for the hash is freed.</p>
<pre class="prettyprint">
int
free_data()
{
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Hash *phone_book = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;phone_book = eina_hash_string_superfast_new(_phone_entry_free_cb);

&nbsp;&nbsp;&nbsp;&nbsp;/* Empty the phone book without destroying it */
&nbsp;&nbsp;&nbsp;&nbsp;eina_hash_free_buckets(phone_book);
&nbsp;&nbsp;&nbsp;&nbsp;eina_hash_free(phone_book);
}
</pre>
</li>
</ol>




<h3>Modifying Hash Table Content</h3>

<p>To modify hash table content:</p>
<ul>
<li>
<p>To add some data to a hash, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_add()</span> function. This function takes the hash, the key to access the data, and the data as its parameters.</p>
<p>The following example shows how to add the initial data declared earlier to the hash:</p>
<pre class="prettyprint">
for (i = 0; _start_entries[i].name != NULL; i++)
&nbsp;&nbsp;&nbsp;&nbsp;eina_hash_add(phone_book, _start_entries[i].name, strdup(_start_entries[i].number));
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> offers various ways to add elements to a hash, such as the <span style="font-family: Courier New,Courier,monospace">eina_hash_direct_add()</span> function, which adds the entry without duplicating the string key. The key is stored in the struct, so this function can be used with <span style="font-family: Courier New,Courier,monospace">eina_stringshare</span> to avoid key data duplication.</p>
<pre class="prettyprint">
for (i = 0; _start_entries[i].name != NULL; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;/* Allocating memory for the phone entry */
&nbsp;&nbsp;&nbsp;&nbsp;Phone_Entry *e = malloc(sizeof(Phone_Entry));

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating an eina_stringshare for the name and the phone number */
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;name = eina_stringshare_add(_start_entries[i].name);
&nbsp;&nbsp;&nbsp;&nbsp;e-&gt;number = eina_stringshare_add(_start_entries[i].number);

&nbsp;&nbsp;&nbsp;&nbsp;/* Adding the entry to the hash */
&nbsp;&nbsp;&nbsp;&nbsp;eina_hash_direct_add(phone_book, e-&gt;name, e);
}
</pre>
</li>
<li>
<p>To modify an entry, use <span style="font-family: Courier New,Courier,monospace">eina_hash_modify()</span> function passing the hash, the key of the data to change, and the new data. The function returns the old data on success.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_hash_set()</span> function does the same work as <span style="font-family: Courier New,Courier,monospace">eina_hash_modify()</span>, but if the entry does not exist, the function creates a new one.</p>
<pre class="prettyprint">
char *old_phone = NULL;
char *phone = NULL;
/* Replace the phone number of Richard Strauss */
old_phone = eina_hash_modify(phone_book, &quot;Richard Georg Strauss&quot;, strdup(&quot;+23 45 111-11111&quot;));
phone = eina_hash_set(phone_book, &quot;Philippe de Magalhães&quot;, strdup(&quot;+33 6 111-11111&quot;));
eina_hash_set(phone_book, &quot;Richard Georg Strauss&quot;, strdup(&quot;+23 45 111-117711&quot;));
</pre>
</li>
<li>
<p>To change the key associated with the data without freeing and creating a new entry, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_move()</span> function. You only have to pass the hash, the old key, and the new key. If the operation succeeds, the function returns <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span>, if not, it returns <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span>.</p>
<pre class="prettyprint">
Eina_Bool res;
res = eina_hash_move(phone_book, &quot;Philippe de Magalhães&quot;, &quot;Filipe de Magalhães&quot;);
</pre>
</li>
<li>
<p>To delete entries from a hash table:</p>
<ul><li>Use the <span style="font-family: Courier New,Courier,monospace">eina_hash_del()</span> function to remove the entry identified by a key or data from the given hash table:
<pre class="prettyprint">
Eina_Bool r;
const char *entry_name = &quot;Heitor Villa-Lobos&quot;;
r = eina_hash_del(phone_book, entry_name, NULL);
</pre></li>
<li>Use the <span style="font-family: Courier New,Courier,monospace">eina_hash_del_by_key()</span> function to remove an entry based on the key:
<pre class="prettyprint">
r = eina_hash_del_by_key(phone_book, &quot;Richard Georg Strauss&quot;);
</pre>
</li>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">eina_hash_del_by_data()</span> function to remove an entry based on the data:</p>
<pre class="prettyprint">
r = eina_hash_del_by_data(phone_book, &quot;+12 34 567-89101&quot;);
</pre>
</li>
</ul></li></ul>

<h3>Accessing Hash Table Data</h3>
<p>To find hash table elements and get data based on the key name:</p>
<ul>
<li>
<p>To retrieve an entry based on its key, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_find()</span> function by passing the hash and the key you are looking for:</p>
<pre class="prettyprint">
char *phone = NULL;
const char *entry_name = &quot;Heitor Villa-Lobos&quot;;

/* Look for a specific entry and get its phone number */
phone = eina_hash_find(phone_book, entry_name);
</pre>
</li>
<li>
<p>To get the number of entries in a hash, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_population()</span> function. Pass the hash as the only argument.</p>
<pre class="prettyprint">
unsigned int nb_elm;
nb_elm = eina_hash_population(phone_book);
</pre>
</li>

<li>To iterate through a hash table, you can use various methods: 
<ul>

<li>To iterate over the hash table, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_foreach()</span> function:

<ul><li>The first parameter is the hash.</li>
<li>The second parameter is the callback function called on each iteration.
<p>The callback function has to return an <span style="font-family: Courier New,Courier,monospace">Eina_Bool</span>, <span style="font-family: Courier New,Courier,monospace">EINA_TRUE</span> if the iteration has to continue and <span style="font-family: Courier New,Courier,monospace">EINA_FALSE</span> if the iteration has to stop.</p></li>
<li>The last parameter is the data passed to the callback function.</li></ul>

<p>The following example prints the key and the data of the hash entry (the name and the phone number):</p>

<pre class="prettyprint">
static Eina_Bool
pb_foreach_cb(const Eina_Hash *phone_book, const void *key, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;const char *name = key;
&nbsp;&nbsp;&nbsp;&nbsp;const char *number = data;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s: %s\n&quot;, name, number);

&nbsp;&nbsp;&nbsp;&nbsp;/* Return EINA_FALSE to stop this callback from being called */
&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

printf(&quot;List of phones:\n&quot;);

/* Running the callback on the hash called phone_book */
eina_hash_foreach(phone_book, pb_foreach_cb, NULL);
printf(&quot;\n&quot;);
</pre>
</li>
<li>To iterate over the keys, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_key_new()</span> function:
<pre class="prettyprint">
/* Declaration of the Eina_Iterator */
Eina_Iterator *it;

/* Variable to handle the current iteration &quot;data&quot; */
void *data;

/* Iterate over the keys (names) */
printf(&quot;List of names in the phone book:\n&quot;);

it = eina_hash_iterator_key_new(phone_book);

/* Use the generic eina_iterator_next() */
while (eina_iterator_next(it, &amp;data)) {
&nbsp;&nbsp;&nbsp;&nbsp;const char *name = data;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, name);
}

/* Free the iterator */
eina_iterator_free(it);
</pre>
</li>

<li>To iterate over the hash data, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_data_new()</span> function the same way as <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_key_new()</span>:
<pre class="prettyprint">
/* Declaration of the Eina_Iterator */
Eina_Iterator *it;

/* Variable to handle the current iteration &quot;data&quot; */
void *data;

/* Iterate over hash data */
printf(&quot;List of numbers in the phone book:\n&quot;);

it = eina_hash_iterator_data_new(phone_book);
while (eina_iterator_next(it, &amp;data)) {
&nbsp;&nbsp;&nbsp;&nbsp;const char *number = data;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, number);
}

/* Free the iterator */
eina_iterator_free(it);
</pre>
</li>
<li>To iterate over a tuple composed of keys and data, use the <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_tuple_new()</span> function:
<pre class="prettyprint">
/* Declaration of the Eina_Iterator */
Eina_Iterator *tit;

/* Variable to handle the current iteration &quot;data&quot; */
void *tuple;

printf(&quot;List of phones:\n&quot;);
tit = eina_hash_iterator_tuple_new(phone_book);
while (eina_iterator_next(tit, &amp;tuple)) {
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Hash_Tuple *t = tuple;
&nbsp;&nbsp;&nbsp;&nbsp;const char *name = t-&gt;key;
&nbsp;&nbsp;&nbsp;&nbsp;const char *number = t-&gt;data;
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s: %s\n&quot;, name, number);
}

/* Always free the iterator after its use */
eina_iterator_free(tit);
</pre>
</li>
</ul>
</li>
</ul>


<h2 id="list" name="list">Lists</h2>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_List</span> is a double-linked list that can store data of any type as void pointers. It provides a set of functions to create and manipulate the list to avoid the access to the struct&#39;s fields, similar to a self-made double-link list.</p>
<p>In addition to the previous and next node and its data, the <span style="font-family: Courier New,Courier,monospace">Eina_List</span> nodes keep a reference to an accounting structure. The accounting structure is used to improve the performance of some functions. The structure is private and must not be modified.</p>

<p>In an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, everything is a &quot;list&quot;: the list itself is a list where each node is a list as well.</p>

<p>Eina provides 2 list types: the classic list (<span style="font-family: Courier New,Courier,monospace">Eina_List</span>) and an inline list (<span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span>).</p>

<h3>Creating and Destroying a List</h3>
<p>To use an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>:</p>

<ol><li>Declare the list with <span style="font-family: Courier New,Courier,monospace">NULL</span> as the default value:
<pre class="prettyprint">
int
list()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Declaration of the Eina_List with NULL as default value */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_List *list = NULL;
</pre></li>

<li>Call the <span style="font-family: Courier New,Courier,monospace">eina_list_append()</span> function with the list and the data you want to append as parameters.
<p>The list must be a pointer to the first element of the list (or <span style="font-family: Courier New,Courier,monospace">NULL</span>). The function returns a pointer to the list.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;&nbsp;/* Creating the first element of the list */
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;watch&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;/* Adding more elements */
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;phone&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;ivi&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;notebook&quot;);
</pre></li>

<li>When you no longer need the list, free it:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;&nbsp;/* Free the Eina_List */
&nbsp;&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre></li>
</ol>


<h3>Modifying List Content</h3>

<p>To modify list content:</p>
<ul>
<li>
<p>To add data to a list:</p>

<ul>
<li>To add data at the end of the list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_append()</span> function. To add data at the top of the list, use <span style="font-family: Courier New,Courier,monospace">eina_list_prepend()</span>. The functions work in the same way, only adding the data to different places.
<pre class="prettyprint">
list = eina_list_prepend(list, &quot;set-top box&quot;);
</pre>
</li>

<li>To insert data into the list after a specified data, use the <span style="font-family: Courier New,Courier,monospace">eina_list_append_relative()</span> function. As the last parameter, define the element after which the data is added.
<p>For example to append data after the &quot;phone&quot; element:</p>
<pre class="prettyprint">
list = eina_list_append_relative(list, &quot;single-board computer&quot;, &quot;phone&quot;);
</pre>
</li>

<li>To add a new entry before a specified data, use the <span style="font-family: Courier New,Courier,monospace">eina_list_prepend_relative()</span> function. It is similar to the <span style="font-family: Courier New,Courier,monospace">eina_list_append_relative()</span> function.
<pre class="prettyprint">
list = eina_list_prepend_relative(list, &quot;ultrabook&quot;, &quot;ivi&quot;);
</pre>
</li>

<li>To append a list node to a linked list after a specified member, use the <span style="font-family: Courier New,Courier,monospace">eina_list_append_relative_list()</span> function. To prepend a list node to a linked list before a specified member, use the <span style="font-family: Courier New,Courier,monospace">Eina_List * eina_list_prepend_relative_list()</span> function.
</li>
</ul>
</li>

<li>To set data in a list member, use the <span style="font-family: Courier New,Courier,monospace">eina_list_data_set()</span> function. Pass the &quot;list&quot; (node) as the first argument and the data to set as the second.

<p>The following example also shows the usage of the <span style="font-family: Courier New,Courier,monospace">eina_list_last()</span> function, which returns the last element of an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>.</p>

<pre class="prettyprint">
/* Setting new data for the last element */
eina_list_data_set(eina_list_last(list), eina_stringshare_add(&quot;Boris&quot;));
</pre>
</li>

<li id="remove_list">To remove a node from the list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_remove()</span> function. This function removes the first instance of the specified data from the given list.
<pre class="prettyprint">
list = eina_list_remove(list, &quot;ultrabook&quot;);
</pre>
<p>You can also remove a &quot;list&quot; (node) from a list using the <span style="font-family: Courier New,Courier,monospace">eina_list_remove_list()</span> function. Pass the list you want to delete an element from and a &#39;list&#39; (node) you want to delete.</p>
<pre class="prettyprint">
Eina_List *app_list = NULL;
Eina_List *to_remove = NULL;

/* Adding some elements to the list (using stringshares) */
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enna&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ebird&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;calaos&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;rage&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;terminology&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enlightenment&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;eyelight&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ephoto&quot;));

/* Finding the &quot;list&quot; to remove */
to_remove = eina_list_data_find_list(list, eina_string_share_add(&quot;enlightenment&quot;));

list = eina_list_remove_list(list, to_remove);
</pre>
</li>

<li>To move elements in a list, you can use various function, such as <span style="font-family: Courier New,Courier,monospace">eina_list_promote_list()</span> that promotes an element to the top of the list or <span style="font-family: Courier New,Courier,monospace">eina_list_demote_list()</span> that puts the specified element at the end of the list. Remember that everything is a list so the second parameter represents the &quot;list&quot; (node) you want to move. Use the functions just like the <span style="font-family: Courier New,Courier,monospace">eina_list_remove_list()</span> function.
<pre class="prettyprint">
list = eina_list_promote_list(list, eina_list_data_find_list(list, &quot;ivi&quot;));
</pre>
</li>
<li>To reverse all the elements of a list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_reverse()</span> function. To obtain a reversed copy of the list while keeping the initial list unchanged, use the <span style="font-family: Courier New,Courier,monospace">eina_list_reverse_clone()</span> function.
<pre class="prettyprint">
Eina_List *rev_copy;

app_list = eina_list_reverse(app_list);
rev_copy = eina_list_reverse_clone(app_list);
</pre>
</li>
<li>To sort a list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_sort()</span> function. This function takes a list which needs to be sorted, the maximum number of elements to be sorted, and a callback function that compares data. To sort all list elements, set the maximum number of elements to 0.
<pre class="prettyprint">
int
sort_cb(const void *d1, const void *d2)
{
&nbsp;&nbsp;&nbsp;&nbsp;const char *txt = d1;
&nbsp;&nbsp;&nbsp;&nbsp;const char *txt2 = d2;
&nbsp;&nbsp;&nbsp;&nbsp;if (!txt)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(1);
&nbsp;&nbsp;&nbsp;&nbsp;if (!txt2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);

&nbsp;&nbsp;&nbsp;&nbsp;return(strcmp(txt, txt2));
}

extern Eina_List *list;
list = eina_list_sort(list, 0, sort_cb);
</pre>
</li>
<li>To merge 2 list into 1, use the <span style="font-family: Courier New,Courier,monospace">eina_list_merge()</span> function. The <span style="font-family: Courier New,Courier,monospace">eina_list_sorted_merge()</span> function merges 2 sorted lists according to the ordering function that you pass as the last argument.
<pre class="prettyprint">
int
sort_cb(void *d1, void *d2)
{
&nbsp;&nbsp;&nbsp;&nbsp;const char *txt = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;const char *txt2 = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if (!d1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(1);
&nbsp;&nbsp;&nbsp;&nbsp;if (!d2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);

&nbsp;&nbsp;&nbsp;&nbsp;return(strcmp((const char*)d1, (const char*)d2));
}

Eina_List *sorted1;
Eina_List *sorted2;
Eina_List *newlist;

/* Insert some values and sort your lists */

/* Simply merge 2 lists without any process */
newlist = eina_list_merge(sorted1, sorted2);

newlist = eina_list_sorted_merge(sorted1, sorted2, sort_cb);
</pre>
</li>
<li>To split a list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_split_list()</span> function:
<ul><li>The first parameter is the list to split.</li>
<li>The second parameter is the &quot;list&quot; (element) after which the list is split.</li>
<li>The last parameter is the head of the second list.</li></ul>
<pre class="prettyprint">
/* Original list (left list) */
Eina_List *list = NULL;

/* New list (right list) */
Eina_List *other_list = NULL;

/* Eina_List (element) */
Eina_List *l;

list = eina_list_append(list, &quot;super tux&quot;);
list = eina_list_append(list, &quot;frozen bubble&quot;);
list = eina_list_append(list, &quot;lincity-ng&quot;);

/* Sorting the list (just for fun) */
list = eina_list_sort(list, 0, cmp_func);

/* Looking for the &#39;split&#39; element */
l = eina_list_search_sorted_list(list, cmp_func, &quot;frozen bubble&quot;);

/* Splitting the list */
list = eina_list_split_list(list, l, &amp;other_list);
</pre>
</li>
<li>To copy a list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_clone()</span> function. The function copies all the elements in the list in the exact same order.
<pre class="prettyprint">
Eina_List *app_list_copy;

app_list_copy = eina_list_clone(app_list);
</pre>
</li>

</ul>


<h3>Accessing List Data</h3>
<p>To access list data:</p>
<ul>
<li>To find some data on your list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_data_find()</span> function. Pass the list containing your data as the first parameter and the data you are looking for as the last one. The function returns the found member data pointer if found, <span style="font-family: Courier New,Courier,monospace">NULL</span> otherwise.
<p>The <span style="font-family: Courier New,Courier,monospace">eina_list_data_find()</span> function searches the list from the beginning to the end for the first member for which the data pointer is data. If it is found, the data is returned, otherwise <span style="font-family: Courier New,Courier,monospace">NULL</span> is returned. The function only compares pointers, which is why using <span style="font-family: Courier New,Courier,monospace">Eina_Stringshare</span> is very useful with lists, because it always returns the same pointer for the same string.</p>
<pre class="prettyprint">
Eina_List *app_list = NULL;
const char *res_str;

/* Adding some elements to the list (using stringshares) */
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enna&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ebird&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;calaos&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;rage&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;terminology&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enlightenment&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;eyelight&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ephoto&quot;));

/* Finding the data */
res_str = eina_list_data_find(list, eina_string_share_add(&quot;enlightenment&quot;));
if (res_str == eina_stringshare_add(&quot;enlightenment&quot;))
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Data is present&quot;);
else
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Data not present&quot;);
</pre>

<p>The above example returns &quot;Data is present&quot;.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_list_data_find_list()</span> function does the same thing as <span style="font-family: Courier New,Courier,monospace">eina_list_data_find()</span>, but returns an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>. For an example, see the <a href="#remove_list"><span style="font-family: Courier New,Courier,monospace">eina_list_remove_list()</span> function</a>.</p>
<p>You can access the data or a &quot;list&quot; (node) of an <span style="font-family: Courier New,Courier,monospace">Eina_List</span> using the <span style="font-family: Courier New,Courier,monospace">eina_list_nth()</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_nth_list()</span> functions. The first one returns a pointer to the data of the &quot;n&quot; element and the second a pointer to the &quot;list&quot;. To access the data of the third element of an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>:</p>
<pre class="prettyprint">
const char *res;
Eina_List *res_lst;

res = eina_list_nth(app_list, 2);
res_lst = eina_list_nth_list(app_list, 2);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">res</span> variable contains the pointer to the string &quot;calaos&quot;. The <span style="font-family: Courier New,Courier,monospace">res_lst</span> variable is the list containing &quot;calaos&quot;.</p>
</li>

<li>To search for data in a list, select your function based on whether the list is sorted or unsorted.
<ul>
<li>To search in an unsorted list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted()</span> function:
<ul><li>The first parameter is the list.</li>
<li>The second parameter is a callback function for comparison.</li>
<li>The last parameter is the data you are looking for.</li></ul>

<p>The <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted_list()</span> function does the same but returns an &quot;Eina_List&quot;.</p>


<p>The following example shows 2 searches using both the <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted()</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted_list()</span> functions:</p>
<pre class="prettyprint">
int
search_list()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Declaring the list */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_List *list = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;Eina_List *l;
&nbsp;&nbsp;&nbsp;&nbsp;/* Little trick to use strcmp as Eina_Compare_Cb */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_Compare_Cb cmp_func = (Eina_Compare_Cb)strcmp;

&nbsp;&nbsp;&nbsp;&nbsp;void *data;
&nbsp;&nbsp;&nbsp;&nbsp;int cmp_result;

&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;debian&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;centos&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;data = eina_list_search_unsorted(list, cmp_func, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;l = eina_list_search_unsorted_list(list, cmp_func, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;if (l-&gt;data != data) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

</li>
<li>To search in sorted lists, use the <span style="font-family: Courier New,Courier,monospace">eina_list_search_sorted_list()</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_search_sorted()</span> functions. They work similarly as the <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted()</span> function.
</li>
</ul>
</li>


<li>To get data from a list element, use the <span style="font-family: Courier New,Courier,monospace">eina_list_data_get()</span> function. The function returns the data contained in the given list.

<p>The following example uses the <span style="font-family: Courier New,Courier,monospace">eina_list_next()</span> function to move through the list in a statement.</p>
<pre class="prettyprint">
int
list_data_set()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Declaring the list */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_List *list = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;/* Eina_List in which to place the elements or lists */
&nbsp;&nbsp;&nbsp;&nbsp;Eina_List *l;

&nbsp;&nbsp;&nbsp;&nbsp;void *list_data;

&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Bertrand&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Cedric&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Nicolas&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Vincent&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Raoul&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Fabien&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Philippe&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;billiob&quot;));

&nbsp;&nbsp;&nbsp;&nbsp;for (l = list; l; l = eina_list_next(l)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Printing the data returned by eina_list_data_get */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)eina_list_data_get(l));
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;EINA_LIST_FREE(list, list_data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_stringshare_del(list_data);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>

<li>To move in a list, use the <span style="font-family: Courier New,Courier,monospace">eina_list_last()</span>, <span style="font-family: Courier New,Courier,monospace">eina_list_next()</span>, or <span style="font-family: Courier New,Courier,monospace">eina_list_prev()</span> functions to move to the last, next, or previous element in the list.
<p>The following example scrolls backwards starting from the end of the list:</p>
<pre class="prettyprint">
for (l = eina_list_last(list); l; l = eina_list_prev(l))
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)eina_list_data_get(l));
</pre>

</li>

<li>To count the list elements, use the <span style="font-family: Courier New,Courier,monospace">eina_list_count()</span> function. The function returns the number of items in a list.
<pre class="prettyprint">
printf(&quot;List size: %d\n&quot;, eina_list_count(list));
</pre>
</li>
<li>To iterate through an array, you can use various iterators: 
<ul>
<li>To iterate over a list from the beginning to the end, use the <span style="font-family: Courier New,Courier,monospace">EINA_LIST_FOREACH</span> macro:
<ul><li>The first parameter is the list to iterate.</li>
<li>The second parameter is an <span style="font-family: Courier New,Courier,monospace">Eina_List *</span> to hold the current &quot;List&quot; (node).</li>
<li>The last parameter receives the current data during the run.</li></ul>

<p>The following example prints the data of each &quot;List&quot; (node) of the list:</p>
<pre class="prettyprint">
Eina_List *list = NULL;
Eina_List *l;
void *list_data;

list = eina_list_append(list, &quot;ls&quot;);
list = eina_list_append(list, &quot;top&quot;);
list = eina_list_append(list, &quot;rmdir&quot;);
list = eina_list_append(list, &quot;uname&quot;);

EINA_LIST_FOREACH(list, l, list_data)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)list_data);

eina_list_free(list);
</pre>
</li>
<li>To iterate from the last element to the first, use the <span style="font-family: Courier New,Courier,monospace">EINA_LIST_REVERSE_FOREACH</span> macro. It works similarly as <span style="font-family: Courier New,Courier,monospace">EINA_LIST_FOREACH()</span>.
</li>
<li>To iterate over a list from the beginning to the end, you can also use the <span style="font-family: Courier New,Courier,monospace">EINA_LIST_FOREACH_SAFE</span> macro. It is called safe, because it stores the next &quot;List&quot; (node), so you can safely remove the current &quot;List&quot; (node) and continue the iteration.
<pre class="prettyprint">
Eina_List *list;
Eina_List *l;
Eina_List *l_next;
char *data;

list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);

/* Using EINA_LIST_FOREACH_SAFE to free the elements that match &quot;tizen&quot; */

EINA_LIST_FOREACH_SAFE(list, l, l_next, data) {
&nbsp;&nbsp;&nbsp;&nbsp;if (strcmp(data, &quot;tizen&quot;) == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_remove_list(list, l);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>


<li>To remove each list element while having access to the node&#39;s data, use the <span style="font-family: Courier New,Courier,monospace">EINA_LIST_FREE</span> macro. Pass the list and a pointer to hold the current data.
<pre class="prettyprint">
Eina_List *list;
char *data;

/* List is filled */

EINA_LIST_FREE(list, data)
&nbsp;&nbsp;&nbsp;&nbsp;free(data);
</pre>
</li>
</ul>
</li>
</ul>

<h3 id="inlist" name="inlist">Using an Inline List</h3>
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> is a special data type drawn to store nodes pointers in the same memory as data. This way the memory is less fragmented, but operations, such as sort and count, are slower. The <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> has its own purpose, but if you do not understand what the purpose is, use the regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span> instead.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> nodes can be part of a regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, simply added with the <span style="font-family: Courier New,Courier,monospace">eina_list_append()</span> or <span style="font-family: Courier New,Courier,monospace">eina_list_prepend()</span> functions.</p>

<p>To use the inline list:</p>
<ol>
<li>Define the structure of the data before creating the inline list:
<pre class="prettyprint">
struct my_struct {
&nbsp;&nbsp;&nbsp;&nbsp;EINA_INLIST;
&nbsp;&nbsp;&nbsp;&nbsp;int a;
&nbsp;&nbsp;&nbsp;&nbsp;int b;
};
</pre>

<p>The structure is composed of 2 integers, the real data, and the <span style="font-family: Courier New,Courier,monospace">EINA_INLIST</span> type which is composed of 3 pointers defining the inline list structure:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace">Eina_Inlist * next</span>: next node</li>
<li><span style="font-family: Courier New,Courier,monospace">Eina_Inlist * prev</span>: previous node</li>
<li><span style="font-family: Courier New,Courier,monospace">Eina_Inlist * last</span>: last node</li>
</ul></li>

<li>
<p>To create the inlist nodes, allocate the memory and use the <span style="font-family: Courier New,Courier,monospace">eina_inlist_append()</span> function:</p>
<ul><li>The first parameter is the existing list head or <span style="font-family: Courier New,Courier,monospace">NULL</span> to create a new list. 
<p>The following example passes <span style="font-family: Courier New,Courier,monospace">NULL</span> to create a new list.</p></li>
<li>The second parameter is the new list node, and it must not be <span style="font-family: Courier New,Courier,monospace">NULL</span>. 
<p>You must use the <span style="font-family: Courier New,Courier,monospace">EINA_INLIST_GET()</span> macro to get the inlist object of the datastruct.</p></li></ul>
<pre class="prettyprint">
struct my_struct *d;
struct my_struct *cur;
Eina_Inlist *list;
Eina_Inlist *itr;
Eina_Inlist *tmp;

d = malloc(sizeof(*d));
d-&gt;a = 1;
d-&gt;b = 10;

list = eina_inlist_append(NULL, EINA_INLIST_GET(d));
</pre>

<p>Repeat this operation for every new node:</p>
<pre class="prettyprint">
d = malloc(sizeof(*d));
d-&gt;a = 2;
d-&gt;b = 20;
list = eina_inlist_append(list, EINA_INLIST_GET(d));
</pre>
</li>

<li>To add data to the inline list:
<ul><li>Put data at the end of the inline list with the <span style="font-family: Courier New,Courier,monospace">eina_inlist_prepend()</span> function:
<pre class="prettyprint">
d = malloc(sizeof(*d));
d-&gt;a = 3;
d-&gt;b = 30;
list = eina_inlist_prepend(list, EINA_INLIST_GET(d));
</pre>
</li>

<li>Add a node before or after a given node with the <span style="font-family: Courier New,Courier,monospace">eina_inlist_prepend_relative()</span> and <span style="font-family: Courier New,Courier,monospace">eina_inlist_append_relative()</span> functions. 
<p>In both functions, the first parameter is the target list, the second is the element you want to add, and the last is the reference element to place data after (in this case). Similarly as in a regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, everything is a list, so the last parameter is an <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> typed variable.</p>
<pre class="prettyprint">
d = malloc(sizeof(*d));
d-&gt;a = 4;
d-&gt;b = 40;
list = eina_inlist_append_relative(list, EINA_INLIST_GET(d), list);
</pre>
</li></ul></li>

<li>To sort and iterate an inline list, to find and move list elements, and to perform other inline list operations, see the <a href="../../../../../org.tizen.native.mobile.apireference/group__Eina__Inline__List__Group.html">Inline List</a> API.</li>

<li>When the inline list is no longer needed, destroy it by looping over the list to free each <span style="font-family: Courier New,Courier,monospace">EINA_INLIST</span> structure and the data using allocated memory. Use the <span style="font-family: Courier New,Courier,monospace">eina_inlist_remove()</span> function on each node.

<p>In the following example, the <span style="font-family: Courier New,Courier,monospace">EINA_INLIST_CONTAINER_GET()</span> macro returns the container object of an inlist (the <span style="font-family: Courier New,Courier,monospace">EINA_INLIST</span> of <span style="font-family: Courier New,Courier,monospace">my_struct</span>), and the list element is removed and the allocated memory of the container &quot;object&quot; is freed.</p>

<pre class="prettyprint">
while (list) {
&nbsp;&nbsp;&nbsp;&nbsp;struct my_struct *aux = EINA_INLIST_CONTAINER_GET(list, struct my_struct);

&nbsp;&nbsp;&nbsp;&nbsp;/* Remove the current list element */
&nbsp;&nbsp;&nbsp;&nbsp;list = eina_inlist_remove(list, list);
&nbsp;&nbsp;&nbsp;&nbsp;free(aux);
}
</pre>
</li>


</ol>

<h2 id="generic" name="generic">Generic Value</h2>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> object provides generic data storage and access, allowing you to store what you want in one single type of <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>. It is meant for simple data types, providing uniform access and release functions, useful to exchange data preserving their types. The <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> comes with predefined types for numbers, array, list, hash, blob, and structs, and it can convert between data types, including string.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> can handle the following types:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_UCHAR</span>: unsigned char</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_USHORT</span>: unsigned short</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_UINT</span>: unsigned int</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_ULONG</span>: unsigned long</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_TIMESTAMP</span>: unsigned long used for timestamps</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_UINT64</span>: unsigned integer of 64 bits</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_CHAR</span>: char</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_SHORT</span>: short</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_INT</span>: int</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_LONG</span>: long</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_INT64</span>: integer of 64 bits</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_FLOAT</span>: float</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_DOUBLE</span>: double</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_STRINGSHARE</span>: stringshared string</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_STRING</span>: string</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_ARRAY</span>: array</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_LIST</span>: list</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_HASH</span>: hash</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_TIMEVAL</span>: &#39;struct timeval&#39;</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_BLOB</span>: blob of bytes</li>
<li><span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_STRUCT</span>: struct</li>
</ul>


<p>To set up a generic value:</p>
<ol>
<li>Declare the necessary variables:
<pre class="prettyprint">
/* Eina_Value itself */
Eina_Value v;
/* Integer */
int i;
/* And char* */
char *newstr;
</pre>
</li>

<li>To set up an <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> for an integer, use the <span style="font-family: Courier New,Courier,monospace">eina_value_setup()</span> function. The first argument is the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> and the second is the type.
<pre class="prettyprint">
eina_value_setup(&amp;v, EINA_VALUE_TYPE_INT);
</pre>
</li>
</ol>
<p>To manage the generic value:</p>
<ul>
<li>To set an integer, use the <span style="font-family: Courier New,Courier,monospace">eina_value_set()</span> function:
<pre class="prettyprint">
eina_value_set(&amp;v, 123);
</pre>
</li>

<li>To get the value, use the <span style="font-family: Courier New,Courier,monospace">eina_value_get()</span> function. Pass the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> as the first argument, and a pointer to a variable to store the value (the target variable must have the same type as the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>).
<pre class="prettyprint">
eina_value_get(&amp;v, &amp;i);
printf(&quot;v=%d\n&quot;, i);
</pre>
<p>The above example prints &quot;v=123&quot;.</p>
</li>

<li>To store an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, use the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> that corresponds to the <span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_LIST</span> type.
</li>
<li>To create an <span style="font-family: Courier New,Courier,monospace">Eina_Value_List</span>, use the <span style="font-family: Courier New,Courier,monospace">eina_value_list_setup()</span> function. The function initializes a generic value storage of the list type. The first parameter is the &quot;object&quot; value, and the second one is the type (how to manage the stored list members).
</li>
</ul>

<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">Except as noted, this content is licensed under <a href="http://opensource.org/licenses/LGPL-2.1" target="_blank">LGPLv2.1+</a>.</td>
        </tr>
    </tbody>
</table> 
   
<script type="text/javascript" src="../../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
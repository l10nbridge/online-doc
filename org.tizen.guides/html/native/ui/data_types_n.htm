<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Data Types</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
        <p class="toc-title">Content</p>
        <ul class="toc">      
			 <li><a href="#iterate">Iterator Functions</a></li>
			 <li><a href="#data_structure">Data Structure</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
        <ul class="toc">
			<li><a href="../../../../org.tizen.tutorials/html/native/ui/ui_tutorials_n.htm">UI Tutorials</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__Eina__Group.html">Eina API</a></li>
		</ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">

  <h1>Data Types</h1>

  <p>The Eina library is a central part of the EFL. It implements an API for data types, and allows you to create and manipulate several data types:</p>

<ul>
<li><a href="#inline">Inline Array</a>: standard array of inlined members</li>
<li><a href="#array">Array</a>: standard array of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#hash">Hash Table</a>: standard hash of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#inlist">Inline List</a>: list with nodes inlined into the user type</li>
<li>Compact List</li>
<li><a href="#list">List</a>: standard list of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li><a href="#iterate">Iterator Functions</a></li>
<li>Sparse Matrix: sparse matrix of <span style="font-family: Courier New,Courier,monospace;">void*</span> data</li>
<li>Red-Black tree: red-black tree with nodes inlined into the user type</li>
<li><a href="#buffer">String Buffer</a>: mutable string to prepend, insert, or append strings to a buffer</li>
<li><a href="#share">Stringshare</a>: shares read-only string references</li>
<li>Tiler split: merges and navigates into 2D tiled regions</li>
<li>Trash: container of unused but allocated data</li>
<li><a href="#generic">Generic Value Storage</a>: container for generic value storage and access</li>
<li>Data Model API: container for data with a user-defined hierarchy or structure</li>
</ul>

  
<h2 id="iterate" name="iterate">Iterator Functions</h2>
<p>Eina provides a set of iterators functions to manipulate data types like arrays.</p>
<p>These functions allow to access elements of a container in a generic way, without knowing which container is used (a bit like iterators in the C++ STL). Iterators only allow sequential access (that is, from one element to the next one). For random access, Eina provides Accessor Functions.</p>
<p>Getting an iterator to access elements of a given container is done through the functions of that particular container. There is no function to create a generic iterator as iterators absolutely depend on the container. This means you won&#39;t find any creation function for iterators in the Iterator chapter of the EFL documentation, those can be found in the documentation of the container type you&#39;re using. Although they are created with container specific functions, iterators are always deleted with the same function: eina_iterator_free().</p>
<p>To get the data and iterate, use eina_iterator_next(). To call a function on every single element of a container, use eina_iterator_foreach().</p>
<p>Each data type owns a set of macros, these macros provide the iterators like FOREACH or REVERSE_FOREACH</p>
<p>More details about iterators are provided in section about data types.</p>
<h2 id="data_structure" name="data_structure">Data Structure</h2>
<h3 id="string" name="string">String Data Types</h3>
<h4 id="share" name="share">Stringshare</h4>
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Stringshare</span> data type functions allow you to store a single copy of a string, and use in multiple places throughout your program. This way you can save a lot of strings with less memory.</p>
<p>With this data type you reduce the number of duplicated strings kept in memory. It&#39;s pretty common for the same strings to be dynamically allocated repeatedly between applications and libraries, especially in circumstances where you could have multiple copies of a structure that allocates the string.</p>
<p>So, rather than duplicating and freeing these strings, you request a read-only pointer to an existing string and only incur the overhead of a hash lookup.</p>
<p>It sounds like micro-optimizing, but profiling has shown this can have a significant impact as the number of copies grows.</p>
<p>It improves string creation/destruction speed, reduces memory use and decreases memory fragmentation, so an all-around win.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Stringshare</span> is quite easy to use. In order create a stringshare, you just have to declare a <span style="font-family: Courier New,Courier,monospace">const char *</span> and call <span style="font-family: Courier New,Courier,monospace">eina_stringshare_add(const char * str)</span></p>
<pre class="prettyprint">
const char *mystr;
const char *prologue = &quot;Enlightenment is not just a window manager for Linux/X11 and others&quot;

mystr = eina_stringshare_add(prologue);
</pre>
<p>When you are done with this string, you can delete it using <span style="font-family: Courier New,Courier,monospace">eina_stringshare_del(Eina_Stringshare * string)</span>.</p>
<pre class="prettyprint">eina_stringshare_del(mystr);</pre>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Stringshare</span> also provides some useful functions to work with stringshares, such as:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">eina_stringshare_printf (const char *fmt, ...)</span></li>
<li><span style="font-family: Courier New,Courier,monospace">eina_stringshare_replace(Eina_Stringshare **p_str, const char *news)</span></li>
<li><span style="font-family: Courier New,Courier,monospace">eina_stringshare_strlen (Eina_Stringshare *str)</span></li>
</ul>

<p><span style="font-family: Courier New,Courier,monospace">eina_stringshare_printf (const char *fmt, ...)</span> retrieves a string for use in a program from a format string. If you have a &quot;format&quot; string to pass to a function like <span style="font-family: Courier New,Courier,monospace">printf</span> you can store it as a stringshare too.</p>
<pre class="prettyprint">
const char *myfmtstr = &quot;%d desktop manager to rule them all&quot;;
const char *str;

str = eina_stringshare_printf(myfmtstr, 1);

print(str)
</pre>
<p>This example produces &quot;1 desktop manager to rule them all&quot;.</p>
<p>You can replace the value of an Eina_Stringshare using <span style="font-family: Courier New,Courier,monospace">eina_stringshare_replace(Eina_Stringshare **p_str, const char *news)</span>. Pass the pointer&#39;s address and the new value to this function like this:</p>
<pre class="prettyprint">eina_stringshare_replace(&amp;str,&quot;One desktop manager to rule them all&quot;);
</pre>
<p><span style="font-family: Courier New,Courier,monospace">eina_stringshare_strlen (Eina_Stringshare *str)</span> gives you the length of the stringshare value.</p>
<pre class="prettyprint">printf(&quot;length: %d\n&quot;, eina_stringshare_strlen(str));
</pre>

<h4 id="buffer" name="buffer">String Buffer</h4>
<p>This data type is designed to be a mutable string, allowing to append, prepend or insert a string to a buffer. By this way, you can easily handle buffers in your applications.</p>
<p>First you need to initialize the <span style="font-family: Courier New,Courier,monospace">Eina_Strbuf</span> and create the buffer.</p>
<pre class="prettyprint">
Eina_Strbuf *buf;
mybuffer = eina_strbuf_new();
</pre>

<h5>Appending and Prepending Characters to the Buffer</h5>
<p>To append or prepend characters to your buffer you have multiple ways.</p>
<p>You can simply use <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append(Eina_Strbuf * buf, const char * str)</span></p>
<pre class="prettyprint">eina_strbuf_append(mybuffer, &quot;This is my string. &quot;);
</pre
><p><span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_char(Eina_Strbuf *buf, char c)</span> just appends one character to your buffer, you also can append a &quot;sized&quot; string to the buffer using <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_length(Eina_Strbuf * buf, const char * str, size_t length)</span></p>
<pre class="prettyprint">eina_strbuf_append_length(mybuffer, &quot;Buffe&quot;, 5);
eina_strbuf_append_char(mybuffer, &#39;r&#39;);
</pre>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Strbuf</span> also handles &quot;printf&quot; format strings, <span style="font-family: Courier New,Courier,monospace">eina_strbuf_append_printf(Eina_Strbuf * buf, const char * fmtmt, ...)</span> adds formatted strings to the buffer.</p>
<pre class="prettyprint">eina_strbuf_append_printf(buf, &quot;%s%c&quot;, &quot;buffe&quot;, &#39;r&#39;);
</pre>

<h5>Removing and Replacing Characters from the Buffer</h5>
<p>To remove characters from a position to another, use <span style="font-family: Courier New,Courier,monospace">eina_strbuf_remove(Eina_Strbuf * buf, size_t started, size_t end)</span> The first parameter is the buffer, the second is the start position of characters you want to delete, and the last the end position.</p>
<p>This example removes the first 19 characters of the buffer:</p>
<pre class="prettyprint">eina_strbuf_remove(buf, 0, 18);
</pre>

<p>To replace characters, call <span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace (Eina_Strbuf *buf, const char *str, const char *with, unsigned int n)</span> or <span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace_all (Eina_Strbuf *buf, const char *str, const char *with)</span>. <span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace</span> replaces the n-th occurrence of given <span style="font-family: Courier New,Courier,monospace">str</span> in the <span style="font-family: Courier New,Courier,monospace">buf</span> with <span style="font-family: Courier New,Courier,monospace">with</span> string. <span style="font-family: Courier New,Courier,monospace">eina_strbuf_replace_all</span> replaces all occurrences of given <span style="font-family: Courier New,Courier,monospace">str</span> in the <span style="font-family: Courier New,Courier,monospace">buf</span> with <span style="font-family: Courier New,Courier,monospace">with</span> string.</p>
<pre class="prettyprint">
eina_strbuf_append(mybuffer, &quot;buffer buffer buffer&quot;);

// Replace one occurrence of &quot;buffer&quot; by &quot;B-U-F-F-E-R&quot;
eina_strbuf_replace(mybuffer, &quot;buffer&quot;, &quot;B-U-F-F-E-R&quot;, 1);

// Replace all the occurrences of &quot;buffer&quot; by &quot;B-U-F-F-E-R&quot;
eina_strbuf_replace_all(mybuffer, &quot;buffer&quot;, &quot;B-U-F-F-E-R&quot;);

// Replace all the occurrences of &quot;B-U-F-F-E-R&quot; by &quot;Buffer&quot;
eina_strbuf_replace_all(mybuffer, &quot;B-U-F-F-E-R&quot;, &quot;Buffer&quot;);
</pre>

<h5>Inserting Characters in the Buffer</h5>
<p>To insert characters you can use the &quot;insert&quot; function, <span style="font-family: Courier New,Courier,monospace">eina_strbuf_insert(Eina_Strbuf * buf, const char * str, size_t pos)</span> will insert the given <span style="font-family: Courier New,Courier,monospace">str</span> at the position <span style="font-family: Courier New,Courier,monospace">pos</span>. <span style="font-family: Courier New,Courier,monospace">eina_strbuf_insert_printf(Eina_Strbuf * buf, const char * fmt, size_t pos, ...)</span> does the same but with formatted strings.</p>
<pre class="prettyprint">eina_strbuf_insert(mybuffer, &quot;More buffer&quot;, 10);

// Using  eina_strbuf_length_get to get the buffer length.
eina_strbuf_insert_printf(buf, &quot; %s: %d&quot;, 6, &quot;length&quot;, eina_strbuf_length_get(buf));
</pre>

<h5>Counting and Printing the Buffer</h5>
<p>You may want to print or get the length of your buffer. In order to get the complete string, calling <span style="font-family: Courier New,Courier,monospace">eina_strbuf_string_get(Eina_Strbuf *buf)</span> and <span style="font-family: Courier New,Courier,monospace">eina_strbuf_length_get(Eina_Strbuf *buf)</span> will return the buffer length.</p>
<pre class="prettyprint">printf(&quot;%s : %d\n&quot;, eina_strbuf_string_get(mybuffer), eina_strbuf_length_get(buf));
</pre>

<h5>Freeing the Buffer</h5>
<p>When you are done with the buffer don&#39;t forget to free the buffer using <span style="font-family: Courier New,Courier,monospace">eina_strbuf_free(Eina_Strbuf * buf)</span>. You can also free the content of a <span style="font-family: Courier New,Courier,monospace">Eina_Strbuf</span> without freeing the buffer itself using <span style="font-family: Courier New,Courier,monospace">eina_strbuf_string_free(Eina_Strbuf * buf)</span>.</p>
<pre class="prettyprint">eina_strbuf_free(mybuffer);
</pre>

<h3 id="array" name="array">Arrays</h3>
<p>An array is a data type which describes an ordered collection of values. The values are accessed by their index. </p>
<pre class="prettyprint">INDEX | VALUE
--------------
0     | value0
1     | value1
2     | value2
3     | value3
4     | value4
5     | value5
6     | value6
7     | value7
</pre>
<p>Eina provides two types of array: the classic Array and an inline array.</p>

<h4>Array Data Type</h4>

<h5>Creating and Destroying the Array</h5>
<p>The <span style="font-family: Courier New,Courier,monospace">eina_array_new(unsigned int step)</span> function creates a new array. You can store strings or &quot;objects&quot; in the created array.</p>
<p>In this example, we create an array to store &quot;strings&quot;:</p>
<pre class="prettyprint">
// The strings we want to store in the array 
const char* strings[] = 
{
&nbsp;&nbsp;&nbsp;&quot;helo&quot;, &quot;hera&quot;, &quot;starbuck&quot;, &quot;kat&quot;, &quot;boomer&quot;,
&nbsp;&nbsp;&nbsp;&quot;hotdog&quot;, &quot;longshot&quot;, &quot;jammer&quot;, &quot;crashdown&quot;, &quot;hardball&quot;,
&nbsp;&nbsp;&nbsp;&quot;duck&quot;, &quot;racetrack&quot;, &quot;apolo&quot;, &quot;husker&quot;, &quot;freaker&quot;,
&nbsp;&nbsp;&nbsp;&quot;skulls&quot;, &quot;bulldog&quot;, &quot;flat top&quot;, &quot;hammerhead&quot;, &quot;gonzo&quot;
};
// Declaring the array (type Eina_Array)
Eina_Array *array;
unsigned int i;

// Creating the array
array = eina_array_new(20);

// Inserting elements in the array
for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;eina_array_push(array, strdup(strings[i]));

// We have to free the array elements
while (eina_array_count(array))
&nbsp;&nbsp;&nbsp;free(eina_array_pop(array));

// Free the array itself
eina_array_free(array);
</pre>
<p>The first parameter called &#39;step&#39; defines the size of the allocation step, the array is allocated accordingly to the step. If you set 4 to this parameter, the function will return an array of 4 elements and next time you grow the array it will grow of 4 elements. Unless you have pushed 4 elements inside, it will not grow. But once you add the 5th element, it will grow again and become an array of 8 elements. This is very useful regarding performance issues and reduces also memory fragmentation by having a size that fit the array usage. If you set 0, the function will set a default safe value. This step can be changed using the function <span style="font-family: Courier New,Courier,monospace">eina_array_step_set</span>.</p>
<p>This function return a valid array on success, or NULL if memory allocation fails.</p>
<p>In the previous example we use <span style="font-family: Courier New,Courier,monospace">eina_array_free(Eina_Array *array)</span> to free the array. This function frees array. It first calls <span style="font-family: Courier New,Courier,monospace">eina_array_flush()</span> and then free the memory of the pointer. It does not free the memory allocated for the elements of the array. To free them, we use a &#39;while&#39; statement with <span style="font-family: Courier New,Courier,monospace">eina_array_pop</span>, this function is explained in the &quot;Array push and pop&quot; part of this document.</p>
<p>Like we said before we can change the step of an array using <span style="font-family: Courier New,Courier,monospace">eina_array_step_set(Eina_Array *array, unsigned int sizeof_eina_array, unsigned int step)</span></p>
<pre class="prettyprint">
Eina_Array *array;
array = eina_array_new(10);
eina_array_step_set(array, sizeof(*array), 20);
eina_array_free(array);
</pre>
<p>The first parameter is the array you want to change, the second one is the size of this very array. We use <span style="font-family: Courier New,Courier,monospace">sizeof(*array)</span> to get this size. The last parameter is the new step size. Here we pass from 10 to 20, next time the array grows, it grows of 20 elements.</p>

<h5>Array Push and Pop Operations</h5>
<p>In the creation example we add elements to the array using <span style="font-family: Courier New,Courier,monospace">eina_array_push(Eina_Array *array, const void *data)</span></p>
<pre class="prettyprint">// Inserting elements in the array
for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;eina_array_push(array, strdup(strings[i]));
</pre>
<p>The first parameter is the array to store the element, the second one is the data you want to store. Be careful if you store strings you will have to allocate the memory first. Here we use <span style="font-family: Courier New,Courier,monospace">strdup</span> to duplicate the string contained in <span style="font-family: Courier New,Courier,monospace">strings[]</span>, this function allocates the memory of the returned string, so we don&#39;t have to do it by ourselves.</p>
<p><span style="font-family: Courier New,Courier,monospace">eina_array_push</span> puts the element at the end of the array and returns EINA_TRUE if everything runs well, EINA_FALSE if it doesn&#39;t.</p>
<p>To remove the last element of an array, we use <span style="font-family: Courier New,Courier,monospace">eina_array_pop(Eina_Array *array)</span>, it takes the array as parameter and if the operation succeeds, it will return a pointer to the data of the removed element. That is the reason why we use this method to free the array&#39;s elements in this part of the example:</p>
<pre class="prettyprint">// We have to free the array elements
while (eina_array_count(array))
  free(eina_array_pop(array));
</pre>

<h5>Getting and Setting Data in an Array</h5>
<p>If you want to access the data in the array, you can use <span style="font-family: Courier New,Courier,monospace">eina_array_data_get(const Eina_Array *array, unsigned int idx)</span>, with the array and the index of the element you want to get.</p>
<pre class="prettyprint">// Get the data of the first element 
char *mydata;
mydata = eina_array_data_get(array, 0);
</pre>
<p>The function returns a pointer to the data.</p>
<p>You can also set the data of an element using <span style="font-family: Courier New,Courier,monospace">eina_array_data_set(const Eina_Array *array, unsigned int idx, const void *data)</span> The first parameter is the array, the second the index of the element you want to set, and the last one is the data. This effectively replaces the previously held data. You must therefore get the related pointer if you need to free it. Be careful, for performance reasons, there is no checks of array or idx. If it is NULL or invalid, the program may crash.</p>
<pre class="prettyprint">// Get the data of the first element 
free(eina_array_data_get(array, 0));
eina_array_data_set(array, 0, strdup(strings[3]);
</pre>

<h5>Array Removal Operations</h5>
<p><span style="font-family: Courier New,Courier,monospace">eina_array_remove(Eina_Array *array, Eina_Bool(*keep)(void *data, void *gdata), void *gdata)</span> rebuilds an array by specifying the data to be kept. The first parameter is the array to be changed, the second is the function which selects the data to keep in the rebuild array, the last one is the data to pass to the &#39;callback&#39; function defined as the second parameter.</p>
<p>The keep function has to return an <span style="font-family: Courier New,Courier,monospace">Eina_Bool</span>, EINA_TRUE if the element stays and EINA_FALSE if it has to be removed.</p>
<p>In this example we remove all the elements of the array which has a length greater than 5.</p>
<pre class="prettyprint">// The keep function 
Eina_Bool keep(void *data, void *gdata)
{
&nbsp;&nbsp;&nbsp;if (strlen((const char*)data) &lt;= 5)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int remove_array()
{
&nbsp;&nbsp;&nbsp;const char* strs[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;, &quot;sixteen&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;seventeen&quot;, &quot;eighteen&quot;, &quot;nineteen&quot;, &quot;twenty&quot;
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;const char* strings[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;helo&quot;, &quot;hera&quot;, &quot;starbuck&quot;, &quot;kat&quot;, &quot;boomer&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hotdog&quot;, &quot;longshot&quot;, &quot;jammer&quot;, &quot;crashdown&quot;, &quot;hardball&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;duck&quot;, &quot;racetrack&quot;, &quot;apolo&quot;, &quot;husker&quot;, &quot;freaker&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;skulls&quot;, &quot;bulldog&quot;, &quot;flat top&quot;, &quot;hammerhead&quot;, &quot;gonzo&quot;
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;Eina_Array_Iterator iterator;
&nbsp;&nbsp;&nbsp;const char *item;
&nbsp;&nbsp;&nbsp;unsigned int i;

&nbsp;&nbsp;&nbsp;array = eina_array_new(10);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;  eina_array_push(array, strs[i]);

&nbsp;&nbsp;&nbsp;eina_array_clean(array);
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;  eina_array_push(array, strings[i]);

&nbsp;&nbsp;&nbsp;eina_array_data_set(array, 17, &quot;flattop&quot;);

&nbsp;&nbsp;&nbsp;// Removing the undesired elements 
&nbsp;&nbsp;&nbsp;eina_array_remove(array, keep, NULL);

&nbsp;&nbsp;&nbsp;EINA_ARRAY_ITER_NEXT(array, i, item, iterator)
&nbsp;&nbsp;&nbsp;  printf(&quot;item #%d: %s\n&quot;, i, item);

&nbsp;&nbsp;&nbsp;// Flushing the array.
&nbsp;&nbsp;&nbsp;eina_array_flush(array);

&nbsp;&nbsp;&nbsp;// Free the array 
&nbsp;&nbsp;&nbsp;eina_array_free(array);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<h5>Array Flush Operation</h5>
<p>To completely wipe an array out, you can use <span style="font-family: Courier New,Courier,monospace">eina_array_flush (Eina_Array *array)</span>. This function sets the counting and total members of array to 0, frees and sets to NULL all its data members. For performance issues, there is no check of the array. If it is NULL or invalid, the program may crash. The only parameter of this function is a pointer to the array (Eina_Array *) you want to flush.</p>
<pre class="prettyprint">eina_array_flush(array);
</pre>

<h5>Counting Operations</h5>
<p>To get the number of elements in an array you must use <span style="font-family: Courier New,Courier,monospace">eina_array_count(const Eina_Array *arrays)</span></p>
<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The function returns an unsigned int representing to the number of elements.</p>
<pre class="prettyprint">unsigned int nb_elm;
nb_elm = eina_array_count(array);
</pre>

<h5>Array Clean Operation</h5>
<p>If you need to empty an array quickly, you can use <span style="font-family: Courier New,Courier,monospace">eina_array_clean(Eina_Array *array)</span> this function sets the counting of members in the array to 0. It doesn&#39;t free any space so you have to use it carefully. For performance reasons, there is no check of array. If it is NULL or invalid, the program may crash.</p>
<pre class="prettyprint">eina_array_clean(array);
</pre>

<h5>Iterating in an Array</h5>
<p>We may want to iterate through the array. Eina implements Iterators to give the ability to the programmer of iterating in the data type.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Array</span> has one iterator the <span style="font-family: Courier New,Courier,monospace">ITER_NEXT</span>. You can use it by calling the macro <span style="font-family: Courier New,Courier,monospace">EINA_ARRAY_ITER_NEXT(array, i, item, iterator)</span>. It takes the array to iterate as first parameter, an counter for the current index during iteration, and variable of the same type of item data and an <span style="font-family: Courier New,Courier,monospace">Eina_Iterator</span>. So in order to use it, you have to declare an <span style="font-family: Courier New,Courier,monospace">Eina_Iterator</span>, an <span style="font-family: Courier New,Courier,monospace">int</span> counter, and for example an <span style="font-family: Courier New,Courier,monospace">char *</span> item if your array contains &#39;strings&#39;</p>
<pre class="prettyprint">
Eina_Array_Iterator iterator;
const char *item;
unsigned int i;

EINA_ARRAY_ITER_NEXT(array, i, item, iterator)
&nbsp;&nbsp;&nbsp;printf(&quot;item #%d: %s\n&quot;, i, item);
</pre>
<p>Eina also provides a function to iterate over an array, <span style="font-family: Courier New,Courier,monospace">eina_array_foreach(Eina_Array *array, Eina_Each_Cb cb, void *fdata)</span>. This function takes as first parameter the array to iterate, the second parameter called &quot;cb&quot; is a callback function which determines if the iteration can continue or not, the last parameter called fdata is the data passed to the callback function.</p>
<p>In this example we print the data of each element:</p>
<pre class="prettyprint">// The callback function 
static Eina_Bool
elm_print(const void *container, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char *)data);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int iterating_array()
{
&nbsp;&nbsp;&nbsp;const char* strings[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;helo&quot;, &quot;hera&quot;, &quot;starbuck&quot;, &quot;kat&quot;, &quot;boomer&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;hotdog&quot;, &quot;longshot&quot;, &quot;jammer&quot;, &quot;crashdown&quot;, &quot;hardball&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;duck&quot;, &quot;racetrack&quot;, &quot;apolo&quot;, &quot;husker&quot;, &quot;freaker&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;skulls&quot;, &quot;bulldog&quot;, &quot;flat top&quot;, &quot;hammerhead&quot;, &quot;gonzo&quot;
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;unsigned int i;

&nbsp;&nbsp;&nbsp;array = eina_array_new(10);
&nbsp;&nbsp;&nbsp;eina_array_step_set(array, sizeof(*array), 20);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 20; i++)
&nbsp;&nbsp;&nbsp;  eina_array_push(array, strdup(strings[i]));

&nbsp;&nbsp;&nbsp;// Iterating over the array and calling elm_print on each element
&nbsp;&nbsp;&nbsp;eina_array_foreach(array, elm_print, NULL);

&nbsp;&nbsp;&nbsp;// Free the elements data
&nbsp;&nbsp;&nbsp;while (eina_array_count(array))
&nbsp;&nbsp;&nbsp;  free(eina_array_pop(array));

&nbsp;&nbsp;&nbsp;// Free the array
&nbsp;&nbsp;&nbsp;eina_array_free(array);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p><span style="font-family: Courier New,Courier,monospace">eina_array_iterator_new(const Eina_Array *array)</span> function returns a newly allocated iterator associated to array. If array is NULL or the counting of array members is less or equal than 0, this function will return NULL. If the memory cannot be allocated, NULL is returned and EINA_ERROR_OUT_OF_MEMORY is thrown. Otherwise, a valid iterator is returned.*</p>
<p>Pass to this function the array for which you want to create a new Iterator.</p>
<p>The iterator is used to run a sequential walk through the array, just like <span style="font-family: Courier New,Courier,monospace">eina_array_foreach</span>.</p>
<p>In this example we print the data for all elements.</p>
<pre class="prettyprint">static Eina_Bool
print_one(const void *container, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)data);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int new_iterator()
{
&nbsp;&nbsp;&nbsp;Eina_Array *arra;
&nbsp;&nbsp;&nbsp;Eina_Iterator *it;
&nbsp;&nbsp;&nbsp;unsigned short int i;
&nbsp;&nbsp;&nbsp;void *uninteresting;
&nbsp;&nbsp;&nbsp;Eina_Bool rt;

&nbsp;&nbsp;&nbsp;array = eina_array_new(4);

&nbsp;&nbsp;&nbsp;const char *strings[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;uninteresting string&quot;, &quot;husker&quot;, &quot;starbuck&quot;, &quot;husker&quot;
&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 4; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_array_push(array, strings[i]);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;it = eina_array_iterator_new(array);

&nbsp;&nbsp;&nbsp;it = eina_iterator_next(it, &amp;uninteresting);
&nbsp;&nbsp;&nbsp;eina_iterator_foreach(it, print_one, NULL);
&nbsp;&nbsp;&nbsp;eina_iterator_free(it);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p><span style="font-family: Courier New,Courier,monospace">eina_array_accessor_new(const Eina_Array *array)</span> function returns a newly allocated accessor associated to the array. If the array is NULL or the counting of array members is less or equal than 0, this function will return NULL. If the memory cannot be allocated, NULL is returned and EINA_ERROR_OUT_OF_MEMORY is thrown. Otherwise, a valid accessor is returned. The accessors allows random access on the array.</p>
<p>This example shows how to use accessors for a random access to the array elements.</p>
<pre class="prettyprint">int random_access()
{
&nbsp;&nbsp;&nbsp;const char *strings[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;even&quot;, &quot;odd&quot;, &quot;even&quot;, &quot;odd&quot;, &quot;even&quot;, &quot;odd&quot;, &quot;even&quot;, &quot;odd&quot;, &quot;even&quot;, &quot;odd&quot;
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;const char *more_strings[] = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;// Declaration of the array 
&nbsp;&nbsp;&nbsp;Eina_Array *array;
&nbsp;&nbsp;&nbsp;// Declaration of the accessor
&nbsp;&nbsp;&nbsp;Eina_Accessor *acc;

&nbsp;&nbsp;&nbsp;// A generic counter
&nbsp;&nbsp;&nbsp;unsigned short int i;

&nbsp;&nbsp;&nbsp;// Variable to put the data retrieved from an array element
&nbsp;&nbsp;&nbsp;void *data;

&nbsp;&nbsp;&nbsp;array = eina_array_new(10);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 10; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_array_push(array, strings[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Creating the array accessor
&nbsp;&nbsp;&nbsp;acc = eina_array_accessor_new(array);

&nbsp;&nbsp;&nbsp;// Random access to the data of the array elements
&nbsp;&nbsp;&nbsp;for(i = 1; i &lt; 10; i += 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Put the data in the variable &#39;data&#39;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_accessor_data_get(acc, i, &amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (const char *)data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Free the accessor
&nbsp;&nbsp;&nbsp;eina_accessor_free(acc);

&nbsp;&nbsp;&nbsp;// Free the array
&nbsp;&nbsp;&nbsp;eina_array_free(array);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<h3 id="inline" name="inline">Inline Arrays</h3>
<p>The inline array is a container that stores the data itself (not the pointers to the data), this means there is no memory fragmentation. Also, for small data types (such as char, short, int, etc.), it&#39;s more memory efficient: data will be stored in cache and faster accessible, but the bigger the data gets, the less likely it is and the less interesting it becomes).</p>
<p>To create an inline array you have to use <span style="font-family: Courier New,Courier,monospace">eina_inarray_new(unsigned int member_size, unsigned int step)</span> like in this example:</p>
<pre class="prettyprint">int inline_array() 
{
&nbsp;&nbsp;&nbsp;// Declaration of inline array variable of the type Eina_Inarray
&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;

&nbsp;&nbsp;&nbsp;// Creation of an Inline array of &quot;char&quot;
&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 0);

&nbsp;&nbsp;&nbsp;// Free the memory
&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p>The first parameter called &#39;member_size&#39; is the size of the value. In this example we want to store only characters, so we pass <span style="font-family: Courier New,Courier,monospace">sizeof(char)</span> to the function. The second parameter called &#39;step&#39; defines the size of the allocation step, the inline array is allocated by step. If you set 4 to this parameter, the function will return an inline array of 4 elements, next time you grow the inline array it will grow of 4 elements, so next time you grow the inline array will be a inline array of 8 elements. I you set 0, the function will set a default safe value. This step can be changed using the function <span style="font-family: Courier New,Courier,monospace">eina_inarray_step_set</span>.</p>
<p>The function will return a pointer to the new Eina_Inarray variable.</p>
<p>This example only shows the creation of an array, now we will see the following manipulation operations:</p>
<ul>
<li>push and pop</li>
<li>insert and insert sorted</li>
<li>remove and flush</li>
<li>replace</li>
<li>search</li>
<li>sort</li>
<li>count</li>
</ul>

<h4>Push and Pop Operations</h4>
<p>To add data as the last element of the inline array you can use <span style="font-family: Courier New,Courier,monospace">eina_inarray_push(Eina_Inarray *array, const void *data)</span> like in this example:</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

// Adding a value to the Inline array
ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span> The second parameter called &#39;data&#39; is the data you want to push to the inline array</p>
<p>If everything runs fine the function will return the index of the new element. If something goes wrong it returns <span style="font-family: Courier New,Courier,monospace">-1</span>.</p>
<p>To remove the last element of the inline array you can use <span style="font-family: Courier New,Courier,monospace">eina_inarray_pop(Eina_Inarray *array)</span> like in this example:</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);

// Removing the last element
eina_inarray_pop(iarr);
</pre>

<p>The only parameter of <span style="font-family: Courier New,Courier,monospace">eina_inarray_pop</span> is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span>Â·</p>
<p>This function returns the data removed from the inline array.</p>
<h4>Insertion Operations</h4>
<p>To insert data on a given position of the inline array, you can use the function <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_at(Eina_Inarray *array, unsigned int position, const void *data)</span>.</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;d&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Adding data on position 3
ch = &#39;c&#39;;
eina_inarray_insert_at(iarr, 2, &amp;ch)
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span> The second parameter called &#39;position&#39; is the index of the element you want to remove from the inline array.</p>
<p>The content of pointer is copied at the given position in the inline array. All the members from position to the end of the array are shifted to the end.</p>
<p>If position is equal to the end of the array, then the member is appended.</p>
<p>Be careful, if position is bigger than the array length, it will fail.</p>
<p>If you want to insert data with your own criteria of position you can use <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert(Eina_Inarray *array, const void * data, Eina_Compare_Cb compare)</span>. In this example we insert before a greater value.</p>
<pre class="prettyprint">
// Defining the function with our own criteria of position.
Eina_Compare_Cb cmp(const void *a, const void *b)
{
&nbsp;&nbsp;&nbsp;return *(int*)a &gt; *(int*)b;
}

int inline_insert()
{
&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;char ch, *ch3;
&nbsp;&nbsp;&nbsp;int a, *b;

&nbsp;&nbsp;&nbsp;// Creation of an inline array of ints with step of 4
&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(int), 4);

&nbsp;&nbsp;&nbsp;// Adding data to this inline array
&nbsp;&nbsp;&nbsp;a = 97;
&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);
&nbsp;&nbsp;&nbsp;a = 98;
&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);
&nbsp;&nbsp;&nbsp;a = 100;
&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;a);

&nbsp;&nbsp;&nbsp;/* Inserting data with our own criteria */
&nbsp;&nbsp;&nbsp;a = 99;
&nbsp;&nbsp;&nbsp;eina_inarray_insert_sorted(iarr, &amp;a, cmp);

&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);
}
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span> The second parameter called &#39;data&#39; is the data you want to push to the inline array</p>
<p>The last parameter called &#39;compare&#39; is the callback comparison function. This &quot;callback&quot; function of type <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> compares data1 and data2. data1 is the value contained in the inline array and data2 is the data you pass to <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted</span> as second parameter. If data1 is &#39;less&#39; than data2, -1 must be returned, if it is &#39;greater&#39;, 1 must be returned, and if they are equal, 0 must be returned.</p>
<h4>Remove and Flush Operations</h4>
<p>If you want to remove some data from an inline array you can use the function <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove(Eina_Inarray *array, const void *data)</span>. It finds the data and removes matching members from the array. The data may be an existing member of inline array for an optimized usage. If it&#39;s not the case the contents will be matched using <span style="font-family: Courier New,Courier,monospace">memcmp()</span>.</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;d&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Removing data from the array
eina_inarray_remove(iarr, &amp;ch);
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span> The second parameter called &#39;data&#39; is the data you want to remove from the inline array.</p>
<p>The function returns the index of the removed member or -1 on errors.</p>
<p>You can also remove data from a defined position in the array, you must use <span style="font-family: Courier New,Courier,monospace">eina_inarray_remove_at(Eina_Inarray *array, unsigned int position)</span></p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;d&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Removing data from position 2
eina_inarray_remove_at(iarr, 2);
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The second parameter called &#39;position&#39; is the index of the element you want to remove from the inline array.</p>
<p>The function returns EINA_TRUE on success and EINA_FALSE if something goes wrong</p>
<p>The member is removed from the inline array and any members after it are moved towards the array&#39;s head.</p>
<p>You can also remove all the elements of the array using <span style="font-family: Courier New,Courier,monospace">eina_inarray_flush(Eina_Inarray *array)</span>.</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;d&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Removing all inline array members 
eina_inarray_flush(iarr);
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The function removes every member from array.</p>
<h4>Replace Operations</h4>
<p>In most of the cases when we use arrays we want to replace some values, you can do it using the function <span style="font-family: Courier New,Courier,monospace">eina_inarray_replace_at(Eina_Inarray *array, unsigned int position, const void *data)</span> This function will copy the data over the given position.</p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Removing all inline array members 
ch = &#39;d&#39;;
eina_inarray_replace_at(iarr, 3, &amp;ch);
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The second parameter called &#39;position&#39; is the index of the element you want to remove from the inline array.</p>
<p>The last parameter called &#39;data&#39; is the data you want to be copied in place of the current data.</p>
<p><span style="font-family: Courier New,Courier,monospace">eina_inarray_replace_at</span> returns EINA_TRUE on success, EINA_FALSE on failure.</p>
<p>The given pointer contents is copied at the given position in the array.</p>
<p>The pointer is not referenced, instead it&#39;s contents is copied to the members array using the previously defined member_size.</p>
<p>If position does not exist, it will fail.</p>
<h4>Searching in the Inline Array</h4>
<p>The function <span style="font-family: Courier New,Courier,monospace">eina_inarray_search(const Eina_Inarray * array, const void * data, Eina_Compare_Cb compare)</span> allows you to search a member in an inline array. It runs a linear walk looking for the given data.</p>
<pre class="prettyprint">Eina_Compare_Cb
compare(const void *pa, const void *pb)
{
&nbsp;&nbsp;&nbsp;const short *a = pa, *b = pb;
&nbsp;&nbsp;&nbsp;if (*a == *b)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int search_inline_array()
{
&nbsp;&nbsp;&nbsp;Eina_Inarray *array;
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;int elm_index;
&nbsp;&nbsp;&nbsp;int to_search = 3;

&nbsp;&nbsp;&nbsp;array = eina_inarray_new(sizeof(short), 1);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numbers_count; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(array, &amp;val);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;elm_index = eina_inarray_search(array, &amp;to_search, compare);
&nbsp;&nbsp;&nbsp;eina_inarray_free(array);
}
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The second parameter called &#39;data&#39; is the data used by the callback function to run comparison.</p>
<p>The last parameter called &#39;compare&#39; is the callback comparison function. This &quot;callback&quot; function of type <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> compares data1 and data2. data1 is the value contained in the inline array and data2 is the data you pass to <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted</span> as second parameter. If data matches function must return 0, if data1 is &#39;less&#39; than data2, -1 must be returned and if it is &#39;greater&#39;, 1 must be returned.</p>
<p>The function returns the member index or -1 if not found.</p>
<p>Be careful the data given to compare function is the pointer to member memory itself, do no change it.</p>
<p>The function <span style="font-family: Courier New,Courier,monospace">eina_inarray_search_sorted</span> does exactly the same as <span style="font-family: Courier New,Courier,monospace">eina_inarray_search</span> but uses binary search instead for given data as compared by the compare function.</p>


<h4>Sorting and Counting the Inline Array Elements</h4>
<p>To sort and inline array you must use <span style="font-family: Courier New,Courier,monospace">eina_inarray_sort(Eina_Inarray *array, Eina_Compare_Cb compare)</span> this function applies a quick sort algorithm to the inline array.</p>
<pre class="prettyprint">static int
short_cmp(const void *pa, const void *pb)
{
&nbsp;&nbsp;&nbsp;const short *a = pa, *b = pb;

&nbsp;&nbsp;&nbsp;return *a - *b;
}

static const short rand_numbers[] = 
{
&nbsp;&nbsp;&nbsp;9, 0, 2, 3, 6, 5, 4, 7, 8, 1, 10
};

int sorting_inline_array()
{
&nbsp;&nbsp;&nbsp;Eina_Inarray *array;
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;array = eina_inarray_new(sizeof(short), 1);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; sizeof(rand_numbers)/sizeof(rand_numbers[0]); i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = rand_numbers[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(array, &amp;val);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;eina_inarray_sort(array, short_cmp);
&nbsp;&nbsp;&nbsp;eina_inarray_free(array);
}
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span>. The last parameter called &#39;compare&#39; is the callback comparison function. This &quot;callback&quot; function of type <span style="font-family: Courier New,Courier,monospace">Eina_Compare_Cb</span> compares data1 and data2. data1 is the value contained in the inline array and data2 is the data you pass to <span style="font-family: Courier New,Courier,monospace">eina_inarray_insert_sorted</span> as second parameter. If the data matches, the function must return 0, if data1 is &#39;less&#39; than data2, -1 must be returned and if it is &#39;greater&#39;, 1 must be returned.</p>
<p>Same as <span style="font-family: Courier New,Courier,monospace">eina_inarray_search</span>, the data given to compare function is the pointer to member memory itself, do no change it.</p>
<p>To get the number of elements in an inline array you must use <span style="font-family: Courier New,Courier,monospace">eina_inarray_count(const Eina_Inarray *arrays)</span></p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);

ch = &#39;a&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;b&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;c&#39;;
eina_inarray_push(iarr, &amp;ch);
ch = &#39;e&#39;;
eina_inarray_push(iarr, &amp;ch);

// Printing the number of array elements using eina_inarray_count
printf(&quot;Inline array of integers with %d elements:\n&quot;, eina_inarray_count(iarr));
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span> The function returns an unsigned int, the number of elements.</p>
<h4>Iterating over an Inline Array</h4>
<p>When we use datatypes in any language we want to iterate through lists and arrays, Eina implements Iterators to give the ability for the programmer to iterate over the datatype.</p>
<p>The inline array have two iterators macros: the <span style="font-family: Courier New,Courier,monospace">FOREACH</span> and the <span style="font-family: Courier New,Courier,monospace">REVERSE_FOREACH</span>.</p>
<p>To run a linear walk over an array of elements, we use the macro <span style="font-family: Courier New,Courier,monospace">EINA_INARRAY_FOREACH(array, itr)</span></p>
<pre class="prettyprint">iarr = eina_inarray_new(sizeof(char), 0);
int a, *b;

a = 97;
eina_inarray_push(iarr, &amp;a);
a = 98;
eina_inarray_push(iarr, &amp;a);
a = 100;
eina_inarray_push(iarr, &amp;a);
a = 99;
EINA_INARRAY_FOREACH(iarr, b)
  printf(&quot;int: %d(pointer: %p)\n&quot;, *b, b);
</pre>

<p>In this example we print each element and its pointer.</p>
<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span>.</p>
<p>The second parameter called &#39;itr&#39; is the variable used to put the current value during the walk.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">EINA_INARRAY_REVERSE_FOREACH</span> macro does the same thing but starts from the last element.</p>
<p>You might need to perform some processing on the array&#39;s data, to do this you can use <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach(const Eina_Inarray *array, Eina_Each_Cb function, const void * user_data)</span>. It will invoke the given function on each element of the array with the given data.</p>
<pre class="prettyprint">
static Eina_Bool
array_foreach(const void *array __UNUSED__, void *p, void *user_data __UNUSED__)
{
&nbsp;&nbsp;&nbsp;short *member = p;
&nbsp;&nbsp;&nbsp;int *i = user_data;
&nbsp;&nbsp;&nbsp;(*p)++;
&nbsp;&nbsp;&nbsp;(*i)++;

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

int inline_array_foreach()
{
&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 1);
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numbers_count; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;val);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;i = 0;
&nbsp;&nbsp;&nbsp;eina_inarray_foreach(iarr, array_foreach, &amp;i);

&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array variable returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The second parameter called &#39;function&#39; is the function to run on each element.</p>
<p>The last parameter called &#39;user_data&#39; is the data passed to the &#39;function&#39; called on each element.</p>
<p>The function returns EINA_TRUE if it successfully iterates through all items of the array.</p>
<p>Call function for every given data in array.</p>
<p>Safe way to iterate over an array.</p>
<p>The &#39;callback&#39; function should return EINA_TRUE as long as you want the function to continue iterating, by returning EINA_FALSE it will stop and return EINA_FALSE as result.</p>
<p>The data given to the function is the pointer to the member itself.</p>
<p>If you want to remove some elements based on your own criteria you can use <span style="font-family: Courier New,Courier,monospace">eina_inarray_foreach_remove(Eina_Inarray *array, Eina_Each_Cb match, const void *user_data)</span> to do that. This function walks through the array and if the value matches in the &#39;callback&#39; function, it removes the element.</p>
<pre class="prettyprint">static Eina_Bool
array_foreach(const void *array __UNUSED__, void *p, void *user_data __UNUSED__)
{
&nbsp;&nbsp;&nbsp;short *member = p;
&nbsp;&nbsp;&nbsp;int *i = user_data;
&nbsp;&nbsp;&nbsp;if (*i == *p) 
&nbsp;&nbsp;&nbsp;{ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_TRUE;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return EINA_FALSE;
}

int inline_array_foreach_remove()
{
&nbsp;&nbsp;&nbsp;Eina_Inarray *iarr;
&nbsp;&nbsp;&nbsp;iarr = eina_inarray_new(sizeof(char), 1);
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numbers_count; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short val = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_inarray_push(iarr, &amp;val);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;i = 6;
&nbsp;&nbsp;&nbsp;eina_inarray_foreach_remove(iarr, array_foreach, &amp;i);

&nbsp;&nbsp;&nbsp;eina_inarray_free(iarr);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p>The first parameter called &#39;array&#39; is a pointer to the array returned by <span style="font-family: Courier New,Courier,monospace">eina_inarray_new</span></p>
<p>The second parameter called &#39;match&#39; is the function to run on each element.</p>
<p>The last parameter called &#39;user_data&#39; is the data passed to the &#39;function&#39; called on each element.</p>
<p>The function returns the number of removed entries or -1 if something goes wrong.</p>
<p>The match function have to return EINA_TRUE if it matches or EINA_FALSE if it doesn&#39;t.</p>
<h3 id="hash" name="hash">Hash Tables</h3>
<p>Eina_Hash has the same goal as every other hash table implementations. It provides a way to store values in association with a key.</p>
<p>For example, if you want to store some tuples into a table, you can do it using <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span>.</p>
<p>The Eina_Hash is implemented using an array of N &quot;buckets&quot;, where each bucket is a pointer to a structure that is the head of a red-black tree. This implementation makes it very robust against week key as at worst case you will still depend on an efficient binary tree implementation.</p>

<p>First, like for the other data types of Eina, you have to create the &quot;hash
table&quot;, you can do it using `eina_hash_new(Eina_Key_Length key_length_cb, Eina_Key_Cmp key_cmp_cb, Eina_Key_Hash key_hash_cb, Eina_Free_Cb data_free_cb, int buckets_power_size)`</p>
<p>To understand Eina_Hash, we are going to detail the parameters you must pass to this function.</p>
<ul>
<li>key_length_cb is the function called when getting the size of the key.</li>
<li>key_cmp_cb is function called when comparing the keys.</li>
<li>key_hash_cb is the function called when getting the values.</li>
<li>data_free_cb is the function called on each value when the hash table is freed, or when an item is deleted from it. NULL can be passed as callback.</li>
<li>buckets_power_size is the size of the buckets.</li>
</ul>
<p>So when you create an <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span>, you will have to create 4 callback functions and this can be very long. That&#39;s why <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> offers you pre-defined functions to create a hash table like</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_djb2_new(Eina_Free_Cb data_free_cb)</span> this function creates a new hash table using the djb2 algorithm for strings.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_superfast_new (Eina_Free_Cb data_free_cb)</span> creates a new hash table for use with strings (better with long strings).</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_string_small_new (Eina_Free_Cb data_free_cb)</span> which creates a new hash table for use with strings with small bucket size.</li>
<li><span style="font-family: Courier New,Courier,monospace">eina_hash_int32_new(Eina_Free_Cb data_free_cb)</span> for use with 32bit integers. and <span style="font-family: Courier New,Courier,monospace">eina_hash_int64_new(Eina_Free_Cb data_free_cb)</span> for 64bit integers.</li>
</ul>
<p>With this predefined functions, you only have to manage the function to free the data you store in you hash. <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> also have pre-defined functions to use white pointers and shared strings, <span style="font-family: Courier New,Courier,monospace">eina_hash_pointer_new(Eina_Free_Cb data_free_cb)</span> and <span style="font-family: Courier New,Courier,monospace">eina_hash_stringshared_new(Eina_Free_Cb data_free_cb)</span>.</p>
<p>In the following example we manage a &quot;small phone book&quot; using <span style="font-family: Courier New,Courier,monospace">eina_hash_string_superfast_new</span></p>
<p>First we create the structure of the &quot;phone book&quot; and some static data.</p>
<pre class="prettyprint">struct _Phone_Entry 
{
&nbsp;&nbsp;&nbsp;const char *name; // Full name
&nbsp;&nbsp;&nbsp;const char *number; // Phone number
};

typedef struct _Phone_Entry Phone_Entry;

static Phone_Entry _start_entries[] = 
{
&nbsp;&nbsp;&nbsp;{ &quot;Wolfgang Amadeus Mozart&quot;, &quot;+01 23 456-78910&quot; },
&nbsp;&nbsp;&nbsp;{ &quot;Ludwig van Beethoven&quot;, &quot;+12 34 567-89101&quot; },
&nbsp;&nbsp;&nbsp;{ &quot;Richard Georg Strauss&quot;, &quot;+23 45 678-91012&quot; },
&nbsp;&nbsp;&nbsp;{ &quot;Heitor Villa-Lobos&quot;, &quot;+34 56 789-10123&quot; },
&nbsp;&nbsp;&nbsp;{ NULL, NULL }
};
</pre>

<p>Now we create the free callback:</p>
<pre class="prettyprint">static void
_phone_entry_free_cb(void *data)
{
&nbsp;&nbsp;&nbsp;free(data);
}
</pre>

<p>And finally we create the Hash and destroy the hash.</p>
<pre class="prettyprint">int free_data()
{
&nbsp;&nbsp;&nbsp;Eina_Hash *phone_book = NULL;
&nbsp;&nbsp;&nbsp;phone_book = eina_hash_string_superfast_new(_phone_entry_free_cb);
&nbsp;&nbsp;&nbsp;// Empty the phone book, but don&#39;t destroy it
&nbsp;&nbsp;&nbsp;eina_hash_free_buckets(phone_book);
&nbsp;&nbsp;&nbsp;eina_hash_free(phone_book);
}
</pre>

<p><span style="font-family: Courier New,Courier,monospace">eina_hash_free_bucket</span> Free all &#39;buckets&#39; of the hash table, that empties the hash but don&#39;t destroy it so you can still use it for another purpose. When <span style="font-family: Courier New,Courier,monospace">eina_hash_free</span> is called the space allocated for the hash is freed.</p>
<p>The free callback can be changed using <span style="font-family: Courier New,Courier,monospace">eina_hash_free_cb_set(Eina_Hash *hash, Eina_Free_Cb data_free_cb)</span>, you need to pass the hash and the new callback function.</p>
<h4>Working with Eina_Hash</h4>
<p>In the example we create a hash but we do nothing with it. We may want to add some data to this hash, to do that we can use the function <span style="font-family: Courier New,Courier,monospace">eina_hash_add(Eina_Hash *hash, const void *key, const void *data)</span>. This function takes the hash as first parameter and the key to access to the data as second parameter and finally the data.</p>
<pre class="prettyprint">// Add initial entries to our hash
for (i = 0; _start_entries[i].name != NULL; i++)
{
&nbsp;&nbsp;&nbsp;eina_hash_add(phone_book, _start_entries[i].name, strdup(_start_entries[i].number));
}
</pre>
<p>Here we add the &quot;initial&quot; data we declared before to the hash.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> offers lots of methods to add elements to an hash like <span style="font-family: Courier New,Courier,monospace">eina_hash_direct_add(Eina_Hash *hash, const void *key, const void *data)</span> which adds the entry without duplicating the string key. We are storing the key in our struct so we can use this function with eina_stringshare to avoid key data duplication. We develop the usage of Eina_Stringshare in a following chapter. So we could initialize our hash like in this example:</p>
<pre class="prettyprint">// Add initial entries to our hash, using direct_add
for (i = 0; _start_entries[i].name != NULL; i++)
{
&nbsp;&nbsp;&nbsp;// Allocating memory for the &quot;phone entry&quot;
&nbsp;&nbsp;&nbsp;Phone_Entry *e = malloc(sizeof(Phone_Entry));

&nbsp;&nbsp;&nbsp;// Creating an eina_stringshare for the Name and the phone number
&nbsp;&nbsp;&nbsp;e-&gt;name = eina_stringshare_add(_start_entries[i].name);
&nbsp;&nbsp;&nbsp;e-&gt;number = eina_stringshare_add(_start_entries[i].number);

&nbsp;&nbsp;&nbsp;// Adding entry to the hash 
&nbsp;&nbsp;&nbsp;eina_hash_direct_add(phone_book, e-&gt;name, e);
}
</pre>

<p>To delete entries of a table we can use <span style="font-family: Courier New,Courier,monospace">eina_hash_del(Eina_Hash *hash, const void *key, const void *data)</span> this function removes the entry identified by a key or a data from the given hash table</p>
<pre class="prettyprint">
Eina_Bool r;
const char *entry_name = &quot;Heitor Villa-Lobos&quot;;
r = eina_hash_del(phone_book, entry_name, NULL);
</pre>
<p>You can also use <span style="font-family: Courier New,Courier,monospace">eina_hash_del_by_key(Eina_Hash *hash, const void *key)</span> to remove an entry by key.</p>
<pre class="prettyprint">r = eina_hash_del_by_key(phone_book, &quot;Richard Georg Strauss&quot;);
</pre>
<p>To remove en entry by data you can use <span style="font-family: Courier New,Courier,monospace">eina_hash_del_by_data(Eina_Hash *hash, const void *data)</span> by passing hash and the data of entry to be removed.</p>
<pre class="prettyprint">r = eina_hash_del_by_data(phone_book, &quot;+12 34 567-89101&quot;);
</pre>

<h4>Finding, Modifying, Counting Eina Hash</h4>
<p>The other interesting thing with Hash is the ability to find elements and get data by key name.</p>
<p>To retrieve an entry by its key you can use <span style="font-family: Courier New,Courier,monospace">eina_hash_find(const Eina_Hash *hash, const void *key)</span> by passing the hash and the key you are looking for.</p>
<pre class="prettyprint">
char *phone = NULL;
const char *entry_name = &quot;Heitor Villa-Lobos&quot;;

// Look for a specific entry and get its phone number
phone = eina_hash_find(phone_book, entry_name);
</pre>

<p>You can also modify some entry using <span style="font-family: Courier New,Courier,monospace">eina_hash_modify(Eina_Hash *hash, const void *key, const void *data)</span> passing the hash, the key of data to change and the new data, the function will return the old data on success. <span style="font-family: Courier New,Courier,monospace">eina_hash_set(Eina_Hash *hash, const void *key, const void *data)</span> does the same work as <span style="font-family: Courier New,Courier,monospace">eina_hash_modify</span> but if the entry doesn&#39;t exist the function will create a new one.</p>
<pre class="prettyprint">
char *old_phone = NULL;
char *phone = NULL;
// Replacing the phone number of Richard Strauss
old_phone = eina_hash_modify(phone_book, &quot;Richard Georg Strauss&quot;, strdup(&quot;+23 45 111-11111&quot;));
phone = eina_hash_set(phone_book, &quot;Philippe de MagalhÃ£es&quot;, strdup(&quot;+33 6 111-11111&quot;));
eina_hash_set(phone_book, &quot;Richard Georg Strauss&quot;, strdup(&quot;+23 45 111-117711&quot;));
</pre>

<p>The function <span style="font-family: Courier New,Courier,monospace">eina_hash_move(Eina_Hash *hash, const void *old_key, const void *new_key)</span> changes the key associated with a data without freeing and creating a new entry. You just have to pass the hash, the old key and the new one. If the operation succeeds the function will return EINA_TRUE, if it&#39;s not it returns EINA_TRUE.</p>
<pre class="prettyprint">
Eina_Bool res;
res = eina_hash_move(phone_book, &quot;Philippe de MagalhÃ£es&quot;, &quot;Filipe de MagalhÃ£es&quot;);
</pre>

<p>If you need to know the number of entries in a hash you can use <span style="font-family: Courier New,Courier,monospace">eina_hash_population(const Eina_Hash *hash)</span> simply passing the Hash as only argument.</p>
<pre class="prettyprint">
unsigned int nb_elm;
nb_elm = eina_hash_population(phone_book);
</pre>

<h4>Iterating over Eina Hash Tables</h4>
<p>Like the other &quot;container&quot; data type of Eina library, <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> provides Iterators. These iterators can be used for calling functions like <span style="font-family: Courier New,Courier,monospace">eina_hash_foreach(const Eina_Hash *hash, Eina_Hash_Foreach func, const void *fdata)</span>.</p>
<p>The first parameter is the hash, the second is the function called on each iteration and the last one is the data passed to the &#39;callback&#39; function passed as second argument.</p>
<p>The callback function has to return an <span style="font-family: Courier New,Courier,monospace">Eina_Bool</span>, EINA_TRUE if the iteration has to continue and EINA_FALSE if the iteration has to stop.</p>
<pre class="prettyprint">// This callback function prints the key and the data of an hash entry 
// here the name and the phone number.
static Eina_Bool
pb_foreach_cb(const Eina_Hash *phone_book, const void *key, void *data, void *fdata)
{
&nbsp;&nbsp;&nbsp;const char *name = key;
&nbsp;&nbsp;&nbsp;const char *number = data;
&nbsp;&nbsp;&nbsp;printf(&quot;%s: %s\n&quot;, name, number);

&nbsp;&nbsp;&nbsp;// Return EINA_FALSE to stop this callback from being called
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

printf(&quot;List of phones:\n&quot;);

// Running the callback on the hash called phone_book 
eina_hash_foreach(phone_book, pb_foreach_cb, NULL);
printf(&quot;\n&quot;);
</pre>

<p>You can also use <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_key_new(const Eina_Hash *hash)</span> just to iterate over the keys. To iterate over the hash data, we can use <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_data_new (const Eina_Hash *hash)</span> the same way as <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_key_new</span>.</p>
<pre class="prettyprint">// Declaration of the Eina_Iterator
Eina_Iterator *it;

// Variable to handle current iteration &quot;data&quot;
void *data;

// Iterate over the keys (names)
printf(&quot;List of names in the phone book:\n&quot;);

it = eina_hash_iterator_key_new(phone_book);

// Using the generic eina_iterator_next()
while (eina_iterator_next(it, &amp;data))
{
&nbsp;&nbsp;&nbsp;const char *name = data;
&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, name);
}

// You need to free the Iterator
eina_iterator_free(it);

// Iterating over hash data 
printf(&quot;List of numbers in the phone book:\n&quot;);

it = eina_hash_iterator_data_new(phone_book);
while (eina_iterator_next(it, &amp;data))
{
&nbsp;&nbsp;&nbsp;const char *number = data;
&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, number);
}

// You need to free the Iterator
eina_iterator_free(it);
</pre>
<p>Using this method you can also iterate over a tuple composed of keys and data like <span style="font-family: Courier New,Courier,monospace">eina_hash_foreach</span> using <span style="font-family: Courier New,Courier,monospace">eina_hash_iterator_tuple_new(const Eina_Hash *hash)</span></p>
<pre class="prettyprint">// Declaration of the Eina_Iterator
Eina_Iterator *tit;

// Variable to handle current iteration &quot;data&quot;
void *tuple;

printf(&quot;List of phones:\n&quot;);
tit = eina_hash_iterator_tuple_new(phone_book);
while (eina_iterator_next(tit, &amp;tuple))
{
&nbsp;&nbsp;&nbsp;Eina_Hash_Tuple *t = tuple;
&nbsp;&nbsp;&nbsp;const char *name = t-&gt;key;
&nbsp;&nbsp;&nbsp;const char *number = t-&gt;data;
&nbsp;&nbsp;&nbsp;printf(&quot;%s: %s\n&quot;, name, number);
}

eina_iterator_free(tit); // Always free the iterator after its use
</pre>

<h3 id="list" name="list">Lists</h3>

<p>The Eina list (<span style="font-family: Courier New,Courier,monospace">Eina_List</span>) is a double linked list. It can store data of any type as void pointers.</p>
<p>It provides a set of functions to create and manipulate a list to avoid the access to the struct&#39;s fields like in self made double link list.</p>
<p>In addition of keeping references to the references to the previous and the next node and it&#39;s data, the Eina_List nodes keeps a reference to an accounting structure.</p>
<p>This accounting structure is used to improve the performance of some functions. This structure is private and should not be modified.</p>
<p>In Eina_List everything is a &quot;list&quot;, the list itself is a list where each &quot;node&quot; is a list as well.</p>
<h4>Creating and Destroying an Eina_List</h4>
<p>To use an Eina_List you just have to declare it with <span style="font-family: Courier New,Courier,monospace">NULL</span> as default value and * call <span style="font-family: Courier New,Courier,monospace">eina_list_append(Eina_List * list, const void * data)</span>. Pass the list and the data you want to append. This list must be a pointer to the first element of the list (or NULL). It returns a pointer to the list.</p>
<pre class="prettyprint">int list()
{
&nbsp;&nbsp;&nbsp;// Declaration of the Eina_List with NULL as default value;
&nbsp;&nbsp;&nbsp;Eina_List *list = NULL;

&nbsp;&nbsp;&nbsp;// Creating the first element of the list 
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;watch&quot;);

&nbsp;&nbsp;&nbsp;// Adding more elements
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;phone&quot;);
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;ivi&quot;);
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;notebook&quot;);

&nbsp;&nbsp;&nbsp;// Free the Eina_List
&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<h4>Adding Elements to a List</h4>
<p><span style="font-family: Courier New,Courier,monospace">eina_list_append</span> as the name says, appends data to the list. You may want to put some data at the top of the list. To do this, you can use <span style="font-family: Courier New,Courier,monospace">eina_list_prepend(Eina_List *list, const void *data)</span> it works in the same way as <span style="font-family: Courier New,Courier,monospace">eina_list_append</span> but puts the new element on top of the list</p>
<pre class="prettyprint">list = eina_list_prepend(list, &quot;set-top box&quot;);</pre>

<p><span style="font-family: Courier New,Courier,monospace">eina_list_append_relative(Eina_List *list, const void *data, const void *relative)</span> inserts the given data into the given linked list after the specified data. In order to append data after the &quot;phone&quot; element of the example, we pass this data as the last parameter of <span style="font-family: Courier New,Courier,monospace">eina_list_append_relative</span> like this:</p>
<pre class="prettyprint">list = eina_list_append_relative(list, &quot;single-board computer&quot;, &quot;phone&quot;);</pre>

<p>In order to put a new entry after the &quot;ivi&quot; entry, use <span style="font-family: Courier New,Courier,monospace">eina_list_prepend_relative(Eina_List *list, const void *data, const void *relative)</span> like you used <span style="font-family: Courier New,Courier,monospace">eina_list_append_relative</span></p>
<pre class="prettyprint">list = eina_list_append_relative(list, &quot;ultrabook&quot;, &quot;ivi&quot;);</pre>

<p>Eina_List * eina_list_append_relative_list (Eina_List *list, const void *data, Eina_List *relative) Appends a list node to a linked list after the specified member. More...</p>
<p>Eina_List * eina_list_prepend_relative_list (Eina_List *list, const void *data, Eina_List *relative) Prepends a list node to a linked list before the specified member. More...</p>

<h4>Removing Elements from a List</h4>
<p>To remove a node of the list you can use <span style="font-family: Courier New,Courier,monospace">eina_list_remove(Eina_List *list, const void *data)</span>, this function removes the first instance of the specified data from the given list.</p>
<pre class="prettyprint">list = eina_list_remove(list, &quot;ultrabook&quot;);</pre>

<p>You can also remove a &quot;list&quot; (understand a node) from a list using <span style="font-family: Courier New,Courier,monospace">eina_list_remove_list (Eina_List *list, Eina_List *remove_list)</span>. Pass the list you want to delete an element from and a &#39;list&#39; (understand a node) you want to delete.</p>
<pre class="prettyprint">Eina_List *app_list = NULL;
Eina_List *to_remove = NULL;

// Adding some elements to the list (using stringshares)
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enna&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ebird&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;calaos&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;rage&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;terminology&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enlightenment&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;eyelight&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ephoto&quot;));

// Finding the &quot;list&quot; we want to remove 
to_remove = eina_list_data_find_list(list, eina_string_share_add(&quot;enlightenment&quot;));

list = eina_list_remove_list(list, to_remove);
</pre>

<h4>Moving Elements in a List</h4>
<p>Eina_List implements some functions to move elements in a list. For example you can promote an element to the top of the list with <span style="font-family: Courier New,Courier,monospace">eina_list_promote_list (Eina_List *list, Eina_List *move_list)</span>. Remember that everything is a list so the &#39;move_list&#39; parameter represents the &quot;list&quot; (understand node) you want to move, use it just like <span style="font-family: Courier New,Courier,monospace">eina_list_remove_list</span>.</p>
<pre class="prettyprint">list = eina_list_promote_list(list, eina_list_data_find_list(list, &quot;ivi&quot;));
</pre><p><span style="font-family: Courier New,Courier,monospace">eina_list_demote_list(Eina_List *list, Eina_List *move_list)</span> puts the &quot;element&quot; at the end of the list, use it like <span style="font-family: Courier New,Courier,monospace">eina_list_promote_list</span>.</p>

<h4>Finding Elements in a List</h4>
<p>You will probably need to find some data on your list, <span style="font-family: Courier New,Courier,monospace">eina_list_data_find(const Eina_List *list, const void *data)</span> can help you. Pass the list containing your data as first argument and the data you are looking for as last one. It returns the found member data pointer if found, NULL otherwise.</p>
<p><span style="font-family: Courier New,Courier,monospace">eina_list_data_find</span> searches in list from beginning to end for the first member for which data pointer is data. If it is found, data will be returned, otherwise NULL will be returned. The function just compares pointers, that&#39;s why using Eina_Stringshare is very useful with lists, because it always returns the same pointer for the same string.</p>
<pre class="prettyprint">Eina_List *app_list = NULL;
const char *res_str;

// Adding some elements to the list (using stringshares)
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enna&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ebird&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;calaos&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;rage&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;terminology&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;enlightenment&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;eyelight&quot;));
app_list = eina_list_append(app_list, eina_stringshare_add(&quot;ephoto&quot;));

// Finding the data we need
res_str = eina_list_data_find(list, eina_string_share_add(&quot;enlightenment&quot;));
if (res_str == eina_stringshare_add(&quot;enlightenment&quot;))
&nbsp;&nbsp;&nbsp;printf(&quot;Data is present&quot;);
else
  printf(&quot;Data not present&quot;);
</pre>

<p>This example will return &quot;Data is present&quot;.</p>
<p><span style="font-family: Courier New,Courier,monospace">eina_list_data_find_list(const Eina_List *list, const void *data)</span> does the same thing as <span style="font-family: Courier New,Courier,monospace">eina_list_data_find</span> but returns a &quot;Eina_List&quot;. You can see an example of this in the <span style="font-family: Courier New,Courier,monospace">eina_list_remove_list</span> paragraph.</p>
<p>You can access the data or a &quot;list&quot; (understand a node) of a Eina_List, using the <span style="font-family: Courier New,Courier,monospace">eina_list_nth(const Eina_List *list, unsigned int n)</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_nth_list (const Eina_List *list, unsigned int n)</span>. The first one will return a pointer to the data of the &quot;n&quot; element and the second a pointer to the &quot;list&quot;. So if you want to access to the data of the 3rd element of a Eina_List proceed like this:</p>
<pre class="prettyprint">const char *res;
Eina_List *res_lst;

res = eina_list_nth(app_list, 2);
res_lst = eina_list_nth_list(app_list, 2);
</pre>

<p>The variable <span style="font-family: Courier New,Courier,monospace">res</span> will contain the pointer to the string &quot;calaos&quot;. <span style="font-family: Courier New,Courier,monospace">res_lst</span> the list containing &quot;calaos&quot;</p>
<h4>Copying a List</h4>
<p>You can clone a list with <span style="font-family: Courier New,Courier,monospace">eina_list_clone (const Eina_List *list)</span>, this function copies all the elements in the list in the exact same order.</p>
<pre class="prettyprint">Eina_List *app_list_copy;

app_list_copy = eina_list_clone(app_list);
</pre>

<h4>Reversing a List</h4>
<p>To reverse all the elements of a <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, use <span style="font-family: Courier New,Courier,monospace">eina_list_reverse(Eina_List *list)</span>. To obtain a reversed copy of the list keeping the initial list unchanged use <span style="font-family: Courier New,Courier,monospace">eina_list_reverse_clone(const Eina_List *list)</span></p>
<pre class="prettyprint">Eina_List *rev_copy;

app_list = eina_list_reverse(app_list);
rev_copy = eina_list_reverse_clone(app_list);
</pre>

<h4>Searching and Sorting Lists</h4>
<p>You will probably need to search for data in a list, especially in large lists. <span style="font-family: Courier New,Courier,monospace">Eina_List</span> API provides functions to run powerful searches.</p>
<p>If your list is unsorted and you need to get the data you can use <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted(const Eina_List *list, Eina_Compare_Cb func, const void *data)</span>. This function performs a lookup in unsorted lists, it takes the list as first parameter, a callback function for comparison as second parameter and the data you are looking for. <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted_list(const Eina_List *list, Eina_Compare_Cb func, const void *data)</span> does the same but returns a &quot;Eina_List&quot;.</p>
<pre class="prettyprint">int search_list()
{
&nbsp;&nbsp;&nbsp;// Declaring the List
&nbsp;&nbsp;&nbsp;Eina_List *list = NULL; 
&nbsp;&nbsp;&nbsp;Eina_List *l;
&nbsp;&nbsp;&nbsp;// Little trick to use strcmp as Eina_Compare_Cb 
&nbsp;&nbsp;&nbsp;Eina_Compare_Cb cmp_func = (Eina_Compare_Cb)strcmp;

&nbsp;&nbsp;&nbsp;void *data;
&nbsp;&nbsp;&nbsp;int cmp_result;

&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;debian&quot;);
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, &quot;centos&quot;);

&nbsp;&nbsp;&nbsp;data = eina_list_search_unsorted(list, cmp_func, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;l = eina_list_search_unsorted_list(list, cmp_func, &quot;archlinux&quot;);
&nbsp;&nbsp;&nbsp;if (l-&gt;data != data)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;eina_list_free(list);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p>Here we perform two searches: one with <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted</span> and another with <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted_list</span> and we compare the result of the two searches.</p>
<p>You can search in sorted lists with <span style="font-family: Courier New,Courier,monospace">eina_list_search_sorted_list (const Eina_List *list, Eina_Compare_Cb func, const void *data)</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_search_sorted (const Eina_List *list, Eina_Compare_Cb func, const void *data)</span>, these functions work just like <span style="font-family: Courier New,Courier,monospace">eina_list_search_unsorted</span> but sorted list.</p>
<p>You can sort a list using <span style="font-family: Courier New,Courier,monospace">eina_list_sort(Eina_List * list, unsigned int limit, Eina_Compare_Cb func)</span>. This function takes a list which needs to be sorted, &quot;limit&quot; is the maximum number of elements to be sorted, you can set this limit to 0 to sort all the list elements. The last parameter is the callback function that compares data.</p>
<pre class="prettyprint">int sort_cb(const void *d1, const void *d2)
{
&nbsp;&nbsp;&nbsp;const char *txt = d1;
&nbsp;&nbsp;&nbsp;const char *txt2 = d2;
&nbsp;&nbsp;&nbsp;if(!txt) return(1);
&nbsp;&nbsp;&nbsp;if(!txt2) return(-1);

&nbsp;&nbsp;&nbsp;return(strcmp(txt, txt2));
}

extern Eina_List *list;
list = eina_list_sort(list, 0, sort_cb);
</pre>

<h4>Merging and Splitting Lists</h4>
<p>Another interesting thing to do with lists is merging, <span style="font-family: Courier New,Courier,monospace">eina_list_merge(Eina_List *left, Eina_List *right)</span> simply merges two lists into a new one. <span style="font-family: Courier New,Courier,monospace">eina_list_sorted_merge(Eina_List *left, Eina_List *right, Eina_Compare_Cb func)</span> merges two sorted lists according to the ordering func that you pass as last argument, will return.</p>
<pre class="prettyprint">int sort_cb(void *d1, void *d2)
{
&nbsp;&nbsp;&nbsp;const char *txt = NULL;
&nbsp;&nbsp;&nbsp;const char *txt2 = NULL;
&nbsp;&nbsp;&nbsp;if(!d1) return(1);
&nbsp;&nbsp;&nbsp;if(!d2) return(-1);

&nbsp;&nbsp;&nbsp;return(strcmp((const char*)d1, (const char*)d2));
}

Eina_List *sorted1;
Eina_List *sorted2;
Eina_List *newlist;

/* 
 * put some values and sort your lists
 */

// Simply merge two lists without any process
newlist = eina_list_merge(sorted1, sorted2);

newlist = eina_list_sorted_merge(sorted1, sorted2, sort_cb);
</pre>

<p>As you can merge, you can also split lists. <span style="font-family: Courier New,Courier,monospace">eina_list_split_list(Eina_List *list, Eina_List *relative, Eina_List **right)</span> will split a list into two lists.</p>
<p>The first argument is the list to split, the second is the &quot;list&quot; (element) that will be split after and the last is the head of the second list.</p>
<pre class="prettyprint">// The origin list (left list)
Eina_List *list = NULL;

// The new list (right list)
Eina_List *other_list = NULL;

// An Eina_List (element)
Eina_List *l;

list = eina_list_append(list, &quot;super tux&quot;);
list = eina_list_append(list, &quot;frozen bubble&quot;);
list = eina_list_append(list, &quot;lincity-ng&quot;);

// Sorting the list (just for fun)
list = eina_list_sort(list, 0, cmp_func);

// Looking for the &#39;split&#39; element
l = eina_list_search_sorted_list(list, cmp_func, &quot;frozen bubble&quot;);

// Splitting the list
list = eina_list_split_list(list, l, &amp;other_list);
</pre>

<h4>Getting and Setting Data from a List Element</h4>
<p><span style="font-family: Courier New,Courier,monospace">eina_list_data_get(const Eina_List *list)</span> will return the data contained in the given list.</p>
<pre class="prettyprint">int list_data_set()
{
&nbsp;&nbsp;&nbsp;// Declaring the list
&nbsp;&nbsp;&nbsp;Eina_List *list = NULL;
&nbsp;&nbsp;&nbsp;// An Eina_List to place the Elements or lists
&nbsp;&nbsp;&nbsp;Eina_List *l;

&nbsp;&nbsp;&nbsp;void *list_data;

&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Bertrand&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Cedric&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Nicolas&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Vincent&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Raoul&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Fabien&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;Philippe&quot;));
&nbsp;&nbsp;&nbsp;list = eina_list_append(list, eina_stringshare_add(&quot;billiob&quot;));

&nbsp;&nbsp;&nbsp;for(l = list; l; l = eina_list_next(l))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Printing the data returned by eina_list_data_get
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)eina_list_data_get(l));

&nbsp;&nbsp;&nbsp;EINA_LIST_FREE(list, list_data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_stringshare_del(list_data);

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

<p>In this example we also use <span style="font-family: Courier New,Courier,monospace">eina_list_next (const Eina_List *list)</span> to move through the list in a for statement. This function moves to the next element of the linked list.</p>
<p>To set data in a list member you can use <span style="font-family: Courier New,Courier,monospace">eina_list_data_set(Eina_List *list, const void *data)</span> Pass the &quot;list&quot; (understand node) as first argument and the data to set as second.</p>
<pre class="prettyprint">// Setting a new data for the last element.
eina_list_data_set(eina_list_last(list), eina_stringshare_add(&quot;Boris&quot;));
</pre><p>In this example you can also see the usage of <span style="font-family: Courier New,Courier,monospace">eina_list_last(const Eina_List *list)</span> which returns the last element of a <span style="font-family: Courier New,Courier,monospace">Eina_List</span>.</p>

<h4>Moving in a List</h4>
<p>The usage of <span style="font-family: Courier New,Courier,monospace">eina_list_last (const Eina_List *list)</span> and <span style="font-family: Courier New,Courier,monospace">eina_list_next (const Eina_List *list)</span> are explained before. The other interesting function that allows movement in the list is <span style="font-family: Courier New,Courier,monospace">eina_list_prev(const Eina_List *list)</span>: it gets the previous list node before the specified list node.</p>
<pre class="prettyprint">for(l = eina_list_last(list); l; l = eina_list_prev(l))
   printf(&quot;%s\n&quot;, (char*)eina_list_data_get(l));
</pre>
<p>In this example, we scroll backwards starting from the end of the list.</p>

<h4>Counting List Elements</h4>
<p><span style="font-family: Courier New,Courier,monospace">eina_list_count(const Eina_List *list)</span> returns the number of items in a list.</p>
<pre class="prettyprint">printf(&quot;List size: %d\n&quot;, eina_list_count(list));
</pre>

<h4>Iterators</h4>
<p>Like the others Eina data types, <span style="font-family: Courier New,Courier,monospace">Eina_List</span> has iterators:</p>
<ul>
<li>EINA_LIST_FOREACH(list, l, data)</li>
<li>EINA_LIST_REVERSE_FOREACH(list, l, data)</li>
<li>EINA_LIST_FOREACH_SAFE(list, l, l_next, data)</li>
<li>EINA_LIST_FREEE(list, data)</li>
</ul>
<p>This iterators gives you the possibility of walking through the list from the begin or from the end.</p>
<p>For example, in order to print the data of each &quot;List&quot; (understand node) of the list you can use <span style="font-family: Courier New,Courier,monospace">EINA_LIST_FOREACH</span>. It takes the list to iterate, a <span style="font-family: Courier New,Courier,monospace">Eina_List *</span> to hold the current &quot;List&quot; (understand node) and a data parameter to receive the current data during the run.</p>
<pre class="prettyprint">Eina_List *list = NULL;
Eina_List *l;
void *list_data;

list = eina_list_append(list, &quot;ls&quot;);
list = eina_list_append(list, &quot;top&quot;);
list = eina_list_append(list, &quot;rmdir&quot;);
list = eina_list_append(list, &quot;uname&quot;);

EINA_LIST_FOREACH(list, l, list_data)
&nbsp;&nbsp;&nbsp;printf(&quot;%s\n&quot;, (char*)list_data);

eina_list_free(list);
</pre>

<p><span style="font-family: Courier New,Courier,monospace">EINA_LIST_REVERSE_FOREACH</span> macro works like EINA_LIST_FOREACH, but iterates from the last element of a list to the first. The parameters are also the same.</p>
<p><span style="font-family: Courier New,Courier,monospace">EINA_LIST_FOREACH_SAFE</span> macro iterates over list from the first element to the last. It is called safe because it stores the next &quot;List&quot; (understand node) so you can safely remove the current &quot;List&quot; (node) and continue the iteration.</p>
<pre class="prettyprint">Eina_List *list;
Eina_List *l;
Eina_List *l_next;
char *data;

list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);
list = eina_list_append(list, &quot;tizen&quot;);

// Using EINA_LIST_FOREACH_SAFE to free elements that match &quot;tizen&quot;.

EINA_LIST_FOREACH_SAFE(list, l, l_next, data)
&nbsp;&nbsp;&nbsp;if (strcmp(data, &quot;tizen&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list = eina_list_remove_list(list, l);
&nbsp;&nbsp;&nbsp;}
</pre>

<p><span style="font-family: Courier New,Courier,monospace">EINA_LIST_FREE</span> macro removes each list element while having access to node&#39;s data. Just pass the list and a pointer to hold the current data.</p>
<pre class="prettyprint">Eina_List *list;
char *data;

// The list is filled

EINA_LIST_FOREE(list, data)
&nbsp;&nbsp;&nbsp;free(data);
</pre>

<h3 id="inlist" name="inlist">Inline Lists</h3>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> are a special datatype drawn to store nodes pointers in the same memory as data.</p>
<p>This way the memory is less fragmented but operations like &#39;sort&#39; or &#39;count&#39; are slower.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> nodes can be part of a regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, simply added with <span style="font-family: Courier New,Courier,monospace">eina_list_append</span> or <span style="font-family: Courier New,Courier,monospace">eina_list_prepend</span>.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> have their own purposes, but if you don&#39;t understand what those purposes are, just use the regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span> instead.</p>
<h4>Creating and Adding Items to an Inline List</h4>
<p>Like we said before <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> nodes pointers are part of the node&#39;s &quot;data&quot;. So before creating a list, we need to define the structure of our data.</p>
<pre class="prettyprint">struct my_struct 
{
&nbsp;&nbsp;&nbsp;EINA_INLIST;
&nbsp;&nbsp;&nbsp;int a, b;
};
</pre>

<p>Our structure is composed by the EINA_INLIST &quot;type&quot; which is composed by 3 pointers defining the Inline list structure:</p>
<ul>
<li>Eina_Inlist * next // The next node</li>
<li>Eina_Inlist * prev // The previous node</li>
<li>Eina_Inlist * last // The last node</li>
</ul>
<p>and two integers, the real &quot;data&quot;.</p>
<p>To create the Inlist nodes, you need to allocate the memory and use <span style="font-family: Courier New,Courier,monospace">eina_inlist_append</span>.</p>
<pre class="prettyprint">struct my_struct *d, *cur;
Eina_Inlist *list, *itr, *tmp;

d = malloc(sizeof(*d));
d-&gt;a = 1;
d-&gt;b = 10;

list = eina_inlist_append(NULL, EINA_INLIST_GET(d));
</pre>

<p>The first parameter is the existing list head or NULL to create a new list. in the example we pass <span style="font-family: Courier New,Courier,monospace">NULL</span> to create a new list. The second parameter is the new list node, must not be NULL. You have to use <span style="font-family: Courier New,Courier,monospace">EINA_INLIST_GET</span> macro to get the inlist object of the &quot;data&quot; struct.</p>
<p>You have to repeat this operation for every single new node.</p>
<pre class="prettyprint">d = malloc(sizeof(*d));
d-&gt;a = 2;
d-&gt;b = 20;
list = eina_inlist_append(list, EINA_INLIST_GET(d));
</pre>

<p>You also can put data at the end of the inline list using <span style="font-family: Courier New,Courier,monospace">eina_inlist_prepend</span>.</p>
<pre class="prettyprint">d = malloc(sizeof(*d));
d-&gt;a = 3;
d-&gt;b = 30;
list = eina_inlist_prepend(list, EINA_INLIST_GET(d));
</pre>

<p>You also can add a node before or after a given node using <span style="font-family: Courier New,Courier,monospace">eina_inlist_prepend_relative</span> and <span style="font-family: Courier New,Courier,monospace">eina_inlist_append_relative</span>.</p>
<pre class="prettyprint">d = malloc(sizeof(*d));
d-&gt;a = 4;
d-&gt;b = 40;
list = eina_inlist_append_relative(list, EINA_INLIST_GET(d), list);
</pre>

<p>The first parameter is the target list, the second is the element you want to add, and the last is the &quot;reference&quot; element to place data after (in this case). Such as in regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, everything is a List, so this last parameter is a <span style="font-family: Courier New,Courier,monospace">Eina_Inlist</span> typed variable.</p>

<h4>Destroying an Inline List</h4>
<p>To destroy a list you need to loop over the list, to free each <span style="font-family: Courier New,Courier,monospace">EINA_INLIST</span> structure and the data if your data use allocated memory and use <span style="font-family: Courier New,Courier,monospace">eina_inlist_remove</span> on each node.</p>
<pre class="prettyprint">while (list)
{
&nbsp;&nbsp;&nbsp;struct my_struct *aux = EINA_INLIST_CONTAINER_GET(list, struct my_struct);

&nbsp;&nbsp;&nbsp;// Remove the current list element 
&nbsp;&nbsp;&nbsp;list = eina_inlist_remove(list, list);
&nbsp;&nbsp;&nbsp;free(aux);
}
</pre>
<p>The EINA_INLIST_CONTAINER_GET macro returns the container object of an inlist. In our case it returns the <span style="font-family: Courier New,Courier,monospace">EINA_INLIST</span> of <span style="font-family: Courier New,Courier,monospace">my_struc</span>. Then we will remove the list element and free the allocated memory of our container &quot;object&quot;.</p>
<p>You&#39;ve probably realized that this is not really easy to use so if you don&#39;t really need this, just use regular <span style="font-family: Courier New,Courier,monospace">Eina_List</span>.</p>
<p>For sorting, iterating, finding, moving and other operations you can refer to the EFL technical documentation.</p>

<h3 id="generic" name="generic">Generic Value</h3>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Value</span> provides is a generic data storage and access. It comes with pre-defined types for numbers, array, list, hash, blob and structs.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Value</span> is able to convert between data types, including string. It is meant for simple data types, providing uniform access and release functions, useful to exchange data preserving their types.</p>
<p>In brief you can store what you want in one single type <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>.</p>
<p><span style="font-family: Courier New,Courier,monospace">Eina_Value</span> can handle the following types:</p>
<ul>
<li>EINA_VALUE_TYPE_UCHAR manages unsigned char type,</li>
<li>EINA_VALUE_TYPE_USHORT manages unsigned short type,</li>
<li>EINA_VALUE_TYPE_UINT manages unsigned int type,</li>
<li>EINA_VALUE_TYPE_ULONG manages unsigned long type,</li>
<li>EINA_VALUE_TYPE_TIMESTAMP manages unsigned long type used for timestamps,</li>
<li>EINA_VALUE_TYPE_UINT64 manages unsigned integer of 64 bits type,</li>
<li>EINA_VALUE_TYPE_CHAR manages char type,</li>
<li>EINA_VALUE_TYPE_SHORT manages short type,</li>
<li>EINA_VALUE_TYPE_INT manages int type,</li>
<li>EINA_VALUE_TYPE_LONG manages long type,</li>
<li>EINA_VALUE_TYPE_INT64 manages integer of 64 bits type,</li>
<li>EINA_VALUE_TYPE_FLOAT manages float type,</li>
<li>EINA_VALUE_TYPE_DOUBLE manages double type,</li>
<li>EINA_VALUE_TYPE_STRINGSHARE manages stringshared string type,</li>
<li>EINA_VALUE_TYPE_STRING manages string type,</li>
<li>EINA_VALUE_TYPE_ARRAY manages array type,</li>
<li>EINA_VALUE_TYPE_LIST manages list type,</li>
<li>EINA_VALUE_TYPE_HASH manages hash type,</li>
<li>EINA_VALUE_TYPE_TIMEVAL manages &#39;struct timeval&#39; type,</li>
<li>EINA_VALUE_TYPE_BLOB manages blob of bytes type,</li>
<li>EINA_VALUE_TYPE_STRUCT manages struct type.</li>
</ul>

<p>To use <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> you need to do some variable declarations.</p>
<pre class="prettyprint">// The Eina_Value itself
Eina_Value v;
// An integer 
int i;
// And a char *
char *newstr;
</pre>

<p>Now we can start using <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> and setup a <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> for an integer (if you prefer &quot;create&quot; the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>). Use <span style="font-family: Courier New,Courier,monospace">eina_value_setup(Eina_Value * value, const Eina_Value_Type *value type)</span>. First argument is the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> and second is the type.</p>
<pre class="prettyprint">eina_value_setup(&amp;v, EINA_VALUE_TYPE_INT);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> is created and can receive a &quot;value&quot;, here we set it up for an Integer, so we set an integer using <span style="font-family: Courier New,Courier,monospace">eina_value_set(eina_value_set(Eina_Value *value, ...)</span></p>
<pre class="prettyprint">eina_value_set(&amp;v, 123);
</pre>

<p>We can get the value using <span style="font-family: Courier New,Courier,monospace">eina_value_get(const Eina_Value *v, ...)</span>: we pass the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> as first argument, and a pointer to a variable to &quot;store&quot; the value (the target variable must have the same type as the <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>).</p>
<pre class="prettyprint">eina_value_get(&amp;v, &amp;i);
printf(&quot;v=%d\n&quot;, i);
</pre>

<p>This will print &quot;v=123&quot;.</p>
<p>Here comes the interesting part with <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>, in the above snippet of code we printed an int value. We can however print the value as string. We can use <span style="font-family: Courier New,Courier,monospace">eina_value_to_string(const Eina_Value *v()</span> to convert an <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> to string.</p>
<pre class="prettyprint">newstr = eina_value_to_string(&amp;v);
printf(&quot;v as string: %s\n&quot;, newstr);

free(newstr);
</pre>

<p>Don&#39;t forget to free the memory allocated by eina_value_to_string</p>
<p>When you are done with the Generic Value, don&#39;t forget to destroy it using <span style="font-family: Courier New,Courier,monospace">eina_value_flush(cont Eina_Value *v)</span></p>
<pre class="prettyprint">eina_value_flush(&amp;v);
</pre>

<p>Of course we can setup a string, store it, and use it with <span style="font-family: Courier New,Courier,monospace">Eina_Value</span>.</p>
<p>We now reuse v to store a string, get its value and print it:</p>
<pre class="prettyprint">const char *s;

eina_value_setup(&amp;v, EINA_VALUE_TYPE_STRING);
eina_value_set(&amp;v, &quot;My string&quot;);
eina_value_get(&amp;v, &amp;s);

printf(&quot;v=%s (pointer: %p)\n&quot;, s, s);
</pre>

<p>we also can use <span style="font-family: Courier New,Courier,monospace">eina_value_to_string</span> with an <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> setup for strings.</p>
<pre class="prettyprint">char *newstr; 

newstr = eina_value_to_string(&amp;v);
printf(&quot;v as string: %s (pointer: %p)\n&quot;, newstr, newstr);

// Free the memory allocated by eina_value_to_string.
free(newstr);

eina_value_flush(&amp;v); 
</pre>

<p>Another way to convert from one <span style="font-family: Courier New,Courier,monospace">Eina_Value</span> to another is <span style="font-family: Courier New,Courier,monospace">eina_value_convert(Eina_Value *ori, Eina_Value *target)</span>. This function put the converted value into another Eina_Value. This function excepts pointers so you have to pass a Eina_Value pointer.</p>
<pre class="prettyprint">Eina_Value v;
Eina_Value otherv;

// Set up 2 Eina_Values: 1 int and 1 string
eina_value_setup(&amp;otherv, EINA_VALUE_TYPE_STRING);
eina_value_setup(&amp;v, EINA_VALUE_TYPE_INT);

// Convert from int to string
eina_value_set(&amp;v, 123);
eina_value_convert(&amp;v, &amp;otherv);
eina_value_get(&amp;otherv, &amp;s);
printf(&quot;otherv=%s\n&quot;, s);

// Another way to do the same 
eina_value_set(&amp;otherv, &quot;33&quot;);
eina_value_convert(&amp;otherv, &amp;v);
eina_value_get(&amp;v, &amp;i);
printf(&quot;v=%d\n&quot;, i);

// Clean your values
eina_value_flush(&amp;otherv);
eina_value_flush(&amp;v);
</pre>

<p><span style="font-family: Courier New,Courier,monospace">Eina_Value</span> can be used to store an <span style="font-family: Courier New,Courier,monospace">Eina_List</span>, which corresponds to the type <span style="font-family: Courier New,Courier,monospace">EINA_VALUE_TYPE_LIST</span>.</p>
<p>To Create a <span style="font-family: Courier New,Courier,monospace">Eina_Value_List</span>, you can use <span style="font-family: Courier New,Courier,monospace">eina_value_list_setup(Eina_Value * value, const Eina_Value_Type_Type * subtype)</span> This function initializes a generic value storage of type list. The first parameter is value &quot;object&quot;, the second is type (how to manage the stored list members).</p>
   
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer"> 
<p class="footer">Except as noted, this content is licensed under <a href="http://opensource.org/licenses/LGPL-2.1" target="_blank">LGPLv2.1+</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p> 
</div> 

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Media Muxing</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
		<p class="toc-title">Dependencies</p>
		<ul class="toc">
			<li>Tizen Platform 3.0 and Higher for Mobile</li>
			<li>Tizen Platform 3.0 and Higher for Wearable</li>
		</ul>
        <p class="toc-title">Content</p>
        <ul class="toc">
			<li><a href="#muxer">Media Muxer</a></li>
			<li><a href="#demuxer">Media Demuxer</a></li>
			<li><a href="#prerequisites">Prerequisites</a></li>
			<li><a href="#prepare_mux">Preparing the Media Muxer</a></li>
			<li><a href="#manage_mux">Managing the Media Muxer</a></li>
			<li><a href="#prepare_demux">Preparing the Media Demuxer</a></li>
			<li><a href="#manage_demux">Managing the Media Demuxer</a></li>
        </ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIAMUXER__MODULE.html">Media Muxer API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIAMUXER__MODULE.html">Media Muxer API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">Media Demuxer API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">Media Demuxer API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Media Muxing</h1>

<p>You can mux encoded media into a multiplexed stream and parse multiplexed media streams.</p> 

<h2 id="muxer">Media Muxer</h2>

<p>You can <a href="#prepare_mux">create audio and video content with a given container format type</a>, such as MP4.</p>
<p>The main features of the Media Muxer API include:</p>
<ul>
	<li>Video and audio elementary stream multiplexing</li>
	<li>MP4 multiplexing support</li>
</ul>

<p>Tizen supports the MP4 multiplex output streams, and the following MP4 multiplex input elementary streams:</p>
<ul>
	<li>AVC/H.264 video elementary stream</li>
	<li>MPEG-4 video elementary stream</li>
	<li>MPEG-2 video elementary stream</li>
	<li>MPEG audio elementary stream</li>
	<li>AAC audio elementary stream</li>
</ul>

<p>A media muxer instance can be used to <a href="#manage_mux">mux encoded media into 1 multiplexed stream</a>. The media muxer can accommodate single or multiple encoded elementary streams of various types, such as audio, video, and text. A single instance of the media muxer can create 1 compatible container format by taking 1 or more elementary streams as input.</p>

<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the media muxer functionality</a>.</p>

<p>The following figure illustrates the general media muxer state changes.</p>
<p class="figure">Figure: Media muxer state changes</p>
<p align="center"><img src="../../images/muxer.png" alt="Media muxer state changes" /></p>

 <table class="note"> 
<tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">All file types and container formats are not guaranteed to support the Media Muxer API.</td> 
    </tr> 
   </tbody> 
  </table>

<h2 id="demuxer">Media Demuxer</h2> 

<p>You can <a href="#prepare_demux">demux any multiplexed media streams</a>, such as MP4 and MP3.</p>
<p>The main features of the Media Demuxer API include:</p>
<ul>
	<li>Video, audio, and subtitle demultiplexing</li>
	<li>MP4 demultiplexing support</li>
	<li>MP3 parsing support</li>
	<li>AAC parsing support</li>
	<li>AMR parsing support</li>
</ul>

<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the media demuxer functionality</a>.</p>

<p>Tizen supports the following MP4 demultiplex streams:</p>
<ul>
<li>Input streams:
	<ul><li>MP4 (M4A, M4V)</li>
	<li>MP3, AAC, AMR-NB, AMR-WB</li></ul>
</li>
<li>Output elementary streams:
	<ul>
	<li>AVC/H.264 Video Elementary stream</li>
	<li>MPEG-4 Video Elementary stream</li>
	<li>MPEG-2 Video Elementary stream</li>
	<li>MPEG Audio Elementary stream</li>
	<li>AAC Audio Elementary stream</li>
	</ul>
	</li></ul>

<p>A media demuxer instance can be used to parse 1 multiplexed stream. The multiplexed stream can contain single or multiple elementary streams of various types, such as audio, video, or text. A single instance of the media demuxer can <a href="#manage_demux">extract 1, more, or all of these elementary streams</a>.</p>

<p>The following figure illustrates the general media demuxer state changes.</p>
<p class="figure">Figure: Media demuxer state changes</p>
<p align="center"><img src="../../images/demuxer.png" alt="Media demuxer state changes" /></p>

 <table class="note"> 
<tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">All file types and container formats are not guaranteed to support the Media Demuxer API.</td> 
    </tr> 
   </tbody> 
  </table>
  
  
  <h2>Warm-up</h2>

<p>Become familiar with the Media Muxer and Media Demuxer API basics by learning about:</p>
<ul>
	<li><a href="#prerequisites">Prerequisites</a>
	<p>Prepare your application to use the media muxing functionality.</p></li>
	<li><a href="#prepare_mux">Preparing the Media Muxer</a>
	<p>Initialize and configure the media muxer for use.</p></li>
	<li><a href="#manage_mux">Managing the Media Muxer</a>
	<p>Create threads to use the media muxer.</p></li>
	<li><a href="#prepare_demux">Preparing the Media Demuxer</a>
	<p>Initialize and configure the media demuxer for use.</p></li>
	<li><a href="#manage_demux">Managing the Media Demuxer</a>
	<p>Create threads to use the media demuxer.</p></li>
</ul> 


<h2 id="prerequisites">Prerequisites</h2>

<p>To enable your application to use the media muxing functionality:</p>
<ul>
<li>
<p>To use the functions and data types of the Media Muxer API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIAMUXER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIAMUXER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;mediamuxer.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;mediamuxer.h&gt;
</pre>
</li>
<li>
<p>To use the functions and data types of the Media Demuxer API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;mediademuxer.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;mediademuxer.h&gt;

#include &lt;media_format.h&gt;
#include &lt;media_packet.h&gt;
</pre>
<p>You also need the <span style="font-family: Courier New,Courier,monospace">&lt;media_format.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;media_packet.h&gt;</span> header files to identify and manage individual tracks within the media file.</p>
</li>
</ul>

<h2 id="prepare_mux">Preparing the Media Muxer</h2>

<p>To prepare the media muxer:</p>
<ol>
<li>Define a handle for the media muxer and pass it to the <span style="font-family: Courier New,Courier,monospace">mediamuxer_create()</span> function. The same handle must be passed to the rest of the media muxer functions.
<pre class="prettyprint">
mediamuxer_h *muxer;
ret = mediamuxer_create(&amp;muxer);
if (ret != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>

<li>If the handle is created normally, set the output file path by passing the absolute uri path to the <span style="font-family: Courier New,Courier,monospace">mediamuxer_set_data_sink()</span> function:
<pre class="prettyprint">
char *path = &quot;/home/media/myfile.mp4&quot;
mediamuxer_output_format_e format = MEDIAMUXER_CONTAINER_FORMAT_MP4;
if (mediamuxer_set_data_sink(muxer, path, format)!= MEDIAMUXER_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediamuxer_set_data_sink failed\n&quot;);
</pre>
</li>

<li>Add the necessary media tracks to the media muxer. The following function shows adding a video elementary track to be muxed. 
<p>A successful <span style="font-family: Courier New,Courier,monospace">mediamuxer_add_track()</span> function call returns a <span style="font-family: Courier New,Courier,monospace">track_index</span>. Whenever you have to deal with the track, the corresponding <span style="font-family: Courier New,Courier,monospace">track_index</span> must be used. Mapping a <span style="font-family: Courier New,Courier,monospace">track_index</span> to the corresponding media track is your responsibility.</p>
<pre class="prettyprint">
int
test_mediamuxer_add_track_video()
{
&nbsp;&nbsp;&nbsp;&nbsp;int track_index_vid = -1;
&nbsp;&nbsp;&nbsp;&nbsp;media_format_mimetype_e mimetype;
&nbsp;&nbsp;&nbsp;&nbsp;int width;
&nbsp;&nbsp;&nbsp;&nbsp;int height;
&nbsp;&nbsp;&nbsp;&nbsp;int avg_bps;
&nbsp;&nbsp;&nbsp;&nbsp;int max_bps;

&nbsp;&nbsp;&nbsp;&nbsp;media_format_create(&amp;media_format);
&nbsp;&nbsp;&nbsp;&nbsp;media_format_set_video_mime(media_format, MEDIA_FORMAT_H264_SP);
&nbsp;&nbsp;&nbsp;&nbsp;media_format_set_video_width(media_format, 640);
&nbsp;&nbsp;&nbsp;&nbsp;media_format_set_video_height(media_format, 480);
&nbsp;&nbsp;&nbsp;&nbsp;media_format_set_video_avg_bps(media_format, 256000);
&nbsp;&nbsp;&nbsp;&nbsp;media_format_set_video_max_bps(media_format, 256000);

&nbsp;&nbsp;&nbsp;&nbsp;/* Add the video track */
&nbsp;&nbsp;&nbsp;&nbsp;mediamuxer_add_track(myMuxer, media_format, &amp;track_index_vid);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}
</pre>
</li>

<li>Once all the tracks are added, start the media muxer:
<pre class="prettyprint">
if (mediamuxer_start(muxer) != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediamuxer_start API failed\n&quot;);
</pre>
</li>

<li>After a successful muxer start, call a write sample until all the samples of the respective track are written.
<p>The write sample is a specific track. It is your responsibility to use the appropriate <span style="font-family: Courier New,Courier,monospace">track_index</span> to choose the correct track, and to add the corresponding data to the muxer through the write sample. Repeat the same for the rest of the tracks. Before calling this function, create a valid handle for the <span style="font-family: Courier New,Courier,monospace">media_packet_h</span> handle to get the input samples. For more information, see <a href="media_handle_n.htm">Media Handle Management</a>.</p>
<pre class="prettyprint">
if (mediamuxer_write_sample(muxer, track_index, in_buf) != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediamuxer_write_sample API for track %d failed\n&quot;, track_index);
</pre>
</li>

<li>Once the EOS (End Of Stream) of a particular track is reached, call <span style="font-family: Courier New,Courier,monospace">mediamuxer_close_track()</span> function to finalize the track:
<pre class="prettyprint">
if (mediamuxer_close_track(muxer, track_index) != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediamuxer_close_track API failed\n&quot;);
</pre>
</li>
</ol>



<h2 id="manage_mux" name="manage_mux">Managing the Media Muxer</h2> 

<p>To manage the media muxer, the <span style="font-family: Courier New,Courier,monospace">mediamuxer_write_sample()</span> function is called in a loop until the EOS is reached. You can use multi-threading, writing samples corresponding to different tracks in different threads.</p>
<ol>
<li>You can create individual threads to manage each track simultaneously, but it is not mandatory. The following sample code explains how to call the <span style="font-family: Courier New,Courier,monospace">mediamuxer_write_sample()</span> function for a video track in a unique thread:
<pre class="prettyprint">
int
test_mediamuxer_write_sample()
{
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread[1];
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_t attr;
&nbsp;&nbsp;&nbsp;&nbsp;/* Initialize and set thread detached attribute */
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_init(&amp;attr);
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;thread[0], &amp;attr, _write_video_data, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;thread[1], &amp;attr, _write_audio_data, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;/* Add audio track, which is not given in this tutorial */

&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_destroy(&amp;attr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}

void*
_write_video_data()
{
&nbsp;&nbsp;&nbsp;&nbsp;gint is_eos = 0;
&nbsp;&nbsp;&nbsp;&nbsp;int *status = (int *)g_malloc(sizeof(int) * 1);
&nbsp;&nbsp;&nbsp;&nbsp;v*status = -1;
&nbsp;&nbsp;&nbsp;&nbsp;int track_index_vid = 1; /* track_index = 1 for video */
&nbsp;&nbsp;&nbsp;&nbsp;media_packet_h vid_pkt;
&nbsp;&nbsp;&nbsp;&nbsp;while (!is_eos) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Read encoded video data */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Get the proper video media packet from, for example, mediacodec/mediademuxer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_func_get_media_packet(&amp;vid_pkt, &amp;is_eos);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!is_eos) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediamuxer_write_sample(myMuxer, track_index_vid, vid_pkt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_packet_destroy(vid_pkt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;\nVideo while done in the test suite&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediamuxer_close_track(myMuxer, track_index_vid);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
}
</pre>
</li>

<li>After you have finished work with the media muxer handle, reset the media muxer and destroy the handle by using the <span style="font-family: Courier New,Courier,monospace">mediamuxer_stop()</span> and <span style="font-family: Courier New,Courier,monospace">mediamuxer_destroy()</span> functions. 
<p>The media muxer state changes to <span style="font-family: Courier New,Courier,monospace">MEDIAMUXER_STATE_NONE</span>.</p>
<pre class="prettyprint">
ret = mediamuxer_stop(muxer);
if (ret != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
ret = mediamuxer_destroy(muxer);
if (ret != MEDIAMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>
</ol>

<h2 id="prepare_demux">Preparing the Media Demuxer</h2>

<p>To prepare the media demuxer:</p>
<ol>
<li>Define a handle for the media demuxer and pass it to the <span style="font-family: Courier New,Courier,monospace">mediademuxer_create()</span> function. The same handle must be passed to the rest of the media demuxer functions.
<pre class="prettyprint">
mediademuxer_h *demuxer;
ret = mediademuxer_create(&amp;demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>

<li>If the handle is created normally, set the input data source by passing the path to the <span style="font-family: Courier New,Courier,monospace">mediademuxer_set_data_source()</span> function:
<pre class="prettyprint">
if (mediademuxer_set_data_source(demuxer, path)!= MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_set_data_source API failed\n&quot;);
</pre>
</li>

<li>Call the <span style="font-family: Courier New,Courier,monospace">mediademuxer_prepare()</span> function to move the media demuxer into the ready state:
<pre class="prettyprint">
if (mediademuxer_prepare(demuxer) != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_prepare API failed\n&quot;);
</pre>
</li>

<li>Once the media demuxer is in the ready state, get the total number of individual elementary streams present: 
<pre class="prettyprint">
if (mediademuxer_get_track_count(demuxer, &amp;num_tracks) != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_get_track_count API failed\n&quot;);
</pre>
</li>

<li>Select all the tracks to be extracted:
<pre class="prettyprint">
for (track = 0; track &lt; num_tracks; track++) {
&nbsp;&nbsp;&nbsp;&nbsp;if (mediademuxer_select_track(demuxer, track))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;mediademuxer_select track %d failed\n&quot;, track);
}
</pre>
</li>

<li>Start the media demuxer:
<pre class="prettyprint">
if (mediademuxer_start(demuxer))
&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;mediademuxer_start failed\n&quot;);
</pre>
</li>

<li>Once the total track counts are known, the media format for each track must be identified. Before calling the <span style="font-family: Courier New,Courier,monospace">media_format_create()</span> function, you must define and create a valid <span style="font-family: Courier New,Courier,monospace">media_format_h</span> handle (the <span style="font-family: Courier New,Courier,monospace">format</span> parameter in the given function).
<p>The following example retrieves the media format for each track:</p>
<pre class="prettyprint">
media_format_h *g_media_format = NULL;
int track;
g_media_format = (media_format_h *)g_malloc(sizeof(media_format_h) * num_tracks);
for (track = 0; track &lt; num_tracks; track++) {
&nbsp;&nbsp;&nbsp;&nbsp;ret = media_format_create(&amp;g_media_format[track]);
&nbsp;&nbsp;&nbsp;&nbsp;if (ret == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;g_media_format[%d] is created successfully! \n&quot;, track);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = mediademuxer_get_track_info(demuxer, track, g_media_format[track]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_get_video_info(g_media_format[track], &amp;mime, &amp;w, &amp;h, NULL, NULL) == MEDIA_FORMAT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_get_video_info is success!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vid_track = track;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (media_format_get_audio_info(g_media_format[track], &amp;mime, &amp;channel, &amp;samplerate, NULL, NULL) == MEDIA_FORMAT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_get_audio_info is success!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aud_track = track;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Not supported yet&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Error while getting mediademuxer_get_track_info\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Error while creating media_format_create\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ol>



<h2 id="manage_demux" name="manage_demux">Managing the Media Demuxer</h2> 

<p>To manage the media demuxer process:</p>
<ol>
<li>You can create individual threads to manage each track simultaneously, but it is not mandatory. The following sample code explains how to extract the video track in a new thread:
<pre class="prettyprint">
int
test_mediademuxer_read_sample()
{
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread[1];
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_t attr;
&nbsp;&nbsp;&nbsp;&nbsp;/* Initialize and set thread detached attribute */
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_init(&amp;attr);
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
&nbsp;&nbsp;&nbsp;&nbsp;if (vid_track != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;In main: creating thread for video\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;thread[0], &amp;attr, _fetch_video_data, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_destroy(&amp;attr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}

void*
_fetch_video_data(void *ptr)
{
&nbsp;&nbsp;&nbsp;&nbsp;int *status = (int *)g_malloc(sizeof(int) * 1);
&nbsp;&nbsp;&nbsp;&nbsp;*status = -1;
&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Video Data function\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;int count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;media_packet_h vidbuf;
&nbsp;&nbsp;&nbsp;&nbsp;media_format_h vidfmt;
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_create(&amp;vidfmt)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_create failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_mime(vidfmt, MEDIA_FORMAT_H264_SP)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_mime failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_width(vidfmt, 760)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_width failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_height(vidfmt, 480)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_height failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_packet_create_alloc(vidfmt, NULL, NULL, &amp;vidbuf)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_packet_create_alloc failed\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while (1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int EOS = mediademuxer_read_sample(demuxer, vid_track, &amp;vidbuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (EOS == MD_EOS || EOS != MD_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_exit(NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Read::[%d] video sample\n&quot;, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the media packet and release the packet here */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_packet_destroy(vidbuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Create a new packet for getting next frame of data */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_packet_create_alloc(vidfmt, NULL, NULL, &amp;vidbuf)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_packet_create_alloc failed\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;*status = 0;

&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
}
</pre>
</li>

<li>After you have finished work with the media demuxer, reset the media demuxer and destroy the handle by using the <span style="font-family: Courier New,Courier,monospace">mediademuxer_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">mediademuxer_destroy()</span> functions. 
<p>The media demuxer state changes to <span style="font-family: Courier New,Courier,monospace">MEDIADEMUXER_STATE_NONE</span>.</p>
<pre class="prettyprint">
ret = mediademuxer_unprepare(demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
ret = mediademuxer_destroy(demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>
</ol>

  
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

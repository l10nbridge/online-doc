<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Media Playback</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
		<p class="toc-title">Dependencies</p>
		<ul class="toc">
			<li>Tizen Platform 2.4 and Higher for Mobile</li>
			<li>Tizen Platform 2.3.1 and Higher for Wearable</li>
		</ul>
        <p class="toc-title">Content</p>
        <ul class="toc">
			<li><a href="#audio">Handling Audio</a></li>
			<li><a href="#video">Handling Video</a></li>
			<li><a href="#features">Features</a></li>
			<li><a href="#stream">Streaming Playback</a></li>
			<li><a href="#play_pcm">Uncompressed Audio</a></li>
			<li><a href="#wav">WAV Player</a></li>
			<li><a href="#tone">Tone Player</a></li>
			<li><a href="#prerequisites">Prerequisites</a></li>
			<li><a href="#prepare">Preparing the Player</a></li>
            <li>Player
                <ul class="toc">
                    <li><a href="#play_audio">Playing an Audio File</a></li>
                    <li><a href="#play_video">Playing a Video File</a></li>
                    <li><a href="#release">Stopping the Player and Releasing Resources</a></li>
                </ul>
            </li>
            <li>Multi-player
                <ul class="toc">
                    <li><a href="#play">Playing Multiple Files Simultaneously</a></li>
                </ul>
            </li>
			<li>Uncompressed audio
                <ul class="toc">
					<li><a href="#simple">Managing Synchronous Playback</a></li>
					<li><a href="#async">Managing Asynchronous Playback</a></li>
                </ul>
            </li>
            <li>WAV player
                <ul class="toc">
                    <li><a href="#start">Starting and Stopping the WAV Player</a></li>
                </ul>
            </li>
            <li>Tone player
                <ul class="toc">
					<li><a href="#play_tone">Playing a Tone</a></li>
					<li><a href="#duration">Playing a Tone for a Specified Duration</a></li>
                </ul>
            </li>
            <li>Advanced player
                <ul class="toc">
                    <li><a href="#set_parameters">Configuring the Video Playback Display</a></li>
                    <li><a href="#get_stream">Retrieving Stream Information</a></li>
                    <li><a href="#insert">Inserting Subtitles</a></li>
                </ul>
            </li>			
        </ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">Player API for Mobile Native</a></li>
            <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html">Tone Player API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__WAV__PLAYER__MODULE.html">WAV Player API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">Player API for Wearable Native</a></li>
            <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Wearable Native</a></li>			
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html">Tone Player API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__WAV__PLAYER__MODULE.html">WAV Player API for Wearable Native</a></li>
			<li><a href="https://developer.tizen.org/development/sample/native/Multimedia/Media" target="_blank">Media Sample Description</a></li>
        </ul>
    </div></div>
</div>
<div id="container"><div id="contents"><div class="content">
<h1>Media Playback</h1>
<p>You can play audio and video in your application.</p> 
  <p>The main player features are:</p> 
  <ul>
    <li><a href="#audio">Handling audio</a> 
	<p>Enables you to <a href="#play_audio">play audio</a> and control the playback.</p></li>
	<li><a href="#video">Handling video</a>
	<p>Enables you to <a href="#play_video">play video</a>.</p></li>
	<li><a href="#features">Using player features</a>
	<p>Enables you control the player volume, sound mode, display, stream info, and audio effects.</p></li>
	<li><a href="#stream">Streaming playback</a>
	<p>Enables you to set specific URLs for streaming media playback.</p></li>	
</ul>
   
<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the player functionality</a> and <a href="#prepare">set up the player</a>.</p>
<p>The Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">wearable</a> applications) enables your application to play video and sound. It supports 3 content formats: file, network stream, and memory. It also provides the following features:</p>

<ul><li>Operating general controls for the <a href="#audio">audio</a> or <a href="#video">video</a> content, such as play, pause, resume, and stop</li> 
<li>Moving the audio or video content based on time</li>
<li>Controlling the volume of the audio or video content based on each instance</li>
<li>Looping the audio or video content</li>
<li>Getting information of the audio or video content</li>
<li>Playing multiple <a href="#stream">audio streams</a></li></ul>

<p>The maximum count of a player instance is limited by the system and multimedia resources. The maximum count is a system-wide count and it can be applied depending on the CPU model, CPU speed, CPU core number, CPU load from other applications, and the available memory. Thus, the exact count can be smaller than the maximum count, in which case the prepare functions fail. A reasonable working player count is under 10. You can <a href="#release">stop a player</a> to free up system resources.</p>
<p>The player works based on the audio session manager policy. This means that an application can be interrupted by another application if a resource is in conflict or it has an audio policy rule to follow. You can change the session&#39;s property directly by using the Sound Manager API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications).</p>
<p>The callback interface specifies the functions used to notify the player status during playback events. Since the player engine works asynchronously, you must implement this listener to ensure that the player flows correctly. When each player operation is completed, an event is generated, and the <span style="font-family: Courier New,Courier,monospace;">player_completed_cb()</span> function is called. If an error occurs in the player engine, you are notified if you have registered the <span style="font-family: Courier New,Courier,monospace;">player_error_cb()</span> callback.</p>
<p>If the player state is changed to <span style="font-family: Courier New,Courier,monospace;">ready</span>, the multimedia resource is available and you can get content information of the media. You can also get content information in a playing state in some cases of playback streaming.</p>

 
  <h2 id="audio" name="audio">Handling Audio</h2> 
  <p>Tizen enables your application to play audio and provides controlling functions for using audio resources. The resources can be media files stored on the device or they can be streamed from a streaming server (defined with a URI) through the network.</p> 
  
  <p>The audio formats your application can use include MP3, AAC, WMA, M4A, 3GA, WAV, and AMR. The available formats depend on the target device.</p>

  
  <p>The <span style="font-family: Courier New,Courier,monospace;">player_interrupted_cb()</span> function is called when an application is interrupted by another application. The player is paused or moved to an idle state according to the audio policy. You must check the state of the current instance and take appropriate action. If the player is changed to a paused state due to an interruption, the <span style="font-family: Courier New,Courier,monospace;">PLAYER_INTERRUPTED_COMPLETED</span> can be called at the end of the interruption. For example, if the application is interrupted by a call, alarm, or notification, the completed message is posted. However, no messages are posted if the interruption has other causes. Make sure you handle the application accordingly when audio switching occurs between various applications.</p>
  
  <p>You can use multiple instances of the player to play several audio data streams concurrently. This means that your application can <a href="#play">play multiple uncompressed audio files</a> at the same time.</p> 

  <p>The following figure illustrates the general player state changes:</p> 
  <p class="figure">Figure: Player state changes</p> 
  <p align="center"><img src="../../images/using_players_state_changes.png" alt="Player state changes" style="display: block; text-align: center; margin-left: auto; margin-right: auto;"/></p> 
  <p>The following figure illustrates what happens when the player gets interrupted by the system:</p> 
  <p class="figure">Figure: Player states when interrupted by system</p> 
  <p align="center"><img alt="Player states when interrupted by system" src="../../images/using_players_interrupted_state.png"/></p> 
  
  <h2 id="video" name="video">Handling Video</h2> 
  <p>Tizen enables your application to play video, and it uses its own user surface. The surface requires a drawing area, so you have to get an overlay region and set it to the player instance to display the drawing area:</p> 
  <ol> 
     <li>Get the overlay region or Evas from the Graphics module.
	 <p>You can display video on a UI layer with the Evas object as well as on an overlay layer.</p></li> 
     <li>Create the player instance.</li> 
     <li>Set the surface type and display a handle to the player using the <span style="font-family: Courier New,Courier,monospace;">player_set_display()</span> function.</li> 
    </ol>
  <p>The video formats your application can use include: </p> 
  <ul> 
   <li>WMV, ASF, MP4, 3GP, AVI, MKV, OGG
   <p>The available formats depend on the target device.</p></li> 
  </ul> 

  <p>In case of a video interruption, the state can be <span style="font-family: Courier New,Courier,monospace;">READY</span> due to the resource restriction in the system. </p> 
  
  <p>The following figure illustrates what happens when the player gets interrupted by the system.</p> 
<p class="figure">Figure: Player states when interrupted by system</p> 
<p align="center"><img alt="Player states when interrupted by system" src="../../images/using_videoplayer_interrupted_state.png"/></p>
<h2 id="features" name="features">Features</h2>
The main features of the Player API include:
<ul>
  <li>Player
  <p>Use the Player API to control audio and video stream.</p>
  <p>After changing to the <span style="font-family: Courier New,Courier,monospace;">READY</span> state, properties such as volume, sound type, latency mode, mute mode, and looping mode can be adjusted.</p>
    </li>
  <li>Display
<p>Use the Display API to play video stream.</p>
<p>After changing to the <span style="font-family: Courier New,Courier,monospace;">IDLE</span> state, create the display handle and <a href="#set_parameters">set the display type</a>.</p>

</li>
  <li>Stream Info
  <p>Use the Stream Info API to play video stream.</p>
    <p>After changing to the <span style="font-family: Courier New,Courier,monospace;">READY</span> state, you can <a href="#get_stream">retrieve stream information</a>.</p>
    </li>

  <li>Audio Effect
    <p>Use the Audio Effect API to set and get the audio effect.</p>
<p>After changing to the <span style="font-family: Courier New,Courier,monospace;">IDLE</span> state, you can adjust the audio effect.</p>
    </li>
  <li>Subtitle
    <p>Use the Subtitle API to <a href="#insert">read the subtitle track</a>.</p>
    <p>After changing to the <span style="font-family: Courier New,Courier,monospace;">READY</span> state, the subtitle can be read.</p>
    </li>
  </ul>
 
<h2 id="stream" name="stream">Streaming Playback</h2> 
  <p>You can set specific URLs for streaming media playback by using the <span style="font-family: Courier New,Courier,monospace;">player_set_uri()</span> function.</p> 
  <p>Both Hypertext Transfer Protocol (HTTP) and Real Time Streaming Protocol (RTSP) protocols support streaming media   playback. The HTTP request header supports the playback of both complete and download-in-progress media files. The index table (atoms) must be moved in front of the file for progressive download.</p> 
 
 <p>In case of HTTP streaming, buffering can happen when the player is prepared. You can get the status using the <span style="font-family: Courier New,Courier,monospace;">player_set_buffering_cb()</span> function.</p>
 
 <h3 id="protocol" name="protocol">Streaming Protocol Features</h3>
<p>The following table lists the streaming protocol features supported by the player.</p>

  <table> 
   <caption>
     Table: Supported streaming protocol features 
   </caption> 
   <tbody> 
    <tr> 
     <th>Streaming protocol</th> 
     <th>Supported feature</th> 
    </tr> 
    <tr> 
     <td rowspan="3">Hypertext Transfer Protocol (HTTP)</td> 
     <td>HTTP Streaming</td> 
    </tr> 
    <tr> 
     <td>HTTP Live Streaming</td> 
    </tr> 
    <tr> 
     <td>HTTP Progressive Download Play</td> 
    </tr> 	
    <tr> 
     <td>Real Time Streaming Protocol (RTSP)</td> 
     <td>RTSP Streaming</td> 
    </tr> 
   </tbody> 
  </table> 

 <h2 id="play_pcm" name="play_pcm">Uncompressed Audio</h2>
 
<p>The Pulse Code Modulated (PCM) data contains non-compressed audio. The Audio Output API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__OUT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__OUT__MODULE.html">wearable</a> applications) enables your application to play such data using output devices. You can <a href="#simple">play audio synchronously</a>, or <a href="#async">do it asynchronously</a>.</p>
  <p>To play the audio PCM data, the application must call the <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> function to initialize the audio output handle.</p>
  <p>Before you start, remember to <a href="#prerequisites">prepare your application to use the audio input and output functionalities</a>. Your application must also define the following PCM data settings:</p>
  <ul>
   <li>Audio channels:
    <ul>
     <li>Mono (1 channel)</li>
     <li>Stereo (2 channels)</li>
    </ul> </li>
   <li>Audio sample type:
    <ul>
     <li>Unsigned 8-bit PCM</li>
     <li>Signed 16-bit little endian PCM</li>
    </ul> </li>
   <li>Audio sample rate:
   <ul>
    <li>8000 ~ 48000 Hz</li>
   </ul> </li>
  </ul>
  
  <p>The following figures illustrate the general audio output states, and how the state changes when the audio output is interrupted by the system.</p>
  <p class="figure">Figure: Audio output states</p>
  <p align="center"><img src="../../images/audio_output.png" alt="Audio output states" /></p>
  <p class="figure">Figure: Audio output states when interrupted by system</p>
  <p align="center"><img src="../../images/audio_output_interrupt_state.png" alt="Audio output states when interrupted by system" /></p>
  
  <h3 id="use" name="use">Using Audio Output</h3>
  <p>For supporting various low-end Tizen devices, the application must follow certain guidelines:</p>
  <ul>
   <li>Do not use multiple instances of the Audio Output excessively.
   <p>Using excessive multiple instances of the Audio Output has a negative effect on the application, because the audio data processing for re-sampling and mixing imposes a heavy burden on the system. </p> </li>
   <li>Use device-preferred PCM format.
   <ul>

    <li><p>To reduce the processing overhead inside, use the target device-preferred PCM format (for example, signed 16-bit little endian, stereo, 44100 Hz).</p></li>
    <li><p>Using the preferred format reduces internal operations, such as converting audio samples from mono to stereo or re-sampling audio frequency to fit the target device&#39;s input sample rate.</p></li>
   </ul> </li>
   <li>Do not call the Audio Output functions too frequently.
   <ul>
    <li><p>The Audio Output functions require more time while repeated in the order of <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> &gt; <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> &gt; <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> &gt; <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span>. Therefore, keep the frequency of calling these functions to a minimum. Note that the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> functions are much faster than <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span>.</p></li>
</ul></li>
   <li>Reduce event delay and remove glitches.
   <ul>
    <li><p>The Audio Output API works recursively with events. The smaller the buffer size, the more often are events generated. If you use the Audio Output API with the smallest buffer and other resources (for example, a timer or sensor), the application is negatively influenced by the delay of the event. To prevent problems, set the write buffer size properly based on the other resources you need.</p></li>
    <li><p>To guarantee the working events of the Audio Output API independently, an instance of the Audio Output API needs to be created and worked on the event thread.</p></li> 
   </ul> </li>
   <li>Use double-buffering.
   <ul>
    <li><p>Use the double buffering mechanism to reduce latency. The mechanism works by first writing data twice before starting. After starting, whenever the listener (event) is called, you can write additional data.</p></li>
   </ul> </li>
   	<li>Save power.
	<ul>
	<li><p>If the Audio Output does not play for a long time for some reason, such as the screen turning off, or idle playback, call the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function to pause the stream and save power. The device cannot go to sleep while in the <span style="font-family: Courier New,Courier,monospace">PLAYING</span> state.</p></li>
	</ul> </li>
  </ul>
  
<h2 id="wav">WAV Player</h2>

<p>Tizen enables your application to play audio in 1 of 2 ways: </p> 
  <ul> 
   <li>Audio player AppControl <p>When using the audio application control, the device standard media player application is launched to play audio. </p> </li> 
   <li><span style="font-family: Courier New,Courier,monospace">wav player header</span> <p>When using the <span style="font-family: Courier New,Courier,monospace">wav player header</span>, your application uses its own user interface.</p> </li> 
  </ul> 
  <p>The WAV Player API provides controlling functions for using audio resources. The resources can be a media file stored in the device.</p> 
  <p>Use the WAV Player API to enable your application to play audio and control playback. The audio features of this API let you:</p> 
  <ul> 
   <li>Play audio media from local files</li> 
   <li><a href="#start">Control playback</a> using play and stop</li> 
  </ul> 
<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the WAV player functionality</a>.</p>
  <p>The audio formats your application can use with the WAV Player API include:</p> 
  <ul> 
   <li>WAV, OGG</li> 
  </ul> 
  <p>Most operations of the WAV Player API work in synchronous mode The WAV Player API requires a callback to notify the application of the operational status of the player. The callback must be implemented and passed to stop the WAV playback.</p> 
  <p>Multiple instances of the <span style="font-family: Courier New,Courier,monospace">wav player</span> can be used to play several audio data streams concurrently. This means that your application can play multiple uncompressed audio files, such as WAV, at the same time.</p> 
  <p>The most common audio uses of the WAV Player API include: </p> 
  <ul> 
   <li>Playing an audio file and controlling the playback</li> 
   <li>Handling player controls</li> 
  </ul> 
  
  <p>The following figure illustrates the general WAV player state changes.</p> 
  <p class="figure">Figure: WAV player state changes</p> 
  <p align="center"><img src="../../images/wav_player_state_changes.png" alt="WAV player state changes" /></p> 

<h2 id="tone">Tone Player</h2>

<p>Tizen enables your application to play a tone or a list of tones.</p> 
  <p>You can generate tones in 2 ways: </p> 
  <ul> 
   <li><p>Specify the frequency values. You can specify either 1 or 2 frequencies.</p></li> 
   <li><p>Use a DTMF (Dual Tone Multi Frequency) preset frequency value of the <span style="font-family: Courier New,Courier,monospace;">tone_type_e</span>.</p></li> 
  </ul> 

  <p>You can <a href="#play_tone">start and stop playing a tone</a>, and <a href="#duration">play a tone for a specified duration</a>.</p>
  
  <p>Before you start, remember to <a href="#prerequisites">prepare your application to use the tone player functionality</a>.</p>
  
  <p>The following figures illustrate the general tone player states, and how the state changes when your application calls the Tone player API.</p> 
  <p class="figure">Figure: Tone player states</p> 
  <p align="center"><img src="../../images/tone.png" alt="Tone player states" /></p>    

<h2>Warm-up</h2>

<p>Become familiar with the Player, Audio I/O and Sound Manager, WAV Player, and Tone Player API basics by learning about:</p>

<ul>
	<li><a href="#prerequisites">Prerequisites</a>
		<p>Prepare your application to use the playback functionality.</p></li>
		<li><a href="#prepare">Preparing the Player</a>
                <p>Initialize the player for use.</p></li>
    <li>Player
        <ul>
            <li><a href="#play_audio">Playing an Audio File</a>
                <p>Play an audio file.</p></li>
            <li><a href="#play_video">Playing a Video File</a>
                <p>Play a video file.</p></li>
            <li><a href="#release">Stopping the Player and Releasing Resources</a>
                <p>Stop the player, and release the resources allocated to the player.</p></li>
        </ul>
    </li>
    <li>Multi-player
        <ul>
            <li><a href="#play">Playing Multiple Files Simultaneously</a>
                <p>Play multiple files simultaneously.</p></li>
        </ul>
    </li>
	<li>Uncompressed audio
		<ul>
			<li><a href="#simple">Managing Synchronous Playback</a>
				<p>Using a synchronous API, play a recorded audio sample through the audio output device, and modify the volume in the recorded audio sample.</p>
			</li>
			<li><a href="#async">Managing Asynchronous Playback</a>
				<p>Using an asynchronous API, play a recorded audio sample through the audio output device.</p>
			</li>
		</ul>
	</li>
	<li>WAV player
		<ul>
			<li><p><a href="#start">Starting and Stopping the WAV Player</a></p>
				<p>Start and stop the WAV player.</p></li>
		</ul>
	</li>
	<li>Tone player
		<ul>
			<li><p><a href="#play_tone">Playing a Tone</a></p>
				<p>Start and stop playing a tone.</p></li>
			<li><p><a href="#duration">Playing a Tone for a Specified Duration</a></p>
				<p>Play a tone for a specified duration.</p></li>
		</ul>
	</li>	
</ul>

<h2>Follow-up</h2>

<p>Once we have learned the basics of the Player API, we can now move on to more advanced tasks, including:</p>

<ul>
    <li>Advanced player
        <ul>
            <li><a href="#set_parameters">Configuring the Video Playback Display</a>
                <p>Set the display parameters for playing a video file.</p></li>
            <li><a href="#get_stream">Retrieving Stream Information</a>
                <p>Retrieve information about the audio and video streams.</p></li>
            <li><a href="#insert">Inserting Subtitles</a>
                <p>Insert subtitles to a video file.</p></li>
        </ul>
    </li>
</ul>

<h2 id="prerequisites">Prerequisites</h2>

<p>To enable your application to use the playback functionality:</p>
<ol>
<li>
<p>To use the functions and data types of the Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;player.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;player.h&gt;
#include &lt;Elementary.h&gt;
#include &lt;glib.h&gt;
</pre>
<p>In this guide, you also need the <span style="font-family: Courier New,Courier,monospace">&lt;Elementary.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;glib.h&gt;</span> header files to set the display and use the Glib library functions.</p>
</li>
<li>
<p>Retrieve the default internal storage paths for audio and video files, and define the specific paths for the audio and video files to play. To access and use internal storage, include the <span style="font-family: Courier New,Courier,monospace;">storage.h</span> header file in your application.</p>
<pre class="prettyprint">
#define MP3_SAMPLE &quot;SampleAudio.mp3&quot;;
#define MP4_SAMPLE &quot;SampleVideo.mp4&quot;;

int internal_storage_id;
char *audio_storage_path = NULL;
char *video_storage_path = NULL;
char *audio_path = NULL;
char *video_path = NULL;

static bool
storage_cb(int storage_id, storage_type_e type, storage_state_e state,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *path, void *user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;if (type == STORAGE_TYPE_INTERNAL) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal_storage_id = storage_id;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return true;
}

void
_get_storage_path()
{
&nbsp;&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;&nbsp;char *path = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;error_code = storage_foreach_device_supported(storage_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;error_code = storage_get_directory(internal_storage_id, STORAGE_DIRECTORY_MUSIC, &amp;path);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != STORAGE_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_storage_path = strdup(path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;error_code = storage_get_directory(internal_storage_id, STORAGE_DIRECTORY_VIDEOS, &amp;path);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != STORAGE_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_storage_path = strdup(path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

void
_set_test_path()
{
&nbsp;&nbsp;&nbsp;&nbsp;int path_len = 0;

&nbsp;&nbsp;&nbsp;&nbsp;path_len = strlen(audio_storage_path) + strlen(MP3_SAMPLE) + 1;
&nbsp;&nbsp;&nbsp;&nbsp;audio_path = malloc(path_len);
&nbsp;&nbsp;&nbsp;&nbsp;memset(audio_path, 0x0, path_len);

&nbsp;&nbsp;&nbsp;&nbsp;strncat(audio_path, audio_storage_path, strlen(audio_storage_path));
&nbsp;&nbsp;&nbsp;&nbsp;strncat(audio_path, MP3_SAMPLE, strlen(MP3_SAMPLE));

&nbsp;&nbsp;&nbsp;&nbsp;path_len = strlen(video_storage_path) + strlen(MP4_SAMPLE) + 1;
&nbsp;&nbsp;&nbsp;&nbsp;video_path = malloc(path_len);
&nbsp;&nbsp;&nbsp;&nbsp;memset(video_path, 0x0, path_len);

&nbsp;&nbsp;&nbsp;&nbsp;strncat(video_path, video_storage_path, strlen(video_storage_path));
&nbsp;&nbsp;&nbsp;&nbsp;strncat(video_path, MP4_SAMPLE, strlen(MP4_SAMPLE));
}
</pre>
</li>
<li>
<p>To use the functions and data types of the Audio I/O (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">wearable</a> applications) and Sound Manager (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications) APIs, include the <span style="font-family: Courier New,Courier,monospace">&lt;audio_io.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files in your application:</p>
<pre class="prettyprint">
#include &lt;audio_io.h&gt;
#include &lt;sound_manager.h&gt;
</pre>
</li>

<li><p>To initialize the audio input and output devices, use the <span style="font-family: Courier New,Courier,monospace">audio_in_create()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> functions:</p>

<pre class="prettyprint">
/* Define the sample rate for recording audio */
#define SAMPLE_RATE 44100

/* Declare the variable used for checking function results */
audio_io_error_e error_code;

/* Initialize the audio input device */
audio_in_h input;

error_code = audio_in_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, &amp;input);

/* Initialize the audio output device */
audio_out_h output;

error_code = audio_out_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, SOUND_TYPE_SYSTEM, &amp;output);
</pre>
<p>The audio input and output devices support the channel types defined in the <span style="font-family: Courier New,Courier,monospace">audio_channel_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">wearable</a> applications), and the sample types defined in the <span style="font-family: Courier New,Courier,monospace">audio_sample_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">wearable</a> applications). For playing the recorded audio, use the same channel and sample type in both audio devices.</p>

<p>The sound types are defined in the <span style="font-family: Courier New,Courier,monospace">sound_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">wearable</a> applications). You can select the sound type according to the audio sample type.</p></li>
<li>
<p>To use the functions and data types of the Tone Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;tone_player.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files in your application:</p>
<pre class="prettyprint">
#include &lt;tone_player.h&gt;
#include &lt;sound_manager.h&gt;
</pre>
</li>

<li>
<p>To start using the tone player, declare a player ID variable for identifying the tone player:</p>
<pre class="prettyprint">
int tone_player_id;
</pre>
</li>
<li>
<p>To use the functions and data types of the WAV Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__WAV__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__WAV__PLAYER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;wav_player.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;wav_player.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sound_manager.h&gt;
</pre>
<p>In this guide, you also need the <span style="font-family: Courier New,Courier,monospace">&lt;stdio.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files to use standard file input and output functions and the Sound Manager API functions (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications).</p>
</li>
</ol>

<h2 id="prepare" name="prepare">Preparing the Player</h2>

<p>To initialize the player for use:</p>

<ol>
<li id="init_handle" name="init_handle">
<p>Define a variable for the player handle, and create the handle by passing the variable to the <span style="font-family: Courier New,Courier,monospace;">player_create()</span> function. You need the handle for defining which file to play and with what playback settings. The following example code also creates buttons for the UI to control the playback.</p>
<pre class="prettyprint">
struct appdata {
&nbsp;&nbsp;&nbsp;&nbsp;player_h player;
};

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_create(&amp;ad-&gt;player);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to create&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;   Perform more playback configuration, such as setting callbacks,
&nbsp;&nbsp;&nbsp;&nbsp;   setting the source file URI, and preparing the player
&nbsp;&nbsp;&nbsp;&nbsp;*/
}

static void
create_base_gui(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Create a window */
&nbsp;&nbsp;&nbsp;&nbsp;/* Create a button */
&nbsp;&nbsp;&nbsp;&nbsp;/* Add a callback to the button */
&nbsp;&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(button_init, &quot;clicked&quot;, init_base_player, ad);
&nbsp;&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(button_end, &quot;clicked&quot;, release_base_player, ad);
&nbsp;&nbsp;&nbsp;&nbsp;/* Create an Evas image object for the video surface */
}

static void
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;&nbsp;create_base_gui(ad);

&nbsp;&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>

<p>To receive notifications, register the appropriate callbacks:</p>

<ul>

<li>
<p>To receive notifications about playback interruptions, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_interrupted_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_interrupted_cb(player_interrupted_coded_e code, void *data)
{
&nbsp;&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;&nbsp;player_state_e state;

&nbsp;&nbsp;&nbsp;&nbsp;player_get_state(ad-&gt;player, &amp;state);
&nbsp;&nbsp;&nbsp;&nbsp;log_print(DLOG_INFO, LOG_TAG, &quot;current player state = %d&quot;, state);
&nbsp;&nbsp;&nbsp;&nbsp;/* If the state is PLAYER_STATE_PAUSED, update UI (for example, button) */
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Set an interruption callback if the application wants to know the reason */
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_set_interrupted_cb(g_player, _player_interrupted_cb, ad);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to create&quot;);
}
</pre>
<p>The playback is interrupted and the callback triggered when, for example, another multimedia application is run. The player state automatically changes to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span> or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> according to the session policy. To get the current state, use the <span style="font-family: Courier New,Courier,monospace;">player_get_state()</span> function.</p>
</li>

<li>
<p>To receive a notification when the playback ends, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_completed_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_completed_cb(void *data)
{
&nbsp;&nbsp; dlog_print(DLOG_INFO, &quot;Player&quot;, &quot;Playback End&quot;);
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Set a completed callback if the application wants to know when the playback ends */
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_set_completed_cb(g_player, _player_completed_cb, ad);

&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to set completed cb&quot;);
}
</pre>
</li>

<li>
<p>To receive notifications about player errors during playback, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_error_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_error_cb(int error_code, void *user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;playback failed, error = %x&quot;, error_code);
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_set_error_cb(g_player, _player_error_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to set error cb&quot;);
}
</pre>
<p>The player error callback is triggered when the player stops working due to an error. You can use the callback to try to recover from the error. For example, try to change the player state to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> by calling the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> function. Then remove all other callbacks and reset the player by calling the <span style="font-family: Courier New,Courier,monospace;">player_unprepare()</span> function. At the end, the player is in the <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> state, so you can release the resources allocated to the player.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">Do not call the <span style="font-family: Courier New,Courier,monospace;">player_destroy()</span> function from the called context, as this can cause the <span style="font-family: Courier New,Courier,monospace;">PLAYER_ERROR_INVALID_OPERATION</span> error.</td>
        </tr>
    </tbody>
</table>
</li>

</ul>

</li>

</ol>

<h2 id="play_audio" name="play_audio">Playing an Audio File</h2>

<p>To play an audio file:</p>

<ol>

<li>
<p>After creating the player handle, specify the audio file to play using the <span style="font-family: Courier New,Courier,monospace;">player_set_uri()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_uri(ad-&gt;player, audio_path);
</pre>
</li>

<li>
<p>Prepare the player for playback using the <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare(ad-&gt;player);
</pre>
<p>The function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li>
<p>Start playing the audio file using the <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function:</p>
<pre class="prettyprint">
error_code = player_start(ad-&gt;player);
</pre>
<p>The function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>. The audio file plays until you call the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> or <span style="font-family: Courier New,Courier,monospace;">player_pause()</span> function.</p>
</li>

</ol>

<h2 id="play_video" name="play_video">Playing a Video File</h2>

<p>To play a video file:</p>

<ol>

<li>
<p>After creating the player handle, specify the video file to play using the <span style="font-family: Courier New,Courier,monospace;">player_set_uri()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_uri(ad-&gt;player, video_path);
</pre>
</li>

<li id="play_video_display" name="play_video_display">
<p>Set the display on which the video is played.</p>
<p>To retrieve the correct display handle, use the <span style="font-family: Courier New,Courier,monospace;">GET_DISPLAY()</span> function. To set the display, use the <span style="font-family: Courier New,Courier,monospace;">player_set_display()</span> function with the player handle, display type (a <span style="font-family: Courier New,Courier,monospace;">player_display_type_e</span> enumerator in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html#ga6b83386e10a8febc7e5dfbff85b342ab">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html#ga6b83386e10a8febc7e5dfbff85b342ab">wearable</a> applications), and display handle:</p>
<pre class="prettyprint">
error_code = player_set_display(g_player, PLAYER_DISPLAY_TYPE_OVERLAY, GET_DISPLAY(evas_obj));
</pre>
<p>After the <span style="font-family: Courier New,Courier,monospace;">player_set_display()</span> function has been successfully executed, the player is connected to the display.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">In case of an overlay surface, when the device orientation changes, the displayed video does not rotate automatically. If you want to change the video orientation according to the device orientation, use the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function within the <span style="font-family: Courier New,Courier,monospace;">app_device_orientation_cb()</span> callback function used by the application. In case of an Evas surface, the Evas object for the video is rotated by the window manager used by the application, not by the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function.</td>
        </tr>
    </tbody>
</table>
</li>

<li id="play_video_prepare" name="play_video_prepare">
<p>Prepare the player for playback using the <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare(ad-&gt;player);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function works synchronously, so it can block the application execution. To prepare the player asynchronously instead, use the <span style="font-family: Courier New,Courier,monospace;">player_prepare_async()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare_async(ad-&gt;player, _prepared_cb, ad);
</pre>
<p>Both functions change the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li id="play_video_play" name="play_video_play">
<p>Play the video file:</p>
<ol type="a">
<li>
<p>Ensure that the player state has changed to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>. To check the state, use the <span style="font-family: Courier New,Courier,monospace;">player_get_state()</span> function in a waiting loop:</p>
<pre class="prettyprint">
player_state_e state;
do {
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_get_state(ad-&gt;player, &amp;state);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;usleep(1000);
} while (state != PLAYER_STATE_READY);
</pre>
</li>
<li>
<p>Start playing the video file using the <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function:</p>
<pre class="prettyprint">
if (error_code == PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_start(g_player);
</pre>
<p>If you used the <span style="font-family: Courier New,Courier,monospace;">player_prepare_async()</span> function to prepare the player, use the following callback function to handle the playback:</p>
<pre class="prettyprint">
static void
_prepared_cb(void *data)
{
&nbsp;&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_start(ad-&gt;player);
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>. The video file plays until you call the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> or <span style="font-family: Courier New,Courier,monospace;">player_pause()</span> function.</p>
</li>
</ol>
</li>

</ol>

<h2 id="release" name="release">Stopping the Player and Releasing Resources</h2>

<p>To stop the player and release the resources allocated to the player:</p>

<ol>

<li>
<p>Stop the player using the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> function:</p>
<pre class="prettyprint">
error_code = player_stop(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_stop() = %d&quot;, error_code);
</pre>
</li>

<li>
<p>Reset the player using the <span style="font-family: Courier New,Courier,monospace;">player_unprepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_unprepare(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_unprepare() = %d&quot;, error_code);
</pre>
<p>After the player is reset, it is in the <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> state.</p>
</li>

<li>
<p>Destroy the player handle using the <span style="font-family: Courier New,Courier,monospace;">player_destroy()</span> function:</p>
<pre class="prettyprint">
error_code = player_destroy(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_destroy = %d&quot;, error_code);
</pre>
</li>

</ol>


<h2 id="play" name="play">Playing Multiple Files Simultaneously</h2>

<p>To play multiple files simultaneously:</p>

<ol>
<li>
<p>Define the variables for player handlers, player states, file paths, playback time, and return value.</p>
<p>In this guide, you also need the <span style="font-family: Courier New,Courier,monospace">&lt;stdio.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;unistd.h&gt;</span> header files to use standard file input and output functions and system calls.</p>
<pre class="prettyprint">
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

static player_h player_1;
static player_h player_2;
static player_h player_3;
static player_state_e state_1;
static player_state_e state_2;
static player_state_e state_3;
static int ret =0;
static char *path_1 = NULL;
static char *path_2 = NULL;
static char *path_3 = NULL;
char *resource_path = NULL;

resource_path = app_get_resource_path();
snprintf(path_1, sizeof(path_1)-1, &quot;%s/sample.3gp&quot;, resource_path);
snprintf(path_2, sizeof(path_2)-1, &quot;%s/test.wav&quot;, resource_path);
snprintf(path_3, sizeof(path_3)-1, &quot;%s/test2.wav&quot;, resource_path);
free(resource_path);

static const int PLAYBACK_TIME = 6;
</pre>
</li>
<li>
<p>Create a player handle for each file using the <span style="font-family: Courier New,Courier,monospace">player_create()</span> function:</p>
<pre class="prettyprint">
ret = player_create(&amp;player_1);

ret = player_create(&amp;player_2);

ret = player_create(&amp;player_3);
</pre>
</li>

<li>
<p>Specify the files to play using the <span style="font-family: Courier New,Courier,monospace">player_set_uri()</span> function:</p>
<pre class="prettyprint">
ret = player_set_uri(player_1, path_1);

ret = player_set_uri(player_2, path_2);

ret = player_set_uri(player_3, path_3);
</pre>
</li>

<li>
<p>Prepare the players for playback using the <span style="font-family: Courier New,Courier,monospace">player_prepare()</span> function:</p>
<pre class="prettyprint">
ret = player_prepare(player_1);

ret = player_prepare(player_2);

ret = player_prepare(player_3);
</pre>
<p>The function changes the player states from <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li>
<p>Play the files:</p>
<ol type="a">
<li>
<p>Ensure that the player states have changed to <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_READY</span>. To check the states, use the <span style="font-family: Courier New,Courier,monospace">player_get_state()</span> function in a waiting loop:</p>
<pre class="prettyprint">
/* Wait to prepare player_1 */
ret = player_get_state(player_1, &amp;state_1);

while (state_1 != PLAYER_STATE_READY) {
&nbsp;&nbsp;&nbsp;&nbsp;ret = player_get_state(player_1, &amp;state_1);

&nbsp;&nbsp;&nbsp;&nbsp;usleep(1000);
}

/* Wait to prepare player_2 */
ret = player_get_state(player_2, &amp;state_2);

while (state_2 != PLAYER_STATE_READY) {
&nbsp;&nbsp;&nbsp;&nbsp;ret = player_get_state(player_2, &amp;state_2);

&nbsp;&nbsp;&nbsp;&nbsp;usleep(1000);
}

/* Wait to prepare player_3 */
ret = player_get_state(player_3, &amp;state_3);

while (state_3 != PLAYER_STATE_READY) {
&nbsp;&nbsp;&nbsp;&nbsp;ret = player_get_state(player_3, &amp;state_3);

&nbsp;&nbsp;&nbsp;&nbsp;usleep(1000);
}
</pre>
</li>
<li>
<p>Start playing the files using the <span style="font-family: Courier New,Courier,monospace">player_start()</span> function:</p>
<pre class="prettyprint">
ret = player_start(player_1);

ret = player_start(player_2);

ret = player_start(player_3);
</pre>
</li>
</ol>
</li>

<li>
<p>After the playback has ended or been stopped, reset the players and destroy the player handles using the <span style="font-family: Courier New,Courier,monospace">player_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">player_destroy()</span> functions:</p>
<pre class="prettyprint">
ret = player_unprepare(player_1);
ret = player_destroy(player_1);

ret = player_unprepare(player_2);
ret = player_destroy(player_2);

ret = player_unprepare(player_3);
ret = player_destroy(player_3);
</pre>
</li>

</ol>

<h2 id="simple" name="simple">Managing Synchronous Playback</h2>

<p>You can <a href="#record">play an audio sample</a> and <a href="#modify">modify the volume of the playback</a>.</p>


<h3 id="record" name="record">Playing an Audio Sample</h3>

<p>The synchronous playback process blocks other processes running in the same thread. Launching a playback process from the main thread of the application can make the application unresponsive. To prevent this, launch the playback process from its own thread. For example, in this use case, the playback process is run inside the <span style="font-family: Courier New,Courier,monospace">synchronous_playback()</span> function, which is executed in a separate thread using the <span style="font-family: Courier New,Courier,monospace">ecore_thread_run()</span> function:</p>

<pre class="prettyprint">
ecore_thread_run(synchronous_playback, NULL, NULL, NULL);
</pre>

<p>To play audio:</p>

<ol>
<li><p>Prepare the audio output device and start the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio output device (starts the hardware playback process) */
error_code = audio_out_prepare(output);
</pre>

<p>The hardware device prepares its internal output buffer for playback. Playback begins when the internal output buffer starts receiving audio data.</p>

</li>
<li><p>To start playing the recorded audio, copy the audio data from the local buffer to the internal output buffer using the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function:</p>

<pre class="prettyprint">
/* Copy the audio data from the local buffer to the internal output buffer */
int bytes_number = audio_out_write(output, buffer, buffer_size);
</pre>
<p>The returned value represents the number of bytes written to the internal output buffer. A negative value represents an error code.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function behaves in a similar manner to the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function.</p>
</li>

<li><p>After all data has been copied to the internal output buffer, release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function:</p>
<pre class="prettyprint">
/* Release the memory allocated to the local buffer */
free(buffer);
</pre></li>

<li><p>Stop the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware playback process */
error_code = audio_out_unprepare(output);
</pre></li>

<li><p>After you have finished working with the audio output device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio output device */
error_code = audio_out_destroy(output);
</pre></li>
</ol>

<h3 id="modify" name="modify">Modifying the Audio Sample Volume</h3>

<table class="note">
 <tbody>
  <tr>
  <th class="note">Note</th>
  </tr>
  <tr>
   <td class="note">Modifying the volume only works if you have not emptied the local buffer or deinitialized the input audio device.</td>
  </tr>
 </tbody>
</table>

<p>To modify the volume of the audio sample stored in the local buffer:</p>

<pre class="prettyprint">
#define MIN_2BYTES_SIGNED (−32768)
#define MAX_2BYTES_SIGNED 32767

void
modify_sound()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Retrieve the sample type of the input */
&nbsp;&nbsp;&nbsp;&nbsp;audio_sample_type_e sample_type;

&nbsp;&nbsp;&nbsp;&nbsp;int error_code = audio_in_get_sample_type(input, &amp;sample_type);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_get_sample_type() failed! Error code = %d&quot;, error_code);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *index = (uint8_t*)buffer;
&nbsp;&nbsp;&nbsp;&nbsp;while (index &lt; (((uint8_t*)buffer)+buffer_size)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AUDIO_SAMPLE_TYPE_S16_LE == sample_type) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the int16_t type, because it is 2 bytes long */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int16_t *value = (int16_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make the sample louder */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t tmp = (*value) * 8; /* Why not 8 times louder? (on dB scale even much louder) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; MAX_2BYTES_SIGNED)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = MAX_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &lt; MIN_2BYTES_SIGNED)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = MIN_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the uint8_t type, because it is 1 byte long */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *value = (uint8_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make the sample louder */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t tmp = (*value) * 8; /* Why not 8 times louder? (on dB scale even much louder) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; 255)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Go to the next sample */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index += sample_type == AUDIO_SAMPLE_TYPE_S16_LE ? 2 : 1;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Volume of the synchronous recording increased.&quot;);
}
</pre>

<p>In this example, the volume is significantly increased. You can also make other modifications to the audio sample playback.</p>

<h2 id="async" name="async">Managing Asynchronous Playback</h2>

<p>Playing audio asynchronously involves:</p>

<ol>
    <li><p><a href="#start">Starting asynchronous playback</a></p></li>
    <li><p><a href="#stop_async">Stopping asynchronous playback</a></p></li>
</ol>

<h3 id="start" name="start">Starting Asynchronous Playback</h3>

<p>The asynchronous playback process uses a callback function for playing the recorded audio. The callback function is invoked asynchronously for each chunk of recorded audio. In this use case, the audio data is read from a file rather than a local buffer.</p>

<p>To start playing the recorded audio:</p>

<ol><li>
<p>Set the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function:</p>

<pre class="prettyprint">
/* Set a callback function that is invoked asynchronously for each chunk of stored (recorded) audio */
error_code = audio_out_set_stream_cb(output, _audio_io_stream_write_cb, NULL);
</pre>
</li>
<li>
<p>Open the file where the audio data is stored:</p>

<pre class="prettyprint">
#include &lt;storage.h&gt;

/* Prepare the file where the recorded audio data is stored */
char io_stream_r_path[200];
char *storage_path;
/* You can find the storage ID using the storage_foreach_device_supported() function */
int error = storage_get_directory(storage_id, STORAGE_DIRECTORY_SOUNDS, &amp;storage_path);
snprintf(io_stream_r_path, 200, &quot;%s/%s&quot;, storage_path, &quot;pcm_w.raw&quot;);
free(storage_path);

FILE* fp_r = fopen(io_stream_r_path, &quot;r&quot;);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">storage_get_directory()</span> function of the Storage API retrieves the storage path based on the storage ID. To retrieve the storage ID, use the <span style="font-family: Courier New,Courier,monospace">storage_foreach_device_supported()</span> function of the Storage API.</p>
</li>

<li>
<p>Prepare the audio output device and start the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio output device (starts the hardware playback process) */
error_code = audio_out_prepare(output);
</pre>
<p>The hardware device prepares its internal output buffer for playback.</p>
</li>
<li>

<p>To play the audio from the file (inside the callback function):</p>
<ol type="a">

<li><p>Allocate a local buffer for the audio data using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function. The function returns a pointer to the buffer. Reset the buffer by filling it with zeros using the <span style="font-family: Courier New,Courier,monospace">memset()</span> function.</p></li>

<li><p>Read audio data from the file and store the data in the local buffer using the <span style="font-family: Courier New,Courier,monospace">fread()</span> function.</p></li>

<li><p>Copy the audio data from the local buffer to the internal output buffer using the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function. Playback begins when the internal output buffer starts receiving the audio data.</p></li>

<li><p>Release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function.</p></li>

</ol>

<pre class="prettyprint">
/* Callback invoked for each chunk of stored (recorded) audio */
void
_audio_io_stream_write_cb(audio_out_h handle, size_t nbytes, void *userdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;char * buffer = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;if (nbytes &gt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Allocate and reset a local buffer for reading the audio data from the file */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = malloc(nbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(buffer, 0, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Read audio data from the file and store it in the local buffer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fread(buffer, sizeof(char), nbytes, fp_r);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Copy the audio data from the local buffer to the internal output buffer (starts playback) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int data_size = audio_out_write(handle, buffer, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data_size &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_out_write() failed! Error code = %d&quot;, data_size);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Release the memory allocated to the local buffer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre></li></ol>

<h3 id="stop_async" name="stop_async">Stopping Asynchronous Playback</h3>

<p>To stop playing the recorded audio:</p>

<ol><li><p>Stop the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware playback process */
error_code = audio_out_unprepare(output);
</pre>
<p>The device no longer invokes the callback function.</p>
</li>
<li>
<p>If you no longer need asynchronous playback, or if you want to set the callback function separately for each asynchronous playback session, unset the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> function:</p>

<pre class="prettyprint">
/* Unset the callback function used for asynchronous playback */
error_code = audio_out_unset_stream_cb(output);
</pre>
</li>

<li><p>After you have finished working with the audio output device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio output device */
error_code = audio_out_destroy(output);
</pre></li>

<li>
<p>Close the file where the recorded audio is stored using the <span style="font-family: Courier New,Courier,monospace">fclose()</span> function:</p>
<pre class="prettyprint">
/* Close the file used for asynchronous playback */
error_code = fclose(fp_r);
fp_r = NULL;
</pre>
</li>
</ol>

<h2 id="start" name="start">Starting and Stopping the WAV Player</h2>

<p>To start and stop the WAV player:</p>

<ol>

<li>
<p>To start the WAV player, use the <span style="font-family: Courier New,Courier,monospace">wav_player_start()</span> function.</p>
<p>The third parameter defines a callback that is invoked when the player finishes playback. Implement the callback and handle any post-playback actions in it.</p>
<p>The final parameter returns the WAV player ID, which you need to stop the player.</p>
<pre class="prettyprint">
static void
_playback_completed_cb(int id, void *user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;const char* path = (const char*)user_data;
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, &quot;WAV Player&quot;, &quot;Completed! [id:%d, path:%s]&quot;, id, path);
}

void
main()
{
&nbsp;&nbsp;&nbsp;&nbsp;int wav_player_id;
&nbsp;&nbsp;&nbsp;&nbsp;wav_player_error_e ret;
&nbsp;&nbsp;&nbsp;&nbsp;const char* wav_path = &quot;PATH OF YOUR WAV FILE&quot;;

&nbsp;&nbsp;&nbsp;&nbsp;ret = wav_player_start(wav_path, SOUND_TYPE_MEDIA, _playback_completed_cb, (void*)wav_path, &amp;wav_player_id);
}
</pre>
<p>To set the path of your WAV file, you may need to retrieve the default path for audio files. For more information, see the <a href="../data/data_storages_n.htm">Data Storages</a> guide.</p>
</li>

<li>
<p>To stop the WAV player, use the <span style="font-family: Courier New,Courier,monospace">wav_player_stop()</span> function with the ID of the WAV player:</p>
<pre class="prettyprint">
void
my_stop()
{
&nbsp;&nbsp;&nbsp;&nbsp;wav_player_error_e ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = wav_player_stop(wav_player_id);
}
</pre>
</li>

</ol>

<h2 id="play_tone" name="play_tone">Playing a Tone</h2>

<p>To start and stop playing a tone:</p>

<ol>

<li>
<p>To start playback, use the <span style="font-family: Courier New,Courier,monospace">tone_player_start()</span> function.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">tone_type_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html#gaf12912b2c8f9ffe720518ce797506574">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__TONE__PLAYER__MODULE.html#gaf12912b2c8f9ffe720518ce797506574">wearable</a> applications) and <span style="font-family: Courier New,Courier,monospace">sound_type_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">wearable</a> applications) enumerators define the available values for the tone type (first parameter) and sound type (second parameter).</p>
<pre class="prettyprint">
tone_player_start(TONE_TYPE_DEFAULT, SOUND_TYPE_MEDIA, -1, &amp;tone_player_id);
</pre>
<p>The player ID is assigned and returned if the function succeeds. The ID of the tone player that starts first is 0, the ID of the second one is 1, and so on. If you set the player ID parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>, the ID is not returned.</p>
</li>

<li>
<p>To stop playback, use the <span style="font-family: Courier New,Courier,monospace">tone_player_stop()</span> function with the ID of the player you want to stop:</p>
<pre class="prettyprint">
tone_player_stop(tone_player_id);
</pre>
</li>

</ol>

<h2 id="duration" name="duration">Playing a Tone for a Specified Duration</h2>

<p>To play a tone for a specified duration, use the <span style="font-family: Courier New,Courier,monospace">tone_player_start()</span> function with the duration (third parameter) set to the number of milliseconds you want playback to last:</p>
<pre class="prettyprint">
tone_player_start(TONE_TYPE_SUP_CONGESTION, SOUND_TYPE_CALL, 1000, &amp;tone_player_id);
</pre>
<p>When you set the duration to a specified time, playback stops automatically after that time. You can also stop playback manually using the <span style="font-family: Courier New,Courier,monospace">tone_player_stop()</span> function.</p>

<h2 id="set_parameters" name="set_parameters">Configuring the Video Playback Display</h2>

<p>To set the display parameters for playing a video file:</p>

<ol>

<li><p>Make sure that the <a href="#init_handle">player handle has been created</a>, the <a href="#play_video_display">display set</a>, and the <a href="#play_video_prepare">player prepared</a> and <a href="#play_video_play">started</a>.</p></li>

<li>

<p>During playback, you can manage the display settings as needed:</p>

<ul>

<li>
<p>Make the display visible:</p>
<ol type="a">
<li>
<p>Check whether the display is already visible using the <span style="font-family: Courier New,Courier,monospace;">player_is_display_visible()</span> function:</p>
<pre class="prettyprint">
bool is_visible;

error_code = player_is_display_visible(player, &amp;is_visible);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_is_display_visible = %d&quot;, error_code);
</pre>
</li>
<li>
<p>If the display is not visible, make it visible using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_visible()</span> function with the second parameter set to <span style="font-family: Courier New,Courier,monospace;">true</span>:</p>
<pre class="prettyprint">
if (!is_visible) {
&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_set_display_visible(player, true);
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_visible = %d&quot;, error_code);
}
</pre>
</li>
</ol>
</li>

<li>
<p>Set the display mode using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_mode()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_display_mode(player, PLAYER_DISPLAY_MODE_FULL_SCREEN);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
<p>The available display modes are defined in the <span style="font-family: Courier New,Courier,monospace;">player_display_mode_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gaafcf6f7487d8cb376e1851a6e1253f3a">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gaafcf6f7487d8cb376e1851a6e1253f3a">wearable</a> applications).</p>
</li>

<li>
<p>Set the display rotation using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_display_rotation(player, PLAYER_DISPLAY_ROTATION_90);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
<p>The available display rotations are defined in the <span style="font-family: Courier New,Courier,monospace;">player_display_rotation_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gab8c4c170d4b2628a09831edc8d652302">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gab8c4c170d4b2628a09831edc8d652302">wearable</a> applications).</p>
</li>

</ul>

</li>

</ol>

<h2 id="get_stream" name="get_stream">Retrieving Stream Information</h2>

<p>To retrieve information about the audio and video streams:</p>

<ol>

<li>
<p><a href="#init_handle">Create the player handle</a>, <a href="#play_video">prepare and start the player</a>, and <a href="#set_parameters">set the display parameters</a>.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">To retrieve the stream information, the player state must be either <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span> or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span>.</td>
        </tr>
    </tbody>
</table>
</li>

<li>
<p>Retrieve the stream information:</p>
<ul>
<li>
<p>Video display size</p>
<p>Retrieve the width and height of the video display using the <span style="font-family: Courier New,Courier,monospace;">player_get_video_size()</span> function:</p>
<pre class="prettyprint">
int width;
int height;

error_code = player_get_video_size(player, &amp;width, &amp;height);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_is_display_visible = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Duration</p>
<p>Retrieve the total media running time (in milliseconds) using the <span style="font-family: Courier New,Courier,monospace;">player_get_duration()</span> function:</p>
<pre class="prettyprint">
int duration;

error_code = player_get_duration(player, &amp;duration);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_duration = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Audio stream details</p>
<p>Retrieve the audio stream details using the <span style="font-family: Courier New,Courier,monospace;">player_get_audio_stream_info()</span> function. The function returns the audio sample rate (in Hz), number of audio channels (1 for mono or 2 for stereo), and audio bit rate (in Hz).</p>
<pre class="prettyprint">
int sample_rate;
int channels;
int bit_rate;

error_code = player_get_audio_stream_info(player, &amp;sample_rate, &amp;channels, &amp;bit_rate);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_audio_stream_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Video stream details</p>
<p>Retrieve the video stream details using the <span style="font-family: Courier New,Courier,monospace;">player_get_video_stream_info()</span> function. The function returns the number of frames per second and the video bit rate (in Hz).</p>
<pre class="prettyprint">
int fps;
int bit_rate;

error_code = player_get_video_stream_info(player, &amp;fps, &amp;bit_rate);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_video_stream_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Audio and video codec names</p>
<p>Retrieve the audio and video codec names using the <span style="font-family: Courier New,Courier,monospace;">player_get_codec_info()</span> function:</p>
<pre class="prettyprint">
char *audio_codec;
char *video_codec;

error_code = player_get_codec_info(player, &amp;audio_codec, &amp;video_codec);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_codec_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Content metadata</p>
<p>Retrieve information about the album, artist, author, genre, title, and year using the <span style="font-family: Courier New,Courier,monospace;">player_get_content_info()</span> function. The available metadata attributes are defined in the <span style="font-family: Courier New,Courier,monospace;">player_content_info_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__STREAM__INFO__MODULE.html#ga2d25f300270965c3ea302b7a7e845f12">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__STREAM__INFO__MODULE.html#ga2d25f300270965c3ea302b7a7e845f12">wearable</a> applications).</p>

<pre class="prettyprint">
char *album;
char *artist;
char *author;
char *genre;
char *title;
char *year;

error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_ALBUM, &amp;album);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info album = %d&quot;, album);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_ARTIST, &amp;artist);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info artist = %d&quot;, artist);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_AUTHOR, &amp;author);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info author = %d&quot;, author);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_GENRE, &amp;genre);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info genre = %d&quot;, genre);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_TITLE, &amp;title);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info title = %d&quot;, title);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_YEAR, &amp;year);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info year = %d&quot;, year);
</pre>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">The values must be released using the <span style="font-family: Courier New,Courier,monospace;">free()</span> function.</td>
        </tr>
    </tbody>
</table>
</li>
<li>
<p>Album artwork</p>
<p>Retrieve the album artwork using the <span style="font-family: Courier New,Courier,monospace;">player_get_album_art()</span> function. The function returns the encoded artwork image and size.</p>
<pre class="prettyprint">
void *album_art;
int size;

error_code = player_get_album_art(player, &amp;album_art, &amp;size);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
</li>
</ul>
</li>

</ol>

<h2 id="insert" name="insert">Inserting Subtitles</h2>

<p>To insert subtitles to a video file:</p>

<ol>

<li><p><a href="#init_handle">Create the player handle.</a></p></li>

<li>
<p>Set the subtitle path using the <span style="font-family: Courier New,Courier,monospace;">player_set_subtitle_path()</span> function:</p>
<pre class="prettyprint">
#define SUBTITLE &quot;subtitles_test_file.srt&quot;

char *data_path = app_get_data_path();
int path_len = strlen(data_path) + 10;
char *path = malloc(path_len);
strncat(path, data_path, path_len);
strncat(path, SUBTITLE, path_len);

error_code = player_set_subtitle_path(player, path);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_subtitle_path() = %d&quot;, error_code);
free(path);
</pre>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">You can set the subtitle path when the player state is <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span>, <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>, or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span>.</td>
        </tr>
    </tbody>
</table>
</li>

</ol>
  
  
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
  <title>Voice Control</title>
 </head>
 <body onload="prettyPrint()" style="overflow: auto;">

 <div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/></p>
    </div>

    <div id="toc_border"><div id="toc">
		<p class="toc-title">Dependencies</p>
		<ul class="toc">
			<li>Tizen Platform 2.4 and Higher for Mobile</li>
		</ul>
		<p class="toc-title">Content</p>
			<ul class="toc">
				<li><a href="#voice">Voice Control Service</a></li>
				<li><a href="#elementary">Voice Control with Elementary Components</a></li>
				<li><a href="#prerequisites">Prerequisites</a></li>
				<li><a href="#callback">Managing Callbacks</a></li>
				<li><a href="#info">Retrieving Voice Control Information</a></li>
				<li><a href="#commands">Managing Commands</a></li>
				<li>Elementary control
				<ul class="toc">
					<li><a href="#callback">Monitoring Language Changes</a></li>
					<li><a href="#info">Retrieving Voice Control Information</a></li>
					<li><a href="#command_hint">Managing Commands and Hints</a></li>
				</ul>
				</li>
			</ul>		
        <p class="toc-title">Related Info</p>
        <ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__VOICE__CONTROL__MODULE.html">Voice control API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__VOICE__CONTROL__ELEMENTARY__MODULE.html">Voice control elementary API for Mobile Native</a></li>
			<li><a href="https://developer.tizen.org/development/sample/native/UIX/Voice_Control" target="_blank">Voice Control Sample Description</a></li>
			<li><a href="https://developer.tizen.org/development/sample/native/UIX/Voice_Control_Elm" target="_blank">Voice Control Elm Sample Description</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
 
<h1>Voice Control</h1>

<p>Voice control features allow the user to control the device through their voice. You can register general voice commands, which trigger a callback when the user speaks them. You can also register voice commands for EFL-supported UI components to perform component-related actions, such as button clicks.</p>

  <p>This feature is supported in mobile applications only.</p>  

<h2 id="voice">Voice Control Service</h2>
  
<p>You can recognize the sound data recorded by the user and send the result as a predefined command using the Voice control service.</p>
  
<p>The main features of the Voice control API include:</p>  
<ul>  
<li>Managing commands
	<p>You can use the Voice control service to register commands as foreground or background type. When the user speaks a registered command, the callback function returns the recognition result.</p></li>
<li>Retrieving information
	<p>You can <a href="#info">get various information</a> from the voice control:</p>
	<ul><li>Voice control state
<p>The state is changed by functions and applied as a precondition of each API.</p></li>
<li>Voice control service state
<p>The user controls the state by starting and stopping command recognition.</p></li>
<li>Current language
<p>A command is valid only when the command language is the same as the current language. The current language can be changed by changing the application or display language in the device.</p>
<p>You can get a notification of the language change in a callback. If the display language is changed to a non-supported one, the voice control language changed to English.</p></li>
<li>Supported language
<p>You can retrieve a list of supported languages to check whether the language that you want is supported.</p></li></ul>
</li>
</ul>  
  
<p>To use the voice control:</p>
<ol><li>Set up the voice control and <a href="#callback">register callback functions</a>.
<p>The initialization allows the voice control to distinguish your application from any other applications also using voice control. The registered callbacks allow you to receive notifications about changes in the service state, language, and recognition result, and about any errors.</p></li>
<li>Prepare the voice control.
<p>The preparation connects the Voice control service for background work, such as recording and recognizing the user voice.</p>
<p>When the application initializes and prepares the voice control, the Voice control daemon is invoked and connected for background work. The daemon and the application communicate as server and client.</p>
</li>
<li>Set commands.
<p>You can <a href="#commands">create a command list</a>, and add or remove individual commands in the list. When creating an individual command, set the command text and type for each command handle. When all commands are created and added to the command list, set the command list to the voice control for recognition.</p></li>
<li>Get the recognition result.
<p>The recognition result is sent through a registered callback function.</p>
<p>If the registered command is duplicated or the user speaks multiple commands, the recognition result can contain multiple results. If you set duplicated commands, the Voice control service can reject the command. The rejection is shown in the result event.</p></li>
<li>When no longer needed, unprepare and deinitialize the voice control.
<p>You must disconnect the voice control service and deinitialize the voice control using the <span style="font-family: Courier New,Courier,monospace">vc_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">vc_deinitialize()</span> functions.</p></li></ol>

<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the voice control functionality</a>.</p>

<p>The following figure illustrates the voice control life-cycle states.</p>
 
			<p class="figure">Figure: Voice control (left) and Voice control service (right) life-cycle states</p>
			<p align="center"><img alt="Voice control and Voice control service life-cycle states" src="../../images/voice_control.png" /></p> 
  

<h2 id="elementary">Voice Control with Elementary Components</h2>

  <p>You can register voice commands for EFL-supported UI components to allow the user to interact with visible UI components inside the application using their voice. The Voice control elementary library recognizes spoken commands from registered UI components. </p>
  
  <p>The following figure illustrates the application screen when the Voice control elementary features are enabled. When the screen is updated, any UI components that have a registered command and hint are shown with a tooltip (hint). When the user speaks the hint, the callback function of the action related to the UI component is executed.</p>
<p class="figure">Figure: Voice command hints on the screen</p>
			<p align="center"><img alt="Voice command hints on the screen" src="../../images/voice_control_elm_screen.png" /></p> 
  
 <p>You have no need to consider how to recognize voice commands or start and stop the recognition process. A preloaded voice application handles the process automatically. You just need to set the command and hint on every EFL elementary component on which you want to use the voice command.</p>

<p>When the user speaks a command corresponding to a visible EFL elementary component on the screen, the recognized command is sent to the Voice control elementary library from the Voice control service, and the action mapped to the component is executed. For example, if the component is a button, the action can be a button click.</p> 
 
 
			<p class="figure">Figure: Voice command process</p>
			<p align="center"><img alt="Voice command process" src="../../images/voice_control_elm.png" /></p> 
  
  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">The detailed implementation of the preloaded voice application (how to trigger and recognize the user speaking) can differ according to the device (mobile, wearable, or TV).</td> 
    </tr> 
   </tbody> 
  </table>    
  
  
<p>The main features of the Voice control elementary API include:</p>  
<ul>  
<li>Managing commands and hints
	<p>You can <a href="#command_hint">set commands and hints</a> for visible UI components on the application screen. The hint message shows the user which command must be spoken to interact with that UI component. When the user speaks a command, the command is executed.</p></li>
<li>Retrieving information
	<p>You can <a href="#info">get various information</a> from the Voice control elementary API:</p>
	<ul><li>Default language
<p>You can start the recognition with any language you want. However, if you do not set a specific language, the Voice control elementary library start recognizing voice commands with the default language.</p></li>
<li>Supported language
<p>You can retrieve a list of supported languages to check whether the language that you want is supported.</p></li>
<li>Supported UI components, actions, and commands
<p>You can retrieve a list of supported UI components that can be interacted with using the voice commands. You can also retrieve a list of supported actions and their commands for each UI component type.</p></li></ul>
</li>
</ul>  

<p>You can <a href="#callback">set and unset a callback</a> to get notifications when the system or application language changes.</p>

<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the voice control elementary functionality</a>.</p>
 
<p>The following table lists the EFL UI components that support voice commands, and the actions supported by each component and already defined in the configuration file. Note that the label component only supports the hint without any action command.</p>  
<table>
<caption>Table: UI components and their actions</caption>
<tbody>
<tr>
 <th rowspan="2">UI component</th>
 <th colspan="5">Action/command</th>
</tr>
<tr>
 <th>click/()</th>
 <th>up/up</th>
 <th>down/down</th>
 <th>left/left</th>
 <th>right/right</th>
</tr>
 <tr>
 <td>Button</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Check</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Ctxpopup</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Entry</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Gengrid</td>
 <td>No</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td> 
 </tr>
 <tr>
 <td>Genlist</td>
 <td>No</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Label</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Radio</td>
 <td>Yes</td>
 <td>No</td>
 <td>No</td>
 <td>No</td>
 <td>No</td> 
 </tr>
 <tr>
 <td>Slider</td>
 <td>No</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td> 
 </tr>
 <tr>
 <td>Spinner</td>
 <td>No</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td> 
 </tr>
 <tr>
 <td>Toolbar</td>
 <td>No</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td>
 <td>Yes</td> 
 </tr> 
 </tbody></table>  
  
  
  
<p>To use the voice commands:</p>

<ol><li>Initialize the Voice control elementary library and create a handle.
<p>The Voice control elementary handle is used to set user-defined commands and hints for the corresponding UI component in the application.</p></li>
<li>Set commands and hints.
<p>With a handle related to the individual UI component in the application screen, you can specify a command used to distinguish that component from others.</p>
<p>Along with the command, you can set a hint message. The command and hint can be different, but consistency tends to create a better user experience. You can also set a hint without a command simply to provide information to the user.</p>
</li>
<li>When no longer needed, destroy the handle and deinitialize the Voice control elementary library.</li></ol>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">Set the commands and hints on visible EFL elementary UI components only. When the visible components on the screen change, the commands and hints must also change.</td> 
    </tr> 
   </tbody> 
  </table>     

 <h2>Warm-up</h2>
  <p>Become familiar with the Voice control and Voice control elementary API basics by learning about:</p>
  <ul>
  <li><a href="#prerequisites">Prerequisites</a>
		<p>Prepare your application to use the voice control functionality.</p></li>
  <li><a href="#callback">Managing Callbacks</a>
    <p>Set and unset callbacks to get notifications about recognition results, state changes, and errors.</p></li>
  <li><a href="#info">Retrieving Voice Control Information</a>
    <p>Get information about the current states, and current and supported languages.</p></li>
  <li><a href="#commands">Managing Commands</a>
    <p>Create a command list and commands.</p></li>
  <li>Elementary control
  <ul>
	  <li><a href="#callback">Monitoring Language Changes</a>
		<p>Set and unset a callback to get notifications when the system or application language changes.</p></li>
	  <li><a href="#info">Retrieving Voice Control Information</a>
		<p>Get information about supported languages, widgets, and actions.</p></li>
	  <li><a href="#command_hint">Managing Commands and Hints</a>
		<p>Set and unset commands and hints, and define the hint direction and offset.</p></li>	
  </ul>
  </li>
  </ul>

  
<h2 id="prerequisites">Prerequisites</h2>

<p>To enable your application to use the voice control functionality:</p>
<ol>

<li>
<p>To use the functions and data types of the <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__VOICE__CONTROL__MODULE.html">Voice control</a> API, include the <span style="font-family: Courier New,Courier,monospace">&lt;voice_control.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;voice_control.h&gt;
</pre>
</li>
<li>Initialize the voice control with the <span style="font-family: Courier New,Courier,monospace">vc_initialize()</span> function:
<pre class="prettyprint">
void
initialize_voice_control()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_initialize();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
<p>If the function call is successful, the voice control state changes to <span style="font-family: Courier New,Courier,monospace">VC_STATE_INITIALIZED</span>.</p>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">The voice control feature is not thread-safe and depends on the ecore main loop. Implement voice control within the ecore main loop and do not use it in a thread.</td> 
    </tr> 
   </tbody> 
  </table> 

</li>
<li>Prepare the Voice control service with the <span style="font-family: Courier New,Courier,monospace">vc_prepare()</span> function, which connects the background Voice control daemon. The daemon records and recognizes audio data and converts sound to text.


<pre class="prettyprint">
void
prepare_vc()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_prepare();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">vc_prepare()</span> function is asynchronous, and when the preparation succeeds, the voice control state changes from <span style="font-family: Courier New,Courier,monospace">VC_STATE_INITIALIZED</span> to <span style="font-family: Courier New,Courier,monospace">VC_STATE_READY</span>. If the <span style="font-family: Courier New,Courier,monospace">vc_prepare()</span> function fails, the error callback is triggered.</p> 
</li>
<li>When the voice control is no longer needed, unprepare and deinitialize it:
<pre class="prettyprint">
void
unprepared_vc()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unprepare();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
deinitialize_voice_control()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_deinitialize();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>

<p>When the <span style="font-family: Courier New,Courier,monospace">vc_unprepare()</span> function succeeds, the voice control state changes from <span style="font-family: Courier New,Courier,monospace">VC_STATE_READY</span> to <span style="font-family: Courier New,Courier,monospace">VC_STATE_INITIALIZED</span>.</p>  
  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">Do not call the <span style="font-family: Courier New,Courier,monospace">vc_deinitialize()</span> function in a callback. Within a callback, the <span style="font-family: Courier New,Courier,monospace">vc_deinitialize()</span> function fails and returns <span style="font-family: Courier New,Courier,monospace">VC_ERROR_OPERATION_FAILED</span>.</td> 
    </tr> 
   </tbody> 
  </table>
  </li>
<li>To use the functions and data types of the <a href="../../../../org.tizen.native.mobile.apireference/group__VOICE__CONTROL__ELEMENTARY__MODULE.html">Voice control elementary</a> API, include the <span style="font-family: Courier New,Courier,monospace">&lt;voice_control_elm.h&gt;</span> header file in your application:
<pre class="prettyprint">
#include &lt;voice_control_elm.h&gt;
</pre>
</li>
<li>Initialize the Voice control elementary library with the <span style="font-family: Courier New,Courier,monospace">vc_elm_initialize()</span> function:
<pre class="prettyprint">
void
initialize_voice_control_elm()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_initialize();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Create a handle for each UI component for which you want to set a command and hint. 
<p>Use the <span style="font-family: Courier New,Courier,monospace">vc_elm_create_object()</span> function to create a handle for <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> instances, and the <span style="font-family: Courier New,Courier,monospace">vc_elm_create_item()</span> function for <span style="font-family: Courier New,Courier,monospace">Elm_Object_Item</span> instances.</p>
<pre class="prettyprint">
void
create_vc_elm_handler()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_h handler_object;
&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_h handler_item;

&nbsp;&nbsp;&nbsp;&nbsp;/* Creating Evas_Object button */
&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *button = elm_button_add(win);
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_create_object(button, &amp;handler_object);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
&nbsp;&nbsp;&nbsp;&nbsp;/* Creating Elm_Object_Item list */
&nbsp;&nbsp;&nbsp;&nbsp;Elm_Object_Item *item = elm_list_item_append(...);
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_create_item(item, &amp;handler_item);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>When voice control is no longer needed, destroy the handle and deinitialize the library:
<pre class="prettyprint">
void
destroy_vc_elm_handler(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_destroy(handler);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
deinitialize_voice_control_elm()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_deinitialize();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>  
</ol>

      <h2 id="callback" name="callback">Managing Callbacks</h2>
<p>The callback functions are defined in the <span style="font-family: Courier New,Courier,monospace">voice_control_common.h</span> header file, where you can find more information about them.</p>
	
<p>To set and unset callbacks to get notifications about recognition results, state changes, and errors:</p>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">Set and unset all callbacks when the voice control state is <span style="font-family: Courier New,Courier,monospace">VC_STATE_INITIALIZED</span>.</td> 
    </tr> 
   </tbody> 
  </table>

<ul>
<li>Set the state change callback to be invoked when the voice control state changes:
<pre class="prettyprint">
/* Callback */
void
state_changed_cb(vc_state_e previous, vc_state_e current, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Your code */
}

/* Set */
void
set_state_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_state_changed_cb(state_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Unset */
void
unset_state_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_state_changed_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Set the service state change callback to be invoked when the Voice control service state changes:
<pre class="prettyprint">
/* Callback */
void
__service_state_changed_cb(vc_service_state_e previous, vc_service_state_e current, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Your code */
}

/* Set */
void
set_service_state_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_service_state_changed_cb(__service_state_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Unset */
void
unset_service_state_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_service_state_changed_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>

<li>Set the current language change callback to be invoked when the system or application language changes:
<pre class="prettyprint">
/* Callback */
void
__current_language_changed_cb(const char* previous, const char* current, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Your code */
}

/* Set */
void
set_current_language_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_current_language_changed_cb(__current_language_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Unset */
void
unset_current_language_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_current_language_changed_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Set the recognition result callback to be invoked when a voice command is recognized.

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">If the recognition result produces a reject event, the Voice control service has rejected the recognized command. Make sure that the command does not conflict with other commands and there are not duplicated commands.</td> 
    </tr> 
   </tbody> 
  </table>
  
<p>To get the command, use the Voice control APIs with the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list</span> parameter, which is a list of recognized commands. The <span style="font-family: Courier New,Courier,monospace">result</span> parameter contains the recognized text.</p>  

<pre class="prettyprint">
/* Callback */
void
__result_cb(vc_result_event_e event, vc_cmd_list_h vc_cmd_list, const char* result, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret = -1;
&nbsp;&nbsp;&nbsp;&nbsp;int count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_get_count(vc_cmd_list, &amp;count);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* No result */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_list_first(vc_cmd_list);

&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;int type = 0;
&nbsp;&nbsp;&nbsp;&nbsp;char* cmd = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_h result_command = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_command = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_get_current(vc_cmd_list, &amp;result_command);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (0 == ret &amp;&amp; NULL != result_command) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_get_command(result_command, &amp;cmd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_get_type(result_command, &amp;type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Check command and type */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return;
}

/* Set */
void
set_result_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_result_cb(__result_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Unset */
void
unset_result_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_result_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Set the error callback to be invoked when an error occurs in the voice control process:
<pre class="prettyprint">
/* Callback */
void
__error_cb(vc_error_e reason, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Your code */
}

/* Set */
void
set_error_cb(vc_h vc)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_error_cb(__error_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Unset */
void
unset_error_cb(vc_h vc)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_error_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li></ul>
   
   
    <h2 id="info" name="info">Retrieving Voice Control Information</h2>
	
<p>To get information about the current states, and current and supported languages:</p>

<ul>
<li>
<p>Get the current voice control state using the <span style="font-family: Courier New,Courier,monospace">vc_get_state()</span> function.</p>
<p>The voice control state changes according to function calls when the voice control is, for example, initialized and prepared.</p>
<pre class="prettyprint">
void
get_state()
{
&nbsp;&nbsp;&nbsp;&nbsp;vc_state_e current_state;
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_get_state(&amp;current_state);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>
<p>Get the current voice control service state using the <span style="font-family: Courier New,Courier,monospace">vc_get_service_state()</span> function.</p>
<p>The user controls the voice control service state. In a general scenario:</p>
<ol><li>The user starts recording for recognition by using a voice application, button, or voice trigger. If the start is successful, the voice control service state changes to <span style="font-family: Courier New,Courier,monospace">VC_SERVICE_STATE_RECORDING</span>.</li>
<li>After recording, the service state changes to <span style="font-family: Courier New,Courier,monospace">VC_SERVICE_STATE_PROCESSING</span> for recognition processing.</li>
<li>After recognition is completed, the service state returns to <span style="font-family: Courier New,Courier,monospace">VC_SERVICE_STATE_READY</span>.</li></ol>
<p>If the application uses continuous recognition, the voice control service state can be changed from <span style="font-family: Courier New,Courier,monospace">VC_SERVICE_STATE_PROCESSING</span> directly to <span style="font-family: Courier New,Courier,monospace">VC_SERVICE_STATE_RECORDING</span>.</p>

<pre class="prettyprint">
void
get_state(vc_h vc)
{
&nbsp;&nbsp;&nbsp;&nbsp;vc_service_state_e service_state;
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_get_service_state(&amp;service_state);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Get the supported languages with a foreach function that triggers a separate callback for each language.
<p>As long as the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the foreach function continues to loop over the supported languages.</p>
<pre class="prettyprint">
bool
supported_language_cb(const char* language, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;return true; /* To continue to get the next language */

&nbsp;&nbsp;&nbsp;&nbsp;return false; /* To stop the loop */
}

void
get_supported_language()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_foreach_supported_languages(supported_language_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Get the current language with the <span style="font-family: Courier New,Courier,monospace">vc_get_current_language()</span> function. The voice control recognition works for the current (default) language. Use the language change callback to be notified of language changes. 

<pre class="prettyprint">
void
get_current_language()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;char* current_lang = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_get_current_language(&amp;current_lang);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
</ul>
 
      <h2 id="commands" name="commands">Managing Commands</h2>
	  
<p>To create a command list and commands:</p>

<ol>
<li>Create a command list with a command list handle.
<p>The command list can include many commands, which have a command text and type. The list can have both the <span style="font-family: Courier New,Courier,monospace">VC_COMMAND_TYPE_FOREGROUND</span> and <span style="font-family: Courier New,Courier,monospace">VC_COMMAND_TYPE_BACKGROUND</span> type commands. The foreground commands are valid when the application is in a visible state and the background commands are valid when the application is in a visible or invisible state.</p>
<p>You can access the command list after you set it to the voice control and when you get the recognition result. </p>

<pre class="prettyprint">
void
create_command_list()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_list_h vc_cmd_list;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_create(&amp;vc_cmd_list);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Create a command.
<p>First create a command handle, and then define the command and type.</p>
<pre class="prettyprint">
void
create_command()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_h vc_cmd = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_create(&amp;vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */

&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_set_command(vc_cmd, &quot;open&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_set_type(vc_cmd, VC_COMMAND_TYPE_FOREGROUND);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Add the command to the command list. 
<p>If necessary, you can also remove commands from the command list. After you remove a command, if you no longer use it, destroy the command handle with the <span style="font-family: Courier New,Courier,monospace">vc_cmd_destroy()</span> function.</p>
<pre class="prettyprint">
void
add_command(vc_cmd_list_h vc_cmd_list, vc_cmd_h vc_cmd)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_add(vc_cmd_list, vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
remove_command(vc_cmd_list_h vc_cmd_list, vc_cmd_h vc_cmd)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_remove(vc_cmd_list, vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
&nbsp;&nbsp;&nbsp;&nbsp;/* Destroy the command if no longer needed */
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_destroy(vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>

<p>To retrieve the commands you have added to the command list:</p>
<ul>
<li>You can use the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list_foreach_commands()</span> function to get each command within a callback function:
<pre class="prettyprint">
bool
__vc_get_command_cb(vc_cmd_h vc_command, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Your code */

&nbsp;&nbsp;&nbsp;&nbsp;return true;
}

void
foreach_command(vc_cmd_list_h vc_cmd_list)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_h vc_cmd;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_foreach_commands(vc_cmd_list, __vc_get_command_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>You can use the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list_get_current()</span> function to get the current command in an output parameter.

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">When you get the command handle with the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list_get_current()</span> function, do not release it. To release the command handle, call the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list_remove()</span> function before the <span style="font-family: Courier New,Courier,monospace">vc_cmd_destroy()</span> function.</td> 
    </tr> 
   </tbody> 
  </table>
<pre class="prettyprint">
void
get_commands(vc_cmd_list_h vc_cmd_list)
{
&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;int count;
&nbsp;&nbsp;&nbsp;&nbsp;vc_cmd_h vc_cmd;
&nbsp;&nbsp;&nbsp;&nbsp;char* command = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;int type = 0;

&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_get_count(vc_cmd_list, &amp;count);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */

&nbsp;&nbsp;&nbsp;&nbsp;if (0 &gt;= count) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_first(vc_cmd_list);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */

&nbsp;&nbsp;&nbsp;&nbsp;do {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_get_current(vc_cmd_list, &amp;vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE == ret) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_get_command(vc_cmd, &amp;command);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (NULL != command) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Command must be released */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(command);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_get_type(vc_cmd, &amp;type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Do not release the command handle */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_next(vc_cmd_list);
&nbsp;&nbsp;&nbsp;&nbsp;} while (VC_ERROR_ITERATION_END != ret);
}
</pre>
</li>
</ul>
</li>
<li>Register the commands for recognition by setting the command list to the voice control.
<p>If you want to update registered commands, set the command list again with the updated commands.</p>
<pre class="prettyprint">
void
set_command(vc_cmd_list_h vc_cmd_list, int type)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_set_command_list(vc_cmd_list, type);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>When no longer needed, unset the command list, and destroy the command and command list handles.
<p>When you destroy the command list, all the commands in the command list are not automatically released. If you no longer need the commands, set the second parameter of the <span style="font-family: Courier New,Courier,monospace">vc_cmd_list_destroy()</span> function to <span style="font-family: Courier New,Courier,monospace">true</span>.</p>
<pre class="prettyprint">
/* Unset the command list */
void
unset_command(int type)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_unset_command_list(type);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Destroy the command handle */
void
destroy_command(vc_cmd_h vc_cmd)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_destroy(vc_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

/* Destroy the command list handle */
void
destroy_command_list(vc_cmd_list_h vc_cmd_list)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_cmd_list_destroy(vc_cmd_list, true); /* true destroys all commands */
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
</ol>

     <h2 id="callback" name="callback">Monitoring Language Changes</h2>
	  
<p>To monitor when the system or application language changes:</p>

<ol>
<li>Set the language change callback to be invoked when the system or application language changes.
<p>It is important to track the current language, since you must set the commands and hints accordingly to ensure that the voice commands are recognized correctly.</p>
<pre class="prettyprint">
void
set_language_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_set_current_language_changed_cb(language_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Define the callback to set the commands and hints according to the current language:
<pre class="prettyprint">
void
language_changed_cb(const char *previous, const char *current, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;if (&quot;en_US&quot; == current) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_set_command(handler, &quot;button&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_set_command_hint(handler, &quot;button&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;} else if (&quot;ko_KR&quot; = current) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_set_command(handler, &quot;버튼&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_set_command_hint(handler, &quot;버튼&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre></li>

<li>When no longer needed, unset the callback:
<pre class="prettyprint">
void
unset_state_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_unset_current_language_changed_cb();
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li></ol>
   
   
    <h2 id="info" name="info">Retrieving Voice Control Information</h2>
	
<p>To get information about supported languages, widgets, and actions:</p>

<ul>
<li>
<p>Get the current Voice control elementary language using the <span style="font-family: Courier New,Courier,monospace">vc_elm_get_current_language()</span> function:</p>
<pre class="prettyprint">
void
get_language()
{
&nbsp;&nbsp;&nbsp;&nbsp;char *current_language;
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_get_current_language(&amp;current_language);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Get the languages supported by the Voice control elementary library with a foreach function that triggers a separate callback for each language.
<p>As long as the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the foreach function continues to loop over the supported languages.</p>
<pre class="prettyprint">
bool
supported_language_cb(const char *language, void* user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;return true; /* To continue to get the next language */

&nbsp;&nbsp;&nbsp;&nbsp;return false; /* To stop the loop */
}

void
set_default_language_changed_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_foreach_supported_languages(supported_language_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Get the UI components supported by the Voice control elementary library with a foreach function that triggers a separate callback for each UI component.
<p>As long as the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the foreach function continues to loop over the supported UI components.</p>
<pre class="prettyprint">
void
widget_cb(const char *widget, void *user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;return true; /* To continue to get the next UI component */

&nbsp;&nbsp;&nbsp;&nbsp;return false; /* To stop the loop */
}

void
set_supported_widget_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_foreach_supported_widgets(widget_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li>
<li>Get the actions supported by the Voice control elementary library for specific UI components with a foreach function that triggers a separate callback for each action.
<p>As long as the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the foreach function continues to loop over the supported actions.</p>
<p>To translate an action to corresponding command parameters, use the <span style="font-family: Courier New,Courier,monospace">vc_elm_get_action_command()</span> function.</p>
<pre class="prettyprint">
void
action_cb(const char *action, void *user_data)
{
&nbsp;&nbsp;&nbsp;&nbsp;char *command_param;
&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_get_action_command(action, &amp;command_param);

&nbsp;&nbsp;&nbsp;&nbsp;return true; /* To continue to get the next action */

&nbsp;&nbsp;&nbsp;&nbsp;return false; /* To stop the loop */
}

void
set_supported_action_cb()
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;/* Elm_Button is an example, it can be obtained using vc_elm_foreach_supported_widgets callback */
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_foreach_supported_actions(&quot;Elm_Button&quot;, action_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre></li></ul>
 
      <h2 id="command_hint" name="command_hint">Managing Commands and Hints</h2>
	  
<p>To set and unset commands and hints, and define the hint direction and offset:</p>

<ol>
<li>Use the handle created for a specific UI component to set a command the user must speak in order to perform actions on the UI component:

<pre class="prettyprint">
void
set_command(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_set_command(handler, &quot;Command&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>To show the command on the screen as a tooltip, set a hint (tooltip) for the UI component:

<pre class="prettyprint">
void
set_command_hint(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_set_command_hint(handler, &quot;Hint&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>
</li>
<li>Set the hint direction and offset (X and Y coordinates).
<p>By default, the hint tooltip is shown so that it does not cover the underlying UI component and does not intersect with other hints.</p>
<pre class="prettyprint">
void
set_hint_direction(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_set_command_hint_direction(handler, VC_ELM_DIRECTION_RIGHT);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
set_hint_offset(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_set_command_hint_offset(handler, 100, 100);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>

<p>You can get the current hint location using the <span style="font-family: Courier New,Courier,monospace">vc_elm_get_command_hint_direction()</span> and <span style="font-family: Courier New,Courier,monospace">vc_elm_get_command_hint_offset()</span> functions:</p>
<pre class="prettyprint">
void
get_hint_direction(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;vc_elm_direction_e direction;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_get_command_hint_direction(handler, &amp;direction);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
get_hint_offset(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;int x;
&nbsp;&nbsp;&nbsp;&nbsp;int y;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_get_command_hint_offset(handler, &amp;x, &amp;y);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}
</pre>

</li>
<li>When no longer needed, unset the command and hint:
<pre class="prettyprint">
void
unset_command(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_unset_command(handler);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}

void
unset_command_hint(vc_elm_h &amp;handler)
{
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;ret = vc_elm_unset_command_hint(handler);
&nbsp;&nbsp;&nbsp;&nbsp;if (VC_ELM_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Error handling */
}</pre>
</li>
</ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer"> 
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div> 

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

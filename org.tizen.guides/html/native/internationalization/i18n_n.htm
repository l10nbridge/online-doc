<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>i18n</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Dependencies</p>
		<ul class="toc">
			<li>Tizen Platform 2.4 and Higher for Mobile</li>
			<li>Tizen Platform 2.3.1 and Higher for Wearable</li>
		</ul>	
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#ubrk">Ubrk</a></li>
			<li><a href="#ucalendar">Ucalendar</a></li>
			<li><a href="#uchar">Uchar</a></li>
			<li><a href="#ucoll">Ucollator</a></li>
			<li><a href="#udate">Udate</a></li>
			<li><a href="#udatepg">Udatepg</a></li>
			<li><a href="#uenumeration">Uenumeration</a></li>
			<li><a href="#ulocale">Ulocale</a></li>
			<li><a href="#unormal">Unormalization</a></li>
			<li><a href="#unumber">Unumber</a></li>
			<li><a href="#usearch">Usearch</a></li>
			<li><a href="#uset">Uset</a></li>
			<li><a href="#ustring">Ustring</a></li>		
			<li><a href="#prerequisites">Prerequisites</a></li>
			<li><a href="#characters">Managing Characters and Strings</a></li>
			<li><a href="#dates">Managing Dates and Calendar</a></li>
			<li><a href="#locales">Managing Locales</a></li>
			<li><a href="#numbers">Managing Numbers</a></li>
			<li><a href="#ubrk">Managing Iteration Using Ubrk</a></li>
			<li><a href="#uenum">Managing Enumerations</a></li>
			<li><a href="#tmz">Managing Time Zones</a></li>
			<li><a href="#uset">Managing Sets</a></li>			
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__MODULE.html">i18n API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__MODULE.html">i18n API for Wearable Native</a></li>
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">

<h1>i18n</h1>

<p>You can generate flexible number or date format patterns, format and parse dates and numbers for any locale, and <a href="#tmz">manage time zones</a>. The i18n API is implemented by using the ICU library.</p>

<p>Before you start, remember to <a href="#prerequisites">prepare your application to use the i18n functionality</a>.</p>

<h2 id="ubrk" name="ubrk">Ubrk</h2>
<p>The Ubrk API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UBRK__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UBRK__MODULE.html">wearable</a> applications) is used to <a href="#ubrk">find the location of boundaries in text</a>. The <span style="font-family: Courier New,Courier,monospace">i18n_ubreak_iterator_h</span> handle maintains a current position and scans over the text returning the index of characters where the boundaries occur.</p>
<p>The following boundary analyzing methods are available:</p>
<ul>
	<li>Line boundary analysis determines where a text string can be broken when line-wrapping. The mechanism correctly handles punctuation and hyphenated words.</li>
	<li>Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks, such as quotation marks and parentheses.</li>
	<li>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double-click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.</li>
	<li>Character boundary analysis identifies the boundaries of Extended Grapheme Clusters, which are groupings of codepoints that must be treated as character-like units for many text operations. For additional information on grapheme clusters and guidelines on their use, see <a href="http://www.unicode.org/reports/tr29/tr29-21.html" target="_blank">Unicode Standard Annex #29, Unicode Text Segmentation</a>.</li>
	<li>Title boundary analysis locates all positions, typically starts of words, that must be set to Title Case when title casing the text.</li>
	<li>The text boundary positions are found according to the rules described in <a href="http://www.unicode.org/reports/tr29/tr29-21.html" target="_blank">Unicode Standard Annex #29, Unicode Text Segmentation</a>, and <a href="http://www.unicode.org/reports/tr14/tr14-30.html" target="_blank">Unicode Standard Annex #14, Unicode Line Breaking Algorithm</a>.</li>
</ul>


<h2 id="ucalendar" name="ucalendar">Ucalendar</h2>

<p>The Ucalendar API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html">wearable</a> applications) is used for <a href="#dates">converting between a Udate object and a set of integer fields</a>, such as <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_YEAR</span>, <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_MONTH</span>, <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_DAY</span>, and <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_HOUR</span>. A <a href="#udate">Udate</a> object represents a specific instant in time with one millisecond precision.</p>
<p>The types of Ucalendar interpret a Udate according to the rules of a specific calendar system, such as the gregorian or traditional system.</p>
<p>A Ucalendar object can produce all the time field values needed to implement the date-time formatting for a particular language and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).</p>

<p>When computing a Udate from the time fields, 2 special circumstances can arise. The information can be insufficient to compute the Udate (you have only the year and the month, but not the day of the month), or the information can be inconsistent (such as &quot;Tuesday, July 15, 1996&quot; even though July 15, 1996 is actually a Monday).</p>
<ul>
<li><strong>Insufficient information</strong> <p>The calendar uses the default information to specify the missing fields. This can vary by calendar: for the Gregorian calendar, the default for a field is the same as that of the start of the epoch, such as <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_YEAR = 1970</span>, <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_MONTH = JANUARY</span>, <span style="font-family: Courier New,Courier,monospace;">I18N_UCALENDAR_DATE = 1</span>.</p></li>
<li><strong>Inconsistent information</strong> <p>If the fields conflict, the calendar prefers the most recently set fields. For example, when determining the day, the calendar looks for one of the following field combinations listed in the following table. The most recent combination, as determined by the most recently set single field, is used.</p></li>
</ul>
<table> 
   <caption>
     Table: Combinations of the calendar fields to determine the day 
   </caption> 
   <tbody> 
    <tr> 
     <th>Combinations of the calendar fields</th> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_MONTH + I18N_UCALENDAR_DAY_OF_MONTH</span>
<p><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_MONTH + I18N_UCALENDAR_WEEK_OF_MONTH + I18N_UCALENDAR_DAY_OF_WEEK</span></p>
<p><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_MONTH + I18N_UCALENDAR_DAY_OF_WEEK_IN_MONTH + I18N_UCALENDAR_DAY_OF_WEEK</span></p>
<p><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_DAY_OF_YEAR</span></p>
<p><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_DAY_OF_WEEK + I18N_UCALENDAR_WEEK_OF_YEAR</span></p></td>
</tr> 
   </tbody> 
  </table>

<p>For the time of day:</p>
<table> 
   <caption>
     Table: Combinations of calendar fields to determine the time of the day 
   </caption> 
   <tbody> 
    <tr> 
     <th>Combinations of the calendar fields</th> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_HOUR_OF_DAY</span>
	 <p><span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_AM_PM + I18N_UCALENDAR_HOUR</span></p></td>
    </tr> 
   </tbody> 
  </table> 

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">For some non-Gregorian calendars, different fields are necessary for complete disambiguation. For example, a full specification of the historical
    Arabic astronomical calendar requires the year, month, day-of-month and day-of-week in some cases.</td> 
		</tr> 
	   </tbody> 
	  </table> 

<h2 id="uchar" name="uchar">Uchar</h2>
<p>The Uchar API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html">wearable</a> applications) provides a low-level access to the Unicode Character Database.</p>
<p>Unicode assigns each code point (not just the assigned character) values for several properties. Most of them are simple boolean flags, or constants from a small enumerated list. For some properties, values are strings or other relatively more complex types.</p>
<p>For more information, see <a href="http://www.unicode.org/ucd/" target="_blank">About the Unicode Character Database</a> and <a href="http://icu-project.org/userguide/properties.html" target="_blank">ICU User Guide chapter on Properties</a>.
</p>

<p>The following table describes the details of script codes that you can get using the <span style="font-family: Courier New,Courier,monospace">i18n_uchar_get_int_property_value()</span> function.
</p>
<table border="1">
   <caption>
     Table: Script codes
   </caption>  
   <tbody>
<tr>
<th>Value</th><th>Code</th><th>English name</th><th>Value</th><th>Code</th><th>English name</th>
</tr>
<tr>   <td>    0       </td><td>       Zyyy    </td><td>       Code for undetermined script    </td><td>       80      </td><td>       Latf    </td><td>       Latin (Fraktur variant)  </td>   </tr>
<tr>   <td>    1       </td><td>       Zinh    </td><td>       Code for inherited script       </td><td>       81      </td><td>       Latg    </td><td>       Latin (Gaelic variant)   </td>   </tr>
<tr>   <td>    2       </td><td>       Arab    </td><td>       Arabic  </td><td>       82      </td><td>       Lepc    </td><td>       Lepcha (Rong)    </td>   </tr>
<tr>   <td>    3       </td><td>       Armn    </td><td>       Armenian        </td><td>       83      </td><td>       Lina    </td><td>       LinearA </td>   </tr>
<tr>   <td>    4       </td><td>       Beng    </td><td>       Bengali </td><td>       84      </td><td>       Mand    </td><td>       Mandaic, Mandaean       </td>   </tr>
<tr>   <td>    5       </td><td>       Bopo    </td><td>       Bopomofo        </td><td>       85      </td><td>       Maya    </td><td>       Mayan hieroglyphs       </td>   </tr>
<tr>   <td>    6       </td><td>       Cher    </td><td>       Cherokee        </td><td>       86      </td><td>       Mero    </td><td>       Meroitic hieroglyphs    </td>   </tr>
<tr>   <td>    7       </td><td>       Copt    </td><td>       Coptic  </td><td>       87      </td><td>       Nkoo    </td><td>       N’Ko  </td>   </tr>
<tr>   <td>    8       </td><td>       Cyrl    </td><td>       Cyrillic        </td><td>       88      </td><td>       Orkh    </td><td>       Old Turkic, Orkhon Runic  </td>   </tr>
<tr>   <td>    9       </td><td>       Dsrt    </td><td>       Deseret (Mormon) </td><td>       89      </td><td>       Perm    </td><td>       Old Permic      </td>   </tr>
<tr>   <td>    10      </td><td>       Deva    </td><td>       Devanagari (Nagari)      </td><td>       90      </td><td>       Phag    </td><td>       Phags-pa        </td>   </tr>
<tr>   <td>    11      </td><td>       Ethi    </td><td>       Ethiopic (Geʻez)        </td><td>       91      </td><td>       Phnx    </td><td>       Phoenician      </td>   </tr>
<tr>   <td>    12      </td><td>       Geor    </td><td>       Georgian (Mkhedruli)     </td><td>       92      </td><td>       Plrd    </td><td>       Miao (Pollard)   </td>   </tr>
<tr>   <td>    13      </td><td>       Goth    </td><td>       Gothic  </td><td>       93      </td><td>       Roro    </td><td>       Rongorongo      </td>   </tr>
<tr>   <td>    14      </td><td>       Grek    </td><td>       Greek   </td><td>       94      </td><td>       Sara    </td><td>       Sarati  </td>   </tr>
<tr>   <td>    15      </td><td>       Gujr    </td><td>       Gujarati        </td><td>       95      </td><td>       Syre    </td><td>       Syriac (Estrangelo variant)       </td>   </tr>
<tr>   <td>    16      </td><td>       Guru    </td><td>       Gurmukhi        </td><td>       96      </td><td>       Syrj    </td><td>       Syriac (Western variant)  </td>   </tr>
<tr>   <td>    17      </td><td>       Hani    </td><td>       Han (Hanzi, Kanji, Hanja)        </td><td>       97      </td><td>       Syrn    </td><td>       Syriac (Eastern variant) </td>   </tr>
<tr>   <td>    18      </td><td>       Hang    </td><td>       Hangul (Hangŭl, Hangeul)        </td><td>       98      </td><td>       Teng    </td><td>       Tengwar </td>   </tr>
<tr>   <td>    19      </td><td>       Hebr    </td><td>       Hebrew  </td><td>       99      </td><td>       Vaii    </td><td>       Vai     </td>   </tr>
<tr>   <td>    20      </td><td>       Hira    </td><td>       Hiragana        </td><td>       100     </td><td>       Visp    </td><td>       Visible Speech  </td>   </tr>
<tr>   <td>    21      </td><td>       Knda    </td><td>       Kannada </td><td>       101     </td><td>       Xsux    </td><td>       Cuneiform, Sumero-Akkadian      </td>   </tr>
<tr>   <td>    22      </td><td>       Kana    </td><td>       Katakana        </td><td>       102     </td><td>       Zxxx    </td><td>       Code for unwritten documents    </td>   </tr>
<tr>   <td>    23      </td><td>       Khmr    </td><td>       Khmer   </td><td>       103     </td><td>       Zzzz    </td><td>       Code for uncoded script </td>   </tr>
<tr>   <td>    24      </td><td>       Laoo    </td><td>       Lao     </td><td>       104     </td><td>       Cari    </td><td>       Carian  </td>   </tr>
<tr>   <td>    25      </td><td>       Latn    </td><td>       Latin   </td><td>       105     </td><td>       Jpan    </td><td>       Japanese (alias for Han+Hiragana+Katakana) </td>   </tr>
<tr>   <td>    26      </td><td>       Mlym    </td><td>       Malayalam       </td><td>       106     </td><td>       Lana    </td><td>       TaiTham (Lanna)  </td>   </tr>
<tr>   <td>    27      </td><td>       Mong    </td><td>       Mongolian       </td><td>       107     </td><td>       Lyci    </td><td>       Lycian  </td>   </tr>
<tr>   <td>    28      </td><td>       Mymr    </td><td>       Myanmar (Burmese)        </td><td>       108     </td><td>       Lydi    </td><td>       Lydian  </td>   </tr>
<tr>   <td>    29      </td><td>       Ogam    </td><td>       Ogham   </td><td>       109     </td><td>       Olck    </td><td>       Ol Chiki (Ol Cemet’, Ol Santali)      </td>   </tr>
<tr>   <td>    30      </td><td>       Ital    </td><td>       Old Italic (Etruscan, Oscan)       </td><td>       110     </td><td>       Rjng    </td><td>       Rejang (Redjang, Kaganga)        </td>   </tr>
<tr>   <td>    31      </td><td>       Orya    </td><td>       Oriya   </td><td>       111     </td><td>       Saur    </td><td>       Saurashtra      </td>   </tr>
<tr>   <td>    32      </td><td>       Runr    </td><td>       Runic   </td><td>       112     </td><td>       Sgnw    </td><td>       SignWriting     </td>   </tr>
<tr>   <td>    33      </td><td>       Sinh    </td><td>       Sinhala </td><td>       113     </td><td>       Sund    </td><td>       Sundanese       </td>   </tr>
<tr>   <td>    34      </td><td>       Syrc    </td><td>       Syriac  </td><td>       114     </td><td>       Moon    </td><td>       Moon (Mooncode, Moonscript, Moontype)    </td>   </tr>
<tr>   <td>    35      </td><td>       Taml    </td><td>       Tamil   </td><td>       115     </td><td>       Mtei    </td><td>       Meitei Mayek (Meithei, Meetei)   </td>   </tr>
<tr>   <td>    36      </td><td>       Telu    </td><td>       Telugu  </td><td>       116     </td><td>       Armi    </td><td>       Imperial Aramaic        </td>   </tr>
<tr>   <td>    37      </td><td>       Thaa    </td><td>       Thaana  </td><td>       117     </td><td>       Avst    </td><td>       Avestan </td>   </tr>
<tr>   <td>    38      </td><td>       Thai    </td><td>       Thai    </td><td>       118     </td><td>       Cakm    </td><td>       Chakma  </td>   </tr>
<tr>   <td>    39      </td><td>       Tibt    </td><td>       Tibetan </td><td>       119     </td><td>       Kore    </td><td>       Korean (alias for Hangul+Han)    </td>   </tr>
<tr>   <td>    40      </td><td>       Cans    </td><td>       Unified Canadian Aboriginal Syllabics   </td><td>       120     </td><td>       Kthi    </td><td>       Kaithi  </td>   </tr>
<tr>   <td>    41      </td><td>       Yiii    </td><td>       Yi      </td><td>       121     </td><td>       Mani    </td><td>       Manichaean      </td>   </tr>
<tr>   <td>    42      </td><td>       Tglg    </td><td>       Tagalog (Baybayin, Alibata)      </td><td>       122     </td><td>       Phli    </td><td>       Inscriptional Pahlavi   </td>   </tr>
<tr>   <td>    43      </td><td>       Hano    </td><td>       Hanunoo (Hanunoo)        </td><td>       123     </td><td>       Phlp    </td><td>       Psalter Pahlavi </td>   </tr>
<tr>   <td>    44      </td><td>       Buhd    </td><td>       Buhid   </td><td>       124     </td><td>       Phlv    </td><td>       Book Pahlavi    </td>   </tr>
<tr>   <td>    45      </td><td>       Tagb    </td><td>       Tagbanwa        </td><td>       125     </td><td>       Prti    </td><td>       Inscriptional Parthian  </td>   </tr>
<tr>   <td>    46      </td><td>       Brai    </td><td>       Braille </td><td>       126     </td><td>       Samr    </td><td>       Samaritan       </td>   </tr>
<tr>   <td>    47      </td><td>       Cprt    </td><td>       Cypriot </td><td>       127     </td><td>       Tavt    </td><td>       TaiViet </td>   </tr>
<tr>   <td>    48      </td><td>       Limb    </td><td>       Limbu   </td><td>       128     </td><td>       Zmth    </td><td>       Mathematical notation    </td>   </tr>
<tr>   <td>    49      </td><td>       Linb    </td><td>       LinearB </td><td>       129     </td><td>       Zsym    </td><td>       Symbols </td>   </tr>
<tr>   <td>    50      </td><td>       Osma    </td><td>       Osmanya </td><td>       130     </td><td>       Bamu    </td><td>       Bamum   </td>   </tr>
<tr>   <td>    51      </td><td>       Shaw    </td><td>       Shavian (Shaw)   </td><td>       131     </td><td>       Lisu    </td><td>       Lisu (Fraser)    </td>   </tr>
<tr>   <td>    52      </td><td>       Tale    </td><td>       TaiLe   </td><td>       132     </td><td>       Nkgb    </td><td>       Nakhi Geba ('Na-'Khi ²Ggŏ-¹baw, Naxi Geba)    </td>   </tr>
<tr>   <td>    53      </td><td>       Ugar    </td><td>       Ugaritic        </td><td>       133     </td><td>       Sarb    </td><td>       Old South Arabian       </td>   </tr>
<tr>   <td>    54      </td><td>       Hrkt    </td><td>       Japanese syllabaries (alias for Hiragana+Katakana)       </td><td>       134     </td><td>       Bass    </td><td>       BassaVah        </td>   </tr>
<tr>   <td>    55      </td><td>       Bugi    </td><td>       Buginese        </td><td>       135     </td><td>       Dupl    </td><td>       Duployan shorthand, Duployan stenography        </td>   </tr>
<tr>   <td>    56      </td><td>       Glag    </td><td>       Glagolitic      </td><td>       136     </td><td>       Elba    </td><td>       Elbasan </td>   </tr>
<tr>   <td>    57      </td><td>       Khar    </td><td>       Kharoshthi      </td><td>       137     </td><td>       Gran    </td><td>       Grantha </td>   </tr>
<tr>   <td>    58      </td><td>       Sylo    </td><td>       Syloti Nagri    </td><td>       138     </td><td>       Kpel    </td><td>       Kpelle  </td>   </tr>
<tr>   <td>    59      </td><td>       Talu    </td><td>       New Tai Lue     </td><td>       139     </td><td>       Loma    </td><td>       Loma    </td>   </tr>
<tr>   <td>    60      </td><td>       Tfng    </td><td>       Tifinagh (Berber)        </td><td>       140     </td><td>       Mend    </td><td>       Mende Kikakui   </td>   </tr>
<tr>   <td>    61      </td><td>       Xpeo    </td><td>       Old Persian     </td><td>       141     </td><td>       Merc    </td><td>       Meroitic Cursive        </td>   </tr>
<tr>   <td>    62      </td><td>       Bali    </td><td>       Balinese        </td><td>       142     </td><td>       Narb    </td><td>       Old North Arabian (Ancient North Arabian)        </td>   </tr>
<tr>   <td>    63      </td><td>       Batk    </td><td>       Batak   </td><td>       143     </td><td>       Nbat    </td><td>       Nabataean       </td>   </tr>
<tr>   <td>    64      </td><td>       Blis    </td><td>       Blissymbols     </td><td>       144     </td><td>       Palm    </td><td>       Palmyrene       </td>   </tr>
<tr>   <td>    65      </td><td>       Brah    </td><td>       Brahmi  </td><td>       145     </td><td>       Sind    </td><td>       Khudawadi, Sindhi       </td>   </tr>
<tr>   <td>    66      </td><td>       Cham    </td><td>       Cham    </td><td>       146     </td><td>       Wara    </td><td>       Warang Citi (Varang Kshiti)      </td>   </tr>
<tr>   <td>    67      </td><td>       Cirt    </td><td>       Cirth   </td><td>       147     </td><td>       Afak    </td><td>       Afaka   </td>   </tr>
<tr>   <td>    68      </td><td>       Cyrs    </td><td>       Cyrillic (Old Church Slavonic variant)   </td><td>       148     </td><td>       Jurc    </td><td>       Jurchen </td>   </tr>
<tr>   <td>    69      </td><td>       Egyd    </td><td>       Egyptian demotic        </td><td>       149     </td><td>       Mroo    </td><td>       Mro, Mru        </td>   </tr>
<tr>   <td>    70      </td><td>       Egyh    </td><td>       Egyptian hieratic       </td><td>       150     </td><td>       Nshu    </td><td>       Nushu   </td>   </tr>
<tr>   <td>    71      </td><td>       Egyp    </td><td>       Egyptian hieroglyphs     </td><td>       151     </td><td>       Shrd    </td><td>       Sharada, Śāradā      </td>   </tr>
<tr>   <td>    72      </td><td>       Geok    </td><td>       Khutsuri (Asomtavruli and Nuskhuri)      </td><td>       152     </td><td>       Sora    </td><td>       Sora Sompeng    </td>   </tr>
<tr>   <td>    73      </td><td>       Hans    </td><td>       Han (Simplified variant) </td><td>       153     </td><td>       Takr    </td><td>       Takri, Ṭākrī, Ṭāṅkrī </td>    </tr>
<tr>   <td>    74      </td><td>       Hant    </td><td>       Han (Traditional variant)        </td><td>       154     </td><td>       Tang    </td><td>       Tangut  </td>   </tr>
<tr>   <td>    75      </td><td>       Hmng    </td><td>       Pahawh Hmong    </td><td>       155     </td><td>       Wole    </td><td>       Woleai  </td>   </tr>
<tr>   <td>    76      </td><td>       Hung    </td><td>       Old Hungarian (Hungarian Runic)  </td><td>       156     </td><td>       Hluw    </td><td>       Anatolian hieroglyphs (Luwian hieroglyphs, Hittite hieroglyphs) </td>    </tr>
<tr>   <td>    77      </td><td>       Inds    </td><td>       Indus (Harappan) </td><td>       157     </td><td>       Khoj    </td><td>       Khojki  </td>   </tr>
<tr>   <td>    78      </td><td>       Java    </td><td>       Javanese        </td><td>       158     </td><td>       Tirh    </td><td>       Tirhuta </td>   </tr>
<tr>   <td>    79      </td><td>       Kali    </td><td>       KayahLi </td><td>       -1      </td><td>               </td><td>       Invalid code     </td>   </tr>
</tbody>
</table>


<h2 id="ucoll" name="ucoll">Ucollator</h2>
<p>The Ucollator API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCOLLATOR__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCOLLATOR__MODULE.html">wearable</a> applications) performs locale-sensitive string comparison. It builds searching and sorting routines for natural language text and provides correct sorting orders for most supported locales. If specific data for a locale is not available, the order eventually falls back to the <a href="http://www.unicode.org/reports/tr35/tr35-31/tr35-collation.html#Root_Collation" target="_blank">CLDR root sort order</a>. The sorting order can be customized by providing your own set of rules. For more information, see the <a href="http://userguide.icu-project.org/collation/customization" target="_blank">ICU Collation Customization</a> section of the User Guide.</p>

<h2 id="udate" name="udate">Udate</h2>
<p>The Udate API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html">wearable</a> applications) consists of functions that convert dates and times from their internal representations to textual form and back again in a language-independent manner. Converting from the internal representation (milliseconds since midnight, January 1, 1970) to text is known as formatting, and converting from text to milliseconds is known as parsing. Tizen currently defines only one concrete handle (<span style="font-family: Courier New,Courier,monospace">i18n_udate_format_h</span>), which can handle practically all normal date formatting and parsing actions.</p>
<p>The Udate format helps you to format and parse dates for any locale. Your code can be completely independent of the locale conventions for months, days of the week, or even the lunar or solar calendar format.</p>
<p>You can pass in different options for the arguments for date and time style to control the length of the result; you can select from <span style="font-family: Courier New,Courier,monospace">SHORT</span>, <span style="font-family: Courier New,Courier,monospace">MEDIUM</span>, <span style="font-family: Courier New,Courier,monospace">LONG</span>, and <span style="font-family: Courier New,Courier,monospace">FULL</span>. The exact result depends on the locale.</p>

<ul>
    <li>
        <span style="font-family: Courier New,Courier,monospace">I18N_UDATE_SHORT</span> is completely numeric, such as 12/13/52 or 3:30pm
    </li>
    <li>
        <span style="font-family: Courier New,Courier,monospace">I18N_UDATE_MEDIUM</span> is longer, such as Jan 12, 1952
    </li>
    <li>
        <span style="font-family: Courier New,Courier,monospace">I18N_UDATE_LONG</span> is longer, such as January 12, 1952 or 3:30:32pm
    </li>
    <li>
        <span style="font-family: Courier New,Courier,monospace">I18N_UDATE_FULL</span>
        is completely specified, such as Tuesday, April 12, 1952 AD or 3:30:42pm PST.
    </li>
</ul>

<h3 id="pattern" name="pattern">Date and Time Patterns</h3>
<p>The date and time formats are specified by the <span style="font-family: Courier New,Courier,monospace">date and time pattern</span> strings. Within the date and time pattern strings, all unquoted ASCII letters (A-Z and a-z) are reserved as pattern letters representing calendar fields. The <span style="font-family: Courier New,Courier,monospace">i18n_udate_format_h</span> handle supports the date and time formatting algorithm and pattern letters defined by the <a href="http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Field_Symbol_Table" target="_blank">Unicode Technical Standard #35, Unicode Locale Data Markup Language (LDML)</a>. It is further documented in the <a href="https://sites.google.com/site/icuprojectuserguide/formatparse/datetime?pli=1#TOC-Date-Field-Symbol-Table" target="_blank">ICU User Guide</a>.</p>

<h2 id="udatepg" name="udatepg">Udatepg</h2>
<p>The Udatepg API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UDATEPG__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UDATEPG__MODULE.html">wearable</a> applications) enables flexible generation of date format patterns, such as "yy-MM-dd". The user can build up the generator by adding successive patterns. After this, a query can be made using a pattern that includes only the desired fields and lengths. The generator returns the a pattern that is most similar to it.
</p>
<p>The main method is the <span style="font-family: Courier New,Courier,monospace">i18n_udatepg_get_best_pattern()</span> function, since normally the Udatepg API is prebuilt with data from a particular locale. However, generators can be built directly from other data as well.
</p>

<h2 id="uenumeration" name="uenumeration">Uenumeration</h2>

<p>The Uenumeration API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UENUMERATION__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UENUMERATION__MODULE.html">wearable</a> applications) enables you to <a href="#uenum">create an enumeration object</a> out of a given set of strings. The object can be created out of an array of <span style="font-family: Courier New,Courier,monospace">const char*</span> strings or an array of <span style="font-family: Courier New,Courier,monospace">i18n_uchar*</span> strings.</p>
<p>The enumeration object enables navigation through the enumeration values, with the use of the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_next()</span> or <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_unext()</span> function (depending on the type used for creating the enumeration object), and with the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_reset()</span> function.</p>
<p>You can get the number of values stored in the enumeration object with the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_count()</span> function.</p>


<h2 id="ulocale" name="ulocale">Ulocale</h2>
<p>The Ulocale API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__ULOCALE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__ULOCALE__MODULE.html">wearable</a> applications) represents a specific geographical, political, or cultural region. Locale-sensitive operations <a href="#locales">use the Ulocale functions to tailor information</a> for the user. For example, displaying a number is a locale-sensitive operation. The number must be formatted according to the customs and conventions of the user&#39;s native country, region, or culture.
</p>
<p>You create a locale with one of the options listed below. Each component is separated by an underscore in the locale string:</p>

<table> 
   <caption>
     Table: Options for creating a locale
   </caption> 
   <tbody> 
    <tr> 
     <th>Options for creating a locale</th> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">newLanguage</span>
	 <p><span style="font-family: Courier New,Courier,monospace">newLanguage + newCountry</span></p>
	 <p><span style="font-family: Courier New,Courier,monospace">newLanguage + newCountry + newVariant</span></p></td>
    </tr>
   </tbody>
  </table>
  
<p>The first option is a valid <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO Language Code</a>. These codes are the lower-case 2-letter codes as defined by the ISO-639 standard.
</p>
<p>The second option includes an additional <a href="http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html" target="_blank">ISO Country Code</a>.
</p>
<p>The third option requires additional information on the variant. The variant codes are vendor and browser-specific. For example, use <span style="font-family: Courier New,Courier,monospace">WIN</span> for Windows, <span style="font-family: Courier New,Courier,monospace">MAC</span> for Macintosh, and <span style="font-family: Courier New,Courier,monospace">POSIX</span> for POSIX. Where there are 2 variants, separate them with an underscore, and put the most important one first. For example, a Traditional Spanish collation might be referenced, with <span style="font-family: Courier New,Courier,monospace">ES</span>, <span style="font-family: Courier New,Courier,monospace">ES</span>, <span style="font-family: Courier New,Courier,monospace">Traditional_WIN</span>.
</p>
<p>Because a locale is just an identifier for a region, no validity check is performed when you specify a locale. If you want to see whether particular resources are available for the locale you asked for, you must query those resources.
</p>
<p> Once you have specified a locale you can query it for information about itself. Use <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_language()</span> to get the ISO Language Code. You can use <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_display_name()</span> to get the name of the language suitable for display to the user.
</p>

<h2 id="unormal" name="unormal">Unormalization</h2>

<p> The Unicode normalization API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UNORMALIZATION__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UNORMALIZATION__MODULE.html">wearable</a> applications) is for the standard unicode normalization. All instances of <span style="font-family: Courier New,Courier,monospace">i18n_unormalizer_s</span> are unmodifiable and immutable. Instances returned by <span style="font-family: Courier New,Courier,monospace">i18n_unormalization_get_instance()</span> are singletons that must not be deleted by the caller.</p>


<h2 id="unumber" name="unumber">Unumber</h2>
<p>The Unumber API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html">wearable</a> applications) helps you to <a href="#numbers">format and parse numbers for any locale</a>. Your code can be completely independent of the locale conventions for decimal points, thousands-separators, or even the particular decimal digits used, or whether the number format is even decimal. There are different number format styles like decimal, currency, percent and spellout.</p>

<h2 id="usearch" name="usearch">Usearch</h2>
<p>The Usearch API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__USEARCH__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__USEARCH__MODULE.html">wearable</a> applications) provides language-sensitive text searching based on the comparison rules defined in a Ucollator data struct. This ensures that language eccentricity can be handled. For example, for the German collator, characters ß and SS are matched if case is chosen to be ignored. That is why it can be important to pass a locale when creating the usearch with the <span style="font-family: Courier New,Courier,monospace">i18n_usearch_create_new()</span> function.</p>

<h2 id="uset" name="uset">Uset</h2>
<p>Uset is a mutable <a href="#uset">set of Unicode characters and multicharacter strings that you can manage</a>. The sets represent character classes used in regular expressions. A character specifies a subset of the Unicode code points. The legal code points are U+0000 to U+10FFFF, inclusive.</p>
<p>The set supports 2 functions:</p>
<ul><li>The operand function allows the caller to modify the value of the set. The operand function works similarly to the boolean logic: a boolean OR is implemented by add, a boolean AND is implemented by retain, a boolean XOR is implemented by a complement taking an argument, and a boolean NOT is implemented by a complement with no argument. In terms of traditional set theory function names, add is a union, retain is an intersection, remove is an asymmetric difference, and complement with no argument is a set complement with respect to the superset range <span style="font-family: Courier New,Courier,monospace">MIN_VALUE-MAX_VALUE</span>.</li>
<li>The <span style="font-family: Courier New,Courier,monospace">i18n_uset_apply_pattern()</span> or <span style="font-family: Courier New,Courier,monospace">i18n_uset_to_pattern()</span> function. Unlike the functions that add characters or categories, and control the logic of the set, the <span style="font-family: Courier New,Courier,monospace">i18n_uset_apply_pattern()</span> function sets all attributes of a set at once, based on a string pattern.</li></ul>

<h3 id="pattern_syntax" name="pattern_syntax">Pattern Syntax</h3>

<p>Patterns are accepted by the <span style="font-family: Courier New,Courier,monospace">i18n_uset_create_pattern()</span>, <span style="font-family: Courier New,Courier,monospace">i18n_uset_create_pattern_options()</span>, and <span style="font-family: Courier New,Courier,monospace">i18n_uset_apply_pattern()</span> functions and returned by the <span style="font-family: Courier New,Courier,monospace">i18n_uset_to_pattern()</span> function. The patterns follow a syntax similar to that employed by version 8 regular expression character classes.</p>
<table>
   <caption>
     Table: Examples of simple pattern syntaxes
   </caption> 
    <tbody>
		<tr>
            <th>Pattern</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[]</span></td>
            <td>No characters</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[a]</span></td>
            <td>Character &#39;a&#39;</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[ae]</span></td>
            <td>Characters &#39;a&#39; and &#39;e&#39;</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[a-e]</span></td>
            <td>Characters &#39;a&#39; through &#39;e&#39; inclusive, in Unicode code point order</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[\u4E01]</span></td>
            <td>Character U+4E01</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[a{ab}{ac}]</span></td>
            <td>Character &#39;a&#39; and the multicharacter strings &#39;ab&#39; and &#39;ac&#39;</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[\p{Lu}]</span></td>
            <td>All characters in the general category &#39;uppercase letter&#39;</td>
        </tr>
    </tbody>
</table>
<p>Any character can be preceded by a backslash in order to remove any special meaning. Whitespace characters are ignored, unless they are escaped.</p>
<p>Property patterns specify a set of characters having a certain property as defined by the Unicode standard. Both the POSIX-like <span style="font-family: Courier New,Courier,monospace">[:Lu:]</span> and the Perl-like syntax <span style="font-family: Courier New,Courier,monospace">\\p{Lu}</span> are recognized.</p>
<p>Patterns specify individual characters, ranges of characters, and Unicode property sets. When the elements are concatenated, they specify their union. To complement a set, place a &#39;^&#39; immediately after the opening &#39;[&#39;. Property patterns are inverted by modifying their delimiters, <span style="font-family: Courier New,Courier,monospace">[:^foo]</span> and <span style="font-family: Courier New,Courier,monospace">\\P{foo}</span>. In any other location, &#39;^&#39; has no special meaning.</p>
<p>Ranges are indicated by placing a &#39;-&#39; between 2 characters, as in &quot;a-z&quot;. This specifies the range of all characters from the left to the right, in Unicode order. If the left character is greater than or equal to the right character, it is a syntax error. If a &#39;-&#39; occurs as the first character after the opening &#39;[&#39; or &#39;[^&#39;, or if it occurs as the last character before the closing &#39;]&#39;, it is taken as a literal. This means that <span style="font-family: Courier New,Courier,monospace">[a\-b]</span>, <span style="font-family: Courier New,Courier,monospace">[-ab]</span>, and <span style="font-family: Courier New,Courier,monospace">[ab-]</span> all indicate the same set of 3 characters, &#39;a&#39;, &#39;b&#39;, and &#39;-&#39;.</p>
<p>Sets can be intersected using the &#39;&amp;&#39; operator or the asymmetric set difference can be taken using the &#39;-&#39; operator. For example, <span style="font-family: Courier New,Courier,monospace">[[:L:]&amp;[\\u0000-\\u0FFF]]</span> indicates the set of all Unicode letters with values less than 4096. Operators (&#39;&amp;&#39; and &#39;|&#39;) have equal precedence and bind left-to-right. This means that <span style="font-family: Courier New,Courier,monospace">[[:L:]-[a-z]-[\\u0100-\\u01FF]]</span> is equivalent to <span style="font-family: Courier New,Courier,monospace">[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]</span>. This only really matters for difference; intersection is commutative.</p>
<table>
   <caption>
     Table: Examples of set syntaxes
   </caption> 
    <tbody>
		<tr>
            <th>Set</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[a]</span></td>
            <td>Set containing &#39;a&#39;</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[a-z]</span></td>
            <td>Set containing &#39;a&#39; through &#39;z&#39; and all letters in between, in Unicode order</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[^a-z]</span></td>
            <td>Set containing all characters but &#39;a&#39; through &#39;z&#39;, that is, U+0000 through &#39;a&#39;-1 and &#39;z&#39;+1 through U+10FFFF</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[[pat1][pat2]]</span></td>
            <td>Union of sets specified by pat1 and pat2</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[[[pat1]&amp;[pat2]]</span></td>
            <td>Intersection of sets specified by pat1 and pat2</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[[pat1]-[pat2]]</span></td>
            <td>Asymmetric difference of sets specified by pat1 and pat2</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[:Lu:]</span> or <span style="font-family: Courier New,Courier,monospace">\p{Lu}</span></td>
            <td>Set of characters having the specified Unicode property, in this case Unicode uppercase letters</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">[:^Lu:]</span> or <span style="font-family: Courier New,Courier,monospace">\P{Lu}</span></td>
            <td>Set of characters not having the given Unicode property</td>
        </tr>
    </tbody>
</table>

  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">You cannot add an empty string (&quot;&quot;) to a set.</td> 
		</tr> 
	   </tbody> 
	  </table> 


<h3 id="formal_syntax" name="formal_syntax">Formal Syntax</h3>

<p>The following table provide examples of formal syntax patterns.</p>

<table>
   <caption>
     Table: Formal syntax patterns 
   </caption> 
    <tbody>
		<tr>
            <th>Pattern</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">pattern :=</span></td>
            <td>(&#39;[&#39; &#39;^&#39;? item* &#39;]&#39;) | property</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">item :=</span></td>
            <td>char | (char &#39;-&#39; char) | pattern-expr</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">pattern-expr :=</span></td>
            <td>pattern | pattern-expr pattern | pattern-expr or pattern</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">op :=</span></td>
            <td>&#39;&amp;&#39; | &#39;-&#39;</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">special :=</span></td>
            <td>&#39;[&#39; | &#39;]&#39; | &#39;-&#39;</td>
	        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">char :=</span></td>
            <td>Any character that is not special | (&#39;\&#39; any character) | (&#39;\u&#39; hex hex hex hex)</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">property :=</span></td>
            <td>Unicode property set pattern</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">a := b</span></td>
            <td>a can be replaced by b</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">a?</span></td>
            <td>0 or 1 instance of a</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">a*</span></td>
            <td>1 or more instances of a</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">a | b</span></td>
            <td>Either a or b</td>
        </tr>
        <tr>
            <td><span style="font-family: Courier New,Courier,monospace">&#39;a&#39;</span></td>
            <td>Literal string between the quotes</td>
        </tr>
    </tbody>
</table>



<h2 id="ustring" name="ustring">Ustring</h2>
<p>The Ustring API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__USTRING__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__USTRING__MODULE.html">wearable</a> applications) allows you to <a href="#characters">handle general unicode strings</a>. Some functions are similar in name, signature, and behavior to the ANSI C <span style="font-family: Courier New,Courier,monospace">&lt;string.h&gt;</span> functions, and other functions provide more Unicode-specific functionality.</p>
<p>The i18n uses 16-bit Unicode (UTF-16) in the form of arrays of <span style="font-family: Courier New,Courier,monospace">i18n_uchar</span> code units. UTF-16 encodes each Unicode code point with either 1 or 2 <span style="font-family: Courier New,Courier,monospace">i18n_uchar</span> code units. This is the default form of Unicode, and a forward-compatible extension of the original, fixed-width form that was known as UCS-2. UTF-16 superseded UCS-2 with Unicode 2.0 in 1996.</p>
<p>The i18n also handles 16-bit Unicode text with unpaired surrogates. Such text is not well-formed UTF-16. Code-point-related functions treat unpaired surrogates as surrogate code points, such as separate units.</p>
<p>Although UTF-16 is a variable-width encoding form, such as some legacy multi-byte encodings, it is much more efficient even for random access because the code unit values for single-unit characters versus lead units versus trail units are completely disjoint. This means that it is easy to determine character (code point) boundaries from random offsets in the string.</p>
<p>Unicode (UTF-16) string processing is optimized for the single-unit case. Although it is important to support supplementary characters, which use pairs of lead/trail code units called &quot;surrogates&quot;, their occurrence is rare. Almost all characters in modern use require only a single <span style="font-family: Courier New,Courier,monospace">i18n_uchar</span> code unit (such as their code point values are &lt;=0xffff).</p>

 <h3 id="map" name="map">Character Set Mapping Tables</h3>
<p>The i18n API provides a character set conversion with mapping tables for a number of important codepages. The default tables are a subset of IBM&#39;s CDRA conversion table repository. ICU&#39;s <a href="http://demo.icu-project.org/icu-bin/convexp" target="_blank">Converter Explorer</a> shows aliases and codepage charts for the default tables that are built into a standard ICU distribution.</p>
<p>Conversions for most codepages are implemented differently on different platforms. We are providing  mapping tables here from many different sources, so that the i18n users and others can use these tables to get the same conversion behavior as on the original platforms.</p>
<p>The mapping tables and some of the source code of the tools that collected these tables are checked into a <a href="http://source.icu-project.org/repos/icu/data/trunk/charset/data/ucm/" target="_blank">CVS repository</a>.
</p>
<p>For more information about character sets, codepages and encodings, see <a href="http://www.ibm.com/software/globalization/topics/charsets/" target="_blank">Coded Character Sets</a> on the IBM site.
</p>

<h2>Warm-up</h2>

 <p>Become familiar with the i18n API basics by learning about:</p> 
		<ul>
			<li><a href="#prerequisites">Prerequisites</a>
			<p>Prepare your application to use the i18n functionality.</p></li>
			<li><a href="#characters">Managing Characters and Strings</a>
		   <p>Convert and manage characters and strings.</p></li>
		   <li><a href="#dates">Managing Dates and Calendar</a>
			<p>Manage dates and calendar.</p></li>
		   <li><a href="#locales">Managing Locales</a>
			<p>Manage locales, which represent a specific geographical, political, or cultural region.</p></li>
		   <li><a href="#numbers">Managing Numbers</a>
			<p>Format and parse numbers for any locale.</p></li>
    		<li><a href="#ubrk">Managing Iteration Using Ubrk</a>
            <p>Iterate through strings using Ubrk.</p></li>
			<li><a href="#uenum">Managing Enumerations</a>
            <p>Create, acquire, and use enumerations.</p></li>
			<li><a href="#tmz">Managing Time Zones</a>
            <p>Get the time zone name, ID, DST savings, raw offset, and region code.</p></li>
			<li><a href="#uset">Managing Sets</a>
			<p>Manage sets of characters and strings.</p></li>
	</ul>

	<h2 id="prerequisites">Prerequisites</h2>
	
	<p>To use the functions and data types of the i18n API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__MODULE.html">wearable</a> applications) and its submodules, include the <span style="font-family: Courier New,Courier,monospace">&lt;utils_i18n.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;utils_i18n.h&gt;
</pre>
	
<h2 id="characters" name="characters">Managing Characters and Strings</h2>

<p>Character and string management tasks include:</p>
<ul>
<li><a href="#compare">Comparing Ustrings</a></li>
<li><a href="#strings">Converting strings to Ustrings</a></li>
<li><a href="#ustrings">Converting Ustrings to strings</a></li>
<li><a href="#unicode">Getting the Unicode block of a character</a></li>
<li><a href="#property">Getting the property value of a character</a></li>
<li><a href="#normalize">Normalizing Ustrings</a></li>
<li><a href="#search">Searching text in a Ustring</a></li>
<li><a href="#uppercase">Changing the case in a Ustring</a></li>
<li><a href="#concatenate">Concatenating Ustrings</a></li>
<li><a href="#substring">Finding a substring</a></li>
</ul>

	  <table class="note">
	   <tbody>
		<tr>
		 <th class="note">Note</th>
		</tr>
		<tr>
		 <td class="note">All source and destination buffers must be different.
		</td>
		</tr>
	   </tbody>
	  </table>

<h3 id="compare" name="compare">Comparing Ustrings</h3>
<p>To compare 2 Ustrings for bitwise equality, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_compare()</span> function.</p>
<p>The obtained result is equal to 0 if the compared Ustrings are equal. The result is a negative value if the first Ustring is smaller bitwise than the second one, and a positive value if the first Ustring is greater than the second one.</p>
<pre class="prettyprint">
#define BUF_SIZE 64

i18n_uchar s1[BUF_SIZE];
i18n_ustring_copy_ua(s1, &quot;Tizen&quot;);
i18n_uchar s2[BUF_SIZE];
i18n_ustring_copy_ua(s2, &quot;Bada&quot;);
int32_t result = i18n_ustring_compare(s1, s2);
</pre>

<p>For a more complex, locale-sensitive comparison, use the Ucollator API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCOLLATOR__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCOLLATOR__MODULE.html">wearable</a> applications):</p>
<ol>
<li>Create a Ucollator using the <span style="font-family: Courier New,Courier,monospace">i18n_ucollator_create()</span> function. <p>Specify the locale as the first parameter and a handle to the created Ucollator as the second parameter.</p>
<pre class="prettyprint">
i18n_ucollator_h coll;
i18n_ucollator_create(I18N_ULOCALE_US, &amp;coll);
</pre></li>
<li>Set the Ucollator strength using the <span style="font-family: Courier New,Courier,monospace">i18n_ucollator_set_strength()</span> function.
<p>The strength influences how the strings are compared. The following strength levels are available:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_DEFAULT_STRENGTH</span>: Default</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_PRIMARY</span>: Compares the primary differences only, such as different base letters (&quot;a&quot; vs. &quot;b&quot;).</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_SECONDARY</span>: Compares primary and secondary differences, such as different accented forms of the same base letter (&quot;a&quot; vs. &quot;ä&quot;).</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_TERTIARY</span>: Compares primary, secondary, and tertiary differences, such as case differences (&quot;a&quot; vs. &quot;A&quot;).</li>
</ul>

<pre class="prettyprint">
i18n_ucollator_set_strength(coll, I18N_UCOLLATOR_DEFAULT_STRENGTH);
</pre></li>
<li>Compare 2 Ustrings.
<p>To compare 2 Ustrings, you have 2 options:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">i18n_ucollator_equal()</span>: Shows whether the compared Ustrings are equal.</li>
<li><span style="font-family: Courier New,Courier,monospace">i18n_ucollator_str_collator()</span>: Shows whether the first Ustring is equal to, smaller, or greater than the second Ustring (<span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_EQUAL</span>, <span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_LESS</span>, or <span style="font-family: Courier New,Courier,monospace">I18N_UCOLLATOR_GREATER</span>).</li>
</ul>

<pre class="prettyprint">
i18n_ubool equal;
i18n_ucollator_equal(coll, s1, -1, s2, -1, &amp;equal);

i18n_ucollator_result_e result;
i18n_ucollator_str_collator(coll, s1, -1, s2, -1, &amp;result);
</pre></li>
<li>When no longer needed, destroy the Ucollator using the <span style="font-family: Courier New,Courier,monospace">i18n_ucollator_destroy()</span> function:
<pre class="prettyprint">
i18n_ucollator_destroy(coll);
</pre></li></ol>

<h3 id="strings" name="strings">Converting Strings to Ustrings</h3>
<p>To convert strings to Ustrings:</p>

<ul><li><p>To convert a byte string to a Unicode string (Ustring), use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_copy_ua()</span> function:</p>
<pre class="prettyprint">
const char *src = &quot;Tizen&quot;;
i18n_uchar dest[BUF_SIZE];
i18n_ustring_copy_ua(dest, src);
</pre></li>
<li><p>To convert a byte string to a Ustring while defining a maximum number of characters to be copied, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_copy_ua_n()</span> function and set the character limit as the third parameter:</p>
<pre class="prettyprint">
const char *src = &quot;Tizen&quot;;
i18n_uchar dest[BUF_SIZE];
i18n_ustring_copy_ua_n(dest, src, BUF_SIZE);
</pre></li>
<li><p>To convert a UTF-8 string to a UTF-16 string, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_from_UTF8()</span> function.</p>
<p>The function returns the length of the converted string and an error code variable as out parameters.</p>
<pre class="prettyprint">
const char *src = &quot;Tizen&quot;;
i18n_uchar dest[BUF_SIZE];
int dest_len;
i18n_uerror_code_e error_code = I18N_ERROR_NONE;
i18n_ustring_from_UTF8(dest, BUF_SIZE, &amp;dest_len, src, -1, &amp;error_code);
</pre></li></ul>

<h3 id="ustrings" name="ustrings">Converting Ustrings to Strings</h3>
<p>To convert Ustrings to strings:</p>

<ul>
<li><p>To convert a Ustring to a byte string, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_copy_au()</span> function:</p>
<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_ustring_copy_ua(src, &quot;Tizen&quot;);
char dest[BUF_SIZE];
i18n_ustring_copy_au(dest, src);
</pre></li>
<li><p>To convert a Ustring to a byte string while defining a maximum number of characters to be copied, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_copy_au_n()</span> function and set the character limit as the third parameter:</p>
<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_ustring_copy_ua(src, &quot;Tizen&quot;);
char dest[BUF_SIZE];
i18n_ustring_copy_au_n(dest, src, BUF_SIZE);
</pre></li>

<li><p>To convert a UTF-16 string to a UTF-8 string, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_to_UTF8()</span> function.</p>
<p>The function returns the length of the converted string and an error code variable as out parameters.</p>
<p>To get the length of a Ustring, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_get_length()</span> function.</p>

<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_ustring_copy_ua(src, &quot;Tizen&quot;);
char dest[BUF_SIZE];
int dest_len;
i18n_uerror_code_e error_code = I18N_ERROR_NONE;
i18n_ustring_to_UTF8(dest, BUF_SIZE, &amp;dest_len, src, i18n_ustring_get_length(src), &amp;error_code);
</pre></li></ul>

<h3 id="unicode" name="unicode">Getting the Unicode Block of a Character</h3>
<p>To get information about the location of a specified character, use the <span style="font-family: Courier New,Courier,monospace">i18n_uchar_get_ublock_code()</span> function.</p>
<p>The function returns, as an out parameter, the Unicode allocation block that contains the specified character. The Unicode blocks are defined in the <span style="font-family: Courier New,Courier,monospace">i18n_uchar_ublock_code_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html#gaa338daff96b0e62243e25fe240e4eda5">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html#gaa338daff96b0e62243e25fe240e4eda5">wearable</a> applications).</p>
<pre class="prettyprint">
i18n_uchar character = 0xC131;
i18n_uchar_ublock_code_e ublock;
i18n_uchar_get_ublock_code(character, &amp;ublock);
</pre>

<h3 id="property" name="property">Getting the Property Value of a Character</h3>

<p>To get the property value of a specified character, use the <span style="font-family: Courier New,Courier,monospace">i18n_uchar_get_int_property_value()</span> function.</p>
<p>The character properties are defined in the <span style="font-family: Courier New,Courier,monospace">i18n_uchar_uproperty_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html#gaa57de8e60ee941839fdfd80833106757">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCHAR__MODULE.html#gaa57de8e60ee941839fdfd80833106757">wearable</a> applications).</p>

<p>The following example shows how to read the East Asian width property:</p>
<pre class="prettyprint">
i18n_uchar character = 0xC131;
int32_t property_value;
i18n_uchar_get_int_property_value(character, I18N_UCHAR_EAST_ASIAN_WIDTH, &amp;property_value);
</pre>


<h3 id="normalize" name="normalize">Normalizing Ustrings</h3>
<p>To normalize a Ustring:</p>
<ol>
<li>Get a Unormalizer instance using the <span style="font-family: Courier New,Courier,monospace">i18n_unormalization_get_instance()</span> function of the Unormalization API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UNORMALIZATION__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UNORMALIZATION__MODULE.html">wearable</a> applications). 
<p>To use the built-in normalizer, set the first parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>
<pre class="prettyprint">
i18n_unormalizer_h normalizer;
i18n_unormalization_get_instance(NULL, &quot;nfc&quot;, I18N_UNORMALIZATION_DECOMPOSE, &amp;normalizer);
</pre>
</li>

<li>Normalize a Ustring or Uchar with the obtained normalizer using the <span style="font-family: Courier New,Courier,monospace">i18n_unormalization_normalize()</span> function:
<pre class="prettyprint">
i18n_uchar src = 0xACE0;
i18n_uchar dest[4];
int dest_str_len;
i18n_unormalization_normalize(normalizer, &amp;src, 1, dest, 4, &amp;dest_str_len);
</pre></li></ol>

<h3 id="search" name="search">Searching Text in a Ustring</h3>
<p>To search a substring in a Ustring:</p>
<ol>
<li>Create a search iterator using the <span style="font-family: Courier New,Courier,monospace">i18n_usearch_create_new()</span> function of the Usearch API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__USEARCH__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__USEARCH__MODULE.html">wearable</a> applications):
<pre class="prettyprint">
i18n_uchar text[BUF_SIZE];
i18n_ustring_copy_ua(text, &quot;TIZEN&quot;);
i18n_uchar pattern[BUF_SIZE];
i18n_ustring_copy_ua(pattern, &quot;ZEN&quot;);
i18n_usearch_h usearch;
i18n_usearch_create_new(pattern, -1, text, -1, I18N_ULOCALE_US, NULL, &amp;usearch);
</pre></li>
<li>Get the index of the first match (the first occurrence of the found pattern) using the <span style="font-family: Courier New,Courier,monospace">i18n_usearch_first()</span> function:
<pre class="prettyprint">
int index;
i18n_usearch_first(usearch, &amp;index);
</pre></li>
<li>When no longer needed, destroy the search iterator using the <span style="font-family: Courier New,Courier,monospace">i18n_usearch_destroy()</span> function:
<pre class="prettyprint">
i18n_usearch_destroy(usearch);
</pre></li></ol>

<h3 id="uppercase" name="uppercase">Changing the Case in a Ustring</h3>
<p>To change the case in a Ustring:</p>
<ol>
<li>To change all characters&#39; case in a Ustring, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_to_upper()</span> or <span style="font-family: Courier New,Courier,monospace">i18n_ustring_to_lower()</span> function:

<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_ustring_copy_ua(src, &quot;Tizen&quot;);
i18n_uchar dest[BUF_SIZE];
i18n_ustring_to_upper(dest, BUF_SIZE, src, -1, I18N_ULOCALE_US, &amp;error_code);
i18n_ustring_to_lower(dest, BUF_SIZE, src, -1, I18N_ULOCALE_US, &amp;error_code);
</pre>
</li>
<li>To change the string case to title case, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_to_title_new()</span> function:
<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_ustring_copy_ua(src, &quot;Tizen&quot;);
i18n_uchar dest[BUF_SIZE];
i18n_ustring_to_title_new(dest, BUF_SIZE, src, BUF_SIZE, NULL, NULL);
</pre>
</li>
</ol>

<h3 id="concatenate" name="concatenate">Concatenating Ustrings</h3>
<p>To concatenate 2 Ustrings, use the <span style="font-family: Courier New,Courier,monospace">18n_ustring_cat()</span> or <span style="font-family: Courier New,Courier,monospace">18n_ustring_cat_n()</span> function.</p>
<p>The functions differ in that the latter takes a third parameter to define a maximum number of characters to append to the destination string.</p>
<pre class="prettyprint">
i18n_uchar src[BUF_SIZE];
i18n_uchar dest[BUF_SIZE];

i18n_ustring_copy_ua(dest, &quot;Destination string&quot;);
i18n_ustring_copy_ua(src, &quot;Appended string&quot;);

i18n_ustring_cat_n(dest, src, BUF_SIZE);
/* Or */
i18n_ustring_cat(dest, src);
</pre>

<h3 id="substring" name="substring">Finding a Substring</h3>
<p>To find a substring in a Ustring, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_string()</span> function.</p>
<p>The result is a pointer to the first occurrence of the substring, or <span style="font-family: Courier New,Courier,monospace">NULL</span> if the substring is not found. You can use pointer arithmetic to find the index of the character at which the first occurrence begins.</p>

<pre class="prettyprint">
i18n_uchar s[BUF_SIZE];
i18n_uchar substring[BUF_SIZE];

i18n_uchar *result = i18n_ustring_string(s, substr);

if (result == NULL)
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Substring not found&quot;);
else
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Substring index: %d&quot;, result - s);
</pre>

	
<h2 id="dates" name="dates">Managing Dates and Calendar</h2>


<p>To create and use a calendar:</p>
<ol>
<li><p>To manage dates and calendar, the Ucalendar (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html">wearable</a> applications), Udate (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html">wearable</a> applications), and Udatepg (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UDATEPG__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UDATEPG__MODULE.html">wearable</a> applications) APIs are used.</p>
<ul>
	<li>The Ucalendar API is used for converting between an <span style="font-family: Courier New,Courier,monospace">i18n_udate</span> object and a set of integer fields, such as <span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_YEAR</span>, <span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_MONTH</span>, <span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_DAY</span>, and <span style="font-family: Courier New,Courier,monospace">I18N_UCALENDAR_HOUR</span>.</li>
	<li>The Udate API is used to convert dates and times from their internal representations to a textual form and back again in a language-independent manner.</li>
	<li>The Udatepg API is used to generate date format patterns, such as &quot;yy-MM-dd&quot;.</li>
</ul>

</li>
<li>To create a Ucalendar, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_create()</span> function:
<pre class="prettyprint">
i18n_uchar timezone[BUF_SIZE];
const char *timezone_name = &quot;America/New_York&quot;;
int timezone_name_len = strlen(timezone_name);
i18n_ustring_copy_ua_n(timezone, timezone_name, timezone_name_len + 1);
i18n_ucalendar_h ucalendar;
i18n_ucalendar_create(timezone, -1, I18N_ULOCALE_US, I18N_UCALENDAR_DEFAULT, &amp;ucalendar);
</pre></li>

<li>To set a date in the Ucalendar, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_set_date_time()</span> function.
<p>In the following example, the date is set as 1 July 2014, 9:00:00.</p>
<p>To define the month, you can use numbers (month reduced by 1, such as 0 for January and 1 for February), or to avoid mistakes, the values of the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_months_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html#ga094cacb2ef9ee4805e42e276fec5ae2f">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html#ga094cacb2ef9ee4805e42e276fec5ae2f">wearable</a> applications).</p>
<pre class="prettyprint">
i18n_ucalendar_set_date_time(ucalendar, 2014, I18N_UCALENDAR_JULY, 1, 9, 0, 0);
</pre>
<p>To set a date using milliseconds from the epoch, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_set_milliseconds()</span> function:</p>
<pre class="prettyprint">
i18n_udate udate;
/* udate must be set */
i18n_ucalendar_set_milliseconds(ucalendar, udate);
</pre>
<p>To add a specified period to the Ucalendar, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_add()</span> function.</p>
<p>Specify the date field to modify (such as year, week, or day) using the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_date_fields_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html#gaee345f9992035a07732d16d69c41c192">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UCALENDAR__MODULE.html#gaee345f9992035a07732d16d69c41c192">wearable</a> applications) as the second parameter, and the amount to modify as the third parameter (use a negative value to subtract from the existing value).</p>
<pre class="prettyprint">
i18n_ucalendar_add(ucalendar, I18N_UCALENDAR_HOUR, 3);
</pre></li>

<li>To get a date from the Ucalendar, you can use various functions:
<ul>
<li>To get a specific date field from a Ucalendar instance, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_get()</span> function and define the wanted date field with the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_date_fields_e</span> enumeration:
<pre class="prettyprint">
int uday;
i18n_ucalendar_get(ucalendar, I18N_UCALENDAR_DAY_OF_YEAR, &amp;uday);
</pre>
</li>
<li>To get a date from a Ucalendar in milliseconds from the epoch, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_get_milliseconds()</span> function:
<pre class="prettyprint">
i18n_udate date;
i18n_ucalendar_get_milliseconds(ucalendar, &amp;date);
</pre>
</li>
<li>To get the actual current date from the system, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_get_now()</span> function. The obtained date is represented as milliseconds from the epoch.
<pre class="prettyprint">
i18n_udate now;
i18n_ucalendar_get_now(&amp;now);
</pre>
</li>
</ul>
<p>To check whether the Ucalendar date is in daylight saving time, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_is_in_daylight_time()</span> function:</p>
<pre class="prettyprint">
bool dst;
i18n_ucalendar_is_in_daylight_time(ucalendar, &amp;dst);
</pre>
</li>

<li>To format a date, you can use a pattern generator or define a date format:
<ul>
<li>Using a pattern generator:
<ol type="a">
<li>To create a Udatepg pattern generator instance, use the <span style="font-family: Courier New,Courier,monospace">i18n_udatepg_create()</span> function and define the desired locale as the first parameter:
<pre class="prettyprint">
i18n_udatepg_h udatepg;
i18n_udatepg_create(I18N_ULOCALE_UK, &amp;udatepg);
</pre>
</li>
<li>To generate a date best pattern with the pattern generator, use the <span style="font-family: Courier New,Courier,monospace">i18n_udatepg_get_best_pattern()</span> function. 
<p>As the second parameter, you need a draft format, which defines the fields to be displayed (for example, E for the day of the week, M for month, y for year, d for the day of the month, and D for day of the year).</p>
<pre class="prettyprint">
int pattern_len;
i18n_uchar format[BUF_SIZE];
i18n_ustring_copy_ua_n(format, &quot;EEEdMMMyyyyHHmmssz&quot;, BUF_SIZE);
i18n_uchar best_pattern[BUF_SIZE];
i18n_udatepg_get_best_pattern(udatepg, format, BUF_SIZE, best_pattern, BUF_SIZE, &amp;pattern_len);
</pre>
</li>
</ol>
</li>
<li>Using a date format:
<ol>
<li>To create a date format, use the <span style="font-family: Courier New,Courier,monospace">i18n_udate_create()</span> function.
<p>As the first and second parameter, specify the formatting style for time and date using the values of the <span style="font-family: Courier New,Courier,monospace">i18n_udate_format_style_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html#gaee2461e926bc151486d380c43bc4f2a3">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UDATE__MODULE.html#gaee2461e926bc151486d380c43bc4f2a3">wearable</a> applications).</p>
<pre class="prettyprint">
i18n_udate_format_h date_format;
const char *timezone_name = &quot;Asia/Seoul&quot;;
int timezone_name_len = strlen(timezone_name);
i18n_ustring_copy_ua_n(timezone, timezone_name, timezone_name_len + 1);
i18n_udate_create(I18N_UDATE_FULL, I18N_UDATE_FULL, I18N_ULOCALE_UK, timezone, -1, best_pattern, -1, &amp;date_format);
</pre>
</li>
<li>To obtain a Ustring with a specified date and the created date format, use the <span style="font-family: Courier New,Courier,monospace">i18n_udate_format_date()</span> function:
<pre class="prettyprint">
i18n_uchar date_result[BUF_SIZE];
int date_len;
i18n_udate_format_date(date_format, now, date_result, BUF_SIZE, NULL, &amp;date_len);
</pre>
</li>
</ol>
</li>
</ul>
</li>

<li>When no longer needed, destroy the Ucalendar, Udatepg, and Udate instances using the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_destroy()</span>, <span style="font-family: Courier New,Courier,monospace">i18n_udatepg_destroy()</span>, and <span style="font-family: Courier New,Courier,monospace">i18n_udate_destroy()</span> functions:
<pre class="prettyprint">
i18n_ucalendar_destroy(ucalendar);
i18n_udatepg_destroy(udatepg);
i18n_udate_destroy(date_format);
</pre></li>
</ol>

<h2 id="locales" name="locales">Managing Locales</h2>

<p>To manage the features of a specific geographical, political, or cultural region:</p>

<ul>
<li>To get the language code associated with a locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_language()</span> function:
<pre class="prettyprint">
char language[BUF_SIZE];
int lang_len;
i18n_ulocale_get_language(I18N_ULOCALE_GERMANY, language, BUF_SIZE, &amp;lang_len);
</pre></li>

<li>To get the language ISO-3 code for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_iso3_language()</span> function:
<pre class="prettyprint">
const char *language_iso = i18n_ulocale_get_iso3_language(I18N_ULOCALE_GERMANY);
</pre>
</li>

<li>To get the full name of the language for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_display_language()</span> function.
<p>In the following example, the name of the &quot;fr_CA&quot; locale is obtained in German:</p>
<pre class="prettyprint">
char *locale = I18N_ULOCALE_CANADA_FRENCH;
i18n_uchar language_name[BUF_SIZE];
int lang_len;
i18n_ulocale_get_display_language(locale, I18N_ULOCALE_GERMANY, language_name, BUF_SIZE, &amp;lang_len);
</pre>
</li>

<li>To get the line orientation for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_line_orientation()</span> function:
<pre class="prettyprint">
const char *locale = I18N_ULOCALE_ENGLISH;
i18n_ulocale_layout_type_e type;
i18n_ulocale_get_line_orientation(locale, &amp;type);
</pre></li>

<li>To get the character orientation for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_character_orientation()</span> function:
<pre class="prettyprint">
const char *locale = I18N_ULOCALE_ENGLISH;
i18n_ulocale_layout_type_e type;
i18n_ulocale_get_character_orientation(locale, &amp;type);
</pre></li>

<li>To get the variant code for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_variant()</span> function.
<p>The function returns the actual size of the variant code.</p>
<pre class="prettyprint">
const char *locale = I18N_ULOCALE_ENGLISH;
char *variant = malloc(sizeof(char) * BUF_SIZE);
int32_t variant_len = i18n_ulocale_get_variant(locale, variant, BUF_SIZE);
</pre>
</li>

<li>To get a full name for the specified locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_display_name()</span> function. 
<p>In the following example, the name of the &quot;fr_CA&quot; locale is obtained in German:</p>
<pre class="prettyprint">
i18n_uchar name[BUF_SIZE];
int name_len;
i18n_ulocale_get_display_name(I18N_ULOCALE_CANADA_FRENCH, I18N_ULOCALE_GERMANY, name, BUF_SIZE, &amp;name_len);
</pre>
</li>

<li>To get or set the default locale, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_get_default()</span> or <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_set_default()</span> function:
<pre class="prettyprint">
/* Get */
char *locale;
i18n_ulocale_get_default(&amp;locale);

/* Set */
i18n_ulocale_set_default(I18N_ULOCALE_KOREA);
</pre></li>
</ul>

<h2 id="numbers" name="numbers">Managing Numbers</h2>

<p>To format and parse numbers for a locale:</p>
<ol>
<li>To create a number format, use the <span style="font-family: Courier New,Courier,monospace">i18n_unumber_create()</span> function.
<p>Define the style as the first parameter using the <span style="font-family: Courier New,Courier,monospace">i18n_unumber_format_style_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html#ga4edc8cb72e7f46e05d8cdfe24cf386f1">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html#ga4edc8cb72e7f46e05d8cdfe24cf386f1">wearable</a> applications).</p>
<p>The fourth parameter sets the locale (<span style="font-family: Courier New,Courier,monospace">NULL</span> for default). Some string shortcuts for specific locales are defined in the <span style="font-family: Courier New,Courier,monospace">utils_i18n_types.h</span> header file. For example, <span style="font-family: Courier New,Courier,monospace">I18N_ULOCALE_US</span> is equal to &quot;en_US&quot;.</p>
<pre class="prettyprint">
i18n_unumber_format_h num_format;
i18n_unumber_format_style_e format_style = I18N_UNUMBER_CURRENCY;
const char* locale = I18N_ULOCALE_US;
i18n_unumber_create(format_style, NULL, -1, locale, NULL, &amp;num_format);
</pre>
</li>
<li>To use the created number format to format a given number based on the rules of a specified locale, you can use various <span style="font-family: Courier New,Courier,monospace">i18n_unumber_format_XXX()</span> functions.
<p>The following example formats a double-type number:</p>
<pre class="prettyprint">
#define BUF_SIZE 64
i18n_uchar myString[BUF_SIZE];
double myNumber = 4.5;
i18n_unumber_format_double(num_format, myNumber, myString, BUF_SIZE, NULL);
</pre>

<p>The result set in the <span style="font-family: Courier New,Courier,monospace">myString</span> variable is equal to:</p>
<pre class="prettyprint">
$4.50
</pre>
</li>
<li>To get a symbol associated with the created number format, use the <span style="font-family: Courier New,Courier,monospace">i18n_unumber_get_symbol()</span> function. 
<p>The second parameter uses the values of the <span style="font-family: Courier New,Courier,monospace">i18n_unumber_format_symbol_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html#ga9abb496f12b9fd47244060af5ecbc39e">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__BASE__UTILS__I18N__UNUMBER__MODULE.html#ga9abb496f12b9fd47244060af5ecbc39e">wearable</a> applications) to define the symbol to be retrieved.</p>
<p>The function returns the symbol used in the given locale. In the following example, it returns the currency <span style="font-family: Courier New,Courier,monospace">$</span> sign:</p>
<pre class="prettyprint">
i18n_uchar buffer[BUF_SIZE];
int buf_len;
i18n_unumber_format_symbol_e symbol = I18N_UNUMBER_CURRENCY_SYMBOL;
i18n_unumber_get_symbol(num_format, symbol, buffer, BUF_SIZE, &amp;buf_len);
</pre>
</li>

<li>When no longer needed, destroy the number format with the <span style="font-family: Courier New,Courier,monospace">i18n_unumber_destroy()</span> function:
<pre class="prettyprint">
i18n_unumber_destroy(num_format);
</pre>
</li>

</ol>

<h2 id="ubrk" name="ubrk">Managing Iteration Using Ubrk</h2>

<p>To manipulate or iterate through strings, you can use the Ubrk library. It helps you to treat strings as a set of characters, words, or sentences:</p>
<ol>
<li>To create an iterator to iterate through a string, use the <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_create()</span> function. 
<p>The first parameter defines the type of the iterator:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UBRK_WORD</span> for word iteration</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UBRK_CHARACTER</span> for character iteration</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UBRK_LINE</span> for line iteration</li>
<li><span style="font-family: Courier New,Courier,monospace">I18N_UBRK_SENTENCE</span> for sentence iteration</li>
</ul>
<pre class="prettyprint">
i18n_ubreak_iterator_h boundary;
const char *str = &quot;Twinkle, twinkle little star&quot;;
int str_len = strlen(str);
i18n_uchar* stringToExamine = malloc(sizeof(i18n_uchar)*(str_len + 1));
i18n_ustring_copy_ua(stringToExamine, str);
i18n_ubrk_create(I18N_UBRK_WORD, I18N_ULOCALE_US, stringToExamine, -1, &amp;boundary);
</pre></li>

<li>To change the position of the iterator, you can use several functions, such as <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_first()</span>, <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_last()</span>, <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_next()</span>, and <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_previous()</span>. 
<p>The following example retrieves the boundaries of the first word in the <span style="font-family: Courier New,Courier,monospace">stringToExamine</span> string. The <span style="font-family: Courier New,Courier,monospace">start</span> and <span style="font-family: Courier New,Courier,monospace">end</span> variables represent the boundaries of the first word, in this example 0 and 7.</p>
<pre class="prettyprint">
int32_t start = i18n_ubrk_first(boundary);
int32_t end = i18n_ubrk_next(boundary);
</pre>
</li>

<li>To retrieve a string delimited with the <span style="font-family: Courier New,Courier,monospace">start</span> and <span style="font-family: Courier New,Courier,monospace">end</span> boundary variables, use the <span style="font-family: Courier New,Courier,monospace">i18n_ustring_copy_n()</span> function.
<p>The second parameter defines the source string, and the third parameter defines the maximum number of characters to copy.</p>
<pre class="prettyprint">
i18n_ustring_copy_n(result, &amp;str[start], end-start);
</pre></li>

<li>When no longer needed, destroy the ubreak iterator with the <span style="font-family: Courier New,Courier,monospace">i18n_ubrk_destroy()</span> function. Remember to free all allocated memory with the <span style="font-family: Courier New,Courier,monospace">free()</span> function.
<pre class="prettyprint">
i18n_ubrk_destroy(boundary);
</pre></li>
</ol>

<h2 id="uenum" name="uenum">Managing Enumerations</h2>
<p>To create collections of strings and iterate through them, <a href="#create_enum">create an enumeration</a>. You can also <a href="#get_enum">obtain enumerations from specific functions</a>.</p>

<h3 id="create_enum" name="create_enum">Creating an Enumeration</h3>
<p>To create an enumeration based on existing strings:</p>
<ol>
<li>Define an array of strings (pointers to <span style="font-family: Courier New,Courier,monospace">char</span>):
<pre class="prettyprint">
const char* strings[] = {&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;};

/* Length of the pointers array (the number of strings) */
int32_t size = sizeof(strings) / sizeof(strings[0]);
</pre>
</li>

<li>Create an enumeration of the <span style="font-family: Courier New,Courier,monospace">char</span> strings:
<pre class="prettyprint">
i18n_uenumeration_h strings_enum;

i18n_uenumeration_char_strings_enumeration_create(strings, size, &amp;strings_enum);
</pre>

<p>In case of <span style="font-family: Courier New,Courier,monospace">i18n_uchar</span> strings, use the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_uchar_strings_enumeration_create()</span> function.</p>
</li>

<li>Get the number of elements:
<pre class="prettyprint">
int32_t count = i18n_uenumeration_count(strings_enum);
</pre>
<p>If the enumeration was created successfully, the value is equal to the <span style="font-family: Courier New,Courier,monospace">size</span> variable used above.</p>
</li>

<li>Iterate through the <span style="font-family: Courier New,Courier,monospace">char</span> elements using the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_next()</span> function, until it returns <span style="font-family: Courier New,Courier,monospace">NULL</span>.
<p>The string is null-terminated, and the <span style="font-family: Courier New,Courier,monospace">len</span> variable is the length of the string.</p>
<p>Do not free the returned string. The returned pointer is valid until a function is called for the enumeration.</p>
<pre class="prettyprint">
const char *element = NULL;
int len;

element = i18n_uenumeration_next(strings_enum, &amp;len);
while (element != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;/* Use the returned string */

&nbsp;&nbsp;&nbsp;&nbsp;element = i18n_uenumeration_next(strings_enum, &amp;len);
}
</pre>

<p>In case of <span style="font-family: Courier New,Courier,monospace">i18n_uchar</span> strings, use the <span style="font-family: Courier New,Courier,monospace">i18n_uenumeration_unext()</span> function.</p>
</li>

<li>When no longer needed, destroy the enumeration with the <span style="font-family: Courier New,Courier,monospace">18n_uenumeration_destroy()</span> function:
<pre class="prettyprint">
18n_uenumeration_destroy(strings_enum);
</pre>
</li>

</ol>

<h3 id="get_enum" name="get_enum">Obtaining an Enumeration</h3>
<p>Certain functions in the i18n module provide enumerations of values related to them. After the enumeration is obtained, you can iterate through its values.</p>
<ul>
<li>To get an enumeration of available time zones and iterate through them, use the <span style="font-family: Courier New,Courier,monospace">i18n_ucalendar_timezones_create()</span> function:
<pre class="prettyprint">
i18n_uenumeration_h timezones;
i18n_ucalendar_timezones_create(&amp;timezones);

int32_t count = i18n_uenumeration_count(timezones);

const char *tz = NULL;
int len;

tz = i18n_uenumeration_next(timezones, &amp;len);
while (tz != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;/* Use the time zone string */

&nbsp;&nbsp;&nbsp;&nbsp;tz = i18n_uenumeration_next(timezones, &amp;len);
}

i18n_uenumeration_destroy(timezones);
</pre>
</li>
<li>After creating a date pattern generator for a given locale, you can obtain an enumeration of all the pattern skeletons in a canonical form.
<p>To get the enumeration and iterate through the skeletons, use the <span style="font-family: Courier New,Courier,monospace">i18n_udatepg_skeletons_create()</span> function:</p>
<pre class="prettyprint">
i18n_udatepg_h udatepg;
i18n_udatepg_create(I18N_ULOCALE_UK, &amp;udatepg);

i18n_uenumeration_h skeletons;
i18n_udatepg_skeletons_create(udatepg, &amp;skeletons);

i18n_udatepg_destroy(udatepg);

int32_t count = i18n_uenumeration_count(skeletons);

const char *sk = NULL;
int len;

sk = i18n_uenumeration_next(skeletons, &amp;len);
while (sk != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;/* Use the skeleton string */

&nbsp;&nbsp;&nbsp;&nbsp;sk = i18n_uenumeration_next(skeletons, &amp;len);
}

i18n_uenumeration_destroy(skeletons);
</pre>
</li>
<li>To get an enumeration of keywords for a given locale string and iterate through the keywords, use the <span style="font-family: Courier New,Courier,monospace">i18n_ulocale_keywords_create()</span> function:
<pre class="prettyprint">
const char *loc_string = &quot;en_US@collation=PHONEBOOK;calendar=GREGORIAN;currency=USD&quot;;

i18n_uenumeration_h keywords;
i18n_ulocale_keywords_create(loc_string, &amp;keywords);

int32_t count = i18n_uenumeration_count(keywords);

const char *keyword = NULL;
int len;

keyword = i18n_uenumeration_next(keywords, &amp;len);
while (keyword != NULL) {
&nbsp;&nbsp;&nbsp;&nbsp;/* Use the keyword string */

&nbsp;&nbsp;&nbsp;&nbsp;keyword = i18n_uenumeration_next(keywords, &amp;len);
}

i18n_uenumeration_destroy(keywords);
</pre>
</li>
</ul>
	

<h2 id="tmz" name="tmz">Managing Time Zones</h2>
<p>To manage time zone details, such as the time zone offset and daylight savings:</p>

<ol>
<li>To retrieve time zone information:

<ul><li><p>To get the default time zone based on the time zone where the program is running, use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_create_default()</span> function:</p>
<pre class="prettyprint">
i18n_timezone_h tmz;
i18n_timezone_create_default(&amp;tmz);
</pre></li>

<li><p>To get the display name of the time zone, use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_get_display_name()</span> function:</p>
<pre class="prettyprint">
char *display_name;
i18n_timezone_get_display_name(tmz, &amp;display_name);
</pre></li>

<li><p>To get the time zone ID, use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_get_id()</span> function:</p>
<pre class="prettyprint">
char *timezone_id;
i18n_timezone_get_id(tmz, &amp;timezone_id);
</pre></li>

<li>
<p>To check whether a given time zone uses daylight savings time (DST), use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_use_daylight_time()</span> function:</p>
<pre class="prettyprint">
bool dst_savings;
i18n_timezone_use_daylight_time(tmz, &amp;dst_savings);
</pre></li>

<li>
<p>To get the daylight savings (the amount of time to be added to the local standard time to get the local wall clock time), use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_get_dst_savings()</span> function.</p>
<p>The result is returned in milliseconds (3600000 ms = 1 hour). In the following example, milliseconds are changed to minutes (1 min = 60000 ms).</p>
<pre class="prettyprint">
#define MS_TO_MIN 60000
int32_t dst_savings;
i18n_timezone_get_dst_savings(tmz, &amp;dst_savings/MS_TO_MIN);
</pre>
</li>

<li><p>To get the raw GMT offset, use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_get_raw_offset()</span> function.</p>
<p>The result is the number of milliseconds to add to GMT to get the local time, before taking DST into account, and it is returned in milliseconds. In the following example, milliseconds are changed to minutes (1 min = 60000 ms).</p>
<pre class="prettyprint">
#define MS_TO_MIN 60000
int32_t offset_milliseconds;
i18n_timezone_get_raw_offset(tmz, &amp;offset_milliseconds/MS_TO_MIN);
</pre>
</li>

<li><p>To get the region code associated with the time zone ID, use the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_get_region()</span> function:</p>
<pre class="prettyprint">
char region[BUF_SIZE];
int32_t region_len = -1;
i18n_timezone_get_region(timezone_id, region, &amp;region_len, BUF_SIZE);
</pre></li></ul></li>

<li><p>When no longer needed, destroy the time zone instance with the <span style="font-family: Courier New,Courier,monospace">i18n_timezone_destroy()</span> function:</p>
<pre class="prettyprint">
i18n_timezone_destroy(tmz);
</pre></li></ol>	
	
<h2 id="uset" name="uset">Managing Sets</h2>
<p>You can create sets, which contain characters and strings. You can iterate through the set elements and carry out various operations on the set.</p>
<p>To manage sets:</p>
<ol>

<li>To create a set, use various <span style="font-family: Courier New,Courier,monospace">i18n_uset_create_XXX()</span> functions.
<p>The following example creates an empty set:</p>
<pre class="prettyprint">
i18n_uset_h set;
i18n_uset_create_empty(&amp;set);
</pre>
</li>
<li>To manage character sets:
<p>A character set contains characters as its elements.</p>
<ul>
<li>Add characters from a string to the set using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_add_all_code_points()</span> function:
<pre class="prettyprint">
const char *text = &quot;Example string&quot;;
i18n_uchar u_input_text[BUF_SIZE];
i18n_ustring_copy_ua(u_input_text, text);

i18n_uset_add_all_code_points(set, u_input_text, -1);
</pre>
</li>

<li>Get the list of characters in the set using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_char_at()</span> function:
<pre class="prettyprint">
int chars_count = i18n_uset_size(set);
int i;

/* Get all characters in the set */
for (i = 0; i &lt; chars_count; i++) 
&nbsp;&nbsp;&nbsp;&nbsp;i18n_uchar32 uchar = i18n_uset_char_at(set, i);
</pre>
</li>

<li>Check whether the set contains a specific character using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_contains()</span> function:
<pre class="prettyprint">
i18n_ubool contains_character = i18n_uset_contains(set, &#39;a&#39;);
</pre>
</li>

<li>Check whether the set contains characters from a specific range using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_contains_range()</span> function.
<p>The following example uses the range &quot;a-c&quot;.</p>
<pre class="prettyprint">
i18n_ubool contains_character = i18n_uset_contains_range(set, &#39;a&#39;, &#39;c&#39;);
</pre>
</li>

<li>Check whether the set contains characters from another set using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_contains_all()</span> function:
<pre class="prettyprint">
i18n_uset_h compare_set = NULL;
i18n_uset_create_empty(&amp;compare_set);
/* Fill the second set */

i18n_ubool contains_character = i18n_uset_contains_all(set, compare_set);
</pre>
</li>
</ul>
</li>
<li>To manage string sets:
<p>A string set contains strings as its elements.</p>	
<ul>
<li>Add a string to the set using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_add_string()</span> function.
<p>The entire string is a single element.</p>
<pre class="prettyprint">
const char *text = &quot;Example string&quot;;
i18n_uchar u_input_text[BUF_SIZE];
i18n_ustring_copy_ua(u_input_text, text);

i18n_uset_add_string(set, u_input_text, -1);
</pre>
</li>

<li>List all strings in the set using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_get_item()</span> function.
<p>The function returns the length of a string item, or 0, if the item is a range.</p>
<pre class="prettyprint">
int strings_count = i18n_uset_get_item_count(set);
int32_t len = 0;
int32_t i;
for (i = 0; i &lt; strings_count; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;i18n_uchar32 start, end;
&nbsp;&nbsp;&nbsp;&nbsp;i18n_uchar string[100];
&nbsp;&nbsp;&nbsp;&nbsp;len = i18n_uset_get_item(set, i, &amp;start, &amp;end, string, 100);
&nbsp;&nbsp;&nbsp;&nbsp;if (len != 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* String was found, use the &#39;string&#39; variable */
}
</pre>
</li>
<li>Check whether the set contains a string using the <span style="font-family: Courier New,Courier,monospace">i18n_uset_contains_string()</span> function:
<pre class="prettyprint">
const char *input_string = &quot;Input string&quot;;
int input_string_len = strlen(input_string);
i18n_uchar *input_ustring = malloc(sizeof(i18n_uchar) * (input_string_len + 1));
i18n_ustring_copy_ua(input_ustring, input_string);

i18n_ubool contains = i18n_uset_contains_string(set, input_ustring, -1);
</pre>
</li>
</ul>
</li>
</ol>
 
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>


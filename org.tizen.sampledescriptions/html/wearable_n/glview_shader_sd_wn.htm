<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>GLViewShader Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Wearable native" src="../images/wearable_s_n.png"/></p>
	</div>

  <h1>GLViewShader Sample Overview</h1> 

<p>The GLViewShader sample application demonstrates how you can render more complex geometries with OpenGL ES 2.0, using slightly more advanced vertex and fragment shaders to draw a rotating teapot. It also demonstrates how to use Elementary GLView helper macros to port existing code easily to Tizen.</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">The application presented in this overview is not a full Tizen application, since it does not use the Application Framework. The application simply starts and runs.</td> 
		</tr> 
	   </tbody> 
	  </table> 
	  
<p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>
	  
	  <p>The following figure illustrates the main screen of the GLViewShader.</p>

  <p class="figure">Figure: GLViewShader screen</p> 
  <p align="center"><img alt="GLViewShader screen" src="../images/glview_shader_wn.png" /></p>  
	
	<p>The application opens with an animated wobbly teapot.</p>
	
<h2>Implementation</h2>
	
<h3>Elementary_GL_Helpers</h3>
<p>The <span style="font-family: Courier New,Courier,monospace">&lt;Elementary_GL_Helpers.h&gt;</span> header file provides a set of convenient functions and macros. To use these functions and macros, include this header file in the application.</p>
<pre class="prettyprint">
#include &lt;app.h&gt;
#include &lt;Elementary.h&gt;
#include &lt;Elementary_GL_Helpers.h&gt;
#include &lt;efl_extension.h&gt;

#include &quot;glviewcube_utils.h&quot;

ELEMENTARY_GLVIEW_GLOBAL_DEFINE();

static bool 
app_create(void *data) 
{
&nbsp;&nbsp;&nbsp;// Create and initialize GLView
&nbsp;&nbsp;&nbsp;gl = elm_glview_add(ad-&gt;conform);
&nbsp;&nbsp;&nbsp;ELEMENTARY_GLVIEW_GLOBAL_USE(gl);
}
</pre>

<h3>Setting up Callbacks</h3>

<p>To set up callbacks:</p>
<ol>
<li>Set the initialization callback.
<p>The initialization callback is called when the GLView is first created, after a valid OpenGL ES context and surface have been created.</p>
<p>This callback function initializes shaders using the <span style="font-family: Courier New,Courier,monospace">init_shaders(obj)</span> function.</p>
<p>A Vertex Buffer Object (VBO) allows vertex array data to be stored in a high-performance graphics memory on the server to maximize data transfer efficiency.</p>
<p>A VBO is created in the application for the teapot vertices. Additionally, an Index Buffer Object (IBO) is created for the indices. The <span style="font-family: Courier New,Courier,monospace">glGenBuffers()</span> function specifies an array in which the buffer object name is stored.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">glBindBuffer()</span> function binds the buffer object to a specified target. In this case, the target is <span style="font-family: Courier New,Courier,monospace">GL_ARRAY_BUFFER</span>.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">glBufferData()</span> function is used to create a new data storage for the current buffer object. The parameters of the function are the buffer object target, the data store size, the array of teapot vertices, and the usage function of the data store (in this case, <span style="font-family: Courier New,Courier,monospace">GL_STATIC_DRAW</span>).</p>
<pre class="prettyprint">
static void 
init_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;if (!ad-&gt;initialized) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_shaders(obj);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glEnable(GL_DEPTH_TEST);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;idx_vbo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;idx_vbo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float) * MAX_V_COUNT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEAPOT_VERTICES, GL_STATIC_DRAW);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;idx_ibo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ad-&gt;idx_ibo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBufferData(GL_ELEMENT_ARRAY_BUFFER,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 * sizeof(unsigned short) * MAX_F_COUNT, TEAPOT_INDICES,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_STATIC_DRAW);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;initialized = EINA_TRUE;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Initialize the shaders:
<ol type="a">
	<li>Vertex and fragment shaders are created and compiled by passing the shader parameters to the <span style="font-family: Courier New,Courier,monospace">glCreateShader()</span> function.
	<p>Load the shader objects, use the GLES2 Shader compiler to read and compile the shader source code for both the fragment and the vertex shader.</p>
	<pre class="prettyprint">
static void 
init_shaders(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);
&nbsp;&nbsp;&nbsp;const char *p;
&nbsp;&nbsp;&nbsp;p = vertex_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;vtx_shader = glCreateShader(GL_VERTEX_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;vtx_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;vtx_shader);

&nbsp;&nbsp;&nbsp;p = fragment_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;fgmt_shader = glCreateShader(GL_FRAGMENT_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;fgmt_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;fgmt_shader);
</pre></li>
	<li>Once the shader objects have been loaded, a shader program is created. The program attaches and links the shader objects to the shader program.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ad-&gt;program = glCreateProgram();
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;fgmt_shader);
&nbsp;&nbsp;&nbsp;glLinkProgram(ad-&gt;program);
</pre>
</li>

<li>Get the location for each attribute in the shader program using the <span style="font-family: Courier New,Courier,monospace">glGetUniformLocation()</span> and <span style="font-family: Courier New,Courier,monospace">glGetAttribLocation()</span> functions. If the shader program attributes, such as <span style="font-family: Courier New,Courier,monospace">u_mvpMatrix</span> and <span style="font-family: Courier New,Courier,monospace">a_position</span> are valid, these functions return an integer value that represents the index location of the attributes. For invalid attributes, the return value is -1.
<p>The <span style="font-family: Courier New,Courier,monospace">glGetUniformLocation()</span> function retrieves the location of the uniform related to groups of vertices or pixels, such as the model view matrix, projection matrix, or light position. The <span style="font-family: Courier New,Courier,monospace">glGetAttribLocation()</span> function retrieves the location of the attributes related to a vertex or pixel, such as position vector, normal vector, or vertex color.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ad-&gt;idx_light_dir = glGetUniformLocation(ad-&gt;program, &quot;u_light_dir&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;idx_mvp = glGetUniformLocation(ad-&gt;program, &quot;u_mvpMatrix&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;idx_time_stamp = glGetUniformLocation(ad-&gt;program, &quot;u_time_stamp&quot;);

&nbsp;&nbsp;&nbsp;ad-&gt;idx_vposition = glGetAttribLocation(ad-&gt;program, &quot;a_position&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;idx_vnormal = glGetAttribLocation(ad-&gt;program, &quot;a_normal&quot;);
</pre>
</li>
	
	<li>Install the shader program and enable the GPU to execute the shader operations in the frame buffer.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glUseProgram(ad-&gt;program);
}
</pre>
</li>
</ol>
</li>

<li>Set the resize callback.
<p>The resize callback is called whenever the GLView component is resized. It resets the viewport.</p>
<pre class="prettyprint">
static void 
resize_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);
&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;ad-&gt;glview_w, &amp;ad-&gt;glview_h);
}
</pre>
</li>

<li>Set the draw callback.
<p>The draw callback is called whenever a new frame has to be drawn.</p>
<p>The application can now draw anything using GL primitives when this callback is triggered.</p>
<ol type="a">
	<li>The <span style="font-family: Courier New,Courier,monospace">glViewport()</span> function specifies the affine transformation of the x and y values from normalized device coordinates to window coordinates as specified by the <span style="font-family: Courier New,Courier,monospace">elm_glview_size_get()</span> function.
	<pre class="prettyprint">
static void 
draw_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;ad-&gt;glview_w, &amp;ad-&gt;glview_h);

&nbsp;&nbsp;&nbsp;glViewport(0, 0, ad-&gt;glview_w, ad-&gt;glview_h);
</pre>
	</li>
	<li>The <span style="font-family: Courier New,Courier,monospace">glUniform4fv()</span> function modifies the light direction in the graphic based on the light-related information of the teapot.
	<p>The <span style="font-family: Courier New,Courier,monospace">glUniformMatrix4fv()</span> modifies the values of the 4x4 MVP (Model View/Projection) uniform matrix according to the vertices information of the teapot. An MVP matrix is created with data after each vertex of the teapot has passed through 2 transformation stages. The first transformation state is the model view transformation, which includes translation, rotation, and scaling of objects. The second state is projection, which includes changes in the  perspective or orthography.</p>
	<p>The <span style="font-family: Courier New,Courier,monospace">glUniform1f()</span> function modifies the timer-related information while drawing the teapot on the screen.</p>
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glUniform4fv(ad-&gt;idx_light_dir, 1, ad-&gt;light_dir);
&nbsp;&nbsp;&nbsp;glUniformMatrix4fv(ad-&gt;idx_mvp, 1, GL_FALSE, ad-&gt;mvp);
&nbsp;&nbsp;&nbsp;glUniform1f(ad-&gt;idx_time_stamp, ad-&gt;time_stamp);
</pre>
	</li>
	
	<li>The <span style="font-family: Courier New,Courier,monospace">glVertexAttribPointer()</span> function is used to define an array of generic vertex attribute data. These attributes are parameters associated with each vertex of the teapot. In this case, they are position and normal.
	<p>A normal tells you in which direction a surface is facing. This helps in identifying the proper lighting of a surface.</p>
	<p>The <span style="font-family: Courier New,Courier,monospace">glEnableVertexAttribArray()</span> function enables the generic vertex attribute data arrays. These enabled attributes can be accessed and used to render the scene and apply the desired shading to it.</p>
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;idx_vbo);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;idx_vposition, 3, GL_FLOAT, GL_FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(float) * 6, 0);
&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;idx_vposition);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;idx_vnormal, 3, GL_FLOAT, GL_FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(float) * 6, (void*) (sizeof(float) * 3));
&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;idx_vnormal);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ad-&gt;idx_ibo);
</pre>
	</li>
	
	<li>Once the vertex arrays have been enabled, the actual process of rendering graphics primitives from the array data occurs using the <span style="font-family: Courier New,Courier,monospace">glDrawElements()</span> function.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glDrawElements(GL_TRIANGLES, MAX_F_COUNT * 3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_UNSIGNED_SHORT, 0);
</pre>
	</li>
	
	<li>The <span style="font-family: Courier New,Courier,monospace">glFlush()</span> function empties all buffers causing all issued commands to be executed as quickly as they are accepted by the rendering engine.
	<p>Finally, the vertex attribute arrays are disabled using the <span style="font-family: Courier New,Courier,monospace">glDisableVertexAttribArray()</span> function, and the buffer object binding is released by calling the <span style="font-family: Courier New,Courier,monospace">glBindBuffer()</span> function. The buffer is reset at 0.</p>
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glFlush();

&nbsp;&nbsp;&nbsp;glDisableVertexAttribArray(ad-&gt;idx_vposition);
&nbsp;&nbsp;&nbsp;glDisableVertexAttribArray(ad-&gt;idx_vnormal);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, 0);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}
</pre>
	</li></ol></li>

<li>Add an animator.
<p>The application regularly triggers an update of the GLView using the <span style="font-family: Courier New,Courier,monospace">elm_glview_changed_set()</span> function.</p>

<p>The animator callback function is also triggered when the display is off. Use the <span style="font-family: Courier New,Courier,monospace">ecore_animator_freeze()</span> and <span style="font-family: Courier New,Courier,monospace">ecore_animator_thaw()</span> functions in the <span style="font-family: Courier New,Courier,monospace">app_pause_cb</span> and <span style="font-family: Courier New,Courier,monospace">app_resume_cb</span> callbacks for power saving.</p>

<pre class="prettyprint">
static Eina_Bool 
anim(void *data) 
{
&nbsp;&nbsp;&nbsp;elm_glview_changed_set(data);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static bool 
app_create(void *data) 
{
&nbsp;&nbsp;&nbsp;ad-&gt;ani = ecore_animator_add(anim, gl);
}

static void
app_pause(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ecore_animator_freeze(ad-&gt;ani);
}

static void
app_resume(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ecore_animator_thaw(ad-&gt;ani);
}
</pre>
</li>	

<li>Set the delete callback.
<p>The delete callback is triggered when the GLView is destroyed from the main loop.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">glDeleteBuffers()</span>, <span style="font-family: Courier New,Courier,monospace">glDeleteShader()</span>, and <span style="font-family: Courier New,Courier,monospace">glDeleteProgram()</span> functions are used to free the memory.</p>
<pre class="prettyprint">
static void 
del_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;glDeleteBuffers(1, &amp;ad-&gt;idx_vbo);
&nbsp;&nbsp;&nbsp;glDeleteBuffers(1, &amp;ad-&gt;idx_ibo);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;fgmt_shader);
&nbsp;&nbsp;&nbsp;glDeleteProgram(ad-&gt;program);

&nbsp;&nbsp;&nbsp;evas_object_data_del((Evas_Object*) obj, &quot;ad&quot;);
}
</pre>
</li>
</ol>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
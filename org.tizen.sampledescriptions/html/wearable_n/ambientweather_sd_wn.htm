<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>Ambient Weather Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Wearable native" src="../images/wearable_s_n.png"/></p>
	</div>

  <h1>Ambient Weather Sample Overview</h1>

<p>The Ambient Weather sample application demonstrates how to implement a simple watch with the current weather displayed in the ambient mode.</p>

<p>The following figure illustrates the main screen of the Ambient Weather application and the UI component structure.</p>

<p class="figure">Figure: Ambient Weather screen</p>
  <p align="center">
	  <img alt="Ambient Weather screen" src="../images/ambientweather_wn1.png" /> <img alt="Ambient Weather screen" src="../images/ambientweather_wn0.png" /> </p>
<p align="center"><img alt="Ambient Weather component structure" src="../images/ambientweather_wn3.png" />
</p>

<p>The application shows a digital watch on the screen. When the device goes into the ambient mode, the watch is replaced with current weather information.</p>

<p>The application is multi-threaded. The time-consuming task of requesting the weather data runs in a separate thread to avoid UI lockups. The following figure shows the weather data request diagram.</p>

<p class="figure">Figure: Weather data request diagram</p>
<p align="center">
 <img alt="Weather data request diagram" src="../images/ambientweather_wn2.png" />
</p>

<h2>Prerequisites</h2>
<p>To ensure proper application execution, the following privileges must be set:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/network.get</span></li>
<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/keymanager</span></li>
<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/internet</span></li>
<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/alarm.set</span></li>
</ul>

<h2>Implementation</h2>

<h3>Main Module</h3>
<p>The <span style="font-family: Courier New,Courier,monospace">main()</span> function of the sample application starts the application loop with the <span style="font-family: Courier New,Courier,monospace">watch_app_main()</span> function.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">watch_app_lifecycle_callback_s</span> type object  is passed to the application loop with the <span style="font-family: Courier New,Courier,monospace">watch_app_main()</span> function. Pay attention to how it differs from the <span style="font-family: Courier New,Courier,monospace">ui_app_lifecycle_callback_s</span> type used in the standard application type. The <span style="font-family: Courier New,Courier,monospace">watch_app_lifecycle_callback_s</span> structure introduces 3 new pointers to the following callback functions:</p>
<ul>
 <li><span style="font-family: Courier New,Courier,monospace">watch_app_time_tick_cb()</span>: Called every second when the application is in the normal mode, giving the application a chance to refresh the UI.</li>
 <li><span style="font-family: Courier New,Courier,monospace">watch_app_ambient_tick_cb()</span>: Called every minute when the application is in the ambient mode, giving the application a chance to refresh the UI.</li>
 <li><span style="font-family: Courier New,Courier,monospace">watch_app_ambient_changed_cb()</span>: Called whenever the application enters the normal or ambient mode.</li>
</ul>

<pre class="prettyprint">
int 
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;watch_app_lifecycle_callback_s event_callback = {0,};

&nbsp;&nbsp;&nbsp;event_callback.create = app_create;
&nbsp;&nbsp;&nbsp;event_callback.resume = app_resume;
&nbsp;&nbsp;&nbsp;event_callback.pause = app_pause;
&nbsp;&nbsp;&nbsp;event_callback.terminate = app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.time_tick = app_time_tick;
&nbsp;&nbsp;&nbsp;event_callback.ambient_tick = app_time_tick;
&nbsp;&nbsp;&nbsp;event_callback.ambient_changed = app_ambient_changed;

&nbsp;&nbsp;&nbsp;ret = watch_app_main(argc, argv, &amp;event_callback, NULL);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return ret;
}

static void 
app_time_tick(watch_time_h watch_time, void *data)
{
&nbsp;&nbsp;&nbsp;// Variable definitions and error handling
&nbsp;&nbsp;&nbsp;__get_date_from_watch_time(watch_time, &amp;year, &amp;month, &amp;day, &amp;day_of_week,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;hours, &amp;minutes, &amp;seconds);

&nbsp;&nbsp;&nbsp;controller_tick(hours, minutes, seconds, year, month, day, day_of_week);
}

static void 
app_ambient_changed(bool ambient_mode, void *data)
{
&nbsp;&nbsp;&nbsp;controller_set_ambient_mode(ambient_mode);
}

static void 
__get_date_from_watch_time(const watch_time_h watch_time,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int *year, int *month, int *day, int *day_of_week,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int *hours, int *minutes, int *seconds)
{
&nbsp;&nbsp;&nbsp;watch_time_get_hour24(watch_time, hours);
&nbsp;&nbsp;&nbsp;watch_time_get_minute(watch_time, minutes);
&nbsp;&nbsp;&nbsp;watch_time_get_second(watch_time, seconds);
&nbsp;&nbsp;&nbsp;watch_time_get_year(watch_time, year);
&nbsp;&nbsp;&nbsp;watch_time_get_month(watch_time, month);
&nbsp;&nbsp;&nbsp;watch_time_get_day(watch_time, day);
&nbsp;&nbsp;&nbsp;watch_time_get_day_of_week(watch_time, day_of_week);
}
</pre>

<h3>Controller Module</h3>
<p>The controller module controls the application execution through the following functions:</p>
<ul>
<li>The <span style="font-family: Courier New,Courier,monospace">controller_start_application()</span> function is called at the application startup. It sets up the view and initializes the weather poll thread module by passing the <span style="font-family: Courier New,Courier,monospace">__weather_poll_data_ready_cb()</span> callback to the <span style="font-family: Courier New,Courier,monospace">weather_poll_thread_init()</span> function. It also sets the current time on the watch view.

<pre class="prettyprint">
bool 
controller_start_application(int width, int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int hour, int min, int sec,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int year, int month, int day, int week_day)
{
&nbsp;&nbsp;&nbsp;if (!view_create_gui(width, height))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (!weather_poll_thread_init(__weather_poll_data_ready_cb))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;view_set_time(hour, min, sec, year, month, day, week_day);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__weather_poll_data_ready_cb()</span> callback is called in the main thread context whenever the weather polling thread ends its work successfully. This function updates the UI in the ambient mode by displaying the data received from the server:</p>

<pre class="prettyprint">
static void 
__weather_poll_data_ready_cb(xml_weather_t *weather, const void *icon_data, int icon_data_len)
{
&nbsp;&nbsp;&nbsp;if (weather) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_temperature(weather-&gt;temperature.value, weather-&gt;temperature.unit);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_city(weather-&gt;city.name, weather-&gt;city.country);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_humidity(weather-&gt;humidity.value, weather-&gt;humidity.unit);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_pressure(weather-&gt;pressure.value, weather-&gt;pressure.unit);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_wind(weather-&gt;wind.name, weather-&gt;wind.speed_value, weather-&gt;wind.direction_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_clouds(weather-&gt;clouds.name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_precipitation(weather-&gt;precipitation.value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_last_update(asctime(&amp;weather-&gt;last_update));
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (icon_data &amp;&amp; icon_data_len &gt; 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_set_icon(icon_data, icon_data_len);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">controller_set_ambient_mode()</span> function is called from the <span style="font-family: Courier New,Courier,monospace">app_ambient_changed()</span> callback, defined in the main module.</p>
<p>This way, the application can track whether it is in the ambient or normal mode. Stop any power consuming operations in the ambient mode. For example, you can change the display state to one that has most of its pixels dark.</p>

<pre class="prettyprint">
void 
controller_set_ambient_mode(bool ambient_mode)
{
&nbsp;&nbsp;&nbsp;cdata.ambient_mode = ambient_mode;
&nbsp;&nbsp;&nbsp;view_set_ambient(cdata.ambient_mode);
&nbsp;&nbsp;&nbsp;if (cdata.ambient_mode) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi_monitor_stop_measure();
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi_monitor_start_measure(__wifi_rssi_level_changed_cb);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">controller_tick()</span> function is called at 1-second intervals when the application is in the normal mode and at 1-minute intervals when it is in the ambient mode. The function updates the time view display:</p>

<pre class="prettyprint">
void 
controller_tick(int hour, int min, int sec,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int year, int month, int day, int week_day)
{
&nbsp;&nbsp;&nbsp;view_set_time(hour, min, sec, year, month, day, week_day);
}
</pre>
</li>
</ul>

<h3>Weather Poll Thread Module</h3>

<p>When the weather poll thread module is initialized, it introduces a single <span style="font-family: Courier New,Courier,monospace">ecore_timer</span>, whose callback is launched periodically to execute the server data poll function in a separate thread:</p>

<pre class="prettyprint">
bool 
weather_poll_thread_init(weather_poll_data_ready_cb cb)
{
&nbsp;&nbsp;&nbsp;// Variable definitions and error handling

&nbsp;&nbsp;&nbsp;wpt.tim = ecore_timer_add(1.0, __weather_poll_timer_cb, NULL);

&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;ecore_timer_freeze(wpt.tim);

&nbsp;&nbsp;&nbsp;return true;
}

static Eina_Bool 
__weather_poll_timer_cb(void *data)
{
&nbsp;&nbsp;&nbsp;ecore_timer_interval_set(wpt.tim, WEATHER_POLL_INTERVAL_SEC);

&nbsp;&nbsp;&nbsp;if (!wpt.thread_h) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wpt.thread_h = ecore_thread_run(__thread_function, __thread_end_cb, __thread_cancelled_cb, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p>Both the <span style="font-family: Courier New,Courier,monospace">__thread_function()</span> and <span style="font-family: Courier New,Courier,monospace">__weather_data_read_cb()</span> functions are executed in a separate thread. Since the <span style="font-family: Courier New,Courier,monospace">weather_query()</span> function blocks until it is finished, its execution from the main thread would lock up the UI.</p>
<pre class="prettyprint">
static void 
__thread_function(void *data, Ecore_Thread *thread)
{
&nbsp;&nbsp;&nbsp;if (!weather_query(__weather_data_read_cb))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to make a query&quot;);
}
</pre>

<p>Any UI update function calls from the <span style="font-family: Courier New,Courier,monospace">__weather_data_read_cb()</span> callback are prohibited.  The callback only stores pointers to received data in a common memory area.</p>

<pre class="prettyprint">
static void 
__weather_data_read_cb(xml_weather_t *weather, image_buffer_t *image_buffer)
{
&nbsp;&nbsp;&nbsp;wpt.weather = weather;
&nbsp;&nbsp;&nbsp;wpt.image_buffer = image_buffer;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">__thread_end_cb()</span> callback is called automatically when the <span style="font-family: Courier New,Courier,monospace">__thread_function()</span> function finishes successfully. The callback is called from the main thread, and this is why it can call a callback from the main controller (updating the UI). The server data pointers, previously stored by the <span style="font-family: Courier New,Courier,monospace">__weather_data_read_cb()</span> function, are used.</p>

<pre class="prettyprint">
static void 
__thread_end_cb(void *data, Ecore_Thread *thread)
{
&nbsp;&nbsp;&nbsp;char *buffer = NULL;
&nbsp;&nbsp;&nbsp;int buffer_size = 0;

&nbsp;&nbsp;&nbsp;if (wpt.image_buffer) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = wpt.image_buffer-&gt;buffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size = wpt.image_buffer-&gt;size;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (wpt.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wpt.cb(wpt.weather, buffer, buffer_size);

&nbsp;&nbsp;&nbsp;xml_weather_dispose(wpt.weather);
&nbsp;&nbsp;&nbsp;weather_free_image_buffer(wpt.image_buffer);
&nbsp;&nbsp;&nbsp;wpt.weather = NULL;
&nbsp;&nbsp;&nbsp;wpt.image_buffer = NULL;
&nbsp;&nbsp;&nbsp;wpt.thread_h = NULL;
}
</pre>

<h3>View Module</h3>

<p>The <span style="font-family: Courier New,Courier,monospace">watch_app_get_elm_win()</span> function is used to obtain a special watch type window. This way the application can receive the ambient and normal mode switch events properly.</p>

<pre class="prettyprint">
bool 
view_create_gui(int width, int height)
{
&nbsp;&nbsp;&nbsp;watch_app_get_elm_win(&amp;vd.win);

&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_resize(vd.win, width, height);

&nbsp;&nbsp;&nbsp;vd.digital_clock = digital_clock_create(vd.win, width, height);
&nbsp;&nbsp;&nbsp;evas_object_show(vd.digital_clock);

&nbsp;&nbsp;&nbsp;vd.weather = weather_create(vd.win, width, height);

&nbsp;&nbsp;&nbsp;// Common code
}
</pre>

<p>Each time a time tick occurs, the controller module calls the <span style="font-family: Courier New,Courier,monospace">view_set_time()</span> function. It updates the digital clock available in the normal application mode:</p>
<pre class="prettyprint">
void 
view_set_time(int hours, int minutes, int seconds,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int year, int month, int day, int week_day)
{
&nbsp;&nbsp;&nbsp;digital_clock_set_time(vd.digital_clock, hours, minutes);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">view_set_ambient()</span> function is called each time the application mode changes. In the ambient mode, only the weather view is shown, whereas in the normal mode, only the digital clock is visible.</p>

<pre class="prettyprint">
void 
view_set_ambient(bool on_off)
{
&nbsp;&nbsp;&nbsp;vd.ambient = on_off;

&nbsp;&nbsp;&nbsp;if (on_off) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_show(vd.weather);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_hide(vd.digital_clock);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_show(vd.digital_clock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_hide(vd.weather);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

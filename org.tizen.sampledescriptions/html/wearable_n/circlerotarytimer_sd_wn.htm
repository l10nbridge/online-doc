<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>(Circle) Rotary Timer Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Wearable native" src="../images/wearable_s_n.png"/></p>
	</div>

  <h1>(Circle) Rotary Timer Sample Overview</h1> 
  
<p>The (Circle) Rotary Timer sample application demonstrates how you can implement a circular digital clock with a timer function in your application.</p>
<p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>

<p>The following figure illustrates the main screen of the (Circle) Rotary Timer.</p>

<p class="figure">Figure 1: (Circle) Rotary Timer screen</p>
  <p align="center"><img alt="(Circle) Rotary Timer screen" src="../images/rotary_timer.png" /> <img alt="(Circle) Rotary Timer screen" src="../images/rotary_timer_set.png" /></p>

<p>Click the hour, minute, and second values and rotate the bezel to adjust each of them and set up the timer. To start the timer, click <strong>START</strong>.</p>
<p>The timer is stopped when the set time runs out or when <strong>STOP</strong> button is pressed. You can resume the last timer and count down from the same
time that was displayed when it was stopped. To set another timer, click <strong>SET_TIME</strong> when in countdown view, or simply adjust the time values and click <strong>START</strong> when in timer setup view.</p>
  
<h2>Implementation</h2>
<p>The circular rotary timer was created with the following steps:</p>

<h4>Add the required header file and attach a callback necessary for using the rotary function</h4> 
<p>In order for an <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> to receive rotary events, it needs to be set as an activated object and an appropriate callback function
needs to be attached. The application must include the <span style="font-family: Courier New,Courier,monospace">efl_extension.h</span> header file. The following code snippet demonstrates
how registering an <span style="font-family: Courier New,Courier,monospace">obj</span> for rotary events is done in this sample application.</p>
		
<pre class="prettyprint">
void view_set_rotary_event_callback(Evas_Object *obj, Eext_Rotary_Event_Cb rotary_cb, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... Arguments' validity check */

&nbsp;&nbsp;&nbsp;eext_rotary_object_event_activated_set(obj, EINA_TRUE);
&nbsp;&nbsp;&nbsp;eext_rotary_object_event_callback_add(obj, rotary_cb, user_data);
}
</pre>

<h4>Create the application's user interface</h4>

<ol>
	<li>
		<h5>Create layout for the timer preview.</h5>

		<p>The application's view consists of two separate layouts - Setup timer layout and Timer running layout. They are both created in
		<span style="font-family: Courier New,Courier,monospace">view_create()</span> function that also sets necessary callback functions for them.</p>

		<pre class="prettyprint">Eina_Bool view_create(void)
{
&nbsp;&nbsp;&nbsp;s_info.win = view_create_win(PACKAGE); /* Create window */
&nbsp;&nbsp;&nbsp;/* ... Errors check */

&nbsp;&nbsp;&nbsp;s_info.layout_setup = view_create_layout_for_win(s_info.win, _create_resource_path(TIMER_SETUP_EDJ), GRP_SETUP);
&nbsp;&nbsp;&nbsp;elm_layout_signal_callback_add(s_info.layout_setup, SIGNAL_PART_SELECTED, PART_HOUR, _selected_time_display_part_cb, NULL); /* Setup timer layout's hour part is selected */
&nbsp;&nbsp;&nbsp;elm_layout_signal_callback_add(s_info.layout_setup, SIGNAL_PART_SELECTED, PART_MINUTE, _selected_time_display_part_cb, NULL); /* Setup timer layout's minute part is selected */
&nbsp;&nbsp;&nbsp;elm_layout_signal_callback_add(s_info.layout_setup, SIGNAL_PART_SELECTED, PART_SECOND, _selected_time_display_part_cb, NULL); /* Setup timer layout's second part is selected */
&nbsp;&nbsp;&nbsp;elm_layout_signal_callback_add(s_info.layout_setup, SIGNAL_RESET_TIMER, "", _reset_timer_cb, NULL); /* Setup timer layout's START button was clicked  */

&nbsp;&nbsp;&nbsp;s_info.layout_run = view_create_layout_for_win(s_info.win, _create_resource_path(TIMER_RUN_EDJ), GRP_RUN);
&nbsp;&nbsp;&nbsp;elm_layout_signal_callback_add(s_info.layout_run, SIGNAL_SET_TIMER, "", _set_time_cb, NULL); /* Timer running layout's SET_TIME button was clicked  */

&nbsp;&nbsp;&nbsp;_init_rotary(); /* Invoke view_set_rotary_event_callback() for Setup timer layout - needed for adjusting hours/minutes/seconds values */

&nbsp;&nbsp;&nbsp;evas_object_show(s_info.layout_setup);

&nbsp;&nbsp;&nbsp;evas_object_show(s_info.win); /* Show window after main view is set up */

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
		</pre>
	</li>
	<li>
		<h5>Add communication between code and <span style="font-family: Courier New,Courier,monospace">Edje</span> groups</h5>
		<p>The changes in the UI are managed mainly with EDJE scripts. The communication between the C code and given <span style="font-family: Courier New,Courier,monospace">Edje</span> object's group
		is done using <span style="font-family: Courier New,Courier,monospace">Edje messages</span>. Specifically, the <span style="font-family: Courier New,Courier,monospace">edje_object_message_send()</span>
		function is invoked. In addition to an <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> pointer and a message ID, it takes two important arguments:</p>
		<ol>
			<li><p><span style="font-family: Courier New,Courier,monospace">Edje_Message_Type</span> type - variable which defines the type of values you want to send through (int, string, float, or a mix of them);</p></li>
			<li><p><span style="font-family: Courier New,Courier,monospace">void *</span> message - pointer to a structure which contains the message itself. The type of the structure is defined by the type of message you want to send
			(for example, <span style="font-family: Courier New,Courier,monospace">Edje_Message_Int</span> for single int value, <span style="font-family: Courier New,Courier,monospace">Edje_Message_Float</span> for single
			float value, <span style="font-family: Courier New,Courier,monospace">Edje_Message_Int_Set</span> for an array of int values). For more information, see
			<strong>Edje Object Communication Interface: Message documentation</strong>.</p></li>
		</ol>

		<p>For example, when a timer is running and the displayed time's value needs to be updated, the <span style="font-family: Courier New,Courier,monospace">view_update_time_display()</span> function is invoked.
		It calculates new time's values, creates an <span style="font-family: Courier New,Courier,monospace">Edje message</span> and sends it to the appropriate
		<span style="font-family: Courier New,Courier,monospace">Edje</span> object.</p>

		<pre class="prettyprint">
void view_update_time_display(int start_value, int current_value)
{
&nbsp;&nbsp;&nbsp;Edje_Message_Int_Set *msg = calloc(1, sizeof(Edje_Message_Int_Set) + 1 * sizeof(int)); /* Create a message with an array of int values */

&nbsp;&nbsp;&nbsp;/* Calculate new time's values */

&nbsp;&nbsp;&nbsp;msg->count = 2; /* The size of the message's array */
&nbsp;&nbsp;&nbsp;msg->val[0] = current_value; /* First int value of the message */
&nbsp;&nbsp;&nbsp;msg->val[1] = start_value; /* Second int value of the message */

&nbsp;&nbsp;&nbsp;edje_object_message_send(elm_layout_edje_get(s_info.layout_run), EDJE_MESSAGE_INT_SET, MSG_ID_DOT_ANGLE, msg); /* Send the message to Edje object corresponding to s_info.layout_run Evas_Object */
&nbsp;&nbsp;&nbsp;free(msg);
}
		</pre>

		<p>On The <span style="font-family: Courier New,Courier,monospace">Edje</span> object's group side,
		the <span style="font-family: Courier New,Courier,monospace">message()</span> script handles messages reception.
		The script must have the following signature: <span style="font-family: Courier New,Courier,monospace">public message(Msg_Type:type, id, ...)</span>.</p>

		<pre class="prettyprint">
script {
&nbsp;&nbsp;&nbsp;public message(Msg_Type:type, id, ...) { /* Arguments are numbered from 0 */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Float:hour = getarg(2); /* Get argument no 2 of the message - hours value to set */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Float:minute = getarg(3); /* Get argument no 3 of the message - minutes value to set */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Float:second = getarg(4); /* Get argument no 4 of the message - seconds value to set */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (type == MSG_INT_SET) { /* Check message type validity */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (id == MSG_ID_SET_HOUR) { /* Check message ID */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set UI with regards to the message */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (id == MSG_ID_SET_MINUTE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set UI with regards to the message */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (id == MSG_ID_SET_SECOND) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set UI with regards to the message */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
		</pre>
	</li>
</ol>

<h4>Set the timer</h4>
<p>The quantity of time for the timer is adjusted by rotating the bazel. The user taps a part of displayed timer value he or she wishes to change (hours, minutes or seconds) and rotates
the bazel until the appropriate indicator is in the right place. The <span style="font-family: Courier New,Courier,monospace">_rotary_cb()</span> function is called every time a rotation event
is detected. Each time, the direction of rotation is checked to see if the timer value should be incremented or decremented:</p>
<pre class="prettyprint">
bool inc = (rotary_info->direction == EEXT_ROTARY_DIRECTION_COUNTER_CLOCKWISE);
</pre>

<p><span style="font-family: Courier New,Courier,monospace">rotary_info</span> variable is of <span style="font-family: Courier New,Courier,monospace">Eext_Rotary_Event_Info *</span> type
and is passed as an argument to <span style="font-family: Courier New,Courier,monospace">_rotary_cb()</span> callback function.</p>
<p>Then, the correct value is set using <span style="font-family: Courier New,Courier,monospace">_set_time_value()</span>, which simply increments or decrements the value of the time part that
is currently selected. The validity of the value to be set is checked first as minutes and seconds can only be set to values between 0 and 59, and hours to values between 0 and 24.</p>

<pre class="prettyprint">
static void _set_time_value(int *part_value, bool inc, int max)
{
&nbsp;&nbsp;&nbsp;if (inc && *part_value == max)		/* If the maximum value is reached, do not increment it further */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;else if (!inc && *part_value == 0)	/* If the minimum value is reached, do not decrement it further */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;if (inc == true)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*part_value)++;
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*part_value)--;
}
</pre>

<p>The application's UI is also updated by sending an appropriate <span style="font-family: Courier New,Courier,monospace">Edje_Message</span> to the Timer setup layout.</p>

<h4>Start the timer</h4>
<p>When the user taps the <strong>START</strong> button, the <span style="font-family: Courier New,Courier,monospace">_switch_view_cb()</span> function is called which
is responsible for switching between the Setup timer and Timer running views as well as for starting the timer. It invokes
the <span style="font-family: Courier New,Courier,monospace">data_run()</span> function which starts time elapsing by creating an <span style="font-family: Courier New,Courier,monospace">Ecore_Timer</span>
with a one second interval. The <span style="font-family: Courier New,Courier,monospace">_timer_start_cb()</span> function passed as the second argument
to <span style="font-family: Courier New,Courier,monospace">ecore_timer_add()</span> is called every second to update the time displayed on the screen.</p>

<pre class="prettyprint">
void data_run(void)
{
&nbsp;&nbsp;&nbsp;if (s_info.second_timer) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_timer_thaw(s_info.second_timer);
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s_info.callbacks.time_elapse_tick_cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.callbacks.time_elapse_tick_cb(s_info.start_time, s_info.time);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.second_timer = ecore_timer_add(1.0, _second_timer_update_cb, NULL);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h4>Animate the elapsing time progress</h4>

<p>The Timer running layout is composed of several images (see Fig. 2) that are then transformed to indicate the elapsing time progress.</p>

<p class="figure">Figure 2: Timer running layout's layers</p>
  <p align="center"><img alt="Timer running layout's components" src="../images/rotary_timer_run_layers.png" /></p>

<p>The progress indicator (top layer in Fig. 2) is made from two images: an arc (line) and a dot that is placed on the arc in a position
corresponding to the current progress. Both the arc and the dot images are rotated to show the current progress. Each time the timer value is changed, an EDJE message is sent to the Timer running layout's
group containing current progress' value. Based on that, an appropriate angle of the rotation is calculated. The angle is then used to properly rotate the arc and the dot images which have
mapping enabled to allow for transformations (rotation). The following code snippet demonstrates how the dot part rotation is done.</p>

<pre class="prettyprint">
public _dot_animate(Float:angle) {
&nbsp;&nbsp;&nbsp;custom_state(PART:PART_RUN_DOT, STATE_DEFAULT, 0.0);
&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_DOT, STATE_MAP_ROT_Z, angle);
&nbsp;&nbsp;&nbsp;set_state(PART:PART_RUN_DOT, STATE_CUSTOM, 0.0);
}
</pre>

<p>To only show the part of the arc that indicates the current progress, a clipping mask is used. The mechanism is demonstrated in Fig. 3 (the clipping mask is shown in blue).</p>

<p class="figure">Figure 3: Timer running animation using mask</p>
  <p align="center"><img alt="Timer running animation using mask 1" src="../images/rotary_timer_run_mask_1.png" /><img alt="Timer running animation using mask 2" src="../images/rotary_timer_run_mask_2.png" />
	<img alt="Timer running animation using mask 3" src="../images/rotary_timer_run_mask_3.png" /><img alt="Timer running animation using mask 4" src="../images/rotary_timer_run_mask_4.png" /></p>


<p>It can be done by simply defining <span style="font-family: Courier New,Courier,monospace">clip_to</span> parameter of the EDJE part we want to clip and setting it to the part we want to use as the clipping mask -
in this case, <span style="font-family: Courier New,Courier,monospace">PART_RUN_PROGRESS</span> is clipped to <span style="font-family: Courier New,Courier,monospace">PART_RUN_CLIPPER</span>.</p>

<pre class="prettyprint">
part {
&nbsp;&nbsp;&nbsp;name: PART_RUN_PROGRESS;
&nbsp;&nbsp;&nbsp;type: IMAGE;
&nbsp;&nbsp;&nbsp;description {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: STATE_DEFAULT 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 { relative: 0.0 0.0; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 { relative: 1.0 1.0; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image { normal: IMAGE_FPATH_INDICATOR_RUNNER_LINE_GLOW; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smooth: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perspective_on: 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotation { z: 0; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;clip_to: PART_RUN_CLIPPER;
}
</pre>

<p><span style="font-family: Courier New,Courier,monospace">PART_RUN_CLIPPER</span> is the clipping mask in this example (shown in blue in Fig. 3). Its relative position is calculated based on the angle
of the animation.</p>

<pre class="prettyprint">
public _clipper_animate_progress(Float:angle) {
&nbsp;&nbsp;&nbsp;custom_state(PART:PART_RUN_PROGRESS, STATE_DEFAULT, 0.0);
&nbsp;&nbsp;&nbsp;custom_state(PART:PART_RUN_CLIPPER, STATE_DEFAULT, 0.0);

&nbsp;&nbsp;&nbsp;if (angle <= -90.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_CLIPPER, STATE_REL2, 0.25, PART_CLIPPER_REL_2_Y);
&nbsp;&nbsp;&nbsp;else if (angle <= -15.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_CLIPPER, STATE_REL2, 0.50, PART_CLIPPER_REL_2_Y);
&nbsp;&nbsp;&nbsp;else if (angle <= 30.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_CLIPPER, STATE_REL2, 0.75, PART_CLIPPER_REL_2_Y);
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_CLIPPER, STATE_REL2, 1.00, PART_CLIPPER_REL_2_Y);

&nbsp;&nbsp;&nbsp;set_state_val(PART:PART_RUN_PROGRESS, STATE_MAP_ROT_Z, angle - 133);
&nbsp;&nbsp;&nbsp;set_state(PART:PART_RUN_CLIPPER, STATE_CUSTOM, 0.0);
&nbsp;&nbsp;&nbsp;set_state(PART:PART_RUN_PROGRESS, STATE_CUSTOM, 0.0);
}
</pre>

<h4>Reset the timer</h4>
<p>To set another time when the user clicks <strong>RESET</strong>, the <span style="font-family: Courier New,Courier,monospace">_reset_clicked_cb()</span> callback function is invoked. It resets
the hours, minutes and seconds values stored by the application to 0 and updates the UI accordingly.</p>

<pre class="prettyprint">
static void _reset_timer_cb(void *data, Evas_Object *obj, const char *emission, const char *source)
{
&nbsp;&nbsp;&nbsp;s_info.displayed_time.hour = 0;
&nbsp;&nbsp;&nbsp;s_info.displayed_time.minute = 0;
&nbsp;&nbsp;&nbsp;s_info.displayed_time.second = 0;

&nbsp;&nbsp;&nbsp;_set_displayed_time_value(s_info.layout_setup);

&nbsp;&nbsp;&nbsp;data_set_time(0, 0, 0);
}
</pre>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>GLViewCube Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Wearable native" src="../images/wn_icon.png"/></p>
	</div>

  <h1>GLViewCube Sample Overview</h1> 
  
<p>This sample demonstrates how to render with OpenGL&reg; ES 2.0 using an Elementary GLView component. It goes through the creation of a simple UI and how to draw a rotating cube using simple vertex and fragment shaders.</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">The application presented in this overview is not a full Tizen application, since it does not use the Application Framework. The application simply starts and runs.</td> 
		</tr> 
	   </tbody> 
	  </table> 
 
 
 <p class="figure">Figure: GLViewCube</p> 
 <p align="center"><img alt="GLViewCube" src="../images/glview_cube_wn.png" /></p>  
	  
<h2>Elementary_GL_Helpers</h2>
<p>The <span style="font-family: Courier New,Courier,monospace">&lt;Elementary_GL_Helpers.h&gt;</span> header file provides a set of convenience functions and macros. To use these functions and macros, include this header file in the application.</p>
<pre class="prettyprint">
#include &lt;app.h&gt;
#include &lt;Elementary.h&gt;
#include &lt;Elementary_GL_Helpers.h&gt;
#include &lt;efl_extension.h&gt;

#include &quot;glviewcube_utils.h&quot;

ELEMENTARY_GLVIEW_GLOBAL_DEFINE();
...
static bool app_create(void *data) 
{
...
&nbsp;&nbsp;&nbsp;// Create and initialize GLView
&nbsp;&nbsp;&nbsp;gl = elm_glview_add(win);
&nbsp;&nbsp;&nbsp;ELEMENTARY_GLVIEW_GLOBAL_USE(gl);
...
}
</pre>

<h2>Setting up Callbacks</h2>
<ol>
<li>Set the initialization callback.
<p>The initialization callback is called when the GLView is first created, after a valid OpenGL&reg; context and surface have been created.</p>
<p>This callback function initializes shaders using the <span style="font-family: Courier New,Courier,monospace">init_shaders(obj)</span> function.</p>

<pre class="prettyprint">
static void init_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;if (!ad-&gt;initialized) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_shaders(obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glEnable(GL_DEPTH_TEST);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;initialized = EINA_TRUE;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
}
</pre>
</li>

<li>Initialize the shaders.
<ol type="a">
<li>The shader instances for the fragment and vertex shader are compiled and created by passing the shader type as a parameter to the <span style="font-family: Courier New,Courier,monospace">glCreateShader()</span> function.
	<p>Load the shader objects, use the GLES2 Shader compiler to read and compile the shader source code for both the fragment and the vertex shader.</p>
	<pre class="prettyprint">
static void init_shaders(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);
&nbsp;&nbsp;&nbsp;const char *p;
&nbsp;&nbsp;&nbsp;p = vertex_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;vtx_shader = glCreateShader(GL_VERTEX_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;vtx_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;vtx_shader);

&nbsp;&nbsp;&nbsp;p = fragment_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;fgmt_shader = glCreateShader(GL_FRAGMENT_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;fgmt_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;fgmt_shader);
</pre></li>
	<li>Once the shader objects have been loaded, a shader program is created. The program attaches and links the shader objects to the shader program.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ad-&gt;program = glCreateProgram();
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;fgmt_shader);
&nbsp;&nbsp;&nbsp;glLinkProgram(ad-&gt;program);
</pre>	
	</li>

	<li>Get the location for each vertex or pixel attribute in the shader program using the <span style="font-family: Courier New,Courier,monospace">glGetAttribLocation()</span> and <span style="font-family: Courier New,Courier,monospace">glGetUniformLocation()</span> functions. If the shader program attributes <span style="font-family: Courier New,Courier,monospace">a_position</span>, <span style="font-family: Courier New,Courier,monospace">a_color</span>, and <span style="font-family: Courier New,Courier,monospace">u_mvpMatrix</span> are valid, these functions return an integer value that represents the index location of the attributes. For invalid attributes, the return value is -1.
	<p>The <span style="font-family: Courier New,Courier,monospace">glGetAttribLocation()</span> function retrieves the location of the attributes that have an effect on a vertex or pixel, such as position vector, normal vector, or vertex color. The <span style="font-family: Courier New,Courier,monospace">glGetUniformLocation()</span> retrieves the location of the attributes that have an effect on groups of vertices or pixels, such as model view matrix, projection matrix, or light position.</p>
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ad-&gt;idx_position = glGetAttribLocation(ad-&gt;program, &quot;a_position&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;idx_color = glGetAttribLocation(ad-&gt;program, &quot;a_color&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;idx_mvp = glGetUniformLocation(ad-&gt;program, &quot;u_mvpMatrix&quot;);
	</pre>
	</li>
	
		<li>Install the shader program and enable the GPU to execute the shader operations in the frame buffer.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glUseProgram(ad-&gt;program);
}
</pre>
</li>
</ol>
</li>

<li>Set the resize callback.
<p>The resize callback is called whenever the GLView component is resized. It resets the viewport.</p>
<pre class="prettyprint">
static void resize_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;int w, h;
&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;glViewport(0, 0, w, h);
}
</pre>
</li>


<li>Set the draw callback.
<p>The draw callback is called whenever a new frame has to be drawn.</p>
<p>The application can now draw anything using GL primitives when this callback is triggered.</p>
<ol type="a">
	<li>The <span style="font-family: Courier New,Courier,monospace">glViewport()</span> function specifies the affine transformation of the x and y values from normalized device coordinates to window coordinates as specified by the <span style="font-family: Courier New,Courier,monospace">elm_glview_size_get()</span> function.
	<pre class="prettyprint">
static void draw_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;glViewport(0, 0, w, h);
</pre>
	</li>
	<li>The <span style="font-family: Courier New,Courier,monospace">glVertexAttribPointer()</span> function is used to define an array of generic vertex attribute data. These attributes are parameters associated with each vertex of the cube. In this case, the parameters are position and color. In both instances, the final parameter (vertices and colors) represent the previously defined arrays - vertices and colors.
	<p>The <span style="font-family: Courier New,Courier,monospace">glEnableVertexAttribArray()</span> function enables the generic vertex attribute data arrays. The enabled attributes can be accessed and used to render the scene.</p>
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;idx_position, 3, GL_FLOAT, GL_FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 * sizeof(float), cube_vertices);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;idx_color, 4, GL_FLOAT, GL_FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 * sizeof(float), cube_colors);

&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;idx_position);
&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;idx_color);
	</pre>
	</li>

	<li>The <span style="font-family: Courier New,Courier,monospace">glUniformMatrix4fv()</span> function modifies the values of the 4x4 MVP (Model View/Projection) uniform matrix according to the vertices information of the cube. An MVP matrix is created with data after each vertex of the cube has passed through 2 transformation stages: The first transformation state is the model view transformation, which includes translation, rotation, and scaling of objects. The second state is projection, which includes changes in the  perspective or orthography.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glUniformMatrix4fv(ad-&gt;idx_mvp, 1, GL_FALSE, ad-&gt;mvp);</pre>
	</li>
	
	<li>Once the vertex arrays have been enabled, the actual process of rendering graphics primitives from the array data occurs using the <span style="font-family: Courier New,Courier,monospace">glDrawElements()</span> function. The final parameter in this function is the indices array.
	<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glDrawElements(GL_TRIANGLES, cube_indices_count, 				
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_UNSIGNED_SHORT, cube_indices);
	</pre>
	</li>
	</ol>
	</li>

<li>Add an animator.
<p>The application regularly triggers updates of the GLView using the <span style="font-family: Courier New,Courier,monospace">elm_glview_changed_set()</span> function.</p>
<pre class="prettyprint">
static Eina_Bool anim(void *data) 
{
elm_glview_changed_set(data);
return EINA_TRUE;
}

static bool app_create(void *data) 
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;ani = ecore_animator_add(anim, gl);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
}
</pre>
</li>

<li>Set event callbacks.
<p>The event callbacks receive touch events and allow you to rotate the cube in a vertical or horizontal direction.</p>

<pre class="prettyprint">
static void mouse_down_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_TRUE;
}

static void mouse_move_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;Evas_Event_Mouse_Move *ev;
&nbsp;&nbsp;&nbsp;ev = (Evas_Event_Mouse_Move *)event_info;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;float dx = 0, dy = 0;

&nbsp;&nbsp;&nbsp;if (ad-&gt;mouse_down) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx = ev-&gt;cur.canvas.x - ev-&gt;prev.canvas.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy = ev-&gt;cur.canvas.y - ev-&gt;prev.canvas.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;xangle += dy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;yangle += dx;
&nbsp;&nbsp;&nbsp;}
}

static void mouse_up_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_FALSE;
}
</pre>
</li>


<li>Set the delete callback.
<p>The delete callback is triggered when the GLView is destroyed from the main loop.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">glDeleteShader()</span> and <span style="font-family: Courier New,Courier,monospace">glDeleteProgram()</span> functions are used to free memory.</p>
<pre class="prettyprint">
static void del_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;fgmt_shader);
&nbsp;&nbsp;&nbsp;glDeleteProgram(ad-&gt;program);

&nbsp;&nbsp;&nbsp;evas_object_data_del((Evas_Object*) obj, &quot;ad&quot;);
}
</pre>
</li>
</ol>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Badge Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>
  <h1>Badge Sample Overview</h1>

  <p>The Tizen API's Badge module provides some routines which enable the possibility of handling application's badges. This sample application demonstrates how to work with this API. It shows how to
  create, modify and delete badges displayed by any of the applications installed on a platform.</p>
  <p>The figure below illustrates the view of the application. </p>
  <p class="figure">Figure: Preference screen</p>
  <p style="text-align:center;">
    <img alt="Main view of the application" hspace="20" src="../images/badge_main_view_default_sd.png" />
	<img alt="Main view with the target application selected" hspace="20" src="../images/badge_main_view_app_selected_sd.png" />
  </p>

  <p>The sample application provides a user interface for:
  <ul>
    <li>target applications listing and browsing - all applications which can have a badge attached are displayed together with the badge counter;</li>
	<li>badge manipulation - creation, counter updating and badge removal can be performed by altering the badge counter value.</li>
  </ul>
  The structure of the user interface is depicted below (EDJE layout scripts are used).
  </p>
  <p class="figure">Figure: Badge UI layout structure</p>
  <p style="text-align:center;" id="ui-struct">
    <img alt="Preference UI layout structure" hspace="80" src="../images/badge_ui_structure_1_sd.png" />
	<img alt="Preference UI widgets structure" hspace="80" src="../images/badge_ui_structure_2_sd.png" />
  </p>
  <p>
  The application's workflow can be divided into two logical blocks:
  <ul>
    <li>startup,</li>
	<li>application's badge update.</li>
  </ul>
  which can be described by the following figure.
  </p>
  <p class="figure">Figure: Application workflow.</p>
  <p style="text-align:center;">
	<img alt="Application workflow - startup" hspace="80" height="550" src="../images/badge_workflow_startup_sd.png"/>
	<img alt="Application workflow - update" hspace="80" height="550" src="../images/badge_workflow_badge_update_sd.png"/>
  </p>
  <h3>Requirements</h3>
  <p>The following privilege must be set:
  <ul>
    <li>http://tizen.org/privilege/packagemanager.info;</li>
	<li>http://tizen.org/privilege/notification.</li>
  </ul>
  </p>

<h2>Implementation</h2>

<h3 id="type-defs">Type definitions</h3>
<p>The main data structure used as a container for the <a href="#controller">Controller</a> and the <a href="#model">Model</a> data is listed below.</p>
<pre class="prettyprint">
typedef struct appdata{
	viewdata_s viewdata;	// The View module data.
	modeldata_s modeldata;	// The Model module data.
} appdata_s;
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">viewdata_s</span> structure contains references to all the widget objects created by the <a href="#view">View</a> module.</p>
<pre class="prettyprint">
typedef struct _viewdata {
	Evas_Object* win;				// The main window widget's object.
	Evas_Object* conform;				// The conformant widget's object.
	Evas_Object* layout_main_panel;			// The main window's layout object (embedded into the conform widget).
	Evas_Object* layout_badge_update_panel;		// The top panel layout object (embedded into the main_panel_badge_update_panel part of the layout_main_panel).
	Evas_Object* layout_available_apps_panel;	// The middle panel layout object (embedded into the main_panel_apps_list_panel part of the layout_main_panel).
	Evas_Object* layout_buttons_panel;		// The bottom panel layout object (embedded into the main_panel_buttons_panel part of the layout_main_panel).
	Evas_Object* badge_counter_spinner;		// The spinner widget object used for badge counter setting.
	Evas_Object* available_apps_list;		// The genlist widget object used for available applications listing.
	Evas_Object* update_button;			// The button widget object used to confirm and apply the input data.
} viewdata_s;
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">modeldata_s</span> contains a list of <span style="font-family: Courier New,Courier,monospace">pkginfo_s</span> items,
where each of <span style="font-family: Courier New,Courier,monospace">pkginfo_s</span> structures consists information about installed applications.</p>
<pre class="prettyprint">
typedef struct _pkginfo {
	char *pkg_name;	// Name of the application's package.
	char *app_id;	// Application's identifier.
} pkginfo_s;

typedef struct _modeldata {
	Eina_List *pkg_list;	// List of pkginfo_s structures.
} modeldata_s;
</pre>

<h3 id="app-init">Application initialization</h3>
<p>The entire application's lifecycle is implemented in badge.c file, using common structure of Tizen application.</p>
<pre class="prettyprint">
int
main(int argc, char *argv[])
{
	appdata_s ad = {{0,},};
	... // variables declaration and initialization.

	event_callback.create = app_create;
	event_callback.terminate = app_terminate;
	event_callback.pause = app_pause;
	event_callback.resume = app_resume;
	event_callback.app_control = app_control;

	... // event handlers assignment.

	ret = ui_app_main(argc, argv, &event_callback, &ad);
	... // error checking.

	return ret;
}
</pre>
<p>The Badge sample application is implemented using MVC design pattern. Its initialization is done within app_create() callback function</p>
<pre class="prettyprint">
static bool
app_create(void *data)
{
	... // variables assignment.

	if (!view_base_gui_create(&ad->viewdata)) {
		return false;
	}

	return controller_application_init(&ad->modeldata);
}
</pre>
<p>where the user interface creation is triggered using <span style="font-family: Courier New,Courier,monospace">view_base_gui_create()</span> function and application's data is initialized with
<span style="font-family: Courier New,Courier,monospace">controller_application_init()</span> function. For reference, see the <a href="#view">View</a> and the <a href="#controller">Controller</a>
sections respectively.
<br>
<br>
On application's termination, the <span style="font-family: Courier New,Courier,monospace">app_terminate()</span> callback function is called, where all the allocated resources are freed.
For reference, see the <a href="#controller">Controller</a> section.</p>
<pre class="prettyprint">
static void
app_terminate(void *data)
{
	appdata_s *ad = (appdata_s*)data;

	if (ad->viewdata.win) {
		evas_object_del(ad->viewdata.win);		// Main window and all descendants are deleted.
	}

	controller_application_terminate(&ad->modeldata);	// All the allocated data is freed.
}
</pre>

<h3 id="view">View</h3>
<p>
The entire application layout is implemented using EDJE scripts. All top level swallows are designed for EFL Elementary widgets embedding. See itemization below for EDJE swallow - EFL Elementary widget
relations and assigned functionalities (for reference, see the <a href="#ui-struct">Badge UI layout structure</a> figure):
</p>
<ul>
  <li>badge_update_panel_badge_counter_edit - elm_spinner: set the new value of badge counter for selected application;</li>
  <li>apps_list_panel_list - elm_genlist: list of all installed and displayable applications that consists of:</li>
    <ul>
	  <li>application identifier;</li>
	  <li>badge counter.</li>
	</ul>
  <li>buttons_panel_button - elm_button: applies all the changes;</li>
</ul>
<p>The code snippet below creates the main layout (file: main.edc).</p>
<table>
  <tr>
    <td>
<pre class="prettyprint">
collections {
	group {
		name: GROUP_MAIN;

		parts {
			// The background part occupies the entire window.
			part {
				name: PART_MAIN_BACKGROUND;
				type: RECT;
				...
			}

			// The part is positioned in relation to PART_MAIN_BACKGROUND.
			// The spacer occupies the entire area of PART_MAIN_BACKGROUND with small margin all around.
			part {
				name: PART_MAIN_PANEL;
				type: SPACER;
				...
			}

			// The part is positioned in relation to PART_MAIN_PANEL.
			// The swallow occupies 30% of PART_MAIN_PANEL height.
			// It is designed to hold the layout_badge_update_panel elm_layout.
			part {
				name: PART_MAIN_PANEL_BADGE_UPDATE_PANEL;
				type: SWALLOW;
				...
			}

			// The part is positioned in relation to PART_MAIN_PANEL.
			// The swallow has flexible height which depends on the height of other swallows.
			// At this configuration, the swallow occupies 55% of PART_MAIN_PANEL height.
			// It is designed to hold the layout_available_apps_panel elm_layout.
			part {
				name: PART_MAIN_PANEL_APPS_LIST_PANEL;
				type: SWALLOW;
				...
			}

			// The part is positioned in relation to PART_MAIN_PANEL.
			// The swallow occupies 15% of PART_MAIN_PANEL height.
			// It is designed to hold the layout_buttons_panel elm_layout.
			part {
				name: PART_MAIN_PANEL_BUTTON_PANEL;
				type: SWALLOW;
				...
			}
		}
	}
}
</pre>
	</td>
    <td>
      <p style="text-align:center;">
        <img alt="The main view of the application" src="../images/badge_ui_structure_edje_main_sd.png" />
      </p>
    </td>
  </tr>
  <tr>
    <td colspan = "2">
	  <p>
      The <span style="font-family: Courier New,Courier,monospace">PART_MAIN_PANEL_BADGE_UPDATE_PANEL</span> swallow is used as a container for update layout defined in a badge-update-panel.edc file.
	  </p>
    </td>
  </tr>
  <tr>
    <td>
<pre class="prettyprint">
collections {
	group {
		name: GROUP_BADGE_UPDATE_PANEL;

		parts {
			// The part is positioned in relation to PART_MAIN_PANEL_BADGE_UPDATE_PANEL from badge.edc file.
			// The rect plays a role of the background for the update panel and occupies the entire area
			// of the PART_MAIN_PANEL_BADGE_UPDATE_PANEL.
			part {
				name: PART_BADGE_UPDATE_PANEL_BACKGROUND;
				type: RECT;
				...
			}

			// The part is positioned in relation to PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// The text part occupies 50% height and 30% width of the PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// This part is responsible for static text label display only ("App name").
			part {
				name: "badge_update_panel_app_name_caption";
				type: TEXT;
				...
			}

			// The part is positioned in relation to PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// The text part occupies 50% height and 70% width of the PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// This part is responsible for text display which content is triggered by programs defined
			// at the end of this file: "selected_app_name_show" and "selected_app_name_hide".
			part {
				name: PART_BADGE_UPDATE_PANEL_APP_NAME;
				type: TEXT;
				description
				{
					state: STATE_BADGE_UPDATE_PANEL_APP_NAME_DEFAULT 0.0;
					... // state is triggered by the "selected_app_name_show" program.
				}
				description
				{
					state: STATE_BADGE_UPDATE_PANEL_APP_NAME_SELECTED 0.0;
					... // state is triggered by the "selected_app_name_hide" program.
				}
			}

			// The part is positioned in relation to PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// The text part occupies 50% height and 40% width of the PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// This part is responsible for static text label display only ("Badge counter").
			part {
				name: "badge_update_panel_badge_counter_caption";
				type: TEXT;
				...
			}

			// The part is positioned in relation to PART_BADGE_UPDATE_PANEL_BACKGROUND.
			// The rect plays a role of a background for the elm_spinner widget. Its width is set to
			// 60% of PART_BADGE_UPDATE_PANEL_BACKGROUND width. The height is set to 38% of the
			// PART_PREF_EDIT_PANEL_KEY_PANEL height and it is vertically centered.
			part {
				name: PART_BADGE_UPDATE_PANEL_BADGE_COUNTER_BACKGROUND;
				type: RECT;
				...
			}

			// The part is positioned in relation to PART_BADGE_UPDATE_PANEL_BADGE_COUNTER_BACKGROUND.
			// The swallow occupies entire height of the PART_BADGE_UPDATE_PANEL_BADGE_COUNTER_BACKGROUND
			// part and 100% of its width.
			part {
				name: PART_BADGE_UPDATE_PANEL_BADGE_COUNTER_EDIT;
				type: SWALLOW;
				...
			}
		}

		// The programs below are used to control the text content of the PART_BADGE_UPDATE_PANEL_APP_NAME part.
		programs {
			// The "selected_app_name_show" program is triggered by sending the SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_SHOW
			// signal to the elm_layout embedded into the layout_badge_update_panel. As a result of the program execution,
			// the text content of the PART_BADGE_UPDATE_PANEL_APP_NAME is changed to the "Select an application ...".
			// The text is displayed in red color.
			program {
				name: "selected_app_name_show";
				signal: SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_SHOW;
				source: PART_BADGE_UPDATE_PANEL_APP_NAME;			 // The part affected.
				action: STATE_SET STATE_BADGE_UPDATE_PANEL_APP_NAME_SELECTED 0.0;// The part's state to be triggered.
				target: PART_BADGE_UPDATE_PANEL_APP_NAME;			 // The part affected.
			}
			// The "selected_app_name_hide" program is triggered by sending the SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_HIDE
			// signal to the same elm_layout as above. As a result of the program execution, the text content
			// of the PART_BADGE_UPDATE_PANEL_APP_NAME is changed to the currently selected application identifier.
			// The text is displayed in green color.
			program {
				name: "selected_app_name_hide";
				signal: SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_HIDE;
				source: PART_BADGE_UPDATE_PANEL_APP_NAME;			 // The part affected.
				action: STATE_SET STATE_BADGE_UPDATE_PANEL_APP_NAME_UNSELECTED 0.0;// The part's state to be triggered.
				target: PART_BADGE_UPDATE_PANEL_APP_NAME;			 // The part affected.
			}
		}
	}
}

</pre>
	</td>
    <td>
      <p style="text-align:center;">
        <img alt="The update part of the main view of the application" src="../images/badge_ui_structure_edje_update_sd.png" />
      </p>
    </td>
  </tr>
  <tr>
    <td colspan = "2">
	  <p>
      The PART_MAIN_PANEL_APPS_LIST_PANEL swallow is used as a container for applications list layout defined in the apps-list-panel.edc file.
	  </p>
    </td>
  </tr>
  <tr>
    <td>
<pre class="prettyprint">
collections {
	group {
		name: GROUP_APPS_LIST_PANEL;

		parts {
			// The part is positioned in relation to PART_MAIN_PANEL_APPS_LIST_PANEL from badge.edc file.
			// The rect plays a role of the background for the applications list panel and occupies
			// the entire area of the PART_MAIN_PANEL_APPS_LIST_PANEL.
			part {
				name: PART_APPS_LIST_PANEL_BACKGROUND;
				type: RECT;
				...
			}

			// The part is positioned in relation to PART_APPS_LIST_PANEL_BACKGROUND.
			// The text part occupies 10% height and the entire width of the PART_APPS_LIST_PANEL_BACKGROUND.
			// This part is responsible for static text label display only ("Available applications").
			part {
				name: "apps_list_panel_available_apps_caption";
				type: TEXT;
				...
			}

			// The part is positioned in relation to PART_APPS_LIST_PANEL_BACKGROUND.
			// The swallow occupies 90% height of the PART_APPS_LIST_PANEL_BACKGROUND part
			// and its entire width.
			part {
				name: PART_APPS_LIST_PANEL_LIST;
				type: SWALLOW;
				...
			}
		}
	}
}
</pre>
	</td>
    <td>
      <p style="text-align:center;">
        <img alt="The list part of the main view of the application" src="../images/badge_ui_structure_edje_list_sd.png" />
      </p>
    </td>
  </tr>
  <tr>
    <td colspan = "2">
	  <p>
      The PART_MAIN_PANEL_BUTTONS_PANEL swallow is used as a container for action button layout defined in the buttons-panel.edc file.
	  </p>
    </td>
  </tr>
  <tr>
    <td>
<pre class="prettyprint">
collections {
	group {
		name: GROUP_BUTTONS_PANEL;

		parts {
			// The part is positioned in relation to PART_MAIN_PANEL_BUTTONS_PANEL from badge.edc file.
			// The rect plays a role of the background for the buttons panel and occupies
			// the entire area of the PART_MAIN_PANEL_BUTTONS_PANEL.
			part {
				name: PART_BUTTONS_PANEL_BACKGROUND;
				type: RECT;
				...
			}

			// The part is positioned in relation to PART_BUTTONS_PANEL_BACKGROUND.
			// The swallow occupies 60% height and 60% width of the PART_BUTTONS_PANEL_BACKGROUND part.
			// The swallow is horizontally and vertically centered.
			part {
				name: PART_BUTTONS_PANEL_BUTTON;
				type: SWALLOW;
				...
			}
		}
	}
}
</pre>
	</td>
    <td>
      <p style="text-align:center;">
        <img alt="The buttons part of the main view of the application" src="../images/badge_ui_structure_edje_buttons_sd.png" />
      </p>
    </td>
  </tr>
</table>
<p> Based on the layout defined with EDJE scripts, the application interface is created with <span style="font-family: Courier New,Courier,monospace">view_base_gui_create()</span> function
(see the <a href="#app-init">Application initialization</a>), which takes one argument - a pointer to the structure containing view data (<span style="font-family: Courier New,Courier,monospace">viewdata_s</span> - refer to the
<a href="#type-defs">Type definitions</a> section for more details). In succeeding calls to <span style="font-family: Courier New,Courier,monospace">view_*_panel_create()</span> functions,
the user interface is created.
</p>
<pre class="prettyprint">
bool
view_base_gui_create(viewdata_s *vd)
{
	viewdata = vd;

	if (!view_main_panel_create(vd) ||
		!view_update_panel_create(vd) ||
		!view_available_apps_panel_create(vd) ||
		!view_buttons_panel_create(vd)) {
		evas_object_del(vd->win);
		return false;
	}

	evas_object_show(vd->win);

	return true;
}
</pre>
<p>Base view creation in details:</p>
<table>
  <tr>
    <td>
	  <p><span style="font-family: Courier New,Courier,monospace">view_main_panel_create()</span> - the main window and descendant conformant is created
	  (<span style="font-family: Courier New,Courier,monospace">vd->win</span> and <span style="font-family: Courier New,Courier,monospace">vd->conform</span> respectively)
	  and used as a placeholder for the main layout (<span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span>). The main layout is created with
	  <span style="font-family: Courier New,Courier,monospace">view_layout_create()</span> function by loading the main group from the EDJE layout (badge.edj file), then it is embedded into the
	  <span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span> container.
	  <br>
	  Finally, the <span style="font-family: Courier New,Courier,monospace">view_layout_back_cb()</span> callback function is attached to the
	  <span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span> layout for Back button handling.
	  </p>
	</td>
	<td>
<pre class="prettyprint">
static bool
view_main_panel_create(viewdata_s *vd)
{
	vd->win = view_window_create();
	... // Error control.

	vd->conform = view_conformant_create(vd->win);
	... // Error control.

	vd->layout_main_panel = view_layout_create(vd->conform,
							EDJ_MAIN_FILE_NAME,
							GROUP_MAIN, NULL);
	... // Error control.
	eext_object_event_callback_add(vd->layout_main_panel,
							EEXT_CALLBACK_BACK,
							view_layout_back_cb,
							(void*)vd);

	return true;
}
</pre>
	</td>
	<td>
	  <p style="text-align:center;">
        <img alt="The application's main view" src="../images/badge_ui_view_main_sd.png" />
      </p>
	</td>
  </tr>
  <tr>
    <td>
	<p>
	<span style="font-family: Courier New,Courier,monospace">view_update_panel_create()</span> - update subview is created by loading the
	<span style="font-family: Courier New,Courier,monospace">GROUP_BADGE_UPDATE_PANEL</span> group from EDJE layout (badge-update-panel.edc file), then it is embedded in
	<span style="font-family: Courier New,Courier,monospace">elm_layout</span> container which is then inserted into the
	<span style="font-family: Courier New,Courier,monospace">PART_MAIN_PANEL_BADGE_UPDATE_PANEL</span> swallow of the
	<span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span>. Finally, the <span style="font-family: Courier New,Courier,monospace">elm_spinner</span> widget
	is created for setting the badge counter value.
	</p>
	</td>
	<td>
<pre class="prettyprint">
static bool
view_update_panel_create(viewdata_s *vd)
{
	vd->layout_badge_update_panel = view_layout_create(vd->layout_main_panel,
							EDJ_BADGE_UPDATE_PANEL_FILE_NAME,
							GROUP_BADGE_UPDATE_PANEL,
							PART_MAIN_PANEL_BADGE_UPDATE_PANEL);
	... // Error control.

	vd->badge_counter_spinner = view_spinner_create(vd->layout_badge_update_panel);
	... // Error control.

	return true;
}
</pre>
    </td>
	<td>
	  <p style="text-align:center;">
        <img alt="The application's main view with update panel" src="../images/badge_ui_view_main_update_panel_sd.png" />
      </p>
	</td>
  </tr>
  <tr>
    <td>
	<p>
	<span style="font-family: Courier New,Courier,monospace">view_available_apps_panel_create()</span> - available application subview is created by loading the
	<span style="font-family: Courier New,Courier,monospace">GROUP_APPS_LIST_PANEL</span> group from EDJE layout (apps-list-panel.edc file), then it is embedded to the
	<span style="font-family: Courier New,Courier,monospace">elm_layout</span> container which is then inserted into the
	<span style="font-family: Courier New,Courier,monospace">PART_MAIN_PANEL_APPS_LIST_PANEL</span> swallow of the
	<span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span>. Once the layout
	<span style="font-family: Courier New,Courier,monospace">vd->layout_available_apps_panel</span> is ready, the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span>
	widget is created (<span style="font-family: Courier New,Courier,monospace">vd->available_apps_list</span>) for available applications list display. Two callback functions are assigned to the
	<span style="font-family: Courier New,Courier,monospace">vd->available_apps_list</span> widget:
	<ul>
	  <li><span style="font-family: Courier New,Courier,monospace">view_available_apps_item_selected_cb()</span> for item selected action,</li>
	  <li><span style="font-family: Courier New,Courier,monospace">view_available_apps_item_unselected_cb()</span> for item unselected action.</li>
	</ul>
	For callbacks details, see the description below the table.
	</p>
	</td>
	<td>
<pre class="prettyprint">
static bool
view_available_apps_panel_create(viewdata_s *vd)
{
	vd->layout_available_apps_panel = view_layout_create(vd->layout_main_panel,
							EDJ_APPS_LIST_PANEL_FILE_NAME,
							GROUP_APPS_LIST_PANEL,
							PART_MAIN_PANEL_APPS_LIST_PANEL);
	... // Error control.

	vd->available_apps_list = view_genlist_create(vd->layout_available_apps_panel,
							PART_APPS_LIST_PANEL_LIST);
	... // Error control.

	evas_object_smart_callback_add(vd->available_apps_list,
					"selected",
					view_available_apps_item_selected_cb,
					(void*)vd);
	evas_object_smart_callback_add(vd->available_apps_list,
					"unselected",
					view_available_apps_item_unselected_cb,
					(void*)vd);

	return true;
}
</pre>
    </td>
	<td>
	  <p style="text-align:center;">
        <img alt="The application's main view with application list panel" src="../images/badge_ui_view_main_apps_list_sd.png" />
      </p>
	</td>
  </tr>
  <tr>
    <td>
	<p>
	<span style="font-family: Courier New,Courier,monospace">view_buttons_panel_create()</span> - action button subview is created by loading the
	<span style="font-family: Courier New,Courier,monospace">GROUP_BUTTONS_PANEL</span> group from EDJE layout (buttons-panel.edc file), then it is embedded in the
	<span style="font-family: Courier New,Courier,monospace">elm_layout</span> container which is then inserted into the
	<span style="font-family: Courier New,Courier,monospace">PART_MAIN_PANEL_APPS_LIST_PANEL</span> swallow of the
	<span style="font-family: Courier New,Courier,monospace">vd->layout_main_panel</span>. Once the layout
	<span style="font-family: Courier New,Courier,monospace">vd->layout_buttons_panel</span> is ready, the <span style="font-family: Courier New,Courier,monospace">elm_button</span>
	widget is created (<span style="font-family: Courier New,Courier,monospace">vd->update_button</span>) for triggering update action. A callback function which is responsible for introducing
	the changes to the application is connected to the <span style="font-family: Courier New,Courier,monospace">vd->update_button</span> widget.
	</p>
	</td>
	<td>
<pre class="prettyprint">
static bool
view_buttons_panel_create(viewdata_s *vd)
{
	vd->layout_buttons_panel = view_layout_create(vd->layout_main_panel,
							EDJ_BUTTONS_PANEL_FILE_NAME,
							GROUP_BUTTONS_PANEL,
							PART_MAIN_PANEL_BUTTON_PANEL);
	... // Error control.

	vd->update_button = view_button_create(vd->layout_buttons_panel,
							PART_BUTTONS_PANEL_BUTTON,
							"Update",
							view_badge_update_button_click_cb,
							(void*)vd);
	... // Error control.

	return true;
}
</pre>
    </td>
	<td>
	  <p style="text-align:center;">
        <img alt="The complete application's main view" src="../images/badge_ui_view_main_buttons_panel_sd.png" />
      </p>
	</td>
  </tr>
</table>

<p>Items are added to the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> widget on application's initialization (see the <a href="#app-init">Application initialization</a>
section for details). For this purpose, the <span style="font-family: Courier New,Courier,monospace">view_genlist_item_add()</span> function is used. This function takes only one argument of
pointer to the <span style="font-family: Courier New,Courier,monospace">pkginfo_s</span> structure type (for type specification refer to the <a href="#type-defs">Type definitions</a> section).
It contains the application's identifier and related package name, which is further passed to the <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span>
function for display purpose. Finally, the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span>'s item text content is acquired and displayed with
<span style="font-family: Courier New,Courier,monospace">view_genlist_item_label_get()</span> function.
</p>
<pre class="prettyprint">
bool
view_genlist_item_add(pkginfo_s *pkginfo)
{
	static Elm_Genlist_Item_Class *itc = NULL;

	... // Error control.

	if (!itc) {
		itc = elm_genlist_item_class_new();
		... // Error control.

		itc->item_style = "double_label";
		itc->func.text_get = view_genlist_item_label_get;
		... // NULL value assignment to unused itc fields.
	}

	Elm_Object_Item *item = elm_genlist_item_append(viewdata->available_apps_list, itc, (void*)pkginfo, NULL, ELM_GENLIST_ITEM_NONE, NULL, NULL);
	... // Error control.

	// The data is assigned to the newly created genlist's item.
	elm_object_item_data_set(item, (void*)pkginfo);

	return true;
}
</pre>
<pre class="prettyprint">
static char*
view_genlist_item_label_get(void *data, Evas_Object *obj, const char *part)
{
	pkginfo_s *pkginfo = (pkginfo_s*)data;

	... // Error control.

	// Two text buffers are populated (buff_main and buff_sub) with string content based on the pkginfo:
	//    - buff_main - the application's package name.
	//    - buff_sub - the application's badge counter which is obtained with controller_badge_count_get() function.

	if (!strcmp(part, "elm.text")) {
		return strdup(pkginfo->pkg_name);
	} else if (!strcmp(part, "elm.text.sub")) {
		unsigned int badge_count = controller_badge_count_get(pkginfo->app_id);
		char buff[255] = {0,};

		snprintf(buff, sizeof(buff), "Badge count = %u", badge_count);

		return strdup(buff);
	}

	return NULL;
}
</pre>
<p>Each item added to the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> widget supports selected and unselected actions which are used to display the selected application
package name in the EDJE text container of the <span style="font-family: Courier New,Courier,monospace">vd->layout_badge_update_panel</span> defined in the badge-update-panel.edc file.
<br>
The item "selected" action is handled by the <span style="font-family: Courier New,Courier,monospace">view_available_apps_item_selected_cb()</span> callback function which is shown below.
</p>
<pre class="prettyprint">
static void
view_available_apps_item_selected_cb(void *data, Evas_Object *obj, void *event_info)
{
	viewdata_s *vd = (viewdata_s*)data;

	// Get the selected item's reference.
	item_selected = (Elm_Object_Item*)event_info;
	... // Error control.
	// Get the pkginfo_s data assigned to the selected item.
	pkginfo_s *pkginfo = (pkginfo_s*)elm_object_item_data_get(item_selected);
	... // Error control.

	// Get the badge counter assigned to the selected application.
	unsigned int badge_count = controller_badge_count_get(pkginfo->app_id);
	// Obtained badge counter value is set to the vd->badge_counter_spinner widget
	// for future manipulation.
	elm_spinner_value_set(vd->badge_counter_spinner, (double)badge_count);
	// The selected item is updated.
	elm_genlist_item_update(item_selected);
	// Send the SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_SHOW signal in order to display
	// the selected application's package name in the PART_BADGE_UPDATE_PANEL_APP_NAME
	// part of the vd->layout_badge_update_panel layout with predefined color.
	elm_object_signal_emit(vd->layout_badge_update_panel,
							SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_SHOW,
							PART_BADGE_UPDATE_PANEL_APP_NAME);
	// The application's package name is assigned to the PART_BADGE_UPDATE_PANEL_APP_NAME
	// part of the viewdata->layout_badge_update_panel layout.
	elm_object_part_text_set(viewdata->layout_badge_update_panel,
							PART_BADGE_UPDATE_PANEL_APP_NAME,
							pkginfo->app_id);
}
</pre>
<p>The item "unselected" action is handled by the <span style="font-family: Courier New,Courier,monospace">view_available_apps_item_unselected_cb()</span> callback function which is shown below.</p>
<pre class="prettyprint">
static void
view_available_apps_item_unselected_cb(void *data, Evas_Object *obj, void *event_info)
{
	viewdata_s *vd = (viewdata_s*)data;

	// Send the SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_HIDE signal in order to display
	// the default text in the PART_BADGE_UPDATE_PANEL_APP_NAME part of the
	// vd->layout_badge_update_panel layout with predefined color.
	elm_object_signal_emit(vd->layout_badge_update_panel,
							SIGNAL_BADGE_UPDATE_PANEL_APP_NAME_HIDE,
							PART_BADGE_UPDATE_PANEL_APP_NAME);
	// The default text is assigned to the PART_BADGE_UPDATE_PANEL_APP_NAME
	// part of the viewdata->layout_badge_update_panel layout.
	elm_object_part_text_set(viewdata->layout_badge_update_panel,
							PART_BADGE_UPDATE_PANEL_APP_NAME,
							TEXT_LABEL_BADGE_UPDATE_PANEL_APP_NAME_DEFAULT);

	// The current selection reference is cleared.
	item_selected = NULL;
}
</pre>
<p>Finally, the implementation of badge update procedure is shown below. The procedure is triggered by the "Update" button click action. The
<span style="font-family: Courier New,Courier,monospace">view_badge_update_button_click_cb()</span> callback function, assigned to the "Update" button, is invoked.</p>
<pre class="prettyprint">
static void
view_badge_update_button_click_cb(void *data, Evas_Object *obj, void *event_info)
{
	viewdata_s *vd = (viewdata_s*)data;

	// Check if any item was selected. The item_selected variable is declared
	// statically in global scope. The valid value of item_selected variable
	// is assigned in view_available_apps_item_selected_cb() callback function.
	if (!item_selected) {
		return;
	}

	// Get the pkginfo_s data assigned to the selected item.
	pkginfo_s *pkginfo = (pkginfo_s*)elm_object_item_data_get(item_selected);
	... // Error control.

	// Get the badge counter assigned to the selected application.
	unsigned int curr_badge_count = controller_badge_count_get(pkginfo->app_id);
	// Get the value of badge counter adjusted via the elm_spinner widget.
	int new_badge_count = (int)elm_spinner_value_get(vd->badge_counter_spinner);

	// If the adjusted badge counter value is equal to the badge counter value
	// currently assigned to the selected application, then nothing happens.
	if (curr_badge_count == new_badge_count) {
		return;
	} else
	// If the adjusted badge counter value is not equal to the badge counter value
	// currently assigned to the selected application, which is equal to zero,
	// then new badge for the selected application is created.
	if (curr_badge_count == 0) {
		controller_badge_new(pkginfo->app_id, new_badge_count);
	} else
	// If the adjusted badge counter value equals zero and the badge counter
	// value currently assigned to the selected application is greater then zero,
	// then existing badge is removed.
	if (new_badge_count == 0) {
		controller_badge_remove(pkginfo->app_id);
	} else {
		// Otherwise, the badge counter assigned to the selected application
		// is updated.
		controller_badge_update(pkginfo->app_id, new_badge_count);
	}

	// The selected item is updated.
	elm_genlist_item_update(item_selected);
}
</pre>

<h3 id="controller">Controller</h3>
<p>The Controller module provides a function used during application initialization process: <span style="font-family: Courier New,Courier,monospace">controller_application_init()</span>. It is responsible
for acquiring applications packages list for its badges control (<span style="font-family: Courier New,Courier,monospace">model_packages_list_get()</span>) and finally for adding them to the list view
(<span style="font-family: Courier New,Courier,monospace">view_genlist_item_add()</span>) using the data acquired in the previous step. For reference, see the <a href="#model">Model</a> and the
<a href="#view">View</a> sections respectively.</p>
<pre class="prettyprint">
bool
controller_application_init(modeldata_s *md)
{
	if (!model_packages_list_get(&md->pkg_list)) {
		return false;
	}

	... // variables declaration.

	EINA_LIST_FOREACH(md->pkg_list, it, pkginfo) {
		view_genlist_item_add(pkginfo);
	}

	return true;
}
</pre>
<p>Additionally, the Controller module provides a function used during application termination process: <span style="font-family: Courier New,Courier,monospace">controller_application_terminate()</span>.
It is responsible for releasing all the memory allocated previously (a list of <span style="font-family: Courier New,Courier,monospace">pkginfo_s</span> structures). For reference, see the
<a href="#app-init">Application initialization</a> and the <a href="#model">Model</a> sections.
</p>
<pre class="prettyprint">
void
controller_application_terminate(modeldata_s *md)
{
	model_packages_list_free(md->pkg_list);
}
</pre>
<br>
<p>In order to control the process of badges management, a set of four functions is implemented. The following actions are supported:
<ul>
  <li>get the badge number pinned to the chosen application (<span style="font-family: Courier New,Courier,monospace">controller_badge_count_get()</span>),</li>
  <li>create a new badge for chosen application (<span style="font-family: Courier New,Courier,monospace">controller_badge_new()</span>),</li>
  <li>remove the badge which is already pinned to chosen application (<span style="font-family: Courier New,Courier,monospace">controller_badge_remove()</span>),</li>
  <li>update the badge counter pinned to chosen application (<span style="font-family: Courier New,Courier,monospace">controller_badge_update()</span>).</li>
</ul>
Each of the above functions require application's id to be provided as an input argument. It is used to identify the target application whose badge is to be handled. Additionally, for the functions for badge
creating and updating, the badge counter is required. Listings of functions supporting these operations are shown below. For Model function reference, see the <a href="#model">Model</a> section.
<br>
<br>
Obtain the badge counter.</p>
<pre class="prettyprint">
unsigned int
controller_badge_count_get(const char *app_id)
{
	...	// Variables declaration.

	if (!model_badge_count_get(app_id, &badge_count)) {	// Query the badge counter value.
		return 0;
	}

	... // Log message.

	return badge_count;
}
</pre>
<br>
<p>Create a new badge.</p>
<pre class="prettyprint">
bool
controller_badge_new(const char *app_id, unsigned int badge_count)
{
	if (!model_badge_add(app_id)) {
		return false;
	}

	if (!model_badge_display_set(app_id, 1)) {	// The badge visibility is requested.
		return false;
	}

	return model_badge_count_set(app_id, badge_count);	// The badge counter initialization with provided badge_counter value is requested.
}
</pre>
<br>
<p>Remove the existing badge.</p>
<pre class="prettyprint">
bool
controller_badge_remove(const char *app_id)
{
	if (!model_badge_count_set(app_id, 0)) {	// Clearing the badge counter is requested.
		return false;
	}

	if (!model_badge_display_set(app_id, 0)) {	// The badge invisibility is requested.
		return false;
	}

	return model_badge_remove(app_id);		// The badge deletion is requested.
}
</pre>
<br>
<p>Update the existing badge counter.</p>
<pre class="prettyprint">
bool
controller_badge_update(const char *app_id, unsigned int badge_count)
{
	bool display = false;

	if (!model_badge_display_get(app_id, &display)) {	// Query visibility state of the badge.
		return false;
	}

	if (!display) {						// Only visible badges are updated.
		return false;
	}

	return model_badge_count_set(app_id, badge_count);	// The badge counter alteration is requested.
}
</pre>

<h3 id="model">Model</h3>
<p>The Model module deals directly with the application's data. It is responsible for:
<ul>
  <li>packages names and related application's identifier acquisition,</li>
  <li>badge creation, counter alteration and badge removal.</li>
</ul>
In order to perform the operations specified above, the Application Manager and Badge API are used respectively.
<br>
<br>
In the initialization step, the <span style="font-family: Courier New,Courier,monospace">model_packages_list_get()</span> function is used to obtain the list of valid application identifiers and related
packages names (for reference, see the <a href="#app-init">Application initialization</a> and <a href="#controller">Controller</a> sections). The function invokes
<span style="font-family: Courier New,Courier,monospace">app_manager_foreach_app_info()</span> with <span style="font-family: Courier New,Courier,monospace">model_app_info_cb()</span>
callback function passed as an argument in order to retrive all information about installed applications. The applications and packages information is obtained with subsequent calls to the callback function.
For details, see the listings below.
</p>
<pre class="prettyprint">
bool
model_packages_list_get(Eina_List **list)
{
	*list = NULL;

	int ret = app_manager_foreach_app_info(model_app_info_cb, (void*)list);
	... // Error handling.

	return true;
}
</pre>
<pre class="prettyprint">
static bool
model_app_info_cb(app_info_h app_info, void *user_data)
{
	Eina_List **list = (Eina_List**)user_data;

	char *pkg_name = NULL;
	int ret = app_info_get_package(app_info, &pkg_name);	// Get the application's package name.
	... // Error handling.

	bool nodisplay = true;
	ret = app_info_is_nodisplay(app_info, &nodisplay);	// Get the application's display flag.
	... // Error handling.

	if (nodisplay) {					// Return, if the application is non-displayable.
		free(pkg_name);
		return true;
	}

	char *app_id = NULL;
	ret = app_info_get_app_id(app_info, &app_id);		// Get the application's identifier.
	... // Error handling.

	// If the application is displayable and all the required information is retreived successfully
	// (the package name and the application's identifier), then the pkginfo_s structure is created
	// and added to the list.
	pkginfo_s *pkginfo = NULL;
	if (model_package_info_create(pkg_name, app_id, &pkginfo)) {
		*list = eina_list_append(*list, (void*)pkginfo);
	}

	free(pkg_name);

	return true;	// Continue the applications information enumeration.
}
</pre>
<p>In the finalization step (application's termination), the <span style="font-family: Courier New,Courier,monospace">model_packages_list_free()</span> function is used to release the memory allocated
in the <a href="#app-init">Application initialization</a> step. Also, refer to the <a href="#controller">Controller</a> section for the
<span style="font-family: Courier New,Courier,monospace">controller_application_terminate()</span> function implementation.
</p>
<pre class="prettyprint">
void
model_packages_list_free(Eina_List *list)
{
	... // Variables declaration.

	// The list consists of pkginfo_s structures. The loop below results in
	// pkginfo->pkg_name, pkginfo->app_id and pkginfo deallocation.
	EINA_LIST_FOREACH(list, it, pkginfo) {
		...
			free(pkginfo->pkg_name);
		...
			free(pkginfo->app_id);
		...
		free(pkginfo);
		...
	}

	list = eina_list_free(list);
}
</pre>
<p>Additionally, the Model module provides a set of wrapper functions for the badge API used by the <a href="#controller">Controller</a> module for the badges management:
<ul>
  <li>create and remove the badge,</li>
  <li>get and set the badge's display flag,</li>
  <li>get and set the badge's counter,</li>
  <li>check the badge's existence.</li>
</ul>
Each of the above functions require application's id to be provided as an input argument. It is used to identify the target application whose badge is to be handled. All the functions, except those used
for badge creation, removal and existence check, require additional argument for setting or getting a value (display flag or badge counter). Listings of functions supporting these operations are shown below.
</p>

<pre class="prettyprint">
bool
model_badge_remove(const char *app_id)
{
	int ret = badge_remove(app_id);
	... // Error handling.

	return true;
}
</pre>
<pre class="prettyprint">
bool
model_badge_display_get(const char *app_id, bool *display)
{
	unsigned int is_display = 0;

	*display = (bool)is_display;	// By default, the false value is returned.

	int ret = badge_get_display(app_id, &is_display);
	... // Error handling.

	*display = (bool)is_display;

	return true;
}
</pre>
<pre class="prettyprint">
bool
model_badge_display_set(const char *app_id, bool display)
{
	unsigned int display_val = 0;

	if (display) {
		display_val = 1;
	}

	int ret = badge_set_display(app_id, display_val);
	... // Error handling.

	return true;
}
</pre>
<pre class="prettyprint">
bool
model_badge_count_get(const char *app_id, unsigned int *badge_count)
{
	int ret = badge_get_count(app_id, badge_count);
	... // Error handling.

	return true;
}
</pre>
<pre class="prettyprint">
bool
model_badge_count_set(const char *app_id, unsigned int badge_count)
{
	int ret = badge_set_count(app_id, badge_count);
	... // Error handling.

	return true;
}
</pre>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
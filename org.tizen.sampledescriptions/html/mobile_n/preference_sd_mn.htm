<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>Preference Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mn_icon.png"/></p>
	</div>

  <h1>Preference Sample Overview</h1> 

  <p>The Preference sample application demonstrates how to work with custom preferences stored in an underlying database. The preferences are stored as key-value pairs with a defined value type (integer, double, boolean, or string). You can use the preferences as an application configuration storage, where the key-value pairs remain valid for subsequent launches of the related application. </p>
  <p>The following figure illustrates the application view.</p>
  <p class="figure">Figure: Preference screen</p>
  <p align="center"><img alt="Preference screen" height="364" src="../images/preference_main_view_sd.png" /></p>

  <p>You can:</p>
  <ul>
    <li>Create a new preference (key, value, type)
<p>You must provide a custom key name and value type to be stored (integer, double, boolean, or string), and assign a value corresponding to the defined type.</p></li>
	<li>List and browse all available preferences
<p>All defined preferences are displayed using the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> component. The related value and its type are displayed in a text format.</p></li>
	<li>Remove all available preferences
<p>You can remove all defined preferences with a single batch operation.</p></li>
	<li>Remove selected preferences
<p>Once the available preferences are displayed in a list, you can remove selected preferences using the remove button attached to the list item.</p></li>
  </ul>
  
<p>The following figure illustrates the structure of the user interface (EDJE layout scripts are used).</p>
  <p class="figure">Figure: Preference UI layout and component structure</p>
  <p align="center"><img alt="Preference UI layout structure" src="../images/preference_ui_structure_edje_sd.png" /></p>
  <p align="center"><img alt="Preference UI components structure" src="../images/preference_ui_structure_elementary_sd.png" /></p>
  <p>The application workflow can be divided into 4 logical blocks:</p>
  <ul>
    <li>Startup</li>
	<li>Key-value input</li>
	<li>Preference deletion</li>
	<li>Removal of all preferences</li>
  </ul>

  <p>Due to the <a href="../../../org.tizen.native.mobile.apireference/group__CAPI__PREFERENCE__MODULE.html">Preference</a> API constraints, the application defines 1 additional preference (<span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span>), which is used internally. Its purpose is to bind a value type to the key name, as the Preference API does not provide information on the type of the key value.</p>
  <p>In order to identify the type of the value assigned to a specified key, the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> preference is used as a lookup table. The structure of the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> preference is:</p>
  <p><span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY = key_name_1:value_type;key_name_2:value_type; ... ;key_name_N:value_type;</span></p>
  <p>Where</p>
  <ul>
    <li><span style="font-family: Courier New,Courier,monospace">key_name_X</span> is the name of the X<sup>th</sup> preference defined by the user</li>
	<li><span style="font-family: Courier New,Courier,monospace">value_type</span> is the type of the value assigned to the preference:
	  <ul>
	    <li>Integer: 0</li>
		<li>Double: 1</li>
		<li>Boolean: 2</li>
		<li>String: 3</li>
	  </ul>
	</li>
  </ul>

  <p>The following figure illustrates the application workflow with the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> constraints.  </p>
  <p class="figure" id="app_workflow" name="app_workflow">Figure: Application workflow</p>
  <p align="center"><img alt="Application workflow" src="../images/preference_workflow_sd.png" /></p>
  <h2>Prerequisites</h2>
  <p>The following privilege must be set:</p>
  <ul>
    <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/systemsettings</span></li>
  </ul>


<h2>Implementation</h2>
<h3 id="types" name="types">Type Definitions</h3>
<pre class="prettyprint">
typedef struct _viewdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object* win;
&nbsp;&nbsp;&nbsp;Evas_Object* conform;
&nbsp;&nbsp;&nbsp;Evas_Object* main_layout;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_edit_panel_layout;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_edit_panel_key_entry;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_edit_panel_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_edit_panel_type_selector;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_buttons_panel_layout;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_buttons_panel_left_button;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_buttons_panel_right_button;
&nbsp;&nbsp;&nbsp;Evas_Object* pref_list_panel_list;
&nbsp;&nbsp;&nbsp;Eina_List* genlist_items;
} viewdata_s;
</pre>
<pre class="prettyprint">
typedef struct _modeldata 
{
&nbsp;&nbsp;&nbsp;pref_value_type_t selected_pref_value_type;
} modeldata_s;
</pre>
<pre class="prettyprint">
typedef enum {PREF_INTEGER = 0, PREF_DOUBLE, PREF_BOOL, PREF_STRING, PREF_MAX} pref_value_type_t;

typedef struct _key_value 
{
&nbsp;&nbsp;&nbsp;char *key;
&nbsp;&nbsp;&nbsp;void *value;
&nbsp;&nbsp;&nbsp;pref_value_type_t value_type;
} key_value_t;
</pre>
<pre class="prettyprint">
typedef void (*preference_read_cb)(key_value_t *key_value);
</pre>

<h3>Application Initialization</h3>
<p>The entire application life-cycle is implemented in the <span style="font-family: Courier New,Courier,monospace">preferences.c</span> file, using a common Tizen application structure:</p>
<pre class="prettyprint">
int
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;appdata_s ad = {{0,},};
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback = {0,};
&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL,};

&nbsp;&nbsp;&nbsp;event_callback.create = app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.pause = app_pause;
&nbsp;&nbsp;&nbsp;event_callback.resume = app_resume;
&nbsp;&nbsp;&nbsp;event_callback.app_control = app_control;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, ui_app_low_battery, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, ui_app_low_memory, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, ui_app_orient_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, ui_app_lang_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, ui_app_region_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_remove_event_handler(handlers[APP_EVENT_LOW_MEMORY]);

&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &amp;event_callback, &amp;ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;ui_app_main() is failed. err = %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
<p>The Preference sample application is implemented using an MVC design pattern. Its initialization is done within the <span style="font-family: Courier New,Courier,monospace">app_create()</span> callback function:</p>
<pre class="prettyprint">
static bool
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;// Hook to take necessary actions before main event loop starts
&nbsp;&nbsp;&nbsp;// Initialize UI resources and application's data
&nbsp;&nbsp;&nbsp;// If this function returns true, the main loop of application starts
&nbsp;&nbsp;&nbsp;// If this function returns false, the application is terminated
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;return controller_initialize(&amp;ad-&gt;vd, &amp;ad-&gt;md);
}
</pre>
<p>In the initialization step, the <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_get()</span> function is used to obtains the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> preference in the form of an <span style="font-family: Courier New,Courier,monospace">Eina_List</span> list. It contains all the preferences defined by the user together with the value types. Once the list of defined preferences types is known, the user interface is created using the <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function. Finally, the application model is created with the <span style="font-family: Courier New,Courier,monospace">model_create()</span> function and the defined preference type list is disposed of using the <span style="font-family: Courier New,Courier,monospace">controller_key_value_list_remove()</span> function.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">controller_initialize()</span> function takes 2 parameters (for details, see <a href="#types">Type Definitions</a>):</p>
<ul>
  <li>
    <span style="font-family: Courier New,Courier,monospace">viewdata_s *vd</span> is a pointer to a static structure whose members are referencing UI components.
  </li>
  <li>
    <span style="font-family: Courier New,Courier,monospace">modeldata_s *md</span> is a pointer to a static structure, referencing the preference type selected through the UI selector.</li>
</ul>

<pre class="prettyprint">
bool
controller_initialize(viewdata_s *vd, modeldata_s *md)
{
&nbsp;&nbsp;&nbsp;Eina_List *pref_types = NULL;

&nbsp;&nbsp;&nbsp;if (!controller_property_items_enum_item_get(&amp;pref_types)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!view_create_base_gui(vd)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;model_create(md, pref_types, preference_read_valid_cb);

&nbsp;&nbsp;&nbsp;controller_key_value_list_remove(pref_types);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>Inside the <span style="font-family: Courier New,Courier,monospace">controller_initialize()</span> function, the list of user-defined preferences and related types (stored in the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> internal preference) are retrieved with the <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_get()</span> function.</p>

<p>At the entry point, you check whether the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> preference has already been defined (<span style="font-family: Courier New,Courier,monospace">model_preference_exists_check()</span>). If yes, its value is retrieved with the <span style="font-family: Courier New,Courier,monospace">model_preference_string_get()</span> function. On success, the string composed of 
<span style="font-family: Courier New,Courier,monospace">key_name:value_type</span> pairs is returned:</p>

<p><span style="font-family: Courier New,Courier,monospace">key_name_1:value_type;key_name_2:value_type; ... ;key_name_N:value_type;</span></p>

<p>The string of property types is then decomposed into a list of <span style="font-family: Courier New,Courier,monospace">key_name:value_type</span> pairs using the <span style="font-family: Courier New,Courier,monospace">property_items_enum_key_type_decompose()</span> function (this function listing is not provided as it is a simple string decomposition that uses the tokenized property of the string). The decomposition result is stored in the
<span style="font-family: Courier New,Courier,monospace">properties_enum</span> variable of the <span style="font-family: Courier New,Courier,monospace">Eina_List</span> type.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">properties_enum</span> list consists of a number of structures of the <span style="font-family: Courier New,Courier,monospace">key_value_t</span> type (for details, see <a href="#types">Type Definitions</a>).</p>
<pre class="prettyprint">
bool
controller_property_items_enum_item_get(Eina_List **properties_enum)
{
&nbsp;&nbsp;&nbsp;bool key_exists = model_preference_exists_check(PROPERTY_ITEMS_ENUM_KEY);

&nbsp;&nbsp;&nbsp;char *items_enum_value = NULL;
&nbsp;&nbsp;&nbsp;if (key_exists) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_preference_string_get(PROPERTY_ITEMS_ENUM_KEY, &amp;items_enum_value)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;bool ret = property_items_enum_key_type_decompose(items_enum_value, properties_enum);

&nbsp;&nbsp;&nbsp;if (items_enum_value) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(items_enum_value);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<p>The user interface is created with the <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function (for more details, see <a href="#view_imp">View Implementation</a>). Once the user interface is created successfully,
the application model is created using the <span style="font-family: Courier New,Courier,monospace">model_create()</span> function. This function is responsible for enumerating all the user-defined preferences only using the Preference API&#39;s <span style="font-family: Courier New,Courier,monospace">preference_foreach_item()</span> function.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">model_create()</span> function takes 3 parameters:</p>
<ul>
  <li>
    <span style="font-family: Courier New,Courier,monospace">modeldata_s *md</span> is a pointer to the static structure, referencing the preference type selected through the UI selector (for details, see <a href="#types">Type Definitions</a>).
  </li>
  <li>
    <span style="font-family: Courier New,Courier,monospace">Eina_List *pref_types</span> is a list of the <span style="font-family: Courier New,Courier,monospace">key_value_t</span> type structures (for details, see <a href="#types">Type Definitions</a>).
  </li>
  <li>
    <span style="font-family: Courier New,Courier,monospace">preference_read_cb func_cb</span> is a callback function called for each preference read from the underlying database for which the key name matches the key name stored in the <span style="font-family: Courier New,Courier,monospace">pref_types</span> list. At this point, the preference key-value with type matching is performed (basically, this is the startup workflow, as shown in the <a href="#app_workflow">Application workflow</a> figure).
  </li>
</ul>
<pre class="prettyprint">
void
model_create(modeldata_s *md, Eina_List *pref_types, preference_read_cb func_cb)
{
&nbsp;&nbsp;&nbsp;pref_foreach_data_s pref_foreach_data = 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pref_types = pref_types,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.func_cb = func_cb,
&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;modeldata = md;

&nbsp;&nbsp;&nbsp;int ret = preference_foreach_item(preference_item_enum_cb, (void*)&amp;pref_foreach_data);
&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function preference_foreach_item() failed with error %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}
}
</pre>
<p>Note that the mechanism of doubled callback functions is used. It means that the <span style="font-family: Courier New,Courier,monospace">preference_foreach_item()</span> function calls the <span style="font-family: Courier New,Courier,monospace">preference_item_enum_cb()</span> function for each preference found in the underlying database. The <span style="font-family: Courier New,Courier,monospace">preference_item_enum_cb()</span> callback function is called from the application model.</p>
<p>Within the <span style="font-family: Courier New,Courier,monospace">preference_item_enum_cb()</span> function, the additional callback function (<span style="font-family: Courier New,Courier,monospace">func_cb()</span> of the <span style="font-family: Courier New,Courier,monospace">preference_read_cb</span> type) is called whenever a key-value is successfully matched with the preference type. The <span style="font-family: Courier New,Courier,monospace">func_cb()</span> callback function is called in the application controller.</p>

<p>This doubled approach is used to deliver only those preferences whose key values are successfully matched with the related data type to the controller. The following code snippet illustrates the matching procedure in the <span style="font-family: Courier New,Courier,monospace">preference_item_enum_cb()</span> function:</p>
<pre class="prettyprint">
static bool
preference_item_enum_cb(const char *key, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Extracting data passed to the preference_foreach_item() function
&nbsp;&nbsp;&nbsp;pref_foreach_data_s *data = (pref_foreach_data_s*)user_data;	
&nbsp;&nbsp;&nbsp;Eina_List *it = NULL;
&nbsp;&nbsp;&nbsp;key_value_t *key_val = NULL;
&nbsp;&nbsp;&nbsp;int val_type = -1;

&nbsp;&nbsp;&nbsp;// Iteration over key_value_t structures decoded from the PROPERTY_ITEMS_ENUM_KEY
&nbsp;&nbsp;&nbsp;// to find a matching preference type for the key name passed to the preference_item_enum_cb
&nbsp;&nbsp;&nbsp;EINA_LIST_FOREACH(data-&gt;pref_types, it, key_val) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!controller_same_string_check((char*)key, key_val-&gt;key)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val_type = (int)key_val-&gt;value_type;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// If the matching preference type is found, the additional callback function func_cb
&nbsp;&nbsp;&nbsp;// is called in the application controller. func_cb gets full information about the preference
&nbsp;&nbsp;&nbsp;//  defined by the user (key-name, value, value-type).
&nbsp;&nbsp;&nbsp;if (data-&gt;func_cb) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key_value_t *kv = (key_value_t*)malloc(sizeof(key_value_t));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kv-&gt;key = strdup(key_val-&gt;key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kv-&gt;value = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kv-&gt;value_type = key_val-&gt;value_type;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Obtain the preference value with respect to its data type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (controller_preference_get(key_val-&gt;key, key_val-&gt;value_type, &amp;kv-&gt;value)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data-&gt;func_cb(kv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Finally, the callback function for the preference value change is bonded to the key,
&nbsp;&nbsp;&nbsp;// which was successfully matched with related data type
&nbsp;&nbsp;&nbsp;int ret = preference_set_changed_cb(key, preference_item_changed_cb, NULL);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<p>If the above callback function is called successfully, as a result, the <span style="font-family: Courier New,Courier,monospace">preference_read_valid_cb</span> callback function is invoked through the <span style="font-family: Courier New,Courier,monospace">data-&gt;func_cb(kv)</span>. The second callback function invocation is responsible for updating the view and the list of preferences.</p>
<pre class="prettyprint">
void
preference_read_valid_cb(key_value_t *key_value)
{
&nbsp;&nbsp;&nbsp;view_genlist_item_update(key_value);
}
</pre>
<p>As a final step within the <span style="font-family: Courier New,Courier,monospace">controller_initialize()</span> function, the list of items obtained using the <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_get()</span> function is freed with the <span style="font-family: Courier New,Courier,monospace">controller_key_value_list_remove()</span> function:</p>
<pre class="prettyprint">
void
controller_key_value_list_remove(Eina_List *list)
{
&nbsp;&nbsp;&nbsp;if (!list) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;key_value_t *key_val = NULL;

&nbsp;&nbsp;&nbsp;EINA_LIST_FREE(list, key_val) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_key_value_remove(key_val);
&nbsp;&nbsp;&nbsp;}
}

void
controller_key_value_remove(key_value_t *key_value)
{
&nbsp;&nbsp;&nbsp;if (!key_value) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (key_value-&gt;key) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(key_value-&gt;key);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;free(key_value);
}
</pre>

<h3 id="view_imp" name="view_imp">View Implementation</h3>
<p>The entire application layout is implemented using EDJE scripts. All the top level swallows are designed for EFL Elementary UI component embedding. The following EDJE swallow - EFL Elementary UI component relations and assigned functionalities are used:</p>
<ul>
  <li><span style="font-family: Courier New,Courier,monospace">pref_buttons_panel_left_button</span>: <span style="font-family: Courier New,Courier,monospace">elm_button</span> used to remove all defined preferences</li>
  <li><span style="font-family: Courier New,Courier,monospace">pref_buttons_panel_right_button</span>: <span style="font-family: Courier New,Courier,monospace">elm_button</span> used to update (add or alter) a preference with a provided key name, value, and value type</li>
  <li><span style="font-family: Courier New,Courier,monospace">pref_edit_panel_key_panel_entry</span>: <span style="font-family: Courier New,Courier,monospace">elm_entry</span> used as a preference key name input field</li>
  <li><span style="font-family: Courier New,Courier,monospace">pref_edit_panel_value_panel_entry</span>: <span style="font-family: Courier New,Courier,monospace">elm_entry</span> used as a preference value input field</li>
  <li><span style="font-family: Courier New,Courier,monospace">pref_edit_panel_type_panel_entry</span>: <span style="font-family: Courier New,Courier,monospace">elm_hoversel</span> used as a preference value type selector (integer, double, boolean, or string);</li>
  <li><span style="font-family: Courier New,Courier,monospace">main_panel_pref_list_panel</span>: <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> used as a list of all defined preferences, whose list items consist of:
    <ul>
	  <li>Key name, value, and value type</li>
	  <li><strong>X</strong> button for deleting a specific preference</li>
	</ul>
  </li>
</ul>

<p>The following table defines the code snippets that create the UI layout.</p>
<table>
   <caption>
     Table: UI layout code snippets and figures
   </caption> 
    <tr> 
     <th>Code snippet</th> 
     <th>Figure</th> 
    </tr> 

  <tr>
    <td colspan = "2">
      <strong>The main layout is defined in the <span style="font-family: Courier New,Courier,monospace">preference.edc</span> file:</strong>
    </td>
  </tr>
  <tr>
    <td>
      <pre class="prettyprint">
collections 
{
&nbsp;&nbsp;&nbsp;group 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: GROUP_MAIN;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part occupies the entire window
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_MAIN_BACKGROUND; // &quot;background&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 0 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_MAIN_BACKGROUND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The spacer occupies the entire PART_MAIN_BACKGROUND area with small margin all around
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_MAIN_MAIN_PANEL; // &quot;main_panel&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SPACER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_MAIN_MAIN_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow occupies 10% of PART_MAIN_MAIN_PANEL height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_MAIN_PREF_BUTTONS_PANEL; // &quot;main_panel_pref_buttons_panel&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_MAIN_MAIN_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow occupies 40% of PART_MAIN_MAIN_PANEL height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_MAIN_PREF_EDIT_PANEL; // &quot;main_panel_pref_edit_panel&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_MAIN_MAIN_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow has flexible height which depends on the height of swallows placed above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// At this configuration, the swallow occupies 50% of PART_MAIN_MAIN_PANEL height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_MAIN_PREF_LIST_PANEL; // &quot;main_panel_pref_list_panel&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>
    </td>
    <td>
      <p align="center"><img alt="Main layout" src="../images/preference_ui_structure_edje_main_sd.png" /></p>
    </td>
  </tr>
  <tr>
    <td colspan = "2">
      <strong>The <span style="font-family: Courier New,Courier,monospace">PART_MAIN_PREF_BUTTONS_PANEL</span> swallow is used as a container for the button layout defined in the <span style="font-family: Courier New,Courier,monospace">pref_buttons_panel.edc</span> file:</strong>
    </td>
  </tr>
  <tr>
    <td>
      <pre class="prettyprint">
collections 
{
&nbsp;&nbsp;&nbsp;group 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: GROUP_PREF_BUTTONS_PANEL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_MAIN_PREF_BUTTONS_PANEL from preference.edc file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The rect plays a role of a background for buttons panel and occupies the entire area
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// of the PART_MAIN_PREF_BUTTONS_PANEL swallow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_BUTTONS_PANEL_BACKGROUND; // &quot;pref_buttons_panel_background&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 0 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_BUTTONS_PANEL_BACKGROUND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow occupies the entire height of the PART_PREF_BUTTONS_PANEL_BACKGROUND with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a small margin at the top and the bottom. The swallow width is 50% of the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// PART_PREF_BUTTONS_PANEL_BACKGROUND width with a small margin at the left and right
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// sides. It is located in the top half of the PART_PREF_BUTTONS_PANEL_BACKGROUND swallow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_BUTTONS_PANEL_LEFT_BUTTON; // &quot;pref_buttons_panel_left_button&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_BUTTONS_PANEL_BACKGROUND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow sizing specification is exactly the same as for
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the PART_PREF_BUTTONS_PANEL_BACKGROUND swallow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It is located in the bottom half of the PART_PREF_BUTTONS_PANEL_BACKGROUND swallow
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_BUTTONS_PANEL_RIGHT_BUTTON; // &quot;pref_buttons_panel_right_button&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>
    </td>
    <td>
      <p align="center"><img alt="Button layout" src="../images/preference_ui_structure_edje_buttons_sd.png" /></p>
    </td>
  </tr>
  <tr>
    <td colspan = "2">
      <strong>The <span style="font-family: Courier New,Courier,monospace">main_panel_pref_edit_panel</span> swallow (defined in the main layout) is used to embed the input panel layout defined in the <span style="font-family: Courier New,Courier,monospace">pref_edit_panel.edc</span> file:</strong>
    </td>
  </tr>
  <tr>
    <td>
      <pre class="prettyprint">
collections 
{
&nbsp;&nbsp;&nbsp;group 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: GROUP_PREF_EDIT_PANEL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to main_panel_pref_edit_panel from preference.edc file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The rect plays a role of the background for the input panel and occupies the entire area
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// of the PART_MAIN_PREF_EDIT_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_EDIT_PANEL_BACKGROUND; // &quot;pref_edit_panel_background&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color: 0 0 0 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ----------=============== KEY INPUT PANEL ===============----------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_EDIT_PANEL_BACKGROUND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The spacer occupies 33% of the PART_PREF_EDIT_PANEL_BACKGROUND height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It is located at the top of the PART_PREF_EDIT_PANEL_BACKGROUND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_EDIT_PANEL_KEY_PANEL; // &quot;pref_edit_panel_key_panel&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SPACER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_EDIT_PANEL_KEY_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The text part occupies the entire height and 30% width of the PART_PREF_EDIT_PANEL_KEY_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This part is responsible for static text label display only
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (LABEL_KEY_CAPTION == &quot;Key name&quot;).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: &quot;pref_edit_panel_key_panel_label&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: TEXT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;align: 0.5 0.5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: LABEL_KEY_CAPTION;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size: 27;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_EDIT_PANEL_KEY_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The rect plays a role of a background for the elm_entry component. Its width is flexible
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and occupies all the area remaining from pref_edit_panel_key_panel_label part positioning.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The height is set to 70% of the PART_PREF_EDIT_PANEL_KEY_PANEL height and it is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vertically centered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ // &quot;pref_edit_panel_key_panel_entry_background&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_EDIT_PANEL_KEY_PANEL_ENTRY_BACKGROUND;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: RECT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The part is positioned in relation to PART_PREF_EDIT_PANEL_KEY_PANEL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The swallow occupies entire height of the PART_PREF_EDIT_PANEL_KEY_PANEL part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and 70% of its width. The swallow is located just to the right from the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pref_edit_panel_key_panel_label text part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: PART_PREF_EDIT_PANEL_KEY_PANEL_ENTRY; // &quot;pref_edit_panel_key_panel_entry&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: SWALLOW;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ----------=============== VALUE INPUT PANEL ===============----------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The layout of the PART_PREF_EDIT_PANEL_VALUE_PANEL part is exactly the same
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as the layout of the PART_PREF_EDIT_PANEL_KEY_PANEL part. The only exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is that its vertical location is set to the 33% of PART_PREF_EDIT_PANEL_BACKGROUND height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For this reason, the source code is not listed here

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ----------=============== TYPE INPUT PANEL ===============----------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The layout of the PART_PREF_EDIT_PANEL_TYPE_PANEL part is exactly the same
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as the layout of the PART_PREF_EDIT_PANEL_KEY_PANEL part. There are only 2 exceptions:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1. Its height is set to 34% of the PART_PREF_EDIT_PANEL_BACKGROUND height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2. Its vertical location is set to the 66% of PART_PREF_EDIT_PANEL_BACKGROUND height
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// For this reason, the source code is not listed here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>
    </td>
    <td>
      <p align="center"><img alt="Input layouts" src="../images/preference_ui_structure_edje_input_sd.png" /></p>
    </td>
  </tr>
</table>


<p>Based on the layout defined with EDJE scripts, the application interface is created with the <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function, which takes 1 parameter (a pointer to the structure containing the view data). In succeeding calls to the <span style="font-family: Courier New,Courier,monospace">*_layout_create()</span> functions, the user interface is created.</p>
<pre class="prettyprint">
bool
view_create_base_gui(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;viewdata = vd;

&nbsp;&nbsp;&nbsp;if (!main_layout_create(vd)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!pref_edit_panel_layout_create(vd)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!pref_buttons_panel_layout_create(vd)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!pref_list_panel_layout_create(vd)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;eext_object_event_callback_add(vd-&gt;main_layout, EEXT_CALLBACK_BACK, layout_back_cb, vd);

&nbsp;&nbsp;&nbsp;evas_object_show(vd-&gt;win);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>The following table defines the base view creation details.</p>
<table>
   <caption>
     Table: Base view creation code snippets and figures
   </caption> 
  <col width="25%"/>
  <col width="50%"/>
  <col width="25%"/>
      <tr> 
	  <th>Description</th> 
     <th>Code snippet</th> 
     <th>Figure</th> 
    </tr> 
  <tr>
    <td>
	  <span style="font-family: Courier New,Courier,monospace">main_layout_create()</span>:
<p>The main view is created by loading the <span style="font-family: Courier New,Courier,monospace">main</span> group from the EDJE layout (<span style="font-family: Courier New,Courier,monospace">preference.edj</span> file). The group is embedded to the <span style="font-family: Courier New,Courier,monospace">elm_layout</span> container, which is inserted into the <span style="font-family: Courier New,Courier,monospace">elm_conformant</span> component.</p>
	</td>
	<td>
	  <pre class="prettyprint">
static bool
main_layout_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;win = window_create();

&nbsp;&nbsp;&nbsp;vd-&gt;conform = conformant_create(vd-&gt;win);

&nbsp;&nbsp;&nbsp;vd-&gt;main_layout = layout_create(vd-&gt;conform, EDJ_FILE_NAME_MAIN, GROUP_MAIN, NULL);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
	</td>
	<td>
	  <p align="center"><img alt="Main view" src="../images/preference_ui_view_main_sd.png" /></p>
	</td>
  </tr>

  <tr>
    <td>
	  <span style="font-family: Courier New,Courier,monospace">pref_edit_panel_layout_create()</span>:
<p>The edit subview is created by loading the <span style="font-family: Courier New,Courier,monospace">pref_edit_panel</span> group from the EDJE layout (<span style="font-family: Courier New,Courier,monospace">pref_edit_panel.edc</span> file). It is embedded to the <span style="font-family: Courier New,Courier,monospace">elm_layout</span> container, which is inserted into the <span style="font-family: Courier New,Courier,monospace">main_panel_pref_edit_panel</span> swallow of the <span style="font-family: Courier New,Courier,monospace">main</span> layout.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">preference_type_selected_cb()</span> callback function is assigned to each of the selector items. This function is invoked on the <span style="font-family: Courier New,Courier,monospace">selected</span> event of the <span style="font-family: Courier New,Courier,monospace">elm_hoversel</span> item.</p>
	</td>
	<td>
	  <pre class="prettyprint">
static bool
pref_edit_panel_layout_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;pref_edit_panel_layout = layout_create(vd-&gt;main_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDJ_FILE_NAME_PREF_EDIT_PANEL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GROUP_PREF_EDIT_PANEL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_MAIN_PREF_EDIT_PANEL);

&nbsp;&nbsp;&nbsp;vd-&gt;pref_edit_panel_key_entry = entry_create(vd-&gt;pref_edit_panel_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_PREF_EDIT_PANEL_KEY_PANEL_ENTRY);

&nbsp;&nbsp;&nbsp;vd-&gt;pref_edit_panel_value_entry = entry_create(vd-&gt;pref_edit_panel_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_PREF_EDIT_PANEL_VALUE_PANEL_ENTRY);

&nbsp;&nbsp;&nbsp;vd-&gt;pref_edit_panel_type_selector = hoversel_create(vd-&gt;pref_edit_panel_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_PREF_EDIT_PANEL_TYPE_PANEL_ENTRY);

&nbsp;&nbsp;&nbsp;// Type names are added to the elm_hoversel component. On item selection,
&nbsp;&nbsp;&nbsp;// the preference_type_selected_cb callback function will be invoked with
&nbsp;&nbsp;&nbsp;// the pointer to the item of the statically defined array of type names.
&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; PREF_MAX; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_hoversel_item_add(vd-&gt;pref_edit_panel_type_selector,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preftypes[i].caption,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_ICON_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preference_type_selected_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)&amp;preftypes[i]);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
	</td>
	<td>
	  <p align="center"><img alt="Edit panel view" src="../images/preference_ui_view_input_sd.png" /></p>
	</td>
  </tr>

  <tr>
    <td>
	  <span style="font-family: Courier New,Courier,monospace">pref_buttons_panel_layout_create()</span>:
<p>The button subview is created by loading the <span style="font-family: Courier New,Courier,monospace">pref_buttons_panel</span> group from the EDJE layout (<span style="font-family: Courier New,Courier,monospace">pref_buttons_panel.edc</span> file). It is embedded to the <span style="font-family: Courier New,Courier,monospace">elm_layout</span> container, which is inserted into the <span style="font-family: Courier New,Courier,monospace">main_panel_pref_buttons_panel</span> swallow of the <span style="font-family: Courier New,Courier,monospace">main</span> layout.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">remove_all_click_cb()</span> callback function is assigned to the left button. This function is invoked on the left button <span style="font-family: Courier New,Courier,monospace">clicked</span> event. The <span style="font-family: Courier New,Courier,monospace">update_click_cb()</span> callback function is assigned to the right button. This function is invoked on the right button <span style="font-family: Courier New,Courier,monospace">clicked</span> event. For the implementation details, see <a href="#add_remove">Adding and Removing Properties</a>.</p>
	</td>
	<td>
	  <pre class="prettyprint">
static bool
pref_buttons_panel_layout_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;pref_buttons_panel_layout = layout_create(vd-&gt;main_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDJ_FILE_NAME_PREF_BUTTONS_PANEL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GROUP_PREF_BUTTONS_PANEL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_MAIN_PREF_BUTTONS_PANEL);

&nbsp;&nbsp;&nbsp;vd-&gt;pref_buttons_panel_left_button = button_create(vd-&gt;pref_buttons_panel_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_PREF_BUTTONS_PANEL_LEFT_BUTTON,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REMOVE_ALL_PREFS_CAPTION,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove_all_click_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);

&nbsp;&nbsp;&nbsp;vd-&gt;pref_buttons_panel_right_button = button_create(vd-&gt;pref_buttons_panel_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_PREF_BUTTONS_PANEL_RIGHT_BUTTON,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UPDATE_PREF_CAPTION,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update_click_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)vd);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
	</td>
	<td>
	  <p align="center"><img alt="Button view" src="../images/preference_ui_view_buttons_sd.png" /></p>
	</td>
  </tr>

  <tr>
    <td>
	  <span style="font-family: Courier New,Courier,monospace">pref_list_panel_layout_create()</span>:
<p>The list subview does not have any EDJE layout. Simply, the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> component is embedded into the <span style="font-family: Courier New,Courier,monospace">main_panel_pref_list_panel</span> swallow of the <span style="font-family: Courier New,Courier,monospace">main</span> layout.</p>

<p>Items are added to the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> component on the application model creation. For this purpose, the <span style="font-family: Courier New,Courier,monospace">view_genlist_item_update()</span> function is used.</p>
	</td>
	<td>
	  <pre class="prettyprint">
static bool
pref_list_panel_layout_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;pref_list_panel_list = genlist_create(vd-&gt;main_layout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_MAIN_PREF_LIST_PANEL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)vd);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
	</td>
	<td>
	  <p align="center"><img alt="List view" src="../images/preference_ui_view_list_sd.png" /></p>
	</td>
  </tr>
</table>

<p>To add items to the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> component, the <span style="font-family: Courier New,Courier,monospace">view_genlist_item_update()</span> function takes 1 pointer parameter to the
<span style="font-family: Courier New,Courier,monospace">key_value_t</span> structure type (for details, see <a href="#types">Type Definitions</a>). It contains the name of the preference key, and its value together with its type.</p>
<p>Based on the key name, the <span style="font-family: Courier New,Courier,monospace">genlist_item_find()</span> function looks for an item in the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> utilizing a temporary list that references the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> items (see <span style="font-family: Courier New,Courier,monospace">viewdata_s.genlist_items</span> in <a href="#types">Type Definitions</a>). If the item is found successfully:</p>
<ol>
  <li>The data pointer bound to the item is obtained with the <span style="font-family: Courier New,Courier,monospace">elm_object_item_data_get()</span> function and disposed with the <span style="font-family: Courier New,Courier,monospace">controller_key_value_remove()</span> function.</li>
  <li>In place of the disposed data, a new data is bound (<span style="font-family: Courier New,Courier,monospace">elm_object_item_data_set()</span>) to the item.</li>
  <li>The entire <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> is finally updated with the <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_updated()</span> function.</li>
</ol>

<p>If the item is not found, a new preference is created by adding it to the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> using the <span style="font-family: Courier New,Courier,monospace">view_genlist_item_add()</span> function.</p>

<pre class="prettyprint">
bool
view_genlist_item_update(key_value_t *key_value)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *item = NULL;

&nbsp;&nbsp;&nbsp;// If an item with given key name already exists in the elm_genlist
&nbsp;&nbsp;&nbsp;if (genlist_item_find(key_value-&gt;key, &amp;item)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Data pointer assigned to the item is retrieved
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key_value_t *item_key_value = elm_object_item_data_get(item);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and removed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_key_value_remove(item_key_value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// New data pointer is assigned to the elm_genlist item
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This data describes the preference (key name, value, and value type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_item_data_set(item, (void*)key_value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Updating the list view
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_genlist_item_update(item);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// If an item with given key name does not exist in the elm_genlist,
&nbsp;&nbsp;&nbsp;// a new item is added together with the data describing related
&nbsp;&nbsp;&nbsp;// preference (key name, value, and value type)
&nbsp;&nbsp;&nbsp;return view_genlist_item_add(key_value);
}
</pre>
<pre class="prettyprint">
static bool
genlist_item_find(const char *key, Elm_Object_Item **item)
{
&nbsp;&nbsp;&nbsp;key_value_t *kv = NULL;
&nbsp;&nbsp;&nbsp;Eina_List *l;

&nbsp;&nbsp;&nbsp;// Itemization of all items and looking for an item with
&nbsp;&nbsp;&nbsp;// matching preference key name
&nbsp;&nbsp;&nbsp;EINA_LIST_FOREACH(viewdata-&gt;genlist_items, l, *item) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Obtain the pointer to the data bound to the item
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kv = elm_object_item_data_get(*item);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check whether item key name matches the key being searched
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The function below performs case-insensitive strings comparison
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (controller_same_string_check(kv-&gt;key, (char*)key)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return false;
}
</pre>
<pre class="prettyprint">
bool
view_genlist_item_add(key_value_t *key_value)
{
&nbsp;&nbsp;&nbsp;// Creating new elm_genlist item
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *itc = elm_genlist_item_class_new();

&nbsp;&nbsp;&nbsp;itc-&gt;item_style = &quot;double_label&quot;;// Item style (2 text labels and content swallow)
&nbsp;&nbsp;&nbsp;itc-&gt;func.text_get = genlist_item_label_get; // Function setting the item text
&nbsp;&nbsp;&nbsp;itc-&gt;func.content_get = genlist_item_content_get; // Function setting the item swallow content
&nbsp;&nbsp;&nbsp;itc-&gt;func.state_get = NULL;
&nbsp;&nbsp;&nbsp;itc-&gt;func.del = genlist_item_del; // Function disposing an item

&nbsp;&nbsp;&nbsp;// Item is appended to the elm_genlist
&nbsp;&nbsp;&nbsp;Elm_Object_Item *item = elm_genlist_item_append(viewdata-&gt;pref_list_panel_list, itc, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)key_value, NULL, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE, NULL, NULL);

&nbsp;&nbsp;&nbsp;// Created item is stored in temporary list for easier access
&nbsp;&nbsp;&nbsp;viewdata-&gt;genlist_items = eina_list_append(viewdata-&gt;genlist_items, item);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>The following code snippet shows the procedure for setting the item text labels and swallow content:</p>
<pre class="prettyprint">
static char*
genlist_item_label_get(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;key_value_t *key_val = (key_value_t*)data;

&nbsp;&nbsp;&nbsp;// Populating 2 buffers (buff_main and buff_sub) with string content
&nbsp;&nbsp;&nbsp;// based on key_val:
&nbsp;&nbsp;&nbsp;//    - buff_main - preference key name and its value is assigned in the form
&nbsp;&nbsp;&nbsp;//      of &quot;key_name = value&quot; string. The value is obtained from key_val-&gt;value
&nbsp;&nbsp;&nbsp;//      of void* type by typecasting using key_val-&gt;value_type for types
&nbsp;&nbsp;&nbsp;//      distinguishing
&nbsp;&nbsp;&nbsp;//    - buff_sub - preference value type is assigned in the string format:
&nbsp;&nbsp;&nbsp;//      &quot;type: INTEGER || DOUBLE || BOOLEAN || STRING&quot; based on key_val-&gt;value_type

&nbsp;&nbsp;&nbsp;if (controller_same_string_check((char*)part, &quot;elm.text&quot;)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buff_main);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (controller_same_string_check((char*)part, &quot;elm.text.sub&quot;)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buff_sub);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return NULL;
}

static Evas_Object*
genlist_item_content_get(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;// This function creates an elm_image component with predefined visual content
&nbsp;&nbsp;&nbsp;if (!strcmp(part, "elm.swallow.icon")) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *image = elm_image_add(obj);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *file_path = image_file_path_get(ICON_DELETE_FILE_NAME);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!elm_image_file_set(image, file_path, NULL)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The callback function is assigned to the elm_image component and is fired
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for &quot;clicked&quot; event
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(image, &quot;clicked&quot;, genlist_item_image_clicked_cb, data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return image;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return NULL;
}
</pre>

<p>Each item added to the elm_genlist has a delete button assigned in the form of the <span style="font-family: Courier New,Courier,monospace">elm_image</span> component with a predefined <strong>X</strong> image. In the code snippet above, the <span style="font-family: Courier New,Courier,monospace">genlist_item_image_clicked_cb()</span> callback function is assigned to each created <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> item. This function is responsible for the chosen item and related preference deletion. Form more details, see the following code snippet and <a href="#controller">Controller Implementation</a>.</p>
<pre class="prettyprint">
static void
genlist_item_image_clicked_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;key_value_t *key_val = (key_value_t*)data;

&nbsp;&nbsp;&nbsp;// Preference removal from the database
&nbsp;&nbsp;&nbsp;if (controller_preference_remove(key_val-&gt;key)) 
&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elm_Object_Item *item = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If an item with given key name exists on the genlist,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// it is removed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (genlist_item_find(key_val-&gt;key, &amp;item)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_item_del(item);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h3 id="add_remove" name="add_remove">Adding and Removing Properties</h3>
<p>The procedure for adding and removing properties is <a href="#view_imp">triggered from the UI</a> as a result of invoking a callback function for the button &quot;clicked&quot; event:</p>

<ul>
  <li>
  <span style="font-family: Courier New,Courier,monospace">update_click_cb()</span>
<p>If all the data (key name, value, and value type) is provided correctly and the key name does not exist in the preference database, a new preference is created. Otherwise, the preference with the existing key name is updated. Finally, all the changes are reflected in the UI.</p>
  <pre class="prettyprint">
static void
update_click_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;// Preference key name, value, and value type is obtained from the UI components

&nbsp;&nbsp;&nbsp;// Newly defined preference is added to the list of user-defined preferences (PROPERTY_ITEMS_ENUM_KEY).
&nbsp;&nbsp;&nbsp;// If the preference already exists in the PROPERTY_ITEMS_ENUM_KEY, only the value and data type
&nbsp;&nbsp;&nbsp;// are updated
&nbsp;&nbsp;&nbsp;controller_property_items_enum_item_add(key, type);

&nbsp;&nbsp;&nbsp;// The defined preference is stored in preferences database. The &quot;value&quot;
&nbsp;&nbsp;&nbsp;// parameter is passed to the controller_preference_set() function
&nbsp;&nbsp;&nbsp;// as a char pointer (string from the elm_entry component)
&nbsp;&nbsp;&nbsp;if (controller_preference_set(key, value, type)) 
&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the preference was successfully added, its value is obtained again
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to convert the value to the proper data type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (controller_preference_get(key, type, &amp;key_value)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Updating the elm_genlist component
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_genlist_item_update(kv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;free(key);
}
</pre>
<p>For the implementation details of the <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_add()</span>, <span style="font-family: Courier New,Courier,monospace">controller_preference_set()</span>, and <span style="font-family: Courier New,Courier,monospace">controller_preference_get()</span> functions, see <a href="#controller">Controller Implementation</a>. For the implementation details of the <span style="font-family: Courier New,Courier,monospace">view_genlist_item_update()</span> function, see <a href="#view_imp">View Implementation</a>.</p>
  </li>
  <li>
  <span style="font-family: Courier New,Courier,monospace">remove_all_click_cb()</span>
<p>All the preferences are removed with 1 operation.</p>
  <pre class="prettyprint">
static void
remove_all_click_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;if (!model_preferences_remove()) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;elm_genlist_clear(viewdata-&gt;pref_list_panel_list);
}
</pre>
  </li>
</ul>

<h3>Model Implementation</h3>

<p>The responsibility of the application model module is to operate directly on the Preference API and related data. The additional benefit of this module is the simplification of the API function calling: the error checking and message logging is performed here.</p>

<p>There are several functions with a general signature in the form of a setter and a getter:</p>
<ul>
  <li><span style="font-family: Courier New,Courier,monospace">bool model_preference_<strong>#type#</strong>_set(const char *key, <strong>#type#</strong> value)</span></li>
  <li><span style="font-family: Courier New,Courier,monospace">bool model_preference_<strong>#type#</strong>_get(const char *key, <strong>#type#</strong> *value)</span></li>
</ul>
<p>Where <strong>#type#</strong> is 1 of the following data types: int, double, bool, or char*. The generalized implementation of these functions is shown below.</p>
<pre class="prettyprint">
bool
model_preference_<strong>#type#</strong>_set(const char *key, <strong>#type#</strong> value)
{
&nbsp;&nbsp;&nbsp;int ret = preference_set_<strong>#type#</strong>(key, value);
&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function preference_set_<strong>#type#</strong>() failed with error %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}

bool
model_preference_<strong>#type#</strong>_get(const char *key, <strong>#type#</strong> *value)
{
&nbsp;&nbsp;&nbsp;int ret = preference_get_<strong>#type#</strong>(key, value);
&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function preference_get_<strong>#type#</strong>() failed with error %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>The preferences deletion can be performed as a single or batch operation using the following functions:</p>
<ul>
  <li><span style="font-family: Courier New,Courier,monospace">bool model_preference_remove(const char *key)</span></li>
  <li><span style="font-family: Courier New,Courier,monospace">bool model_preferences_remove(void)</span></li>
</ul>

<p>The implementation of the 2 functions is very similar and differs only by the API function used. In the first case, the
<span style="font-family: Courier New,Courier,monospace">preference_remove()</span> function is used, while the second one is based on the <span style="font-family: Courier New,Courier,monospace">preference_remove_all()</span> function call. The implementation structure is the same as listed above except for the API function used.</p>

<p>The last feature provided by the application model is the validation of the preference existence. This can be performed with
the <span style="font-family: Courier New,Courier,monospace">model_preference_exists_check()</span> function. The implementation structure is the same as listed above except for the API function used.</p>

<h3 id="controller" name="controller">Controller Implementation</h3>

<p>The Controller module is responsible for sharing the functionality of the Model with the View module. Some additional logic is executed within the Controller to perform model-related operations and deliver the results to the application view.</p>

<p>During the application initialization and preference adding and updating procedure, the <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_add()</span> and <span style="font-family: Courier New,Courier,monospace">controller_property_items_enum_item_get()</span> functions are used. They are used to control the process of the <span style="font-family: Courier New,Courier,monospace">key_name:value_type</span> tuple storage and retrieval.</p>
<pre class="prettyprint">
bool
controller_property_items_enum_item_add(const char *key_name, pref_value_type_t value_type)
{
&nbsp;&nbsp;&nbsp;bool key_exists = model_preference_exists_check(PROPERTY_ITEMS_ENUM_KEY);
&nbsp;&nbsp;&nbsp;char *items_enum_value = NULL;

&nbsp;&nbsp;&nbsp;if (key_exists) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_preference_string_get(PROPERTY_ITEMS_ENUM_KEY, &amp;items_enum_value)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;char *items_enum_new = NULL;
&nbsp;&nbsp;&nbsp;bool ret = property_items_enum_key_type_compose(items_enum_value, key_name, value_type, &amp;items_enum_new);

&nbsp;&nbsp;&nbsp;if (!model_preference_string_set(PROPERTY_ITEMS_ENUM_KEY, items_enum_new)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(items_enum_new);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;free(items_enum_new);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>First of all, the existence of the <span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span> property is verified and its value is obtained, if it exists. The <span style="font-family: Courier New,Courier,monospace">property_items_enum_key_type_compose()</span> function call performs the merge operation with the <span style="font-family: Courier New,Courier,monospace">key_name:value_type</span> tuple (function parameters) to the obtained value of
<span style="font-family: Courier New,Courier,monospace">PROPERTY_ITEMS_ENUM_KEY</span>. The implementation of the <span style="font-family: Courier New,Courier,monospace">property_items_enum_key_type_compose()</span> function is simple, so it is not listed here. The final string is stored using the <span style="font-family: Courier New,Courier,monospace">model_preference_string_set()</span> function.</p>

<p>There are also 2 helper functions used in the Controller module:</p>
<ul>
  <li>
  <span style="font-family: Courier New,Courier,monospace">controller_preference_set()</span> sets the preference in the database with respect to its datatype:
  <pre class="prettyprint">
bool
controller_preference_set(const char *key, const char *value, pref_value_type_t type)
{
&nbsp;&nbsp;&nbsp;int int_value = 0;

&nbsp;&nbsp;&nbsp;switch (type) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_INTEGER:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Conversion from string value to the data type specified
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by the &quot;type&quot; and setting the preference
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (string_to_int(value, &amp;int_value)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = model_preference_int_set(key, int_value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_DOUBLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_BOOL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_STRING:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
  </li>
  <li>
  <span style="font-family: Courier New,Courier,monospace">controller_preference_get()</span> gets the preference with a given key from the database:
  <pre class="prettyprint">
bool
controller_preference_get(const char *key, pref_value_type_t type, void **value)
{
&nbsp;&nbsp;&nbsp;int int_value = 0, size_val = 0;

&nbsp;&nbsp;&nbsp;void *ptr_val = NULL;

&nbsp;&nbsp;&nbsp;switch (type) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_INTEGER:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Obtain the preference value for the given key name. Returned value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is typecasted to the void pointer for unification. Get the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// size of the variable required for the storage in a memory
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = model_preference_int_get(key, &amp;int_value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr_val = (void*)&amp;int_value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_val = sizeof(int);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_DOUBLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_BOOL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PREF_STRING:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The same approach as for PREF_INTEGER is used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (size_val &gt; 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Obtained value of the preference is returned as a void pointer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// stored in designated memory area for further usage
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*value = (void*)malloc(size_val);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(*value, ptr_val, size_val);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
  </li>
</ul>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Event Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
  <div id="profile">
    <p><img alt="Mobile native" src="../images/mn_icon.png"/></p>
  </div>

  <h1>Event Sample Overview</h1>

  <p>
  The Tizen API's Event module provides a set of functions enabling listeners creation for specified system and custom events. In order to receive a custom event via created listener, one must be created
  and published. This sample application gives an example of custom events creation and publishing as well as the listening for both types of events.
  </p>
  <p>The figure below illustrates the view of the application.</p>
  <p id="app-screenshot" class="figure">Figure: Event application screens.</p>
  <p style="text-align:center;">
    <img alt="System events view" height="364" hspace="20" src="../images/event_system_events_view_sd_mn.png" />
	<img alt="Custom events view" height="364" hspace="20" src="../images/event_custom_events_view_sd_mn.png" />
	<img alt="Received custom event view" height="364" hspace="20" src="../images/event_custom_events_received_view_sd_mn.png" />
  </p>

  <p>The sample application provides a user interface for previewing available events and their status:
  <ul>
    <li>system events:
      <ul>
	    <li>battery level and charger status,</li>
	    <li>USB and earjack status,</li>
	    <li>display state and auto-rotation mode,</li>
	    <li>system boot and shutdown status,</li>
	    <li>memory status,</li>
	    <li>Wi-Fi, Bluetooth, mobile data and roaming state,</li>
		<li>location, GPS and NPS state,</li>
		<li>incoming message status,</li>
		<li>time, zone and hour format change,</li>
		<li>language and region format change,</li>
		<li>silent and vibration mode change,</li>
		<li>font change;</li>
      </ul>
	</li>
	<li>custom events:
	  <ul>
	    <li>custom events are received once they are registered and published by the user via "Custom events" tab.</li>
	  </ul>
	</li>
  </ul>
  The structure of the user interface is depicted below (EDJE layout scripts are used).
  </p>
  <p id="ui-main-struct" class="figure">Figure: Event main layout structure.</p>
  <p style="text-align:center;">
    <img alt="Event main layout structure" hspace="80" height="400" src="../images/event_ui_layout_1_sd_mn.png" />
  </p>
  <p>
  The <span style="font-family: Courier New,Courier,monospace">PART_MAIN_CONTENT</span> swallow is used as a container for any of the below layouts.
  </p>
  <p id="ui-tabs-struct" class="figure">Figure: Event tabs layout structure.</p>
  <p style="text-align:center;">
    <img alt="Event tabs layout structure" hspace="80" height="400" src="../images/event_ui_layout_2_sd_mn.png" />
  </p>
  <p>
  The final application's view is created by embedding proper widgets into the layouts depicted above. The resulting UI views are shown below.
  </p>
  <p id="ui-view" class="figure">Figure: Event application's UI view.</p>
  <p style="text-align:center;">
    <img alt="Event application's UI view" hspace="80" height="450" src="../images/event_ui_tabs_view_sd_mn.png" />
  </p>
  <br>
  The application's workflow can be divided into three logical pipelines:
  <ul>
    <li>application startup,</li>
	<li>system events handling,</li>
	<li>custom event creation, publishing and receiving,</li>
  </ul>
  which can be described by the following figure:
  </p>
  <p id="workflow" class="figure">Figure: Event application workflow.</p>
  <p style="text-align:center;">
    <img alt="Application workflow" height="450" hspace="0" src="../images/event_workflow_sd_mn.png"/>
  </p>

  <h3>Prerequisites</h3>
  <p>
  To ensure proper application execution, the following privileges must be set:
    <ul>
      <li>http://tizen.org/privilege/network.get,</li>
      <li>http://tizen.org/privilege/message.read,</li>
      <li>http://tizen.org/privilege/display.</li>
	</ul>
  </p>

<h2>Implementation</h2>

<h3 id="type-defs">Type definitions</h3>

<pre class="prettyprint">
/* The general structure for application's data storage. */
struct __appdata {
&nbsp;&nbsp;&nbsp;viewdata_s view;
};
</pre>

<pre class="prettyprint">
/* All the Evas_Object objects represent UI widgets. */
struct __viewdata {
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *conform;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_main_panel;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar_item_system_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar_item_custom_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_system_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *system_ev_list;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_custom_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_name;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_submit;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_list;
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *custom_ev_itc;
&nbsp;&nbsp;&nbsp;/* The structure of callbacks handlers used by the Controller module to establish interaction with the Model module. */
&nbsp;&nbsp;&nbsp;viewcallbacks_s callbacks;
};

typedef struct __viewdata viewdata_s;
</pre>

<pre class="prettyprint">
/* All the callbacks handlers are hooked by the Controller module in order to relate the control flow between the View and the Model modules. */
struct __viewcallbacks {
&nbsp;&nbsp;&nbsp;/* The callback handler is invoked when the custom event needs to be published. */
&nbsp;&nbsp;&nbsp;event_do_publish_cb do_publish_cb;
&nbsp;&nbsp;&nbsp;/* The callback handler is invoked at the initialization phase to obtain all the information about system events for UI generation purpose. */
&nbsp;&nbsp;&nbsp;event_get_system_info_cb get_system_info_cb;
&nbsp;&nbsp;&nbsp;/* The callback handler is invoked when the user requests to register the custom event handler. */
&nbsp;&nbsp;&nbsp;event_set_custom_info_cb set_custom_info_cb;
};

typedef struct __viewcallbacks viewcallbacks_s;
</pre>

<pre class="prettyprint">
/* The definition of callbacks handlers declared in the viewcallbacks_s structure. */
&nbsp;&nbsp;&nbsp;typedef void (* event_do_publish_cb)(const char *event_name);
&nbsp;&nbsp;&nbsp;typedef bool (* event_get_system_info_cb)(int index, void **ev_info);
&nbsp;&nbsp;&nbsp;typedef bool (* event_set_custom_info_cb)(const char *event_name, void **ev_info);
</pre>

<pre class="prettyprint">
/* The structure keeps all the event related information. */
struct __system_ev_info {
&nbsp;&nbsp;&nbsp;/* The type of the event - used only for the system events specification.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The type is defined as an enum whose values represents all available system events. */
&nbsp;&nbsp;&nbsp;event_type_t type;
&nbsp;&nbsp;&nbsp;/* The name of the event. */
&nbsp;&nbsp;&nbsp;char *name;
&nbsp;&nbsp;&nbsp;/* The readable description of the event. */
&nbsp;&nbsp;&nbsp;char *desc;
&nbsp;&nbsp;&nbsp;/* The status of the event. */
&nbsp;&nbsp;&nbsp;char *status_1;
&nbsp;&nbsp;&nbsp;/* The status of the event. Used if the event contains up to two different status information:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Incoming message type / id; */
&nbsp;&nbsp;&nbsp;char *status_2;
&nbsp;&nbsp;&nbsp;/* The status of the event. Used if the event contains up to three different status information:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Bluetooth state / LE state / transferring state; */
&nbsp;&nbsp;&nbsp;char *status_3;
&nbsp;&nbsp;&nbsp;/* Event's callback handler function. */
&nbsp;&nbsp;&nbsp;event_handler_h event_h;
};

typedef struct __system_ev_info system_ev_info_s;
typedef struct __system_ev_info custom_ev_info_s;
</pre>

<pre class="prettyprint">
/* Types of system events defined for source code simplification.
&nbsp;&nbsp;&nbsp;This type definition introduces event's name mapping to its numerical representation. */
typedef enum {
&nbsp;&nbsp;&nbsp;ET_BATTERY_CHARGER_STATUS,  /* SYSTEM_EVENT_BATTERY_CHARGER_STATUS */
&nbsp;&nbsp;&nbsp;ET_BATTERY_LEVEL_STATUS,    /* SYSTEM_EVENT_BATTERY_LEVEL_STATUS */
&nbsp;&nbsp;&nbsp;ET_USB_STATUS,              /* SYSTEM_EVENT_USB_STATUS */
&nbsp;&nbsp;&nbsp;ET_EARJACK_STATUS,          /* SYSTEM_EVENT_EARJACK_STATUS */
&nbsp;&nbsp;&nbsp;ET_DISPLAY_STATE,           /* SYSTEM_EVENT_DISPLAY_STATE */
&nbsp;&nbsp;&nbsp;ET_BOOT_COMPLETED,          /* SYSTEM_EVENT_BOOT_COMPLETED */
&nbsp;&nbsp;&nbsp;ET_SYSTEM_SHUTDOWN,         /* SYSTEM_EVENT_SYSTEM_SHUTDOWN */
&nbsp;&nbsp;&nbsp;ET_LOW_MEMORY,              /* SYSTEM_EVENT_LOW_MEMORY */
&nbsp;&nbsp;&nbsp;ET_WIFI_STATE,              /* SYSTEM_EVENT_WIFI_STATE */
&nbsp;&nbsp;&nbsp;ET_BT_STATE,                /* SYSTEM_EVENT_BT_STATE */
&nbsp;&nbsp;&nbsp;ET_LOCATION_ENABLE_STATE,   /* SYSTEM_EVENT_LOCATION_ENABLE_STATE */
&nbsp;&nbsp;&nbsp;ET_GPS_ENABLE_STATE,        /* SYSTEM_EVENT_GPS_ENABLE_STATE */
&nbsp;&nbsp;&nbsp;ET_NPS_ENABLE_STATE,        /* SYSTEM_EVENT_NPS_ENABLE_STATE */
&nbsp;&nbsp;&nbsp;ET_INCOMMING_MSG,           /* SYSTEM_EVENT_INCOMMING_MSG */
&nbsp;&nbsp;&nbsp;ET_TIME_CHANGED,            /* SYSTEM_EVENT_TIME_CHANGED */
&nbsp;&nbsp;&nbsp;ET_TIME_ZONE,               /* SYSTEM_EVENT_TIME_ZONE */
&nbsp;&nbsp;&nbsp;ET_HOUR_FORMAT,             /* SYSTEM_EVENT_HOUR_FORMAT */
&nbsp;&nbsp;&nbsp;ET_LANGUAGE_SET,            /* SYSTEM_EVENT_LANGUAGE_SET */
&nbsp;&nbsp;&nbsp;ET_REGION_FORMAT,           /*SYSTEM_EVENT_REGION_FORMAT  */
&nbsp;&nbsp;&nbsp;ET_SILENT_MODE,             /* SYSTEM_EVENT_SILENT_MODE */
&nbsp;&nbsp;&nbsp;ET_VIBRATION_STATE,         /* SYSTEM_EVENT_VIBRATION_STATE */
&nbsp;&nbsp;&nbsp;ET_SCREEN_AUTOROTATE_STATE, /* SYSTEM_EVENT_SCREEN_AUTOROTATE_STATE */
&nbsp;&nbsp;&nbsp;ET_MOBILE_DATA_STATE,       /* SYSTEM_EVENT_MOBILE_DATA_STATE */
&nbsp;&nbsp;&nbsp;ET_DATA_ROAMING_STATE,      /* SYSTEM_EVENT_DATA_ROAMING_STATE */
&nbsp;&nbsp;&nbsp;ET_FONT_SET                 /* SYSTEM_EVENT_FONT_SET */
} event_type_t;
</pre>

   <p>
   The Model module declares two arrays:
     <ul>
	   <li><span style="font-family: Courier New,Courier,monospace">static system_ev_info_s __system_ev[__SYSTEM_EVENT_COUNT_MAX];</span></li>
	   <li><span style="font-family: Courier New,Courier,monospace">static custom_ev_info_s __custom_ev[__CUSTOM_EVENT_COUNT_MAX];</span></li>
	  </ul>
	which are used to store system and custom events information, respectively. The <span style="font-family: Courier New,Courier,monospace">__SYSTEM_EVENT_COUNT_MAX</span> and
	<span style="font-family: Courier New,Courier,monospace">__CUSTOM_EVENT_COUNT_MAX</span> values are both set to 25 as an upperbound limit.
   </p>

<h3 id="app-init">Application initialization</h3>

   <p>
  The entire application's life-cycle is implemented in the main source file, using a common Tizen application structure:
  </p>

<pre class="prettyprint">
int main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;appdata_s ad = {{0,},};
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback;
&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL, };

&nbsp;&nbsp;&nbsp;event_callback.create = __create_app;
&nbsp;&nbsp;&nbsp;event_callback.terminate = __terminate_app;
&nbsp;&nbsp;&nbsp;event_callback.pause = __pause_app;
&nbsp;&nbsp;&nbsp;event_callback.resume = __resume_app;
&nbsp;&nbsp;&nbsp;event_callback.app_control = __control_app;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, __ui_app_low_battery, &ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, __ui_app_low_memory, &ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, __ui_app_orient_changed, &ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, __ui_app_lang_changed, &ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, __ui_app_region_changed, &ad);

&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &event_callback, &ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function ui_app_main() failed with error = %d", ret);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>

  <p>
  The application's initilization procedure is executed in <span style="font-family: Courier New,Courier,monospace">__create_app()</span> callback function, which is invoked on application's startup.
  </p>

<pre class="prettyprint">
static bool __create_app(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = (appdata_s *)data;

&nbsp;&nbsp;&nbsp;return controller_init(&ad->view);
}
</pre>

  <p>
  Finally, the <span style="font-family: Courier New,Courier,monospace">controller_init()</span> function is invoked, which controls the entire initialization process
  (see the code snippet below for details). This function is responsible for attaching callback functions invoked by the View module in order to perform required tasks:
    <ul>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_do_publish_cb()</span> - publish the custom event registered by the user;</li>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_get_system_info_cb()</span> - query system's event information to populate the list with relevant data;</li>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span> - register event handler to be invoked on custom event occurance.</li>
	</ul>
  The first and the third callback function is called when the user performs appropriate action from the application's UI. The second callback function is called during the application's UI creation.
  The application's UI is afterwards created by the <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function. Its source code is not listed
  within this documentation, as it is not a subject of this document. At the end of the initialization phase, a callback function is attached to each of the available system events within the
  <span style="font-family: Courier New,Courier,monospace">__add_system_event_handlers()</span> function (see the function's listing below).
  </p>
  <p>
  For reference of all model related functions that are not listed here refer to the <a href="#model">Model</a> section.
  </p>

<pre class="prettyprint">
bool controller_init(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd->callbacks.do_publish_cb = __controller_event_do_publish_cb;
&nbsp;&nbsp;&nbsp;vd->callbacks.get_system_info_cb = __controller_event_get_system_info_cb;
&nbsp;&nbsp;&nbsp;vd->callbacks.set_custom_info_cb = __controller_event_set_custom_info_cb;

&nbsp;&nbsp;&nbsp;if (!view_create_base_gui(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;__add_system_event_handlers();

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<pre class="prettyprint">
static void __add_system_event_handlers(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;/* Iteration over all available system events. */
&nbsp;&nbsp;&nbsp;for (i = 0; i < model_get_system_events_count(); i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* System's event information structure is obtained. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_get_system_event_info(i, &ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Event's handler is created and a callback function is attached. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model_add_system_event_handler(ev_info, __system_event_cb, (void *)ev_info);
&nbsp;&nbsp;&nbsp;}
}
</pre>

  <p>
  The implementation of callback functions attached in the <span style="font-family: Courier New,Courier,monospace">controller_init()</span> function is described below.
  </p>

<pre class="prettyprint">
static void __controller_event_do_publish_cb(const char *event_name)
{
&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, "Event publishing: '%s'.", event_name);

&nbsp;&nbsp;&nbsp;model_publish_event(event_name);
}
</pre>

  <p>
  The <span style="font-family: Courier New,Courier,monospace">__controller_event_get_system_info_cb()</span> is invoked by the View module as long as the function returns
  <span style="font-family: Courier New,Courier,monospace">true</span> value. Each time the function is called with incremented <span style="font-family: Courier New,Courier,monospace">index</span>
  value. As a result, the system's event information <span style="font-family: Courier New,Courier,monospace">ev_info</span>, stored at specified
  <span style="font-family: Courier New,Courier,monospace">index</span>, is returned. The requested data structure is obtained with the
  <span style="font-family: Courier New,Courier,monospace">model_get_system_event_info()</span> function.
  </p>

<pre class="prettyprint">
static bool __controller_event_get_system_info_cb(int index, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;if (index >= model_get_system_events_count())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;if (!model_get_system_event_info(index, &ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (system_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  The <span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span> callback function is invoked by the View model when the user requests to register
  custom event. If the registration procedure succeeds (see the <span style="font-family: Courier New,Courier,monospace">__controller_register_custom_event()</span> function's implementation for
  details), the reference to the event's information structure is returned via the <span style="font-family: Courier New,Courier,monospace">ev_info</span> argument.
  </p>

<pre class="prettyprint">
static bool __controller_event_set_custom_info_cb(const char *event_name, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;if (!__controller_register_custom_event(event_name, &ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (custom_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<pre class="prettyprint">
bool __controller_register_custom_event(const char *event_name, custom_ev_info_s **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;
&nbsp;&nbsp;&nbsp;bool name_exists = false;

&nbsp;&nbsp;&nbsp;/* The event's name, assigned by the user, must be unique, so we have to check if it does not exist yet. */
&nbsp;&nbsp;&nbsp;if (!model_check_event_exists(event_name, &name_exists))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;/* If there is already an event registered with the given name, then the function fails. */
&nbsp;&nbsp;&nbsp;if (name_exists) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, "Custom event '%s' already registered.", event_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* Otherwise new event's information structure is created. */
&nbsp;&nbsp;&nbsp;if (!model_create_custom_event_info(event_name, ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;/* Finally, the event's callback function is assigned, to be invoked when the event occurs. */
&nbsp;&nbsp;&nbsp;if (!model_add_custom_event_handler(*ev_info, __custom_event_cb, (void *)(*ev_info)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, "Custom event registered: '%s'.", (*ev_info)->name);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<h3 id="app-finit">Application termination</h3>

  <p>
  When the application is terminated, the <span style="font-family: Courier New,Courier,monospace">__terminate_app()</span> callback function is called (see the code snippet below).
  </p>

<pre class="prettyprint">
static void __terminate_app(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = (appdata_s *)data;

&nbsp;&nbsp;&nbsp;controller_finit(&ad->view);
}
</pre>

  <p>
  All the resources, allocated previously, are released with <span style="font-family: Courier New,Courier,monospace">controller_finit()</span> function, which is responsible for destroying the UI
  and detaching system and custom events handlers.
  </p>

<pre class="prettyprint">
void controller_finit(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;view_destroy_base_gui(vd);
&nbsp;&nbsp;&nbsp;model_finit();
}
</pre>

  <p>
  As the UI is not a subject for this documentation, the implementation of the <span style="font-family: Courier New,Courier,monospace">view_destroy_base_gui()</span> function is ommited.
  Detaching events handlers is performed in the Model module within the <span style="font-family: Courier New,Courier,monospace">model_finit()</span> function, which calls two internal functions:
  <span style="font-family: Courier New,Courier,monospace">__model_release_system_events()</span> and <span style="font-family: Courier New,Courier,monospace">__model_release_custom_events()</span>.
  </p>

<pre class="prettyprint">
void model_finit(void)
{
&nbsp;&nbsp;&nbsp;__model_release_system_events();
&nbsp;&nbsp;&nbsp;__model_release_custom_events();
}
</pre>

  <p>
  The events handlers detaching procedure relies on <span style="font-family: Courier New,Courier,monospace">__model_remove_event_handler()</span> function (for reference see the
  <a href="#model">Model</a> section) for each attached event handler regardless of its type (system or custom). The related resources are freed with the
  <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span> and
  <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span> functions.
  </p>

<pre class="prettyprint">
static void __model_release_system_events(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i < __SYSTEM_EVENT_COUNT_MAX; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = &__system_ev[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_remove_event_handler(ev_info->event_h);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_free_system_event_info(ev_info);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<pre class="prettyprint">
static void __model_release_custom_events(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i < __custom_ev_count; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = &__custom_ev[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_remove_event_handler(ev_info->event_h);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_free_custom_event_info(ev_info);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;__custom_ev_count = 0;
}
</pre>

  <p>
  The <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span> and
  <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span> functions are not listed here, as their implementation is based only on
  <span style="font-family: Courier New,Courier,monospace">free()</span> function used to free the previously allocated memory.
  </p>

<h3 id="ev-system">System events</h3>

  <p>
  After all the system events are successfully hooked in the initialization phase, one can start to handle them once they occur. This is done with the
  <span style="font-family: Courier New,Courier,monospace">__system_event_cb()</span> callback function registered within the
  <span style="font-family: Courier New,Courier,monospace">__add_system_event_handlers()</span> function (see the <a href="#app-init">Application's initialization</a> for reference).
  </p>

<pre class="prettyprint">
static void __system_event_cb(const char *event_name, bundle *event_data, void *user_data)
{
&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = (system_ev_info_s *)user_data;
&nbsp;&nbsp;&nbsp;char *status_1 = NULL;
&nbsp;&nbsp;&nbsp;char *status_2 = NULL;
&nbsp;&nbsp;&nbsp;char *status_3 = NULL;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, "System event '%s' occured.", event_name);

&nbsp;&nbsp;&nbsp;switch (ev_info->type) {
&nbsp;&nbsp;&nbsp;case ET_<b>#event_type#</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_get_bundle_str(event_data, EVENT_KEY_<b>#name_1#</b>, &status_1) ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!model_get_bundle_str(event_data, EVENT_KEY_<b>#name_2#</b>, &status_2) ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!model_get_bundle_str(event_data, EVENT_KEY_<b>#name_3#</b>, &status_3))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* The status_1 ... status_3 char buffers are copied to the ev_info->status_1 ... ev_info->status_3 */
&nbsp;&nbsp;&nbsp;model_assign_event_status(&ev_info->status_1, status_1);
&nbsp;&nbsp;&nbsp;model_assign_event_status(&ev_info->status_2, status_2);
&nbsp;&nbsp;&nbsp;model_assign_event_status(&ev_info->status_3, status_3);

&nbsp;&nbsp;&nbsp;view_update_system_events();
}
</pre>

  <p>
  All the information carried by the event is stored in a bundle object structure (<span style="font-family: Courier New,Courier,monospace">event_data</span>) followed by the event's name
  (<span style="font-family: Courier New,Courier,monospace">event_name</span>). In order to avoid using inefficient strings comparison function for events distinguishing, the custom
  event's type was introduced (see the <span style="font-family: Courier New,Courier,monospace">event_type_t</span> definition in the <a href="#type-defs">Type definitions</a> section).
  These types are statically preassigned. Based on the value of the <span style="font-family: Courier New,Courier,monospace">type</span> member of the
  <span style="font-family: Courier New,Courier,monospace">ev_info</span> structure of <span style="font-family: Courier New,Courier,monospace">system_ev_info_s</span> data type,
  the events are distinguished and the event state is obtained from the bundle object.
  <br>
  Each event name and relevant bundle keys are defined by the Event API, which are used here to extract event's status. For this purpose, the
  <span style="font-family: Courier New,Courier,monospace">model_get_bundle_str()</span> function is used. For the relation between
  the <span style="font-family: Courier New,Courier,monospace">ET_<b>#event_type#</b></span> and <span style="font-family: Courier New,Courier,monospace">EVENT_KEY_<b>#name_1#</b></span>
  ... <span style="font-family: Courier New,Courier,monospace">EVENT_KEY_<b>#name_3#</b></span>, see the Event API reference.
  <br>
  Once the valid event's status is obtained, the UI is updated to reflect the current events state using the <span style="font-family: Courier New,Courier,monospace">view_update_system_events()</span>
  function.
  </p>

<h3 id="ev-custom">Custom events</h3>

  <p>
  Once the user registers a new event using "Register event" button, the <span style="font-family: Courier New,Courier,monospace">__controller_register_custom_event()</span> function is invoked
  in a <span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span> callback function triggered by the
  <span style="font-family: Courier New,Courier,monospace">__view_register_event_button_clicked_cb()</span> function attached to the "Register event" button. In order to clarify the entire
  procedure, all the mentioned functions are listed below in the order of invocation.
  </p>

<pre class="prettyprint">
/* This callback function is invoked on "Register event" button press. */
static void __view_register_event_button_clicked_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;viewdata_s *vd = (viewdata_s *)data;
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = NULL;
&nbsp;&nbsp;&nbsp;char *event_name = NULL;

&nbsp;&nbsp;&nbsp;/* The event's name input by the user is obtained. */
&nbsp;&nbsp;&nbsp;if (!__view_get_custom_event_name(vd, &event_name)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, "The custom event has no name assigned.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* If the event's name is provided properly, the Controller's callback function is invoked
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in order to register a new event with the given name.*/
&nbsp;&nbsp;&nbsp;bool ret = false;
&nbsp;&nbsp;&nbsp;if (vd->callbacks.set_custom_info_cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vd->callbacks.set_custom_info_cb((const char *)event_name, (void *)&ev_info);

&nbsp;&nbsp;&nbsp;free(event_name);

&nbsp;&nbsp;&nbsp;if (!ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;/* Once the custom event is registered successfully, the UI is updated to reflect recent changes. */
&nbsp;&nbsp;&nbsp;elm_genlist_item_append(__viewdata->custom_ev_list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__viewdata->custom_ev_itc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)ev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__view_custom_event_item_select_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)ev_info);
}
</pre>

<pre class="prettyprint">
/* The callback function invoked within the __view_register_event_button_clicked_cb(). */
static bool __controller_event_set_custom_info_cb(const char *event_name, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;/* Custom event registration is performed here. */
&nbsp;&nbsp;&nbsp;if (!__controller_register_custom_event(event_name, &ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (custom_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<pre class="prettyprint">
bool __controller_register_custom_event(const char *event_name, custom_ev_info_s **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;
&nbsp;&nbsp;&nbsp;bool name_exists = false;

&nbsp;&nbsp;&nbsp;/* Before the custom event is registered, one have to verify if provided name does not exist yet.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There is no dedicated Event's API function which performs this task. In such case
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the Model iterates over all registered custom events stored within internal data structure
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and compares the name being registered with those alredy registered.*/
&nbsp;&nbsp;&nbsp;if (!model_check_event_exists(event_name, &name_exists))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (name_exists) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, "Custom event '%s' already registered.", event_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* If the custom name fails the extence verification, then the relevant data structure is created
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to store event's related information internally. */
&nbsp;&nbsp;&nbsp;if (!model_create_custom_event_info(event_name, ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;/* Once the internal data structure is created, the custom event handler is registered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and the callback function attached to the event's handler. */
&nbsp;&nbsp;&nbsp;if (!model_add_custom_event_handler(*ev_info, __custom_event_cb, (void *)(*ev_info)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, "Custom event registered: '%s'.", (*ev_info)->name);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  For Model-related functions implementation and description, see the <a href="#model">Model</a> section.
  </p>

  <p>
  After the custom event is registered and appears on the list, it may be published by simple click on relevant list's item. The published item can be hooked only by those applications which are signed
  with the publisher's ceriticate.
  <br>
  The entire publishing procedure is shown within the source code below.
  </p>

<pre class="prettyprint">
/* This callback function is invoked when the user selects an event's related item on the list. */
static void __view_custom_event_item_select_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = (custom_ev_info_s *)data;

&nbsp;&nbsp;&nbsp;if (!ev_info) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "ev_info == NULL !!!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;} else if (!ev_info->name) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "ev_info->name == NULL !!!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* The Controller is requested to publish the event by its name. */
&nbsp;&nbsp;&nbsp;if (__viewdata->callbacks.do_publish_cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__viewdata->callbacks.do_publish_cb(ev_info->name);
}
</pre>

<pre class="prettyprint">
/* This callback function is invoked by the __view_custom_event_item_select_cb() function. */
static void __controller_event_do_publish_cb(const char *event_name)
{
&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, "Event publishing: '%s'.", event_name);

&nbsp;&nbsp;&nbsp;/* The event is published. */
&nbsp;&nbsp;&nbsp;model_publish_event(event_name);
}
</pre>

  <p>
  For Model-related functions implementation and description, see the <a href="#model">Model</a> section.
  </p>

  <p>
  Once the event is published, the callback function attached to its handler will be invoked within all those applications which are signed with the same certificate as the publisher.
  In this case, only Event sample application will receive the event via previously attached <span style="font-family: Courier New,Courier,monospace">__custom_event_cb()</span> callback function.
  The implementation of the <span style="font-family: Courier New,Courier,monospace">__custom_event_cb()</span> is shown below.
  </p>

<pre class="prettyprint">
static void __custom_event_cb(const char *event_name, bundle *event_data, void *user_data)
{
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = (custom_ev_info_s *)user_data;
&nbsp;&nbsp;&nbsp;char *status = NULL;

&nbsp;&nbsp;&nbsp;/* Each custom event owns only one predefined key pointing to its status: CUSTOM_EVENT_KEY_STATUS.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key is defined within this application: CUSTOM_EVENT_KEY_STATUS == "custom_event_status". */
&nbsp;&nbsp;&nbsp;if (!model_get_bundle_str(event_data, CUSTOM_EVENT_KEY_STATUS, &status))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;/* If the status is successfully obtained from the event's bundle, it is stored within internal data structure. */
&nbsp;&nbsp;&nbsp;model_assign_event_status(&ev_info->status_1, status);

&nbsp;&nbsp;&nbsp;/* Finally, the event's status is displayed on toast message ... */
&nbsp;&nbsp;&nbsp;view_display_custom_event(ev_info->name, ev_info->status_1);
&nbsp;&nbsp;&nbsp;/* ... and on the relevant list's item. */
&nbsp;&nbsp;&nbsp;view_update_custom_events();
}
</pre>

  <p>
  For Model-related functions implementation and description, see the <a href="#model">Model</a> section.
  </p>

<h3 id="model">Model</h3>

  <p>
  The responsibility of the application's "Model" module is to operate directly on the Event API and related data. The additional benefit of this module is the simplification of the API function calling:
  error checking and message logging is performed here.
  <br>
  Some of the functions implemented within the "Model" module were briefly described in the <a href="#app-finit">Application termination</a> section
  (<span style="font-family: Courier New,Courier,monospace">__model_release_system_events()</span>, <span style="font-family: Courier New,Courier,monospace">__model_release_custom_events()</span>,
  <span style="font-family: Courier New,Courier,monospace">model_finit()</span>, <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span>,
  <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span>). Other, the most important functions, are described here.
  </p>

  <p>
  Most of the Model functions operate on the <span style="font-family: Courier New,Courier,monospace">system_ev_info_s</span> or
  <span style="font-family: Courier New,Courier,monospace">custom_ev_info_s</span> structures which represent the system or custom event internally.
  </p>

  <p>
  Adding a handler to the specified event is performed by the <span style="font-family: Courier New,Courier,monospace">model_add_<b>#event_type#</b>_event_handler()</span> function, where
  <span style="font-family: Courier New,Courier,monospace"><b>#event_type#</b></span> stands for <span style="font-family: Courier New,Courier,monospace">system</span>
  or <span style="font-family: Courier New,Courier,monospace">custom</span>.
  </p>

<pre class="prettyprint">
bool model_add_<b>#event_type#</b>_event_handler(<b>#event_type#</b>_ev_info_s *ev_info, event_cb callback, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (!ev_info || !callback) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Wrong argument provided.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* Event's API function is called with name stored in the internal data structure.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The callback function is attached to the event's handler. */
&nbsp;&nbsp;&nbsp;int ret = event_add_event_handler(ev_info->name, callback, user_data, &ev_info->event_h);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function event_add_event_handler() failed with error = %d.", ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  Event's handler created with the <span style="font-family: Courier New,Courier,monospace">model_add_<b>#event_type#</b>_event_handler()</span> is released using
  <span style="font-family: Courier New,Courier,monospace">__model_remove_event_handler()</span> regardless of its
  <span style="font-family: Courier New,Courier,monospace"><b>#event_type#</b></span>.
  </p>

<pre class="prettyprint">
bool __model_remove_event_handler(event_handler_h event_handler)
{
&nbsp;&nbsp;&nbsp;int ret = event_remove_event_handler(event_handler);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function event_remove_event_handler() failed with error = %d.", ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  In order to publish a custom event, the <span style="font-family: Courier New,Courier,monospace">model_publish_event()</span> function must be called with event's name passed in the function's
  argument.
  </p>

<pre class="prettyprint">
bool model_publish_event(const char *event_name)
{
&nbsp;&nbsp;&nbsp;static unsigned int custom_ev_counter = 0;

&nbsp;&nbsp;&nbsp;if (!event_name) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Wrong argument provided.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* The bundle object is the carrier of the event's information.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It must be created and filled with proper data which describes event's status. */
&nbsp;&nbsp;&nbsp;bundle *bundle_ev = bundle_create();
&nbsp;&nbsp;&nbsp;if (!bundle_ev) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function bundle_create() failed.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* The custom event's status is created by simple concatenation of the status counter (custom_ev_counter) followed by the "status value" label. */
&nbsp;&nbsp;&nbsp;custom_ev_counter++;
&nbsp;&nbsp;&nbsp;char status[__STATUS_MSG_BUFF] = {0,};
&nbsp;&nbsp;&nbsp;snprintf(status, __STATUS_MSG_BUFF, "status value %u", custom_ev_counter);

&nbsp;&nbsp;&nbsp;/* The custom event's status string is added to the event's information carrier (bundle object)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with predefined key: CUSTOM_EVENT_KEY_STATUS == "custom_event_status". */
&nbsp;&nbsp;&nbsp;int ret = bundle_add_str(bundle_ev, CUSTOM_EVENT_KEY_STATUS, status);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function bundle_add_str() failed with error %d.", ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* Finally, the event (identified by event_name) is published (broadcasted) with the bundle object previously created. */
&nbsp;&nbsp;&nbsp;ret = event_publish_app_event(event_name, bundle_ev);
&nbsp;&nbsp;&nbsp;/* Once the event is published, the associated bundle object is not necessary anymore - it must be freed. */
&nbsp;&nbsp;&nbsp;bundle_free(bundle_ev);

&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function event_publish_app_event() failed with error %d.", ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  The custom event's name must strictly follow the rule defined by the Event's API:
  <br>
  <center><span style="font-family: Courier New,Courier,monospace">event.<b>#app_id#</b>.<b>#custom_name#</b></span>,</center>
  <br>
  where:
    <ul>
	  <li><span style="font-family: Courier New,Courier,monospace"><b>#app_id#</b></span> is the identifier of the calling application;</li>
	  <li><span style="font-family: Courier New,Courier,monospace"><b>#custom_name#</b></span> is a custom name assigned by the user/developer.</li>
	</ul>
  For this reason, the supporting <span style="font-family: Courier New,Courier,monospace">__model_format_custom_event_name()</span> function is implemented.
  </p>

<pre class="prettyprint">
static void __model_format_custom_event_name(const char *custom_name, char **ev_name)
{
&nbsp;&nbsp;&nbsp;/* Naming rule is applied. */
&nbsp;&nbsp;&nbsp;int ev_name_len = strlen("event") + strlen(APP_ID) + strlen(custom_name) + 3;
&nbsp;&nbsp;&nbsp;*ev_name = (char *)calloc(ev_name_len, sizeof(char));
&nbsp;&nbsp;&nbsp;snprintf(*ev_name, ev_name_len, "event.%s.%s", APP_ID, custom_name);

&nbsp;&nbsp;&nbsp;/* All whitespaces are removed from the <b>#custom_name#</b> and the string is converted to the lower case. */
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i < ev_name_len; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ev_name)[i] = tolower((*ev_name)[i]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((*ev_name)[i] == 32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ev_name)[i] = '_';
&nbsp;&nbsp;&nbsp;}
}

</pre>

  <p>
  Finally, the <span style="font-family: Courier New,Courier,monospace">model_get_bundle_str()</span> function is used to obtain event's status from the associated bundle object based on
  known key <span style="font-family: Courier New,Courier,monospace">CUSTOM_EVENT_KEY_STATUS == "custom_event_status"</span>.
  </p>

<pre class="prettyprint">
bool model_get_bundle_str(bundle *bundle_obj, const char *key, char **str)
{
&nbsp;&nbsp;&nbsp;*str = NULL;

&nbsp;&nbsp;&nbsp;int ret = bundle_get_str(bundle_obj, key, str);
&nbsp;&nbsp;&nbsp;if (ret != BUNDLE_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, "Function bundle_get_str() failed with error = %d.", ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

  <p>
  The remaining functions play supportive roles only, are self-explanatory and do not need to be described here. Only brief information on their role is included below.
    <ul>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_get_system_events_count()</span> - returns the number of registered system events based on the number of
	    relevant data stored internally.</li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_get_system_event_info()</span> - returns the system event's information structure stored internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_create_custom_event_info()</span> - creates the custom event's information structure and stores it internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_assign_event_status()</span> - assigns the status message to the specified event's structure stored internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_check_event_exists()</span> - checks whether given event's name is already registered within internal data structure.
	  </li>
    </ul>
  </p>



<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

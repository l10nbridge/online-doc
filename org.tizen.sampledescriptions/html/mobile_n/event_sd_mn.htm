<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Event Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
  <div id="profile">
   <p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
  </div>

  <h1>Event Sample Overview</h1>

  <p>The Event sample application demonstrates how you can create listeners for specified system and custom events, and listen to both types of events. To receive a custom event using a listener, the listener must be created and published.</p>
  
  <p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>
  <p>The following figure illustrates the main screens of the Event.</p>
  <p id="app-screenshot" class="figure">Figure: Event screens</p>
  <p align="center">
    <img alt="System events view" src="../images/event_system_events_view_sd_mn.png" />
	<img alt="Custom events view"  src="../images/event_custom_events_view_sd_mn.png" />
	<img alt="Received custom event view" src="../images/event_custom_events_received_view_sd_mn.png" />
  </p>

<p>The sample application provides a user interface for previewing available events and their status:</p>
  <ul>
    <li>System events:
      <ul>
	    <li>Battery level and charger status</li>
	    <li>USB and earjack status</li>
	    <li>Display state and auto-rotation mode</li>
	    <li>System boot and shutdown status</li>
	    <li>Memory status</li>
	    <li>Wi-Fi, Bluetooth, mobile data, and roaming state</li>
		<li>Location, GPS, and NPS state</li>
		<li>Incoming message status</li>
		<li>Time, time zone, and hour format change</li>
		<li>Language and region format change</li>
		<li>Silent and vibration mode change</li>
		<li>Font change</li>
      </ul>
	</li>
	<li>Custom events:
	  <ul>
	    <li>Custom events are received once they are registered and published by the user using the <strong>Custom events</strong> tab.</li>
	  </ul>
	</li>
  </ul>
<p>The following figure shows the structure of the user interface. EDJE layout scripts are used.</p>
  <p id="ui-main-struct" class="figure">Figure: Event main layout structure</p>
  <p align="center">
    <img alt="Event main layout structure" src="../images/event_ui_layout_1_sd_mn.png" />
  </p>
  <p>The <span style="font-family: Courier New,Courier,monospace">PART_MAIN_CONTENT</span> swallow is used as a container for both available layouts.</p>
  <p id="ui-tabs-struct" class="figure">Figure: Event tab layout structure</p>
  <p align="center">
    <img alt="Event tab layout structure" src="../images/event_ui_layout_2_sd_mn.png" />
  </p>
  <p>The final application view is created by embedding the proper components into the layouts depicted above. The resulting UI views are shown in the following figure.</p>
  <p id="ui-view" class="figure">Figure: Event application UI view</p>
  <p align="center">
    <img alt="Event application UI view" src="../images/event_ui_tabs_view_sd_mn.png" />
  </p>
<p>The application workflow can be divided into 3 logical pipelines:</p>
  <ul>
    <li>Application startup</li>
	<li>System event handling</li>
	<li>Custom event creation, publishing, and receiving</li>
  </ul>
  <p>The following figure describes the workflow.</p>
  <p id="workflow" class="figure">Figure: Application workflow</p>
  <p align="center">
    <img alt="Application workflow" src="../images/event_workflow_sd_mn.png" />
  </p>

<h2>Prerequisites</h2>
  <p>To ensure proper application execution, the following privileges must be set:</p>
    <ul>
      <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/network.get</span></li>
      <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/message.read</span></li>
      <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/display</span></li>
	</ul>

<h2>Implementation</h2>

<h3 id="type-defs">Type Definitions</h3>

<p>The following code shows the structures used as placeholders for various application data:</p>

<pre class="prettyprint">
// General structure for application data storage
struct 
__appdata 
{
&nbsp;&nbsp;&nbsp;viewdata_s view;
};

// All the Evas_Object objects represent UI components
struct 
__viewdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *conform;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_main_panel;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar_item_system_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *main_toolbar_item_custom_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_system_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *system_ev_list;
&nbsp;&nbsp;&nbsp;Evas_Object *layout_custom_ev;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_name;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_submit;
&nbsp;&nbsp;&nbsp;Evas_Object *custom_ev_list;
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *custom_ev_itc;
&nbsp;&nbsp;&nbsp;// Structure of callbacks handlers used by the Controller module to establish interaction with the Model module
&nbsp;&nbsp;&nbsp;viewcallbacks_s callbacks;
};

typedef struct __viewdata viewdata_s;

// All the callback handlers are hooked by the Controller module to relate the control flow between the View and the Model modules
struct 
__viewcallbacks 
{
&nbsp;&nbsp;&nbsp;// Invoked when the custom event needs to be published
&nbsp;&nbsp;&nbsp;event_do_publish_cb do_publish_cb;
&nbsp;&nbsp;&nbsp;// Invoked at the initialization phase to obtain all the information about system events for UI generation purpose
&nbsp;&nbsp;&nbsp;event_get_system_info_cb get_system_info_cb;
&nbsp;&nbsp;&nbsp;// Invoked when the user requests to register a custom event handler
&nbsp;&nbsp;&nbsp;event_set_custom_info_cb set_custom_info_cb;
};

typedef struct __viewcallbacks viewcallbacks_s;

// Definition of callback handlers declared in the viewcallbacks_s structure 
typedef void (* event_do_publish_cb)(const char *event_name);
typedef bool (* event_get_system_info_cb)(int index, void **ev_info);
typedef bool (* event_set_custom_info_cb)(const char *event_name, void **ev_info);

// Structure keeps all the event-related information
struct 
__system_ev_info 
{
&nbsp;&nbsp;&nbsp;// Type of the event - used only for the system events specification
&nbsp;&nbsp;&nbsp;// Type is defined as an enum whose values represent all available system events
&nbsp;&nbsp;&nbsp;event_type_t type;
&nbsp;&nbsp;&nbsp;// Name of the event
&nbsp;&nbsp;&nbsp;char *name;
&nbsp;&nbsp;&nbsp;// Readable description of the event
&nbsp;&nbsp;&nbsp;char *desc;
&nbsp;&nbsp;&nbsp;// Status of the event
&nbsp;&nbsp;&nbsp;char *status_1;
&nbsp;&nbsp;&nbsp;// Status of the event. Used if the event contains up to 2 different status information:
&nbsp;&nbsp;&nbsp;// Incoming message type / ID
&nbsp;&nbsp;&nbsp;char *status_2;
&nbsp;&nbsp;&nbsp;// Status of the event. Used if the event contains up to 3 different status information:
&nbsp;&nbsp;&nbsp;// Bluetooth state / LE state / transferring state
&nbsp;&nbsp;&nbsp;char *status_3;
&nbsp;&nbsp;&nbsp;// Event callback handler function
&nbsp;&nbsp;&nbsp;event_handler_h event_h;
};

typedef struct __system_ev_info system_ev_info_s;
typedef struct __system_ev_info custom_ev_info_s;

// Types of system events defined for source code simplification
// This type definition introduces event name mapping to its numerical representation
typedef enum 
{
&nbsp;&nbsp;&nbsp;ET_BATTERY_CHARGER_STATUS, // SYSTEM_EVENT_BATTERY_CHARGER_STATUS
&nbsp;&nbsp;&nbsp;ET_BATTERY_LEVEL_STATUS, // SYSTEM_EVENT_BATTERY_LEVEL_STATUS
&nbsp;&nbsp;&nbsp;ET_USB_STATUS, //SYSTEM_EVENT_USB_STATUS
&nbsp;&nbsp;&nbsp;ET_EARJACK_STATUS, // SYSTEM_EVENT_EARJACK_STATUS
&nbsp;&nbsp;&nbsp;ET_DISPLAY_STATE, // SYSTEM_EVENT_DISPLAY_STATE
&nbsp;&nbsp;&nbsp;ET_BOOT_COMPLETED, // SYSTEM_EVENT_BOOT_COMPLETED
&nbsp;&nbsp;&nbsp;ET_SYSTEM_SHUTDOWN, // SYSTEM_EVENT_SYSTEM_SHUTDOWN
&nbsp;&nbsp;&nbsp;ET_LOW_MEMORY, // SYSTEM_EVENT_LOW_MEMORY
&nbsp;&nbsp;&nbsp;ET_WIFI_STATE, // SYSTEM_EVENT_WIFI_STATE
&nbsp;&nbsp;&nbsp;ET_BT_STATE, // SYSTEM_EVENT_BT_STATE
&nbsp;&nbsp;&nbsp;ET_LOCATION_ENABLE_STATE, // SYSTEM_EVENT_LOCATION_ENABLE_STATE
&nbsp;&nbsp;&nbsp;ET_GPS_ENABLE_STATE, // SYSTEM_EVENT_GPS_ENABLE_STATE
&nbsp;&nbsp;&nbsp;ET_NPS_ENABLE_STATE, // SYSTEM_EVENT_NPS_ENABLE_STATE
&nbsp;&nbsp;&nbsp;ET_INCOMMING_MSG, // SYSTEM_EVENT_INCOMMING_MSG
&nbsp;&nbsp;&nbsp;ET_TIME_CHANGED, // SYSTEM_EVENT_TIME_CHANGED
&nbsp;&nbsp;&nbsp;ET_TIME_ZONE, // SYSTEM_EVENT_TIME_ZONE
&nbsp;&nbsp;&nbsp;ET_HOUR_FORMAT, // SYSTEM_EVENT_HOUR_FORMAT
&nbsp;&nbsp;&nbsp;ET_LANGUAGE_SET, // SYSTEM_EVENT_LANGUAGE_SET
&nbsp;&nbsp;&nbsp;ET_REGION_FORMAT, // SYSTEM_EVENT_REGION_FORMAT
&nbsp;&nbsp;&nbsp;ET_SILENT_MODE, // SYSTEM_EVENT_SILENT_MODE
&nbsp;&nbsp;&nbsp;ET_VIBRATION_STATE, // SYSTEM_EVENT_VIBRATION_STATE
&nbsp;&nbsp;&nbsp;ET_SCREEN_AUTOROTATE_STATE, // SYSTEM_EVENT_SCREEN_AUTOROTATE_STATE
&nbsp;&nbsp;&nbsp;ET_MOBILE_DATA_STATE, // SYSTEM_EVENT_MOBILE_DATA_STATE
&nbsp;&nbsp;&nbsp;ET_DATA_ROAMING_STATE, // SYSTEM_EVENT_DATA_ROAMING_STATE
&nbsp;&nbsp;&nbsp;ET_FONT_SET // SYSTEM_EVENT_FONT_SET
} event_type_t;
</pre>

<p>The Model module declares 2 arrays:</p>
     <ul>
	   <li><span style="font-family: Courier New,Courier,monospace">static system_ev_info_s __system_ev[__SYSTEM_EVENT_COUNT_MAX];</span></li>
	   <li><span style="font-family: Courier New,Courier,monospace">static custom_ev_info_s __custom_ev[__CUSTOM_EVENT_COUNT_MAX];</span></li>
	  </ul>
<p>The arrays are used to store system and custom event information. The <span style="font-family: Courier New,Courier,monospace">__SYSTEM_EVENT_COUNT_MAX</span> and <span style="font-family: Courier New,Courier,monospace">__CUSTOM_EVENT_COUNT_MAX</span> values are both set to 25 as the upperbound limit.</p>

<h3 id="app-init">Application Initialization</h3>

<p>To initialize the application:</p>
<ol>
<li>Implement the entire application life-cycle in the main source file, using a common Tizen application structure:
<pre class="prettyprint">
int 
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;appdata_s ad = {{0,},};
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback;
&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL,};

&nbsp;&nbsp;&nbsp;event_callback.create = __create_app;
&nbsp;&nbsp;&nbsp;event_callback.terminate = __terminate_app;
&nbsp;&nbsp;&nbsp;event_callback.pause = __pause_app;
&nbsp;&nbsp;&nbsp;event_callback.resume = __resume_app;
&nbsp;&nbsp;&nbsp;event_callback.app_control = __control_app;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, __ui_app_low_battery, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, __ui_app_low_memory, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, __ui_app_orient_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, __ui_app_lang_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, __ui_app_region_changed, &amp;ad);

&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &amp;event_callback, &amp;ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function ui_app_main() failed with error = %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
</li>
<li>Execute the application initialization process in the <span style="font-family: Courier New,Courier,monospace">__create_app()</span> callback function, which is invoked on application startup:
<pre class="prettyprint">
static bool 
__create_app(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = (appdata_s *)data;

&nbsp;&nbsp;&nbsp;return controller_init(&amp;ad-&gt;view);
}
</pre>
</li>
<li>Invoke the <span style="font-family: Courier New,Courier,monospace">controller_init()</span> function, which controls the entire initialization process. This function is responsible for attaching the callback functions invoked by the View module to perform the required tasks:
    <ul>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_do_publish_cb()</span>: Publish the custom event registered by the user</li>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_get_system_info_cb()</span>: Query system event information to populate the list with relevant data</li>
	  <li><span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span>: Register the event handler to be invoked on custom event occurrence</li>
	</ul>
<p>The first and the third callback functions are called when the user performs an appropriate action in the application UI. The second callback function is called during the application UI creation.</p>
<p>The application UI is created with the <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function. Its source code is not listed within this topic. At the end of the initialization phase, a callback function is attached to each of the available system events within the <span style="font-family: Courier New,Courier,monospace">__add_system_event_handlers()</span> function. </p>
<p>For a reference of all model-related functions not listed here, see <a href="#model">Model</a>.</p>
<pre class="prettyprint">
bool 
controller_init(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;callbacks.do_publish_cb = __controller_event_do_publish_cb;
&nbsp;&nbsp;&nbsp;vd-&gt;callbacks.get_system_info_cb = __controller_event_get_system_info_cb;
&nbsp;&nbsp;&nbsp;vd-&gt;callbacks.set_custom_info_cb = __controller_event_set_custom_info_cb;

&nbsp;&nbsp;&nbsp;if (!view_create_base_gui(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;__add_system_event_handlers();

&nbsp;&nbsp;&nbsp;return true;
}

static void 
__add_system_event_handlers(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;// Iteration over all available system events
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; model_get_system_events_count(); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// System event information structure is obtained
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_get_system_event_info(i, &amp;ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Event handler is created and a callback function is attached
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model_add_system_event_handler(ev_info, __system_event_cb, (void *)ev_info);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Attach the implementation of the callback functions in the <span style="font-family: Courier New,Courier,monospace">controller_init()</span> function:
<pre class="prettyprint">
static void 
__controller_event_do_publish_cb(const char *event_name)
{
&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, &quot;Event publishing: &#39;%s&#39;.&quot;, event_name);

&nbsp;&nbsp;&nbsp;model_publish_event(event_name);
}
</pre>
</li>

<li><p>The <span style="font-family: Courier New,Courier,monospace">__controller_event_get_system_info_cb()</span> callback is invoked by the View module as long as the function returns <span style="font-family: Courier New,Courier,monospace">true</span>. Each time, the function is called with an incremented <span style="font-family: Courier New,Courier,monospace">index</span> value. As a result, the system event information <span style="font-family: Courier New,Courier,monospace">ev_info</span>, stored at specified <span style="font-family: Courier New,Courier,monospace">index</span>, is returned. The requested data structure is obtained with the <span style="font-family: Courier New,Courier,monospace">model_get_system_event_info()</span> function.</p>
<pre class="prettyprint">
static bool 
__controller_event_get_system_info_cb(int index, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;if (index &gt;= model_get_system_events_count())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;if (!model_get_system_event_info(index, &amp;ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (system_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span> callback is invoked by the View model when the user requests to register custom event. If the registration procedure succeeds (see the <span style="font-family: Courier New,Courier,monospace">__controller_register_custom_event()</span> function implementation for details), the reference to the event information structure is returned using the <span style="font-family: Courier New,Courier,monospace">ev_info</span> parameter.</p>
<pre class="prettyprint">
static bool 
__controller_event_set_custom_info_cb(const char *event_name, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;if (!__controller_register_custom_event(event_name, &amp;ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (custom_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}

bool 
__controller_register_custom_event(const char *event_name, custom_ev_info_s **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;
&nbsp;&nbsp;&nbsp;bool name_exists = false;

&nbsp;&nbsp;&nbsp;// Event name, assigned by the user, must be unique, so you have to check whether it exists yet
&nbsp;&nbsp;&nbsp;if (!model_check_event_exists(event_name, &amp;name_exists))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;// If there is already an event registered with the given name, the function fails
&nbsp;&nbsp;&nbsp;if (name_exists) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, &quot;Custom event &#39;%s&#39; already registered.&quot;, event_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Otherwise new event information structure is created
&nbsp;&nbsp;&nbsp;if (!model_create_custom_event_info(event_name, ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;// Finally, the event callback function is assigned, to be invoked when the event occurs
&nbsp;&nbsp;&nbsp;if (!model_add_custom_event_handler(*ev_info, __custom_event_cb, (void *)(*ev_info)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, &quot;Custom event registered: &#39;%s&#39;.&quot;, (*ev_info)-&gt;name);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>

<h3 id="app-finit">Application Termination</h3>

<p>To terminate the application:</p>

<ol>
<li>When the application is terminated, call the <span style="font-family: Courier New,Courier,monospace">__terminate_app()</span> callback function:
<pre class="prettyprint">
static void 
__terminate_app(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = (appdata_s *)data;

&nbsp;&nbsp;&nbsp;controller_finit(&amp;ad-&gt;view);
}
</pre>
</li>

<li>Release all previously allocated resources with the <span style="font-family: Courier New,Courier,monospace">controller_finit()</span> function, which is responsible for destroying the UI and detaching system and custom events handlers:
<pre class="prettyprint">
void 
controller_finit(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;view_destroy_base_gui(vd);
&nbsp;&nbsp;&nbsp;model_finit();
}
</pre>
</li>

<li>Detach the events handlers in the Model module within the <span style="font-family: Courier New,Courier,monospace">model_finit()</span> function, which calls 2 internal functions: <span style="font-family: Courier New,Courier,monospace">__model_release_system_events()</span> and <span style="font-family: Courier New,Courier,monospace">__model_release_custom_events()</span>.
<p>As the UI is not a subject for this topic, the implementation of the <span style="font-family: Courier New,Courier,monospace">view_destroy_base_gui()</span> function is omitted.</p>
<pre class="prettyprint">
void 
model_finit(void)
{
&nbsp;&nbsp;&nbsp;__model_release_system_events();
&nbsp;&nbsp;&nbsp;__model_release_custom_events();
}
</pre>
</li>
<li>The events handler detaching procedure relies on the <span style="font-family: Courier New,Courier,monospace">__model_remove_event_handler()</span> function for each attached event handler regardless of its type (system or custom). The related resources are freed with the <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span> and <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span> functions. For reference, see <a href="#model">Model</a>. 
<pre class="prettyprint">
static void 
__model_release_system_events(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; __SYSTEM_EVENT_COUNT_MAX; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = &amp;__system_ev[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_remove_event_handler(ev_info-&gt;event_h);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_free_system_event_info(ev_info);
&nbsp;&nbsp;&nbsp;}
}

static void 
__model_release_custom_events(void)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; __custom_ev_count; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = &amp;__custom_ev[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_remove_event_handler(ev_info-&gt;event_h);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__model_free_custom_event_info(ev_info);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;__custom_ev_count = 0;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span> and <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span> functions are not listed here, as their implementation is based only on the <span style="font-family: Courier New,Courier,monospace">free()</span> function used to free the previously allocated memory.</p>
</li>
</ol>

<h3 id="ev-system">System Events</h3>

<p>After all the system events are successfully hooked in the initialization phase, they can be handled once they occur. This is done with the <span style="font-family: Courier New,Courier,monospace">__system_event_cb()</span> callback function registered within the <span style="font-family: Courier New,Courier,monospace">__add_system_event_handlers()</span> function. For reference, see <a href="#app-init">Application Initialization</a>. </p>
<pre class="prettyprint">
static void 
__system_event_cb(const char *event_name, bundle *event_data, void *user_data)
{
&nbsp;&nbsp;&nbsp;system_ev_info_s *ev_info = (system_ev_info_s *)user_data;
&nbsp;&nbsp;&nbsp;char *status_1 = NULL;
&nbsp;&nbsp;&nbsp;char *status_2 = NULL;
&nbsp;&nbsp;&nbsp;char *status_3 = NULL;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, &quot;System event &#39;%s&#39; occurred.&quot;, event_name);

&nbsp;&nbsp;&nbsp;switch (ev_info-&gt;type) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ET_&lt;event_type&gt;:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!model_get_bundle_str(event_data, EVENT_KEY_&lt;name_1&gt;, &amp;status_1) ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!model_get_bundle_str(event_data, EVENT_KEY_&lt;name_2&gt;, &amp;status_2) ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!model_get_bundle_str(event_data, EVENT_KEY_&lt;name_3&gt;, &amp;status_3))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// status_1 ... status_3 char buffers are copied to the ev_info-&gt;status_1 ... ev_info-&gt;status_3
&nbsp;&nbsp;&nbsp;model_assign_event_status(&amp;ev_info-&gt;status_1, status_1);
&nbsp;&nbsp;&nbsp;model_assign_event_status(&amp;ev_info-&gt;status_2, status_2);
&nbsp;&nbsp;&nbsp;model_assign_event_status(&amp;ev_info-&gt;status_3, status_3);

&nbsp;&nbsp;&nbsp;view_update_system_events();
}
</pre>

<p>All the information carried by the event is stored in a bundle object structure (<span style="font-family: Courier New,Courier,monospace">event_data</span>) followed by the event name (<span style="font-family: Courier New,Courier,monospace">event_name</span>). To avoid using an inefficient string comparison function for event distinguishing, the custom event type is used (see the <span style="font-family: Courier New,Courier,monospace">event_type_t</span> definition in the <a href="#type-defs">Type Definitions</a> section). These types are statically preassigned. Based on the value of the <span style="font-family: Courier New,Courier,monospace">type</span> member of the <span style="font-family: Courier New,Courier,monospace">ev_info</span> structure of the <span style="font-family: Courier New,Courier,monospace">system_ev_info_s</span> data type, the events are distinguished and the event state is obtained from the bundle object.</p>
<p>Each event name and the relevant bundle keys are defined by the <a href="../../../org.tizen.native.mobile.apireference/group__CAPI__EVENT__MODULE.html">Event</a> API. To extract the event status, the <span style="font-family: Courier New,Courier,monospace">model_get_bundle_str()</span> function is used. For the relation between the <span style="font-family: Courier New,Courier,monospace">ET_&lt;event_type&gt;</span> and <span style="font-family: Courier New,Courier,monospace">EVENT_KEY_&lt;name_1&gt;</span> ... <span style="font-family: Courier New,Courier,monospace">EVENT_KEY_&lt;name_3&gt;</span>, see the Event API.</p>
<p>Once the valid event status is obtained, the UI is updated to reflect the current event state using the <span style="font-family: Courier New,Courier,monospace">view_update_system_events()</span> function.</p>

<h3 id="ev-custom">Custom Events</h3>

<p>To manage custom events:</p>
<ol>
<li>
<p>Once the user registers a new event using the <strong>Register event</strong> button, the <span style="font-family: Courier New,Courier,monospace">__controller_register_custom_event()</span> function is invoked in a <span style="font-family: Courier New,Courier,monospace">__controller_event_set_custom_info_cb()</span> callback function triggered by the <span style="font-family: Courier New,Courier,monospace">__view_register_event_button_clicked_cb()</span> function attached to the <strong>Register event</strong> button. To clarify the process, all the mentioned functions are listed in the following example in the order of invocation.</p>
<pre class="prettyprint">
// Invoked on &quot;Register event&quot; button press
static void 
__view_register_event_button_clicked_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;viewdata_s *vd = (viewdata_s *)data;
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = NULL;
&nbsp;&nbsp;&nbsp;char *event_name = NULL;

&nbsp;&nbsp;&nbsp;// Event name input by the user is obtained
&nbsp;&nbsp;&nbsp;if (!__view_get_custom_event_name(vd, &amp;event_name)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, &quot;The custom event has no name assigned.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// If the event name is provided properly, the Controller callback function is invoked
&nbsp;&nbsp;&nbsp;// to register a new event with the given name
&nbsp;&nbsp;&nbsp;bool ret = false;
&nbsp;&nbsp;&nbsp;if (vd-&gt;callbacks.set_custom_info_cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = vd-&gt;callbacks.set_custom_info_cb((const char *)event_name, (void *)&amp;ev_info);

&nbsp;&nbsp;&nbsp;free(event_name);

&nbsp;&nbsp;&nbsp;if (!ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;// Once the custom event is registered successfully, the UI is updated to reflect recent changes
&nbsp;&nbsp;&nbsp;elm_genlist_item_append(__viewdata-&gt;custom_ev_list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__viewdata-&gt;custom_ev_itc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)ev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__view_custom_event_item_select_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)ev_info);
}

// Invoked within the __view_register_event_button_clicked_cb()
static bool 
__controller_event_set_custom_info_cb(const char *event_name, void **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;

&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info_tmp = NULL;
&nbsp;&nbsp;&nbsp;// Custom event registration is performed here
&nbsp;&nbsp;&nbsp;if (!__controller_register_custom_event(event_name, &amp;ev_info_tmp))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*ev_info = (custom_ev_info_s *)ev_info_tmp;

&nbsp;&nbsp;&nbsp;return true;
}

bool 
__controller_register_custom_event(const char *event_name, custom_ev_info_s **ev_info)
{
&nbsp;&nbsp;&nbsp;*ev_info = NULL;
&nbsp;&nbsp;&nbsp;bool name_exists = false;

&nbsp;&nbsp;&nbsp;// Before the custom event is registered, verify whether the provided name exists
&nbsp;&nbsp;&nbsp;// There is no dedicated Event API function which performs this task. In such case,
&nbsp;&nbsp;&nbsp;// the Model iterates over all registered custom events stored within the internal data structure
&nbsp;&nbsp;&nbsp;// and compares the name being registered with those already registered
&nbsp;&nbsp;&nbsp;if (!model_check_event_exists(event_name, &amp;name_exists))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (name_exists) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_WARN, &quot;Custom event &#39;%s&#39; already registered.&quot;, event_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// If the custom name fails the existence verification, the relevant data structure is created
&nbsp;&nbsp;&nbsp;// to store event-related information internally
&nbsp;&nbsp;&nbsp;if (!model_create_custom_event_info(event_name, ev_info))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;// Once the internal data structure is created, the custom event handler is registered
&nbsp;&nbsp;&nbsp;// and the callback function attached to the event handler
&nbsp;&nbsp;&nbsp;if (!model_add_custom_event_handler(*ev_info, __custom_event_cb, (void *)(*ev_info)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, &quot;Custom event registered: &#39;%s&#39;.&quot;, (*ev_info)-&gt;name);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>
<p>After the custom event is registered and appears on the list, it can be published by a simple click on the relevant list item. The published item can be hooked only by those applications which are signed with the publisher certificate. The entire publishing process is shown within the following source code.</p>
<pre class="prettyprint">
// Invoked when the user selects an event-related item on the list
static void 
__view_custom_event_item_select_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = (custom_ev_info_s *)data;

&nbsp;&nbsp;&nbsp;if (!ev_info) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;ev_info == NULL !!!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (!ev_info-&gt;name) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;ev_info-&gt;name == NULL !!!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Controller is requested to publish the event by its name
&nbsp;&nbsp;&nbsp;if (__viewdata-&gt;callbacks.do_publish_cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__viewdata-&gt;callbacks.do_publish_cb(ev_info-&gt;name);
}

// Invoked by the __view_custom_event_item_select_cb() function
static void 
__controller_event_do_publish_cb(const char *event_name)
{
&nbsp;&nbsp;&nbsp;controller_log(DLOG_INFO, &quot;Event publishing: &#39;%s&#39;.&quot;, event_name);

&nbsp;&nbsp;&nbsp;// Event is published 
&nbsp;&nbsp;&nbsp;model_publish_event(event_name);
}
</pre>
</li>

<li>
<p>Once the event is published, the callback function attached to its handler is invoked within all those applications which are signed with the same certificate as the publisher. In this case, only the Event sample application receives the event using the previously attached <span style="font-family: Courier New,Courier,monospace">__custom_event_cb()</span> callback function:</p>
<pre class="prettyprint">
static void 
__custom_event_cb(const char *event_name, bundle *event_data, void *user_data)
{
&nbsp;&nbsp;&nbsp;custom_ev_info_s *ev_info = (custom_ev_info_s *)user_data;
&nbsp;&nbsp;&nbsp;char *status = NULL;

&nbsp;&nbsp;&nbsp;// Each custom event owns only one predefined key pointing to its status: CUSTOM_EVENT_KEY_STATUS
&nbsp;&nbsp;&nbsp;// The key is defined within this application: CUSTOM_EVENT_KEY_STATUS == &quot;custom_event_status&quot;
&nbsp;&nbsp;&nbsp;if (!model_get_bundle_str(event_data, CUSTOM_EVENT_KEY_STATUS, &amp;status))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;// If the status is successfully obtained from the event bundle, it is stored within the internal data structure
&nbsp;&nbsp;&nbsp;model_assign_event_status(&amp;ev_info-&gt;status_1, status);

&nbsp;&nbsp;&nbsp;// Finally, the event status is displayed on a toast message...
&nbsp;&nbsp;&nbsp;view_display_custom_event(ev_info-&gt;name, ev_info-&gt;status_1);
&nbsp;&nbsp;&nbsp;// ... and on the relevant list item
&nbsp;&nbsp;&nbsp;view_update_custom_events();
}
</pre>

<p>For Model-related function implementation and description, see <a href="#model">Model</a>.</p>
</li>
</ol>

<h3 id="model">Model</h3>

<p>The responsibility of the application Model module is to operate directly on the Event API and related data. The additional benefit of this module is the simplification of the API function calling, as error checking and message logging is performed here.</p>
<p>Some of the functions implemented within the Model module have been briefly described in <a href="#app-finit">Application Termination</a> section (<span style="font-family: Courier New,Courier,monospace">__model_release_system_events()</span>, <span style="font-family: Courier New,Courier,monospace">__model_release_custom_events()</span>, <span style="font-family: Courier New,Courier,monospace">model_finit()</span>, <span style="font-family: Courier New,Courier,monospace">__model_free_system_event_info()</span>, <span style="font-family: Courier New,Courier,monospace">__model_free_custom_event_info()</span>). The most important functions are described here.</p>

<p>Most of the Model functions operate on the <span style="font-family: Courier New,Courier,monospace">system_ev_info_s</span> or <span style="font-family: Courier New,Courier,monospace">custom_ev_info_s</span> structures, which represent the system and custom events internally.</p>
<p>To operate on the Event API and related data with the Model module:</p>
<ol>
<li>
<p>Add a handler to the specified event with the <span style="font-family: Courier New,Courier,monospace">model_add_&lt;event_type&gt;_event_handler()</span> function, where <span style="font-family: Courier New,Courier,monospace">&lt;event_type&gt;</span> stands for <span style="font-family: Courier New,Courier,monospace">system</span> or <span style="font-family: Courier New,Courier,monospace">custom</span>:</p>
<pre class="prettyprint">
bool 
model_add_&lt;event_type&gt;_event_handler(&lt;event_type&gt;_ev_info_s *ev_info, event_cb callback, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (!ev_info || !callback) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Wrong argument provided.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Event API function is called with name stored in the internal data structure
&nbsp;&nbsp;&nbsp;// Callback function is attached to the event handler
&nbsp;&nbsp;&nbsp;int ret = event_add_event_handler(ev_info-&gt;name, callback, user_data, &amp;ev_info-&gt;event_h);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function event_add_event_handler() failed with error = %d.&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>
<p>Release the event handler using the <span style="font-family: Courier New,Courier,monospace">__model_remove_event_handler()</span> function regardless of its <span style="font-family: Courier New,Courier,monospace">&lt;event_type&gt;</span>:</p>
<pre class="prettyprint">
bool 
__model_remove_event_handler(event_handler_h event_handler)
{
&nbsp;&nbsp;&nbsp;int ret = event_remove_event_handler(event_handler);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function event_remove_event_handler() failed with error = %d.&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>
<p>To publish a custom event, the <span style="font-family: Courier New,Courier,monospace">model_publish_event()</span> function must be called with the event name:</p>
<pre class="prettyprint">
bool 
model_publish_event(const char *event_name)
{
&nbsp;&nbsp;&nbsp;static unsigned int custom_ev_counter = 0;

&nbsp;&nbsp;&nbsp;if (!event_name) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Wrong argument provided.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Bundle object is the carrier of the event information
&nbsp;&nbsp;&nbsp;// It must be created and filled with proper data which describes event status
&nbsp;&nbsp;&nbsp;bundle *bundle_ev = bundle_create();
&nbsp;&nbsp;&nbsp;if (!bundle_ev) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function bundle_create() failed.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Custom event status is created by simple concatenation of the status counter (custom_ev_counter) followed by the &quot;status value&quot; label
&nbsp;&nbsp;&nbsp;custom_ev_counter++;
&nbsp;&nbsp;&nbsp;char status[__STATUS_MSG_BUFF] = {0,};
&nbsp;&nbsp;&nbsp;snprintf(status, __STATUS_MSG_BUFF, &quot;status value %u&quot;, custom_ev_counter);

&nbsp;&nbsp;&nbsp;// Custom event status string is added to the event information carrier (bundle object)
&nbsp;&nbsp;&nbsp;// with predefined key: CUSTOM_EVENT_KEY_STATUS == &quot;custom_event_status&quot;
&nbsp;&nbsp;&nbsp;int ret = bundle_add_str(bundle_ev, CUSTOM_EVENT_KEY_STATUS, status);
&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function bundle_add_str() failed with error %d.&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Finally, the event (identified by event_name) is published (broadcasted) with the previously created bundle object
&nbsp;&nbsp;&nbsp;ret = event_publish_app_event(event_name, bundle_ev);
&nbsp;&nbsp;&nbsp;// Once the event is published, the associated bundle object is not necessary anymore - it must be freed
&nbsp;&nbsp;&nbsp;bundle_free(bundle_ev);

&nbsp;&nbsp;&nbsp;if (ret != EVENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function event_publish_app_event() failed with error %d.&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>The custom event name must strictly follow the <span style="font-family: Courier New,Courier,monospace">event.&lt;app_id&gt;.&lt;custom_name&gt;</span> naming rule defined by the Event API. In the name, <span style="font-family: Courier New,Courier,monospace">&lt;app_id&gt;</span> is the identifier of the calling application, and <span style="font-family: Courier New,Courier,monospace">&lt;custom_name&gt;</span> is a custom name assigned by you or the user. For this reason, the supporting <span style="font-family: Courier New,Courier,monospace">__model_format_custom_event_name()</span> function is implemented.</p>
<pre class="prettyprint">
static void 
__model_format_custom_event_name(const char *custom_name, char **ev_name)
{
&nbsp;&nbsp;&nbsp;// Naming rule is applied
&nbsp;&nbsp;&nbsp;int ev_name_len = strlen(&quot;event&quot;) + strlen(APP_ID) + strlen(custom_name) + 3;
&nbsp;&nbsp;&nbsp;*ev_name = (char *)calloc(ev_name_len, sizeof(char));
&nbsp;&nbsp;&nbsp;snprintf(*ev_name, ev_name_len, &quot;event.%s.%s&quot;, APP_ID, custom_name);

&nbsp;&nbsp;&nbsp;// All whitespaces are removed from the &lt;custom_name&gt; and the string is converted to the lower case
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; ev_name_len; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ev_name)[i] = tolower((*ev_name)[i]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((*ev_name)[i] == 32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*ev_name)[i] = &#39;_&#39;;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">model_get_bundle_str()</span> function to obtain the event status from the associated bundle object based on the known <span style="font-family: Courier New,Courier,monospace">CUSTOM_EVENT_KEY_STATUS == &quot;custom_event_status&quot;</span> key.</p>

<pre class="prettyprint">
bool 
model_get_bundle_str(bundle *bundle_obj, const char *key, char **str)
{
&nbsp;&nbsp;&nbsp;*str = NULL;

&nbsp;&nbsp;&nbsp;int ret = bundle_get_str(bundle_obj, key, str);
&nbsp;&nbsp;&nbsp;if (ret != BUNDLE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller_log(DLOG_ERROR, &quot;Function bundle_get_str() failed with error = %d.&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>

<p>The following list gives a brief description on the roles of the remaining functions.</p>
    <ul>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_get_system_events_count()</span>: Returns the number of registered system events based on the number of
	    relevant data stored internally.</li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_get_system_event_info()</span>: Returns the system event information structure stored internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_create_custom_event_info()</span>: Creates the custom event information structure and stores it internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_assign_event_status()</span>: Assigns the status message to the specified event structure stored internally.
	  </li>
      <li>
	    <span style="font-family: Courier New,Courier,monospace">model_check_event_exists()</span>: Checks whether given event name is already registered within internal data structure.
	  </li>
    </ul>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

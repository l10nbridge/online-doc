<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Bluetooth LE Collector Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
  <div id="profile">
    <p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
  </div>

<h1>Bluetooth LE Collector Sample Overview</h1>

<p>The Bluetooth LE Collector sample application demonstrates how you can discover remote advertisers and consume the data they broadcast over the Bluetooth Low Energy (LE) network using the <a href="../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__LE__MODULE.html">Bluetooth LE Adapter</a> API. This sample application is able to discover any device which advertises itself in the Bluetooth LE network, but only the data provided by the
<a href="../wearable_n/bluetooth_le_service_sd_wn.htm">Bluetooth LE Service</a> application can be consumed.</p>

<p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>

<p>The purpose of this sample application is to gather and display the health information broadcast by the wearable device through the Bluetooth LE service. There are 2 types of advertised information:</p>
	<ul>
		<li>Heart rate measurement
<p>The number of heart beats per second.</p></li>
		<li>Body sensor location
<p>The point of the heart rate measurement.</p></li>
	</ul>
	
<p>
The following figure illustrates the main screens of the Bluetooth LE Collector.
</p>

<p id="app-screenshot" class="figure">Figure: Bluetooth LE Collector screens</p>
<p align="center">
	<img alt="Initial view of the application" src="../images/bluetooth_le_collector_main_view_1.png" />
	<img alt="Device discovery view" src="../images/bluetooth_le_collector_main_view_2.png" />
	<img alt="Detailed view of the selected device" src="../images/bluetooth_le_collector_main_view_3.png" />
</p>	
<p align="center">	
	<img alt="Available services view" src="../images/bluetooth_le_collector_main_view_4.png" />
	<img alt="Heart rate service view" src="../images/bluetooth_le_collector_main_view_5.png" />
	<img alt="Body sensor location view" src="../images/bluetooth_le_collector_main_view_6.png" />
</p>

<p>When the application opens, click <strong>Scan</strong> to discover devices in the Bluetooth LE network. If the Gear 2 device running the Bluetooth LE Service application is found, select it to view the device details.</p>

<p>On the device details view, click <strong>Check</strong> to see the available advertised information.</p>


<p>The application workflow can be divided into the following major pipelines (the first 4 are delivered to the user through the UI):</p>
	<ul>
		<li>Application initialization</li>
		<li>Device discovery</li>
		<li>Acquisition and browsing of the discovered device details</li>
		<li>Acquisition and display of the discovered device service data</li>
		<li>Application termination</li>
	</ul>


<p class="figure">Figure: Application workflow</p>
<p align="center">
	<img alt="Application workflow" src="../images/bluetooth_le_collector_workflow_sd.png" />
</p>

<h2>Prerequisites</h2>

<p>To ensure proper application execution, the following privilege must be set:</p>
<ul><li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/bluetooth</span></li></ul>

<h2>Implementation</h2>

<p>
The entire application workflow is described in the following sections.
</p>

<h3 id="init-terminate">Application Initialization and Termination</h3>

<p>To initialize the application:</p>

<ol>
<li><p>The application is initialized on the application startup with the <span style="font-family: Courier New,Courier,monospace">controller_create()</span> function invoked from the <span style="font-family: Courier New,Courier,monospace">create</span> callback assigned in the <span style="font-family: Courier New,Courier,monospace">main()</span> function.</p>

<p>At the beginning, the following callbacks responsible for handling requests from the UI are assigned:</p>
	<ul>
		<li><span style="font-family: Courier New,Courier,monospace">__scan_start_request_cb()</span> starts Bluetooth LE network scanning
<p>The callback	is called when the user clicks <strong>Scan</strong>.</p></li>
		<li><span style="font-family: Courier New,Courier,monospace">__scan_cancel_request_cb()</span> cancels Bluetooth LE network scanning
<p>The callback	is called when the user clicks <strong>Cancel</strong>.</p></li>
		<li><span style="font-family: Courier New,Courier,monospace">__peer_select_request_cb()</span> selects the advertiser device for its detailed information acquisition
<p>The callback	is called when the user selects a remote device from the list of available advertisers.</p></li>
	</ul>
	
<p>Next, the application main view is created with the <span style="font-family: Courier New,Courier,monospace">view_main_create()</span> function. This is not described, as it is not the subject of this topic.</p>
<p>Afterwards, the availability of Bluetooth and Bluetooth LE features is checked using the <span style="font-family: Courier New,Courier,monospace">__is_feature_supported()</span> function with the <span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth</span> and <span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth.le</span> parameters. If the Bluetooth-related feature verification is passed, the Bluetooth adapter is initialized with the <span style="font-family: Courier New,Courier,monospace">__init()</span> function. Otherwise, an appropriate error message is displayed and the UI is updated with the <span style="font-family: Courier New,Courier,monospace">__set_state()</span> function.</p>

<pre class="prettyprint">
bool 
controller_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd-&gt;scan_start_cb = __scan_start_request_cb;
&nbsp;&nbsp;&nbsp;vd-&gt;scan_cancel_cb = __scan_cancel_request_cb;
&nbsp;&nbsp;&nbsp;vd-&gt;peer_select_cb = __peer_select_request_cb;

&nbsp;&nbsp;&nbsp;if (!view_main_create(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (__is_feature_supported(FEATURE_BLUETOOTH)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (__is_feature_supported(FEATURE_BLUETOOTH_LE)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!__init()) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_DEACTIVE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message(&quot;Bluetooth activation error.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message(&quot;Bluetooth Low Energy is not supported.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message(&quot;Bluetooth is not supported.&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__init()</span> function initializes the Bluetooth adapter and sets the
<span style="font-family: Courier New,Courier,monospace">__bt_device_state_changed_cb()</span> callback for its state change handling (updating the UI to reflect the current adapter state).</p>
<p>The Bluetooth adapter state is verified with the <span style="font-family: Courier New,Courier,monospace">bt_get_state()</span> function to acknowledge its successful initialization. At the end, the UI is updated with the <span style="font-family: Courier New,Courier,monospace">__set_state()</span> function.</p>

<pre class="prettyprint">
static bool 
__init(void)
{
&nbsp;&nbsp;&nbsp;bool is_enabled = false;

&nbsp;&nbsp;&nbsp;if (bt_init()) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_set_callbacks(__bt_device_state_changed_cb, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_get_state(&amp;is_enabled);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_enabled)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_ACTIVE);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li></ol>

<p>At the end of the application life-cycle, the <span style="font-family: Courier New,Courier,monospace">controller_terminate()</span> function is invoked from the <span style="font-family: Courier New,Courier,monospace">terminate</span> callback assigned in the <span style="font-family: Courier New,Courier,monospace">main()</span> function.</p>

<p>The application termination procedure is very simple and relies on the Bluetooth adapter deinitialization (<span style="font-family: Courier New,Courier,monospace">bt_deinit()</span>), allocated resource cleaning (<span style="font-family: Courier New,Courier,monospace">bt_unset_callbacks()</span> and <span style="font-family: Courier New,Courier,monospace">model_free()</span>), and view destroying (<span style="font-family: Courier New,Courier,monospace">view_main_destroy()</span>).</p>

<pre class="prettyprint">
void 
controller_terminate(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;bt_unset_callbacks();
&nbsp;&nbsp;&nbsp;bt_deinit();
&nbsp;&nbsp;&nbsp;view_main_destroy(vd);
&nbsp;&nbsp;&nbsp;model_free();
}
</pre>


<h3 id="dev-discovery">Device Discovery</h3>

<p>To discover devices:</p>

<ol>
<li>
<p>Once the application is initialized successfully, the device discovery procedure starts when the user clicks <strong>Scan</strong> and the <span style="font-family: Courier New,Courier,monospace">__scan_start_request_cb()</span> callback is invoked:</p>

<ol type="a">
<li>The data model is prepared to store incoming data by cleaning relevant data structures (<span style="font-family: Courier New,Courier,monospace">model_free()</span>).</li>
<li>The Bluetooth LE network scanning is initiated with the <span style="font-family: Courier New,Courier,monospace">bt_le_start_scan()</span> function. The assigned <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_cb()</span> callback is invoked each time an advertisement or a scan response is received from a peer device.</li>
</ol>

<pre class="prettyprint">
static bool 
__scan_start_request_cb(void)
{
&nbsp;&nbsp;&nbsp;model_free();

&nbsp;&nbsp;&nbsp;if (!bt_le_start_scan(__bt_le_scan_cb))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE scanning: started.&quot;);
&nbsp;&nbsp;&nbsp;__set_state(VS_SCANNING);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>
<p>There is only 1 callback type defined for received messages, so you must check which message type was received. This check can be performed by inspecting the <a href="../../../org.tizen.native.mobile.apireference/structbt__adapter__le__device__scan__result__info__s.html">info</a> structure against the relevant data:</p>
	<ul>
		<li>If the <span style="font-family: Courier New,Courier,monospace">adv_data</span> pointer is not <span style="font-family: Courier New,Courier,monospace">NULL</span> and the <span style="font-family: Courier New,Courier,monospace">adv_data_len</span> value is greater than 0, an advertisement message was received.</li>
		<li>If the <span style="font-family: Courier New,Courier,monospace">scan_data</span> pointer is not <span style="font-family: Courier New,Courier,monospace">NULL</span> and the <span style="font-family: Courier New,Courier,monospace">scan_data_len</span> value is greater than 0, a scan response message was received.</li>
	</ul>

<pre class="prettyprint">
static void 
__bt_le_scan_cb(int result, bt_adapter_le_device_scan_result_info_s *info, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Advertisement handling
&nbsp;&nbsp;&nbsp;if (info-&gt;adv_data &amp;&amp; info-&gt;adv_data_len &gt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_le_adv_data_process(info);

&nbsp;&nbsp;&nbsp;// Scan response handling
&nbsp;&nbsp;&nbsp;if (info-&gt;scan_data &amp;&amp; info-&gt;scan_data_len &gt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_le_scan_data_process(info);
}
</pre>
</li>
<li>
<p>Depending on the inspection result, the <span style="font-family: Courier New,Courier,monospace">__bt_le_adv_data_process()</span> or
<span style="font-family: Courier New,Courier,monospace">__bt_le_scan_data_process()</span> function is invoked:</p>

<ol type="a">
<li>For peer device identification purposes, the remote name is used. The <span style="font-family: Courier New,Courier,monospace">bt_le_get_adv_device_name()</span> function is called in order to extract the remote name from the advertisement message.</li>
<li>The obtained name is stored (<span style="font-family: Courier New,Courier,monospace">__add_found_le_device()</span>) and further used to identify the remote device.</li>
<li>Each remote device is represented by a custom <span style="font-family: Courier New,Courier,monospace">bt_le_device_info_s</span> structure referenced by the <span style="font-family: Courier New,Courier,monospace">dev_info</span> variable created internally by the <span style="font-family: Courier New,Courier,monospace">__add_found_le_device()</span> function.</li>
<li>The entire advertisement message is <a href="#dev-details">processed for any additional information acquisition</a>
(<span style="font-family: Courier New,Courier,monospace">__adv_data_process()</span>.</li>
</ol>

<pre class="prettyprint">
static void 
__bt_le_adv_data_process(bt_adapter_le_device_scan_result_info_s *info)
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;bool dev_added;
&nbsp;&nbsp;&nbsp;bt_le_device_info_s *dev_info = NULL;

&nbsp;&nbsp;&nbsp;if (!bt_le_get_adv_device_name(info, &amp;name))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;dev_added = __add_found_le_device((const char *)name, &amp;dev_info);
&nbsp;&nbsp;&nbsp;free(name);

&nbsp;&nbsp;&nbsp;if (!dev_added)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;// See the next section for details
&nbsp;&nbsp;&nbsp;__adv_data_process(info, &amp;dev_info);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">bt_le_device_info_s</span> structure is described below and maintained by the model module:</p>

<pre class="prettyprint">
struct 
_bt_le_device_data 
{
&nbsp;&nbsp;&nbsp;// Size of the service data
&nbsp;&nbsp;&nbsp;int size;
&nbsp;&nbsp;&nbsp;// UUID of the service where the data is carried - integral value
&nbsp;&nbsp;&nbsp;int uuid_value;
&nbsp;&nbsp;&nbsp;// UUID of the service where the data is carried - hexadecimal representation
&nbsp;&nbsp;&nbsp;char *uuid;
&nbsp;&nbsp;&nbsp;// Service data
&nbsp;&nbsp;&nbsp;char *data;
};

typedef struct _bt_le_device_data bt_le_device_data_s;

// Structure carries all the peer-related information
struct 
_bt_le_device_info 
{
&nbsp;&nbsp;&nbsp;// Device name
&nbsp;&nbsp;&nbsp;char *name;
&nbsp;&nbsp;&nbsp;// Transmission power level
&nbsp;&nbsp;&nbsp;int tx_power_level;
&nbsp;&nbsp;&nbsp;// Device external appearance identifier
&nbsp;&nbsp;&nbsp;int appearance;
&nbsp;&nbsp;&nbsp;// Device manufacturer identifier
&nbsp;&nbsp;&nbsp;int manufacturer_id;
&nbsp;&nbsp;&nbsp;// Number of exposed services
&nbsp;&nbsp;&nbsp;int services_count;
&nbsp;&nbsp;&nbsp;// Number of exposed solicitation services
&nbsp;&nbsp;&nbsp;int services_solicitation_count;
&nbsp;&nbsp;&nbsp;// Number of exposed service data
&nbsp;&nbsp;&nbsp;int service_data_count;
&nbsp;&nbsp;&nbsp;// UUIDs of exposed services
&nbsp;&nbsp;&nbsp;char **services;
&nbsp;&nbsp;&nbsp;// UUIDs of exposed solicitation services
&nbsp;&nbsp;&nbsp;char **services_solicitation;
&nbsp;&nbsp;&nbsp;// Data bound to the exposed services 
&nbsp;&nbsp;&nbsp;bt_le_device_data_s *service_data;
};

typedef struct _bt_le_device_info bt_le_device_info_s;
</pre>
</li>

<li>
<p>Each discovered device is added to the application model with the <span style="font-family: Courier New,Courier,monospace">__add_found_le_device()</span> function:</p>

<pre class="prettyprint">
static bool 
__add_found_le_device(const char *name, bt_le_device_info_s **dev_info)
{
&nbsp;&nbsp;&nbsp;int index = -1;

&nbsp;&nbsp;&nbsp;*dev_info = NULL;

&nbsp;&nbsp;&nbsp;// Check whether a device name is already registered
&nbsp;&nbsp;&nbsp;// If so, the function returns
&nbsp;&nbsp;&nbsp;if (model_check_device_exist(name, &amp;index))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;// Otherwise, the new bt_le_device_info_s structure is
&nbsp;&nbsp;&nbsp;// created for unregistered device name
&nbsp;&nbsp;&nbsp;if (!model_add_device(name)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to add device %s.&quot;, name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Obtain the index of the newly added device
&nbsp;&nbsp;&nbsp;if (!model_check_device_exist(name, &amp;index)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_WARN, LOG_TAG, &quot;Device does not exist.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Get the bt_le_device_info_s device structure by its index
&nbsp;&nbsp;&nbsp;if (!model_get_device(index, dev_info)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Could not get the device info.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// UI is updated
&nbsp;&nbsp;&nbsp;view_main_add_device((*dev_info)-&gt;name, index);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device %s added.&quot;, (*dev_info)-&gt;name);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>
<p>The device discovery procedure is stopped when the user clicks <strong>Cancel</strong>, which results in the <span style="font-family: Courier New,Courier,monospace">__scan_cancel_request_cb()</span> callback invocation:</p>

<pre class="prettyprint">
static bool 
__scan_cancel_request_cb(void)
{
&nbsp;&nbsp;&nbsp;if (!bt_le_stop_scan())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE scanning: finished.&quot;);

&nbsp;&nbsp;&nbsp;if (model_get_device_count() == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_ACTIVE);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_OPERATION);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<p>After the Bluetooth LE scan procedure is stopped, the UI is updated according to the number of discovered devices. In this state, no messages are received.</p>
</li>
</ol>

<h3 id="dev-details">Acquiring the Discovered Device Details</h3>

<p>Once the devices are discovered, their detailed information can be acquired from the advertisement message (see the <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_cb()</span> callback described in <a href="#dev-discovery">Device Discovery</a>).</p>

<p>The <span style="font-family: Courier New,Courier,monospace">bt_le_get_adv_XXX()</span> functions are invoked to acquire the following information from the advertisement message:</p>
	<ul>
		<li>Manufacturer data
<p>Device vendor identifier (see the <a href="https://www.bluetooth.com/specifications/assigned-numbers/Company-Identifiers" target="_blank">company identifiers</a> for details).</p></li>
		<li>Transmission power level
<p>Transmission power expressed in dBm (decibel-milliwatts).</p></li>
		<li>Appearance code
<p>Value that describes the general device usage (see the <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml" target="_blank">external device appearance</a> for details).</p></li>
		<li>Service UUIDs
<p>List of handled service identifiers.</p></li>
		<li>Solicitation service UUIDs
<p>List of handled solicitation service identifiers.</p></li>
	</ul>

<p>All the acquired information is bound to the remote device name (<span style="font-family: Courier New,Courier,monospace">model_set_device_info()</span>) previously obtained and referenced by the <span style="font-family: Courier New,Courier,monospace">dev_info</span> variable.</p>

<p>Finally, the UI is updated with the <span style="font-family: Courier New,Courier,monospace">view_main_update_peer_info()</span> function to reflect the received data.</p>

<pre class="prettyprint">
static void 
__adv_data_process(bt_adapter_le_device_scan_result_info_s *info, bt_le_device_info_s **dev_info)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;int manufacturer_id = -1;
&nbsp;&nbsp;&nbsp;int tx_power_level = 0;
&nbsp;&nbsp;&nbsp;int appearance = 0;
&nbsp;&nbsp;&nbsp;int services_count = 0;
&nbsp;&nbsp;&nbsp;int services_solicitation_count = 0;
&nbsp;&nbsp;&nbsp;char **services = NULL;
&nbsp;&nbsp;&nbsp;char **services_solicitation = NULL;

&nbsp;&nbsp;&nbsp;bt_le_get_adv_manufacturer_data(info, &amp;manufacturer_id);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_tx_power_level(info, &amp;tx_power_level);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_appearance(info, &amp;appearance);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_service_uuids(info, &amp;services, &amp;services_count);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_service_solicitation_uuids(info, &amp;services_solicitation, &amp;services_solicitation_count);

&nbsp;&nbsp;&nbsp;model_set_device_info(dev_info, tx_power_level, appearance, manufacturer_id, services,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_count, services_solicitation, services_solicitation_count);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services[i]);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_solicitation_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services_solicitation[i]);

&nbsp;&nbsp;&nbsp;free(services);
&nbsp;&nbsp;&nbsp;free(services_solicitation);

&nbsp;&nbsp;&nbsp;view_main_update_peer_info(*dev_info);
}
</pre>

<h3 id="svc-details">Acquiring the Discovered Device Service Data</h3>

<p>The device service data acquisition procedure is very similar to that described in <a href="#dev-details">Acquiring the Discovered Device Details</a>. The process starts in the <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_cb()</span> callback function (see <a href="#dev-discovery">Device Discovery</a>) with the <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_data_process()</span> function invocation:</p>

<ol>
<li>When a scan response message is received, you must obtain the sender name (<span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_device_name()</span>) and check whether
it is already registered (<span style="font-family: Courier New,Courier,monospace">__bt_le_is_device_registered()</span>).</li>
<li>If a received message concerns the registered and selected device, the received data is processed further by the <span style="font-family: Courier New,Courier,monospace">__scan_data_process()</span> function. The scan response message can contain the same information set as the advertisement message extended with the service and solicitation service data.</li>
</ol>

<pre class="prettyprint">
static void 
__bt_le_scan_data_process(bt_adapter_le_device_scan_result_info_s *info)
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;bool is_selected = false;
&nbsp;&nbsp;&nbsp;bt_le_device_info_s *dev_info = NULL;

&nbsp;&nbsp;&nbsp;// Obtain the sender name
&nbsp;&nbsp;&nbsp;if (!bt_le_get_scan_device_name(info, &amp;name))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;// Check whether the sender is already registered; if so, the control flow goes on, otherwise...
&nbsp;&nbsp;&nbsp;if (!__bt_le_is_device_registered(name, &amp;dev_info)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...the device is registered as a new one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__add_found_le_device((const char *)name, &amp;dev_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;free(name);

&nbsp;&nbsp;&nbsp;// Check whether the message concerns the device selected by the user from the list
&nbsp;&nbsp;&nbsp;if (!model_check_device_selected(dev_info-&gt;name, &amp;is_selected))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;if (!is_selected)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;// If a scan response message concerns a registered and selected device,
&nbsp;&nbsp;&nbsp;// it is further processed
&nbsp;&nbsp;&nbsp;__scan_data_process(info, &amp;dev_info);
}
</pre>


<p>The <span style="font-family: Courier New,Courier,monospace">__scan_data_process()</span> function implementation is very similar to <span style="font-family: Courier New,Courier,monospace">__adv_data_process()</span> (see <a href="#dev-details">Acquiring the Discovered Device Details</a>). The only difference concerns the service data acquisition (<span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_service_data_list()</span>) and its storage in model structure (<span style="font-family: Courier New,Courier,monospace">model_set_device_data()</span>):</p>

<ol>
<li>In contrast to the <span style="font-family: Courier New,Courier,monospace">__adv_data_process()</span> function, the <span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_XXX()</span> functions are invoked to acquire the same set of information as from the advertisement message extended with the service data acquisition (<span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_service_data_list()</span>).</li>
<li>All the acquired information and service data is bound to the remote device name (<span style="font-family: Courier New,Courier,monospace">model_set_device_info()</span> and <span style="font-family: Courier New,Courier,monospace">model_set_device_data()</span>) previously obtained and referenced by the <span style="font-family: Courier New,Courier,monospace">dev_info</span> variable.</li>
<li>The UI is updated with the <span style="font-family: Courier New,Courier,monospace">view_main_update_peer_info()</span> function to reflect the received data.</li></ol>

<pre class="prettyprint">
static void 
__scan_data_process(bt_adapter_le_device_scan_result_info_s *info, bt_le_device_info_s **dev_info)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;int manufacturer_id = -1;
&nbsp;&nbsp;&nbsp;int tx_power_level = 0;
&nbsp;&nbsp;&nbsp;int appearance = 0;
&nbsp;&nbsp;&nbsp;int services_count = 0;
&nbsp;&nbsp;&nbsp;int services_solicitation_count = 0;
&nbsp;&nbsp;&nbsp;int data_count = 0;
&nbsp;&nbsp;&nbsp;char **services = NULL;
&nbsp;&nbsp;&nbsp;char **services_solicitation = NULL;
&nbsp;&nbsp;&nbsp;bt_adapter_le_service_data_s *data = NULL;

&nbsp;&nbsp;&nbsp;bt_le_get_scan_manufacturer_data(info, &amp;manufacturer_id);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_tx_power_level(info, &amp;tx_power_level);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_appearance(info, &amp;appearance);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_uuids(info, &amp;services, &amp;services_count);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_solicitation_uuids(info, &amp;services_solicitation, &amp;services_solicitation_count);
&nbsp;&nbsp;&nbsp;// Service data acquisition; if any data is carried by the service, the data_count variable
&nbsp;&nbsp;&nbsp;// points to the number of services exposing its information carried by the data array
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_data_list(info, &amp;data, &amp;data_count);

&nbsp;&nbsp;&nbsp;model_set_device_info(dev_info, tx_power_level, appearance, manufacturer_id, services,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_count, services_solicitation, services_solicitation_count);

&nbsp;&nbsp;&nbsp;// For each service...
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; data_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model_set_device_data(dev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...identified by UUID...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_uuid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...its data is acquired...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...of the service_data_len size...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_data_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...and stored in the model structure

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services[i]);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_solicitation_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services_solicitation[i]);

&nbsp;&nbsp;&nbsp;free(services);
&nbsp;&nbsp;&nbsp;free(services_solicitation);

&nbsp;&nbsp;&nbsp;if (data || data_count &gt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_le_free_service_data_list(data, data_count);

&nbsp;&nbsp;&nbsp;view_main_update_peer_info(*dev_info);
}
</pre>

<h3 id="model">Application Model</h3>

<p>The Model module is responsible for:</p>
	<ul>
		<li>Wrapping Bluetooth-related API function calls in order to simplify the application source code:
			<ul>
				<li><span style="font-family: Courier New,Courier,monospace">bt.c</span> file handles a subset of the
					<a href="../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth</a>
					and <a href="../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__MODULE.html">Bluetooth Adapter</a>
					API functions. Due to their simplicity, they are not listed here.
				</li>
				<li><span style="font-family: Courier New,Courier,monospace">bt_le.c</span> file handles a subset of the
					<a href="../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__LE__MODULE.html">Bluetooth LE Adapter</a> API functions, whose general implementation structure is defined in the following example.
<pre class="prettyprint">
bool 
bt_le_<strong>#op_type#</strong>_<strong>#msg_type#</strong>_<strong>#op_target#</strong>(<strong>#args_in#</strong>, <strong>#args_out#</strong>)
{
&nbsp;&nbsp;&nbsp;return __<strong>#op_type#</strong>_<strong>#op_target#</strong>(<strong>#args_in#</strong>, <strong>#arg_msg_type#</strong>, <strong>#args_out#</strong>);
}

bool 
__<strong>#op_type#</strong>_<strong>#op_target#</strong>(<strong>#args_in#</strong>, <strong>#arg_msg_type#</strong>, <strong>#args_out#</strong>)
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;if (!<strong>#args_out#</strong>) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Function __<strong>#op_type#</strong>_<strong>#op_target#</strong>() failed due to wrong argument.&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;*<strong>#args_out#</strong> = NULL;

&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_<strong>#op_type#</strong>_scan_result_<strong>#op_target#</strong>(<strong>#args_in#</strong>, <strong>#arg_msg_type#</strong>, <strong>#args_out#</strong>);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NO_DATA) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Function bt_adapter_le_<strong>#op_type#</strong>_scan_result_<strong>#op_target#</strong>() failed with error: %s.&quot;, get_error_message(ret));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>Where</p>
					<ul>
						<li><strong>#op_type#</strong> = get/set/free</li>
						<li><strong>#msg_type#</strong> = adv/scan</li>
						<li><strong>#op_target#</strong> = operation target, for example, <span style="font-family: Courier New,Courier,monospace">device_name</span></li>
						<li><strong>#args_in#</strong> = input parameters</li>
						<li><strong>#args_out#</strong> = output parameters</li>
						<li><strong>#arg_msg_type#</strong> = <span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_PACKET_ADVERTISING</span> or <span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_PACKET_SCAN_RESPONSE</span></li>
					</ul>
				</li>
			</ul>
		</li>
		<li>Managing the acquired information and data (<span style="font-family: Courier New,Courier,monospace">model.c</span>).
			<p>This portion of the source code is responsible for <a href="#dev-discovery">discovered devices</a> (referenced with
			<span style="font-family: Courier New,Courier,monospace">bt_le_device_info_s</span> data structure) as well as the advertiser information and broadcast service data storage.</p>
			<p>The implementation details of these functions are irrelevant from the application subject point of view.</p>
		</li>
		<li>Decoding the acquired data (<span style="font-family: Courier New,Courier,monospace">model_heart_rate_measurement.c</span> and <span style="font-family: Courier New,Courier,monospace">model_body_sensor_location.c</span>).
			<p>The data decoding complies with the following standards and directly implements their decomposition:</p>
			<ul>
				<li>
					<a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.heart_rate_measurement.xml" target="_blank">
					Heart Rate Measurement</a>
				</li>
				<li>
					<a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.body_sensor_location.xml" target="_blank">
					Body Sensor Location</a>
				</li>
			</ul>
		</li>
	</ul>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

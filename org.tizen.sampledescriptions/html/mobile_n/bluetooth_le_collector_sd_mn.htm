<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Bluetooth LE Collector Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
  <div id="profile">
    <p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
  </div>

<h1>Bluetooth LE Collector Sample Overview</h1>

<p>
The Bluetooth LE Collector sample application demonstrates how to discover remote advertisers and consume the data they broadcast over the Bluetooth Low Energy network. In order to achieve the goal,
the <a href="https://developer.tizen.org/dev-guide/2.4.0/org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__LE__MODULE.html">Bluetooth LE Adapter</a> API is used.
This sample application is able to discover any device which advertises itself in the Bluetooth LE network, but only the data provided by the
<a href="https://developer.tizen.org/development/sample/2.4/sample-mobile-applications">Bluetooth LE Service</a> can be consumed.
<br>
The general idea behind this sample application is to gather and display the health information broadcasted by the wearable device through the
<a href="https://developer.tizen.org/development/sample/2.4/sample-mobile-applications">Bluetooth LE Service</a>. There are two types of advertized information:
	<ul>
		<li>Heart Rate Measurement - the number of heart beats per second;</li>
		<li>Body Sensor Location - the point of heart rate measurement.</li>
	</ul>
</p>

<p>
The following figures illustrate the view of the application:
</p>

<p id="app-screenshot" class="figure">Figure: Bluetooth LE Collector application screens.</p>
<p align="center">
	<img alt="Initial view of the application" src="../images/bluetooth_le_collector_main_view_1.png" />
	<img alt="Devices discovery view" src="../images/bluetooth_le_collector_main_view_2.png" />
	<img alt="Detailed view of the selected device" src="../images/bluetooth_le_collector_main_view_3.png" />
	<img alt="Available services view" src="../images/bluetooth_le_collector_main_view_4.png" />
	<img alt="Heart Rate service view" src="../images/bluetooth_le_collector_main_view_5.png" />
	<img alt="Body Sensor Location view" src="../images/bluetooth_le_collector_main_view_6.png" />
</p>

<p>
The application's workflow can be divided into five major pipelines:
	<ol>
		<li>application's initialization;</li>
		<li>devices discovery;</li>
		<li>discovered device's details acquisition and browsing;</li>
		<li>discovered device's service data acquisition and display;</li>
		<li>application's termination.</li>
	</ol>
The first 4 features are delivered to the user via the UI (<a href="#app-screenshot">Bluetooth LE Collector application screens</a>) and briefly described by the figure below.
</p>

<p id="app-screenshot" class="figure">Figure: Application's workflow.</p>
<p align="center">
	<img alt="Application's workflow" width="70%" src="../images/bluetooth_le_collector_workflow_sd.png" />
</p>

<h2>Prerequisites</h2>

<p>
To ensure proper service execution, <span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/bluetooth</span> privilege must be set.
</p>

<h2>Implementation</h2>

<p>
The entire application's workflow is described in subsections below.
</p>

<h3 id="init-terminate">Application's initialization and termination</h3>

<p>
The application is initialized on application's startup with <span style="font-family: Courier New,Courier,monospace">controller_create()</span> function invoked from the
<span style="font-family: Courier New,Courier,monospace">create</span> callback assigned in the <span style="font-family: Courier New,Courier,monospace">main()</span> function.
</p>

<pre class="prettyprint">
bool controller_create(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;vd->scan_start_cb = __scan_start_request_cb;
&nbsp;&nbsp;&nbsp;vd->scan_cancel_cb = __scan_cancel_request_cb;
&nbsp;&nbsp;&nbsp;vd->peer_select_cb = __peer_select_request_cb;

&nbsp;&nbsp;&nbsp;if (!view_main_create(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (__is_feature_supported(FEATURE_BLUETOOTH)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (__is_feature_supported(FEATURE_BLUETOOTH_LE)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!__init()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_DEACTIVE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message("Bluetooth activation error.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message("Bluetooth Low Energy is not supported.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_main_display_message("Bluetooth is not supported.");
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>
At the beginning, the following callback functions responsible for handling requests from the UI are assigned:
	<ul>
		<li><span style="font-family: Courier New,Courier,monospace">__scan_start_request_cb()</span> - starts Bluetooth LE network scanning; is called on "Scan" button tap;</li>
		<li><span style="font-family: Courier New,Courier,monospace">__scan_cancel_request_cb()</span> - cancels Bluetooth LE network scanning; is called on "Cancel" button tap;</li>
		<li><span style="font-family: Courier New,Courier,monospace">__peer_select_request_cb()</span> - selects the advertiser's device for its detailed information acquisition;
			is called on remote device selection from the list of available advertisers.</li>
	</ul>
Next, the application's main view is created with <span style="font-family: Courier New,Courier,monospace">view_main_create()</span> function which is not described here as it is not the subject of this
document. Afterwards, the availability of Bluetooth and Bluetooth LE features is checked using <span style="font-family: Courier New,Courier,monospace">__is_feature_supported()</span> function with
<span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth</span> and
<span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth.le</span> arguments, respectively. If the Bluetooth related features' verification is passed,
the Bluetooth adapter is initialized with the <span style="font-family: Courier New,Courier,monospace">__init()</span> function. Otherwise, an appropriate error message is displayed and the UI is updated
with <span style="font-family: Courier New,Courier,monospace">__set_state()</span> function.
</p>

<pre class="prettyprint">
static bool __init(void)
{
&nbsp;&nbsp;&nbsp;bool is_enabled = false;

&nbsp;&nbsp;&nbsp;if (bt_init()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_set_callbacks(__bt_device_state_changed_cb, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_get_state(&is_enabled);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_enabled)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__set_state(VS_ACTIVE);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>
The <span style="font-family: Courier New,Courier,monospace">__init()</span> function initializes the Bluetooth adapter and sets
<span style="font-family: Courier New,Courier,monospace">__bt_device_state_changed_cb()</span> callback function for its state change handling (updating the UI to reflect the current adapter's state).
Finally, the Bluetooth adapter's state is verified with <span style="font-family: Courier New,Courier,monospace">bt_get_state()</span> function to acknowledge its successful initialization.
At the end, the UI is updated with the <span style="font-family: Courier New,Courier,monospace">__set_state()</span> function.
</p>

<p>
At the end of the application's lifecycle, the <span style="font-family: Courier New,Courier,monospace">controller_terminate()</span> function is invoked from the
<span style="font-family: Courier New,Courier,monospace">terminate</span> callback assigned in the <span style="font-family: Courier New,Courier,monospace">main()</span> function.
</p>

<pre class="prettyprint">
void controller_terminate(viewdata_s *vd)
{
&nbsp;&nbsp;&nbsp;bt_unset_callbacks();
&nbsp;&nbsp;&nbsp;bt_deinit();
&nbsp;&nbsp;&nbsp;view_main_destroy(vd);
&nbsp;&nbsp;&nbsp;model_free();
}
</pre>

<p>
The application's termination procedure is very simple and relies on Bluetooth adapter deinitialization (<span style="font-family: Courier New,Courier,monospace">bt_deinit()</span>), allocated
resources cleaning (<span style="font-family: Courier New,Courier,monospace">bt_unset_callbacks()</span>, <span style="font-family: Courier New,Courier,monospace">model_free()</span>)
and view destroying (<span style="font-family: Courier New,Courier,monospace">view_main_destroy()</span>).
</p>

<p>
For undescribed function's reference, see the <a href="#reference">Reference</a> section.
</p>

<h3 id="dev-discovery">Devices discovery</h3>

<p>
Once the application is initialized successfully, the devices discovery procedure starts on "Scan" button press which results in
<span style="font-family: Courier New,Courier,monospace">__scan_start_request_cb()</span> callback function invocation. Firstly, the data model is prepared to store incoming data by cleaning
relevant data structures (<span style="font-family: Courier New,Courier,monospace">model_free()</span>). Then, the Bluetooth LE network scanning is initiated with the
<span style="font-family: Courier New,Courier,monospace">bt_le_start_scan()</span> function. The assigned <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_cb()</span>
callback function is invoked each time an advertisement or a scan response is received from a peer device.

<pre class="prettyprint">
static bool __scan_start_request_cb(void)
{
&nbsp;&nbsp;&nbsp;model_free();

&nbsp;&nbsp;&nbsp;if (!bt_le_start_scan(__bt_le_scan_cb))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "LE scanning: started.");
&nbsp;&nbsp;&nbsp;__set_state(VS_SCANNING);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>
There is only ony type of callback function defined for received messages so one has to check which type of message was received. This check can be performed by
<a href="https://developer.tizen.org/dev-guide/2.4.0/org.tizen.native.mobile.apireference/structbt__adapter__le__device__scan__result__info__s.html">
<span style="font-family: Courier New,Courier,monospace">info</span></a> structure inspection against relevant data existence:
	<ul>
		<li>if the <span style="font-family: Courier New,Courier,monospace">adv_data</span> pointer is not <span style="font-family: Courier New,Courier,monospace">NULL</span>
		and the <span style="font-family: Courier New,Courier,monospace">adv_data_len</span> value is greater than 0 then an advertisement message was received,</li>
		<li>if the <span style="font-family: Courier New,Courier,monospace">scan_data</span> pointer is not <span style="font-family: Courier New,Courier,monospace">NULL</span>
		and the <span style="font-family: Courier New,Courier,monospace">scan_data_len</span> value is greater than 0 then a scan response message was received.</li>
	</ul>
</p>

<pre class="prettyprint">
static void __bt_le_scan_cb(int result, bt_adapter_le_device_scan_result_info_s *info, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* Advertisement handling. */
&nbsp;&nbsp;&nbsp;if (info->adv_data && info->adv_data_len > 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_le_adv_data_process(info);

&nbsp;&nbsp;&nbsp;/* Scan response handling. */
&nbsp;&nbsp;&nbsp;if (info->scan_data && info->scan_data_len > 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_le_scan_data_process(info);
}
</pre>

<p>
Depending on inspection result, the <span style="font-family: Courier New,Courier,monospace">__bt_le_adv_data_process()</span> and/or
<span style="font-family: Courier New,Courier,monospace">__bt_le_scan_data_process()</span> functions are invoked.
</p>

<pre class="prettyprint">
static void __bt_le_adv_data_process(bt_adapter_le_device_scan_result_info_s *info)
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;bool dev_added;
&nbsp;&nbsp;&nbsp;bt_le_device_info_s *dev_info = NULL;

&nbsp;&nbsp;&nbsp;if (!bt_le_get_adv_device_name(info, &name))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;dev_added = __add_found_le_device((const char *)name, &dev_info);
&nbsp;&nbsp;&nbsp;free(name);

&nbsp;&nbsp;&nbsp;if (!dev_added)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;__adv_data_process(info, &dev_info);
}
</pre>

<p>
For peer device identification purpose its remote name is used, so the <span style="font-family: Courier New,Courier,monospace">bt_le_get_adv_device_name()</span> function is called in order to extract
it from the advertisement message. The obtained name is then stored (<span style="font-family: Courier New,Courier,monospace">__add_found_le_device()</span>) and further used to identify the remote device.
Finally, the entire advertisement message is processed for any additional information acquisition (<span style="font-family: Courier New,Courier,monospace">__adv_data_process()</span>).
</p>

<pre class="prettyprint">
static void __adv_data_process(bt_adapter_le_device_scan_result_info_s *info, bt_le_device_info_s **dev_info)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;int manufacturer_id = -1;
&nbsp;&nbsp;&nbsp;int tx_power_level = 0;
&nbsp;&nbsp;&nbsp;int appearance = 0;
&nbsp;&nbsp;&nbsp;int services_count = 0;
&nbsp;&nbsp;&nbsp;int services_solicitation_count = 0;
&nbsp;&nbsp;&nbsp;char **services = NULL;
&nbsp;&nbsp;&nbsp;char **services_solicitation = NULL;

&nbsp;&nbsp;&nbsp;bt_le_get_adv_manufacturer_data(info, &manufacturer_id);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_tx_power_level(info, &tx_power_level);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_appearance(info, &appearance);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_service_uuids(info, &services, &services_count);
&nbsp;&nbsp;&nbsp;bt_le_get_adv_service_solicitation_uuids(info, &services_solicitation, &services_solicitation_count);

&nbsp;&nbsp;&nbsp;model_set_device_info(dev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx_power_level,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appearance,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_count,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_solicitation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_solicitation_count);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services[i]);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_solicitation_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services_solicitation[i]);

&nbsp;&nbsp;&nbsp;free(services);
&nbsp;&nbsp;&nbsp;free(services_solicitation);

&nbsp;&nbsp;&nbsp;view_main_update_peer_info(*dev_info);
}
</pre>

<p>
The <span style="font-family: Courier New,Courier,monospace">bt_le_get_adv_<b>{adv_info_name}</b>()</span> functions are invoked to acquire the following information from the advertisement message:
	<ul>
		<li>manufacturer's data - device's vendor identifier (see the <a href="https://www.bluetooth.com/specifications/assigned-numbers/Company-Identifiers">company identifiers</a> for details);</li>
		<li>transmition power level - the transmition power expressed in dBm (decibel-milliwatts);</li>
		<li>appearance code - a value that describes general device usage (see the
		<a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml">external device's appearance</a>
		for details);</li>
		<li>services UUIDs - a list of handled services identifiers;</li>
		<li>solicitation services UUIDs - a list of handled solicitation services identifiers.</li>
	</ul>
All the acquired information is binded to the remote device name previously obtained and stored internally for further use.
<br>
Finally, the user interface is updated with <span style="font-family: Courier New,Courier,monospace">view_main_update_peer_info()</span> function to reflect received data.
</p>

<h3 id="dev-details">Discovered device's details acquisition and browsing</h3>

<p>
Once the devices are discovered and the list is populated with available advertisers, the user is able to select one from all discovered peers. After selection, the UI is changed to the device's detailed view where the
following information is displayed:
	<ul>
		<li>appearance,</li>
		<li>manufacturer,</li>
		<li>TX power,</li>
		<li>number of provided services,</li>
		<li>number of provided solicitation services.</li>
	</ul>
All the above information is gathered by <span style="font-family: Courier New,Courier,monospace">__bt_le_scan_data_process()</span> function invoked from the
<span style="font-family: Courier New,Courier,monospace">__bt_le_scan_cb()</span> callback function on scan response message received event (for details see the
<a href="#dev-discovery">Devices discovery</a> section).
</p>

<pre class="prettyprint">
static void __bt_le_scan_data_process(bt_adapter_le_device_scan_result_info_s *info)
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;bool is_selected = false;
&nbsp;&nbsp;&nbsp;bt_le_device_info_s *dev_info = NULL;

&nbsp;&nbsp;&nbsp;/* Obtain the sender's name. */
&nbsp;&nbsp;&nbsp;if (!bt_le_get_scan_device_name(info, &name))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;/* Check whether the sender is already registered. If so, the control flow goes on, otherwise ...*/
&nbsp;&nbsp;&nbsp;if (!__bt_le_is_device_registered(name, &dev_info)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... the device is registered as a new one. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__add_found_le_device((const char *)name, &dev_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;free(name);

&nbsp;&nbsp;&nbsp;/* Check whether the message concerns the device selected by the user from the list. */
&nbsp;&nbsp;&nbsp;if (!model_check_device_selected(dev_info->name, &is_selected))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;if (!is_selected)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;/* If a scan response message concerns a registered and selected device,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then it is further processed. */
&nbsp;&nbsp;&nbsp;__scan_data_process(info, &dev_info);
}
</pre>

<p>
When a scan response message is received, then one has to obtain the sender's name (<span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_device_name()</span>) and check whether
it is already registered (<span style="font-family: Courier New,Courier,monospace">__bt_le_is_device_registered()</span>). If a received message concerns the registered and selected device, the
received data is processed further by <span style="font-family: Courier New,Courier,monospace">__scan_data_process()</span> function. The scan response message may contain the same information set
as the advertisement message extended with the service/solicitation service data.
<br>
This function's implementation is very similar to <span style="font-family: Courier New,Courier,monospace">__adv_data_process()</span> (see the <a href="#dev-discovery">Devices discovery</a> section).
The only difference concerns the service's data acquisition (<span style="font-family: Courier New,Courier,monospace">bt_le_get_scan_service_data_list()</span>) and its storage in model's structure
(<span style="font-family: Courier New,Courier,monospace">model_set_device_data()</span>).
</p>

<pre class="prettyprint">
static void __scan_data_process(bt_adapter_le_device_scan_result_info_s *info, bt_le_device_info_s **dev_info)
{
&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;int manufacturer_id = -1;
&nbsp;&nbsp;&nbsp;int tx_power_level = 0;
&nbsp;&nbsp;&nbsp;int appearance = 0;
&nbsp;&nbsp;&nbsp;int services_count = 0;
&nbsp;&nbsp;&nbsp;int services_solicitation_count = 0;
&nbsp;&nbsp;&nbsp;int data_count = 0;
&nbsp;&nbsp;&nbsp;char **services = NULL;
&nbsp;&nbsp;&nbsp;char **services_solicitation = NULL;
&nbsp;&nbsp;&nbsp;bt_adapter_le_service_data_s *data = NULL;

&nbsp;&nbsp;&nbsp;bt_le_get_scan_manufacturer_data(info, &manufacturer_id);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_tx_power_level(info, &tx_power_level);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_appearance(info, &appearance);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_uuids(info, &services, &services_count);
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_solicitation_uuids(info, &services_solicitation, &services_solicitation_count);
&nbsp;&nbsp;&nbsp;/* Service's data acquisition. If any data is carried by the service then the 'data_count' variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points to the number of services exposing its information carried by the 'data' array. */
&nbsp;&nbsp;&nbsp;bt_le_get_scan_service_data_list(info, &data, &data_count);

&nbsp;&nbsp;&nbsp;model_set_device_info(dev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx_power_level,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appearance,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_count,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_solicitation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;services_solicitation_count);

&nbsp;&nbsp;&nbsp;/* For each service ... */
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; data_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model_set_device_data(dev_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... identified by UUID ... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_uuid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... its data is acquired ... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... of 'service_data_len' size ... */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[i].service_data_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... and stored in model's structure. */

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services[i]);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; services_solicitation_count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(services_solicitation[i]);

&nbsp;&nbsp;&nbsp;free(services);
&nbsp;&nbsp;&nbsp;free(services_solicitation);

&nbsp;&nbsp;&nbsp;if (data || data_count > 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_le_free_service_data_list(data, data_count);

&nbsp;&nbsp;&nbsp;view_main_update_peer_info(*dev_info);
}
</pre>

<p>
If the number of services/solicitation services is non-zero, then the 'Check' button in device's detailed view becomes enabled. Once clicked, the popup with a list of all available services/solicitation
services exposed by the advertiser appears.
<br>
All the acquired information is binded to the previously obtained remote device name and stored internally for further use.
<br>
Finally, the user interface is updated with <span style="font-family: Courier New,Courier,monospace">view_main_update_peer_info()</span> function to reflect received data.
</p>

<!--
<h3 id="reference">Reference</h3>
__scan_start_request_cb
__scan_cancel_request_cb
__peer_select_request_cb

__is_feature_supported
__set_state
__add_found_le_device
__bt_le_is_device_registered
bt_init
bt_deinit
bt_set_callbacks
bt_unset_callbacks
bt_get_state
bt_le_start_scan
bt_le_get_adv_device_name
bt_le_get_adv_manufacturer_data
bt_le_get_adv_tx_power_level
bt_le_get_adv_appearance
bt_le_get_adv_service_uuids
bt_le_get_adv_service_solicitation_uuids
bt_le_get_scan_device_name
bt_le_get_scan_manufacturer_data
bt_le_get_scan_tx_power_level
bt_le_get_scan_appearance
bt_le_get_scan_service_uuids
bt_le_get_scan_service_solicitation_uuids
bt_le_get_scan_service_data_list
bt_le_free_service_data_list

model_free
model_set_device_info
model_set_device_data
model_check_device_selected
view_main_destroy
view_main_update_peer_info
-->

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

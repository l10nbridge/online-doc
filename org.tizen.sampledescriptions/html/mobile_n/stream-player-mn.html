<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Stream-Player Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mn_icon.png"/></p>
	</div>

<!-- ********************************************************************************** -->

	<h1>Stream-Player Sample Overview</h1>
	<p>This sample demonstrates how to use the Player API to play audio and video files as well as stream media files from the Web.</p>

	<p>The figure below illustrates the application's view.</p>
	<p class="figure">Figure 1: Stream-Player application's screen</p>
<p id="app-screenshot" style="text-align:center;">
	<img alt="Application screen" height="364" hspace="20" src="../images/stream-player/stream-player-application-view.png" />
</p>

<p>The sample application's user interface consists of a single view divided into the following sections:</p>
<ul>
	<li>Toolbar - Allows the user to choose a file to be played, display information about the file, or capture a screenshot from the played video;</li>
	<li>Option Panel - Allows the user to set the volume level, switch the mute option or switch the looping mode;</li>
	<li>Playback options area - Allows the user to set the play, pause and stop options. It also allows to use the seek and playback rate options;</li>
	<li>Display / Album art area - The played video or album art of a music file is displayed here. Note that if the music file does not provide any album art, a musical note image is displayed instead.</li>
</ul>


<p class="figure">Figure 2: Stream-Player layout structure</p>
<p id="layout-structure" style="text-align:center;">
	<img alt="Stream-Player layout structure" height="550" hspace="80" src="../images/stream-player/stream-player-layout-structure.png" />
</p>

<p>The application's workflow can be divided into the following pipelines:</p>
<ul>
	<li>application initialization;</li>
	<li>local file playback;</li>
	<li>online file playback.</li>
</ul>


<p class="figure">Figure 3: Stream-Player application workflow</p>
<p id="stream-player-application-workflow" style="text-align:center;">
	<img alt="Stream-Player application workflow" height="550" hspace="80" src="../images/stream-player/stream-player-application-workflow.png" />
</p>

<h3>Prerequisites</h3>
<p>To ensure proper application execution, the following privileges must be set:</p>
<ul>
	<li>http://tizen.org/privilege/network.get;</li>
	<li>http://tizen.org/privilege/mediastorage;</li>
	<li>http://tizen.org/privilege/internet;</li>
	<li>http://tizen.org/privilege/network.set;</li>
	<li>http://tizen.org/privilege/content.write;</li>
	<li>http://tizen.org/privilege/appmanager.launch;</li>
	<li>http://tizen.org/privilege/network.profile;</li>
	<li>http://tizen.org/privilege/externalstorage.</li>
</ul>


<!-- ********************************************************************************** -->

<h2>Implementation</h2>
<h3>Type Definitions</h3>
<p> The <span style="font-family: Courier New,Courier,monospace">view_info_s</span> structure contains references to objects created by the view module.</p>
<pre class="prettyprint">
struct view_info_s {
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *conform;
&nbsp;&nbsp;&nbsp;Evas_Object *grid;
&nbsp;&nbsp;&nbsp;Evas_Object *button_panel;
&nbsp;&nbsp;&nbsp;Evas_Object *pause_play_btn;
&nbsp;&nbsp;&nbsp;Evas_Object *toolbar;
&nbsp;&nbsp;&nbsp;Evas_Object *progress_panel;
&nbsp;&nbsp;&nbsp;Evas_Object *seek_slider;
&nbsp;&nbsp;&nbsp;Evas_Object *playback_rate_slider;
&nbsp;&nbsp;&nbsp;Evas_Object *buffer_progress_bar;
&nbsp;&nbsp;&nbsp;Evas_Object *option_panel;
&nbsp;&nbsp;&nbsp;Evas_Object *mute_check;
&nbsp;&nbsp;&nbsp;Evas_Object *display;
&nbsp;&nbsp;&nbsp;Evas_Object *album_art;
&nbsp;&nbsp;&nbsp;Evas_Object *current_popup;
&nbsp;&nbsp;&nbsp;Eina_Bool play_btn_play_mode_on;
&nbsp;&nbsp;&nbsp;int found_storage_id;
&nbsp;&nbsp;&nbsp;Eina_Stringshare *video_path;
&nbsp;&nbsp;&nbsp;Eina_Stringshare *audio_path;
&nbsp;&nbsp;&nbsp;Eina_Stringshare *stream_uri;
&nbsp;&nbsp;&nbsp;Eina_Bool use_stream_album_art;
&nbsp;&nbsp;&nbsp;Ecore_Timer *progress_timer;
};
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">player_s</span> structure contains the objects used in the model.</p>
<pre class="prettyprint">
struct player_s {
&nbsp;&nbsp;&nbsp;player_h player;
&nbsp;&nbsp;&nbsp;Evas_Object *display;
&nbsp;&nbsp;&nbsp;struct player_callback_s callbacks;
};
</pre>


<p>The <span style="font-family: Courier New,Courier,monospace">player_callback_s</span> structure contains pointers to callback functions used to send information from the model to the view.</p>

<pre class="prettyprint">
struct player_callback_s {
&nbsp;&nbsp;&nbsp;Player_Status_Changed_cb_t player_status_changed_cb;
&nbsp;&nbsp;&nbsp;Player_Progress_Changed_cb_t player_progress_changed_cb;
&nbsp;&nbsp;&nbsp;Player_Progress_End_cb_t player_progress_end_cb;
&nbsp;&nbsp;&nbsp;Player_Screen_cb_t player_screen_cb;
&nbsp;&nbsp;&nbsp;Player_Message_cb_t player_msg_cb;
&nbsp;&nbsp;&nbsp;Player_Buffer_progress_cb_t player_buffer_progress_cb;
};
</pre>

<p>The following callbacks are provided:</p>
<ul>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Status_Changed_cb_t</span> - invoked when the player's state changes;</li>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Progress_Changed_cb_t</span> - invoked when there is a change in the playback progress e.g. after the user moves the seek slider;</li>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Progress_End_cb_t</span> - invoked when the playback ends. Note that the function is not invoked when the loop mode is used;</li>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Screen_cb_t</span> - invoked when a screenshot is taken;</li>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Message_cb_t</span> - invoked when a text message should be displayed, e.g an error popup;</li>
	<li><span style="font-family: Courier New,Courier,monospace">Player_Buffer_progress_cb_t</span> - invoked when an online file buffer progress changes.</li>
</ul>

<!-- ********************************************************************************** -->
<h3>Application Initialization</h3>
<p>The entire application life-cycle is implemented in the main.c file, using the common Tizen application structure:</p>

<pre class="prettyprint">
int main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback = {0,};
&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL, };

&nbsp;&nbsp;&nbsp;event_callback.create = __app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = __app_terminate;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, __ui_app_lang_changed, NULL);

&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &event_callback, NULL);
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre>

<p>The Stream-Player application's initialization is done within the <span style="font-family: Courier New,Courier,monospace">__app_create()</span> callback function where the <span style="font-family: Courier New,Courier,monospace">player_model_init()</span> function is responsible for the model's initialization. The <span style="font-family: Courier New,Courier,monospace">view_create_base_gui()</span> function is used to initialize the view module. On the application's termination, the <span style="font-family: Courier New,Courier,monospace">__app_terminate()</span> callback function is invoked, and all resources allocated within the model are freed.</p>

<!-- ********************************************************************************** -->

<h3 id="view">View</h3>
<p>The entire application's GUI is implemented using Elementary widgets and containers. The application's layout is shown in Figure 2. As mentioned above, the application's layout is divided into the following sections:</p>
<ul>
	<li>Toolbar section,</li>
	<li>Display section,</li>
	<li>Playback options section,</li>
	<li>Options section.</li>
</ul>
<p>Note that every section listed above (except for the display) is implemented using an Elementary <span style="font-family: Courier New,Courier,monospace">Box</span> container, filled with Elementary widgets. This box is then packed into a <span style="font-family: Courier New,Courier,monospace">grid</span> container.</p>


<table>
	<caption>Table: Base view creation code snippets and figures</caption>
	<colgroup>
		<col width="25%"></col>
		<col width="50%"></col>
		<col width="25%"></col>
	</colgroup>
	<tbody>
		<tr>
			<th>Description</th>
			<th>Code snippet</th>
			<th>Figure</th>
		</tr>

		<tr>
			<td>The toolbar section is created using the <span style="font-family: Courier New,Courier,monospace">__create_toolbar()</span> function. The toolbar contains five buttons, created using the <span style="font-family: Courier New,Courier,monospace">__create_button()</span> function. The functions provide the user with access to both video and audio files as well as the ability to stream online files. The last two buttons allow the user to capture a screenshot of the displayed video and display information about current file.</td>
			<td>
				<pre class="prettyprint">
static Eina_Bool __create_toolbar(void)
{
&nbsp;&nbsp;&nbsp;s_info.toolbar = elm_box_add(s_info.grid);
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;elm_box_padding_set(s_info.toolbar, 10, 0);
&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(s_info.toolbar, EINA_TRUE);

&nbsp;&nbsp;&nbsp;elm_grid_pack(s_info.grid,  s_info.toolbar,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TOOLBAR_GEOMETRY_X, TOOLBAR_GEOMETRY_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TOOLBAR_GEOMETRY_W, TOOLBAR_GEOMETRY_H);

&nbsp;&nbsp;&nbsp;if (!__create_button(s_info.toolbar,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_FALSE,  0.1, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AUDIO_FILE_PATH, __toolbar_file_open_cb, (void*)EINA_FALSE))
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if (!__create_button(s_info.toolbar,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_FALSE,  0.1, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VIDEO_FILE_PATH, __toolbar_file_open_cb, (void*)EINA_TRUE))
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if (!__create_uri_entry())
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if (!__create_button(s_info.toolbar,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_FALSE, 0.1, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCREENSHOT_ICON_FILE, __screen_capture_btn_clicked_cb, NULL))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (!__create_button(s_info.toolbar,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_FALSE, 0.1, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INFO_ICON_FILE, __info_display_btn_clicked_cb, NULL))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_show(s_info.toolbar);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
			</td>
			<td>
				<p style="text-align:center;">
					<img alt="stream-player-toolbar-section" src="../images/stream-player/view/stream-player-toolbar-section.png" />
				</p>
			</td>
		</tr>

		<tr id="display-section-layout">
			<td>
				The display section is made of two stacked objects:
				<ul>
					<li>The Display (top object) - used to display the played video file;</li>
					<li>The album art (bottom object) - used to display the file's album art.</li>
				</ul>
				<p>The user can tap the display to turn pause on/off.</p>
			</td>
			<td>
				<pre class="prettyprint">
static Eina_Bool __add_display(void)
{
&nbsp;&nbsp;&nbsp;if (!s_info.grid)
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;s_info.display = evas_object_image_add(evas_object_evas_get(s_info.grid));
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_image_filled_set(s_info.display, EINA_TRUE);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(s_info.display,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EVAS_CALLBACK_MOUSE_DOWN, __display_clicked_cb, NULL);
&nbsp;&nbsp;&nbsp;elm_grid_pack(s_info.grid, s_info.display,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DISPLAY_GEOMETRY_X, DISPLAY_GEOMETRY_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DISPLAY_GEOMETRY_W, DISPLAY_GEOMETRY_H);
&nbsp;&nbsp;&nbsp;evas_object_show(s_info.display);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static Eina_Bool __add_album_art(void)
{
&nbsp;&nbsp;&nbsp;if (!s_info.grid) {
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;s_info.album_art = elm_image_add(s_info.grid);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(s_info.display,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EVAS_CALLBACK_MOUSE_DOWN, __display_clicked_cb, NULL);
&nbsp;&nbsp;&nbsp;elm_grid_pack(s_info.grid, s_info.album_art,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DISPLAY_GEOMETRY_X, DISPLAY_GEOMETRY_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DISPLAY_GEOMETRY_W, DISPLAY_GEOMETRY_H);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
			</td>
			<td>
				<p style="text-align:center;">
					<img alt="stream-player-display-section" src="../images/stream-player/view/stream-player-display-section.png" />
				</p>
			</td>
		</tr>

		<tr id="playback-options-section-layout">
			<td>The playback options section is created from the following objects:
				<ul>
					<li>Elm_Slider - used to set seek position;</li>
					<li>Elm_Button - used to stop the playback;</li>
					<li>Elm_Button - used to toggle the pause mode;</li>
				</ul>

				<p>The Player API does not provide a callback to be invoked when playback progress changes. In order to update the progress slider, an <span style="font-family: Courier New,Courier,monospace">Ecore_Timer</span> is used. The current playback position is read using the <span style="font-family: Courier New,Courier,monospace">player_model_get_progress()</span> function. Check <a href="#model-playback-control">playback-controls</a> for details.</p>
			</td>
			<td>
				<pre class="prettyprint">
static Eina_Bool __create_button_panel(void)
{
&nbsp;&nbsp;&nbsp;s_info.button_panel = elm_box_add(s_info.grid);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(s_info.button_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(s_info.button_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(s_info.button_panel, EINA_TRUE);

&nbsp;&nbsp;&nbsp;elm_grid_pack(s_info.grid,  s_info.button_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BUTTON_PANEL_GEOMETRY_X, BUTTON_PANEL_GEOMETRY_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BUTTON_PANEL_GEOMETRY_W, BUTTON_PANEL_GEOMETRY_H);

&nbsp;&nbsp;&nbsp;if (!__create_button(s_info.button_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_TRUE, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BTN_ICON_STOP, __button_stop_clicked_cb, NULL))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;s_info.pause_play_btn = __create_button(s_info.button_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_TRUE, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BTN_ICON_PLAY, __button_pause_play_clicked_cb, NULL);
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;evas_object_show(s_info.button_panel);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
			</td>
			<td>
				<p style="text-align:center;">
					<img alt="stream-player-playback-options-section" src="../images/stream-player/view/stream-player-playback-options-section.png" />
				</p>
			</td>
		</tr>

		<tr>
			<td>The playback options section is created from the following objects:
				<ul>
					<li>Elm_Slider - used to set the volume level;</li>
					<li>Elm_Checkbox - used to set the mute mode;</li>
					<li>Elm_Checkbox - used to set the loop mode;</li>
				</ul>
			</td>
			<td>
				<pre class="prettyprint">
static Eina_Bool __add_option_panel(void)
{
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;s_info.option_panel = elm_box_add(s_info.grid);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;elm_grid_pack(s_info.grid, s_info.option_panel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOUND_PANEL_GEOMETRY_X, SOUND_PANEL_GEOMETRY_Y,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOUND_PANEL_GEOMETRY_W, SOUND_PANEL_GEOMETRY_H);

&nbsp;&nbsp;&nbsp;if (!__add_option_panel_icon(SOUND_ICON_FILE))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (!__add_sound_slider())
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if (!__add_option_panel_icon(MUTE_ICON_FILE))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;s_info.mute_check = __add_option_panel_check(__sound_mute_check_changed_cb);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (!__add_option_panel_icon(LOOP_ICON_FILE))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (!__add_option_panel_check(__playback_looping_changed_cb))
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;evas_object_show(s_info.option_panel);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
			</td>
			<td>
				<p style="text-align:center;">
					<img alt="stream-player-options-section" src="../images/stream-player/view/stream-player-options-section.png" />
				</p>
			</td>
		</tr>
	</tbody>
</table>

<!-- ********************************************************************************** -->

<h5>Information popup</h5>
<p>The information popup displays a text message with all information about a file gathered by the <a href="model-file-information">model</a>. The function below generates the message.</p>
<pre class="prettyprint">
static char *__get_stream_info(void)
{
&nbsp;&nbsp;&nbsp;// Variables declaration

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, "===== Stream info =====");

&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_ALBUM,  msg, "Album: ");
&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_ARTIST, msg, "Artist: ");
&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_AUTHOR, msg, "Author: ");
&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_GENRE,  msg, "Genre: ");
&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_TITLE,  msg, "Title: ");
&nbsp;&nbsp;&nbsp;__append_content_info(PLAYER_CONTENT_INFO_YEAR,   msg, "Year: ");

&nbsp;&nbsp;&nbsp;player_model_get_codec(&audio_codec, &video_codec);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, "CODECS Audio: %s; Video: %s", audio_codec, video_codec);
&nbsp;&nbsp;&nbsp;__append_underlined_text(msg, "Codecs:");
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Audio: ", "%s%s", audio_codec, NEW_LINE);
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Video: ", "%s%s", video_codec, NEW_LINE);
&nbsp;&nbsp;&nbsp;free(audio_codec);
&nbsp;&nbsp;&nbsp;free(video_codec);

&nbsp;&nbsp;&nbsp;player_model_get_audio_stream_info(&sample_rate, &channel, &bit_rate);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, "AUDIO STREAM INFO: sample rate: %d; channel: %d; bit rate: %d", sample_rate, channel, bit_rate);
&nbsp;&nbsp;&nbsp;__append_underlined_text(msg, "Audio stream info:");
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Sample rate: ", "%d%s", sample_rate, NEW_LINE);
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Channel: ", "%d%s", channel, NEW_LINE);
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Bit rate: ", "%d%s", bit_rate, NEW_LINE);

&nbsp;&nbsp;&nbsp;player_model_get_video_stream_info(&fps, &bit_rate);
&nbsp;&nbsp;&nbsp;player_model_get_video_size(&width, &height);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, "VIDEO STREAM INFO: FPS: %d; bit_rate: %d; size=[%d, %d]", fps, bit_rate, width, height);
&nbsp;&nbsp;&nbsp;__append_underlined_text(msg, "Video stream info:");
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "FPS: ", "%d%s", fps, NEW_LINE);
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Bit rate: ", "%d%s", bit_rate, NEW_LINE);
&nbsp;&nbsp;&nbsp;__append_bolded_text(msg, "Size: ", "%d x %d", width, height);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, "===== Stream info =====");

&nbsp;&nbsp;&nbsp;eina_strbuf_replace_all(msg, "&", "&amp;amp;"); //Every '&' character has to be replaced with '&amp;amp;'
&nbsp;&nbsp;&nbsp;ret = eina_strbuf_string_steal(msg);
&nbsp;&nbsp;&nbsp;eina_strbuf_free(msg);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
<p>The text part of the popup uses tags similar to the HTML's ones. This can used to bold or underline parts of the text.</p>
<pre class="prettyprint">
static inline Eina_Stringshare *__bold_text(char *txt)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;return eina_stringshare_printf("&ltfont_weight=bold>%s&lt/font_weight&gt", txt); //&ltfont_weight=bold>%s&lt/font_weight> %s will be bolded
}

static inline void __append_bolded_text(Eina_Strbuf *msg, char *key, char *format, ...)
{
&nbsp;&nbsp;&nbsp;va_list args;
&nbsp;&nbsp;&nbsp;Eina_Stringshare *bolded = __bold_text(key);
&nbsp;&nbsp;&nbsp;va_start(args, format);
&nbsp;&nbsp;&nbsp;eina_strbuf_append(msg, bolded);
&nbsp;&nbsp;&nbsp;eina_strbuf_append_vprintf(msg, format, args);
&nbsp;&nbsp;&nbsp;eina_stringshare_del(bolded);
&nbsp;&nbsp;&nbsp;va_end(args);
}

static inline Eina_Stringshare *__underline_text(const char *txt, const char *color)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;return eina_stringshare_printf("&ltunderline=on underline_color=%s&gt%s&lt/underline&gt", color ? color : "#000000", txt);
&nbsp;&nbsp;&nbsp;//"&ltunderline=on underline_color=%s&gt%s&lt/underline&gt %s will be underlined. Note that the default color of the underline is white.
}

static inline void __append_underlined_text(Eina_Strbuf *msg, const char *txt)
{
&nbsp;&nbsp;&nbsp;Eina_Stringshare *underlined = __underline_text(txt, "#000000");
&nbsp;&nbsp;&nbsp;eina_strbuf_append_printf(msg, "%s%s", underlined, NEW_LINE);
&nbsp;&nbsp;&nbsp;eina_stringshare_del(underlined);
}
</pre>
<p>Refer to the links below for information about the tags:</p>
<ul>
	<li><a href="https://developer.tizen.org/ko/development/ui-practices/native-application/efl/graphical-objects/evas-objects?langredirect=1#block">Textblock</a>;</li>
	<li><a href="https://developer.tizen.org/ko/development/ui-practices/native-application/efl/fonts?langredirect=1">Fonts</a>.</li>
</ul>

<!-- ********************************************************************************** -->

<h3>Model</h3>

<p>The image below describes the typical state changes of the player.</p>
<p class="figure">Figure 4: Stream-Player state changes</p>
<p id="state-changes" style="text-align:center;">
	<img alt="Stream-Player state changes" height="550" hspace="80" src="../images/stream-player/stream-player-state-changes.png" />
</p>

<h5>Initialization</h5>

<pre class="prettyprint">
void player_model_init(Player_Status_Changed_cb_t player_status_changed_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Player_Progress_Changed_cb_t player_progress_changed_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Player_Progress_End_cb_t player_progress_end_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Player_Screen_cb_t player_screen_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Player_Message_cb_t player_msg_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Player_Buffer_progress_cb_t player_buffer_progress_cb)
{
&nbsp;&nbsp;&nbsp;int error_code = player_create(&s_info.player);
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_status_changed_cb = player_status_changed_cb;
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_progress_changed_cb = player_progress_changed_cb;
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_progress_end_cb = player_progress_end_cb;
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_screen_cb = player_screen_cb;
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_msg_cb = player_msg_cb;
&nbsp;&nbsp;&nbsp;s_info.callbacks.player_buffer_progress_cb = player_buffer_progress_cb;

&nbsp;&nbsp;&nbsp;if (player_set_interrupted_cb(s_info.player, __player_interrupted_cb, NULL) != PLAYER_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_completed_cb(s_info.player, __player_completed_cb, NULL) != PLAYER_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_error_cb(s_info.player, __player_error_cb, NULL) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_buffering_cb(s_info.player, __player_buffering_cb, NULL) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_progressive_download_message_cb(s_info.player, __progressive_download_message_cb, NULL) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_video_stream_changed_cb(s_info.player, __video_stream_changed_cb, NULL) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_media_stream_buffer_status_cb (s_info.player,  PLAYER_STREAM_TYPE_AUDIO, __media_stream_buffer_status_cb, (void *)PLAYER_STREAM_TYPE_AUDIO) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_media_stream_buffer_status_cb (s_info.player, PLAYER_STREAM_TYPE_VIDEO, __media_stream_buffer_status_cb, (void *)PLAYER_STREAM_TYPE_VIDEO) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_media_stream_seek_cb(s_info.player, PLAYER_STREAM_TYPE_AUDIO, __media_stream_seek_cb, (void *)PLAYER_STREAM_TYPE_AUDIO) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (player_set_media_stream_seek_cb(s_info.player, PLAYER_STREAM_TYPE_VIDEO, __media_stream_seek_cb, (void *)PLAYER_STREAM_TYPE_VIDEO) != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre>

<p>First of all, a player object has to be created using the <span style="font-family: Courier New,Courier,monospace">player_create()</span> function. If the player is created successfully, we can set all required player callbacks. Check the <a href="https://developer.tizen.org/development/api-references/native-application?redirect=https%3A//developer.tizen.org/dev-guide/2.4.0/org.tizen.native.mobile.apireference/index.html">API documentation</a> for callback's details. Also, the <span style="font-family: Courier New,Courier,monospace">view</span> module callbacks are assigned here.</p>

<h5>Playing a file</h5>

<pre class="prettyprint">
player_error_e player_model_play_file(const char *file_path)
{
&nbsp;&nbsp;&nbsp;// Variables declaration

&nbsp;&nbsp;&nbsp;if (!s_info.player)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (!s_info.display)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;player_model_set_mute(EINA_FALSE);

&nbsp;&nbsp;&nbsp;error_code = player_get_state(s_info.player, &state);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;if (state != PLAYER_STATE_IDLE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (state != PLAYER_STATE_IDLE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "Setting player state to idle");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_code = player_unprepare(s_info.player);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;error_code = player_set_uri(s_info.player, file_path);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;error_code = player_set_display(s_info.player, PLAYER_DISPLAY_TYPE_EVAS, GET_DISPLAY(s_info.display));
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;error_code = player_prepare(s_info.player);
&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;error_code = player_start(s_info.player);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return PLAYER_ERROR_NONE;
}
</pre>

<p>The function above is used to play a given file. Note that there is no difference between a video or audio local file and an online file when it comes to the implementation. Only a correct URI is required. Note that if the player state is different than <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_IDLE</span>, the <span style="font-family: Courier New,Courier,monospace">player_state_unprepare()</span> has to be called first. If not, the previously loaded file will be played instead of the given one. Also, the mute mode has to be turned off before the new file is loaded. After that, the player is ready to load a new file. The file can be loaded using the <span style="font-family: Courier New,Courier,monospace">player_set_uri()</span> function. Also, the <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> used as the display object can now be set using the <span style="font-family: Courier New,Courier,monospace">player_set_display()</span> function. Finally, the player can be set to <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_READY</span> state using <span style="font-family: Courier New,Courier,monospace"> player_prepare()</span> function and the playback can be started by invoking the <span style="font-family: Courier New,Courier,monospace">player_start()</span> function.</p>

<!-- ********************************************************************************** -->

<h5 id="model-playback-control">Playback control</h5>
<p>The Player API provides the following basic playback control options:</p>
<ul>
	<li>play,</li>
	<li>pause,</li>
	<li>stop.</li>
</ul>

<p>The options above change the state of the player (refer the Figure 4 for details) and can be accessed by the user using the <a href="#playback-options-section-layout">playback options section</a> widgets. There is also a seek option available. The view part provides the user with a slider to adjust the playback's progress. Note that the <span style="font-family: Courier New,Courier,monospace">player_get_duration()</span> function can be used to get the length of the file and set the maximum value of the mentioned slider.</p>

<p>Apart from the basic playback control options, the following features are also implemented:</p>
<ul>
	<li>mute - set using the <span style="font-family: Courier New,Courier,monospace">player_set_mute()</span> function;</li>
	<li>loop - set using the <span style="font-family: Courier New,Courier,monospace">player_set_looping()</span> function;</li>
	<li>volume - set using the <span style="font-family: Courier New,Courier,monospace">player_set_volume()</span> function. The sound of the player can be set independently from the system volume settings.</li>
</ul>
<p>Note that when the loop mode is on, the <span style="font-family: Courier New,Courier,monospace">__player_completed_cb</span> callback function is <b>not</b> invoked.</p>

<h5>Other functionalities</h5>
<p>Some of the multimedia files provide an album art image that can be displayed during the playback. To display such an image, the <span style="font-family: Courier New,Courier,monospace">player_get_album_art()</span> function has to be invoked. Raw image data is provided after a succesful call. The data can be later passed to <span style="font-family: Courier New,Courier,monospace">elm_image_memfile_set()</span> function to create an image object that will be set in the display section./p>
<p>During the playback of a video file (local or online) a screenshot can be taken at any moment using the <span style="font-family: Courier New,Courier,monospace">player_capture_video()</span> function. If the capture is successful, the <span style="font-family: Courier New,Courier,monospace">__video_captured_cb()</span> callback function is invoked with the image size and raw data as its parameters. Then, an image file is generated using <span style="font-family: Courier New,Courier,monospace">image_util_encode_jpeg()</span> function. The image is saved in the internal storage of the device, in the Images folder. To get the correct path to the file, <span style="font-family: Courier New,Courier,monospace">__get_storage_path()</span> and <span style="font-family: Courier New,Courier,monospace">__get_storage_path_cb()</span> functions listed below are used.</p>

<pre class="prettyprint">
static bool __get_storage_path_cb(int storage_id, storage_type_e type, storage_state_e state, const char *path, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (type == STORAGE_TYPE_INTERNAL) // Check if the storage type is internal
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.found_storage_id = storage_id; // Save the internal storage key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false; // Stop iterating
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true; // Continue interating
}
</pre>
<pre class="prettyprint">
static char *__get_storage_path(storage_directory_e dir)
{
&nbsp;&nbsp;&nbsp;// Variables declaration

&nbsp;&nbsp;&nbsp;error_code = storage_foreach_device_supported(__get_storage_path_cb, NULL); //iterate each available storages
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;error_code = storage_get_directory(s_info.found_storage_id, dir, &path); //get the path to the storage
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return path;
}
</pre>
<p>Note that to get access to the storage of the device, the <span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/mediastorage</span> privilege must be set. In order to display the image in the gallery application, it has to be added to the media content database using the <span style="font-family: Courier New,Courier,monospace">__insert_image_info_to_db()</span> function.</p>
<pre class="prettyprint">
static void __insert_image_info_to_db(const char *path)
{
&nbsp;&nbsp;&nbsp;int ret = media_content_connect();
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;ret = media_content_scan_file(path);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;ret = media_content_disconnect();
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre>

<!-- ********************************************************************************** -->

<p id="model-file-information">Another feature of the sample application is file's information displaying. Multimedia files provide information about their content which can be accessed using the Player API. The data include:</p>
<ul>
	<li>album name,</li>
	<li>artist name,</li>
	<li>author name,</li>
	<li>genre,</li>
	<li>title,</li>
	<li>year,</li>
	<li>audio codec name,</li>
	<li>video codec name,</li>
	<li>audio sample rate,</li>
	<li>audio channel,</li>
	<li>audio bit rate,</li>
	<li>video frames per second,</li>
	<li>video bit rate,</li>
	<li>video size.</li>
</ul>
<p>The functions below are used to get the file's information.</p>
<pre class="prettyprint">
char *player_model_get_content_info(player_content_info_e key)
{
&nbsp;&nbsp;&nbsp;char *value = NULL;

&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;player_get_content_info(s_info.player, key, &value);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "player_model_content_info_get(%d) == %s", key, value);
&nbsp;&nbsp;&nbsp;return value;
}

void player_model_get_codec(char **audio_codec, char **video_codec)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;player_get_codec_info(s_info.player, audio_codec, video_codec);
}

void player_model_get_audio_stream_info(int *sample_rate, int *channel, int *bit_rate)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;player_get_audio_stream_info(s_info.player, sample_rate, channel, bit_rate);
}

void player_model_get_video_stream_info(int *fps, int *bit_rate)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;player_get_video_stream_info(s_info.player, fps, bit_rate);
}

void player_model_get_video_size(int *width, int *height)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;player_get_video_size(s_info.player, width, height);
}
</pre>
<p>Note that not every file provides all the mentioned data.</p>

<h5>Device orientation</h5>
<p>When the device orientation changes, the <span style="font-family: Courier New,Courier,monospace">player_model_set_orientation()</span> function is invoked.</p>
<pre class="prettyprint">
void player_model_set_orientation(Eina_Bool is_horizontal)
{
&nbsp;&nbsp;&nbsp;if (is_horizontal) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_mode(s_info.player, PLAYER_DISPLAY_MODE_FULL_SCREEN);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_rotation(s_info.player, PLAYER_DISPLAY_ROTATION_NONE);
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_mode(s_info.player, PLAYER_DISPLAY_MODE_ORIGIN_OR_LETTER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_rotation(s_info.player, PLAYER_DISPLAY_ROTATION_NONE);
&nbsp;&nbsp;&nbsp;}
}
</pre>
<p> The function changes the display mode of the player object. The layout of the application is changed as well - the display section is streched to cover the whole screen while other sections are hidden.</p>

<!-- ********************************************************************************** -->
<h5>Player deinitialization</h5>
<p>The function below is used deinitialize and destroy the player object.</p>
<pre class="prettyprint">
void player_model_deinit(void)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;error_code = player_stop(s_info.player);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;error_code = player_unprepare(s_info.player);
&nbsp;&nbsp;&nbsp;// Error handling and callbacks deinitialization

&nbsp;&nbsp;&nbsp;error_code = player_destroy(s_info.player);
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre>
<p>Note that any working playback should be stopped and the player should be put into the <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_IDLE</span> state before it can be destroyed.</p>

<!-- ********************************************************************************** -->

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

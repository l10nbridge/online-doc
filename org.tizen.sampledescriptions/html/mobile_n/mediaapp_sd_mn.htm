<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>Media App Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>

<h1>Media App Sample Overview</h1> 
<p>The Media App sample demonstrates how to develop a media handling application with the ability to open, decode, and transform different media sources, such as video, images, and sound files.</p>
<p>The following figure illustrates the starting screen of the Media App.</p>

<p class="figure">Figure: Media App main view</p> 
<p align="center"><img alt="Media App main view" src="../images/mediaapp_main.png" /></p> 

<p>The purpose of this sample application is to demonstrate how to use the Media API to open, decode, and transform images. Each form contains appropriate UI components to enter the required data, such as phone number, message content, and buttons to send messages or emails.</p>

<p>This sample consists of the following:</p>
<ul>
 <li>Image
	<ul>
	<li><a href="#image">Image Viewer</a>
	<p>Decode images.</p></li>
	<li><a href="#image_conv">Image Converter</a>
	<p>Convert images.</p></li>
	<li><a href="#gif">GIF Viewer</a>
	<p>Open and play GIF images.</p></li>
	<li><a href="#flip">Flip</a>
	<p>Flip and rotate images.</p></li>
	<li><a href="#resize">Image Resize</a>
	<p>Resize images.</p></li>
	<li><a href="#color">Color Converter</a>
	<p>Convert images to pixel format.</p></li>
	<li><a href="#frame">Frame Extractor</a>
	<p>Extract frames.</p></li>
	</ul>
 </li>
 <li>Audio
	<ul>
	<li><a href="#tone">Tone Player</a>
	<p>Play the keypad tone sounds</p></li>
	<li><a href="#inout">Audio In Out</a>
	<p>Record and play audio.</p></li>
	<li><a href="#equal">Audio Equalizer</a>
	<p>Control the equalizer.</p></li>
	<li><a href="#gles">Gles Cube Player</a>
	<p>Manage the OpenGL&reg; functionality with audio streaming.</p></li>
	</ul>
 </li>
 <li>Player
	<ul>
	<li><a href="#media">Media Player</a>
	<p>Play media from different sources</p></li>
	<li><a href="#multi">Multi Play</a>
	<p>Play different kinds of media simultaneously.</p></li>
	<li><a href="#cam_play">Camera and Player</a>
	<p>Manage camera preview and video player</p></li>
	<li><a href="#vid_play">Video Recorder and Player</a>
	<p>Manage camera recording and video player.</p></li>
	</ul>
 </li>
 <li>Recorder
	<ul>
	<li><a href="#camera">Camera Capture</a>
	<p>Manage the camera frame capturing.</p></li>
	<li><a href="#video">Video Recorder</a>
	<p>Manage video recording.</p></li>
	<li><a href="#audio">Audio Recorder</a>
	<p>Manage audio recording.</p></li>
	</ul>
 </li>
 </ul>

<h2>Image</h2>

<h3 id="image" name="image">Image Viewer</h3>
<p>This view allows the user to decode, change the scale, and convert the pixel format of images and fit them to the display. Internally, when the resize slider is changed and released, the <span style="font-family: Courier New,Courier,monospace;">_slider_drag_stop_cb</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">update_scale</span> method is executed:</p>

<pre class="prettyprint">
static void 
_update_scale(image_viewer_view *view)
{
&nbsp;&nbsp;&nbsp;RETM_IF(NULL == view, &quot;view is NULL&quot;);
&nbsp;&nbsp;&nbsp;Evas_Object *evas_image = elm_image_object_get(view-&gt;image);
&nbsp;&nbsp;&nbsp;double scale = elm_slider_value_get(view-&gt;slider) / DEFAULT_SCALE;
&nbsp;&nbsp;&nbsp;Evas_Coord_Rectangle new_geometry = {};
&nbsp;&nbsp;&nbsp;bool result = ic_calc_image_new_geometry(evas_image, view-&gt;image_scroller, scale, &amp;new_geometry);
&nbsp;&nbsp;&nbsp;RETM_IF(!result, &quot;error: on image new geometry calculation&quot;);

&nbsp;&nbsp;&nbsp;evas_object_image_fill_set(evas_image, 0, 0, new_geometry.w, new_geometry.h);
&nbsp;&nbsp;&nbsp;evas_object_resize(evas_image, new_geometry.w, new_geometry.h);
&nbsp;&nbsp;&nbsp;evas_object_move(evas_image, new_geometry.x, new_geometry.y);

&nbsp;&nbsp;&nbsp;_update_scale_factor_params(view);
}
</pre>

<p class="figure">Figure: Image viewer</p> 
<p align="center"><img alt="Image viewer" src="../images/mediaapp_image_viewer.png" /></p> 

<h3 id="image_conv" name="image_conv">Image Converter</h3>

<p>This view allows the user to transform a source image into a new image with a different pixel format and size. Internally, when the <strong>Change pixel format</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_change_format</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">_process</span> method executed:</p>

<pre class="prettyprint">
int 
image_sample_util_resize(const int src_w, const int src_h, const uchar *src, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int dest_w, const int dest_h,  uchar *dest)
{
&nbsp;&nbsp;&nbsp;if (src_w &lt;= 0 || src_h &lt;= 0 || !src || dest_w &lt;= 0 || dest_h &lt;= 0 || !dest)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_INVALID_PARAMETER;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;int h = 0, w = 0;
&nbsp;&nbsp;&nbsp;float t, u, coef;
&nbsp;&nbsp;&nbsp;t = u = coef = 0.0;
&nbsp;&nbsp;&nbsp;float c1, c2, c3, c4;
&nbsp;&nbsp;&nbsp;c1 = c2 = c3 = c4 = 0.0;
&nbsp;&nbsp;&nbsp;u_int32_t pixel1, pixel2, pixel3, pixel4;
&nbsp;&nbsp;&nbsp;pixel1 = pixel2 = pixel3 = pixel4 = 0;
&nbsp;&nbsp;&nbsp;u_int32_t *pixel_res = NULL;
&nbsp;&nbsp;&nbsp;u_int32_t red, green, blue, alpha;
&nbsp;&nbsp;&nbsp;red = green = blue = alpha = 0;

&nbsp;&nbsp;&nbsp;int i = 0, j = 0;
&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; dest_h; j++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coef = (float) (j) / (float) (dest_h - 1) * (src_h - 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = (int) floor(coef);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (h &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (h &gt;= src_h - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = src_h - 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = coef - h;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; dest_w; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coef = (float) (i) / (float) (dest_w - 1) * (src_w - 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = (int) floor(coef);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (w &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (w &gt;= src_w - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = src_w - 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = coef - w;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1 = (1 - t) * (1 - u);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2 = t * (1 - u);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c3 = t * u;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c4 = (1 - t) * u;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel1 = *((u_int32_t*) (src + BRGA_BPP * (h * src_w + w)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel2 = *((u_int32_t*) (src + BRGA_BPP * (h * src_w + w + 1)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel3 = *((u_int32_t*) (src + BRGA_BPP * ((h + 1) * src_w + w + 1)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel4 = *((u_int32_t*) (src + BRGA_BPP * ((h + 1) * src_w + w)));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = (uchar) pixel1 * c1 + (uchar) pixel2 * c2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) pixel3 * c3 + (uchar) pixel4 * c4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = (uchar) (pixel1 &gt;&gt; 8) * c1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel2 &gt;&gt; 8) * c2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel3 &gt;&gt; 8) * c3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel4 &gt;&gt; 8) * c4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = (uchar) (pixel1 &gt;&gt; 16) * c1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel2 &gt;&gt; 16) * c2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel3 &gt;&gt; 16) * c3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel4 &gt;&gt; 16) * c4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alpha = (uchar) (pixel1 &gt;&gt; 24) * c1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel2 &gt;&gt; 24) * c2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel3 &gt;&gt; 24) * c3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (uchar) (pixel4 &gt;&gt; 24) * c4;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel_res = (u_int32_t*)(dest + BRGA_BPP * (i + j * dest_w));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pixel_res = ((u_int32_t) alpha &lt;&lt; 24) | ((u_int32_t) red &lt;&lt; 16)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ((u_int32_t) green &lt;&lt; 8) | (blue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_NONE;
}

static bool 
_process(image_converter_view *view, double scale)
{
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == view, false, &quot;view is NULL&quot;);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == view-&gt;image_source, false, &quot;view is NULL&quot;);
&nbsp;&nbsp;&nbsp;bool result = true;
&nbsp;&nbsp;&nbsp;int w = 0, h = 0;
&nbsp;&nbsp;&nbsp;Evas_Object* source_eo = elm_image_object_get(view-&gt;image_source);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == source_eo, false, &quot;evas_object image is NULL&quot;);

&nbsp;&nbsp;&nbsp;long long ticks_begin = get_ticks();
&nbsp;&nbsp;&nbsp;evas_object_image_size_get(source_eo, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;RETVM_IF(0 == w * h, false, &quot;wrong size of source image: %d x %d&quot;, w, h);
&nbsp;&nbsp;&nbsp;int dest_width = scale * w;
&nbsp;&nbsp;&nbsp;int dest_height = scale * h;

&nbsp;&nbsp;&nbsp;view-&gt;scale_perc = scale * SLIDER_MAX;
&nbsp;&nbsp;&nbsp;int error = IMAGE_UTIL_ERROR_NONE;
&nbsp;&nbsp;&nbsp;unsigned int dest_size = 0;
&nbsp;&nbsp;&nbsp;unsigned char* dest_buff = NULL;
&nbsp;&nbsp;&nbsp;void* src_buff = evas_object_image_data_get(source_eo, EINA_FALSE);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == src_buff, false, &quot;image_util_calculate_buffer_size error&quot;);

&nbsp;&nbsp;&nbsp;error = image_util_calculate_buffer_size(dest_width, dest_height, IMAGE_UTIL_COLORSPACE_BGRA8888, &amp;dest_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(IMAGE_UTIL_ERROR_NONE != error, false, &quot;image_util_calculate_buffer_size error&quot;);

&nbsp;&nbsp;&nbsp;dest_buff = malloc(dest_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == dest_buff, false, &quot;malloc destination buffer error %d&quot;, dest_size);

&nbsp;&nbsp;&nbsp;error = image_sample_util_resize(w, h, src_buff, dest_width, dest_height, dest_buff);
&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_ERROR_NONE == error)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object* im = evas_object_image_filled_add(evas_object_evas_get(view-&gt;layout));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (im)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_colorspace_set(im, EVAS_COLORSPACE_ARGB8888);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_alpha_set(im, EINA_FALSE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_size_set(im, dest_width, dest_height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_data_copy_set(im, dest_buff);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char output_buf[PATH_MAX] = {&#39;\0&#39;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(output_buf, PATH_MAX, &quot;%s%s%s.%s&quot;, get_resource_path(&quot;&quot;), IMAGE_OUTPUT_DIR, image_names[view-&gt;image_id], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_file_format_to_str(converted_formats[view-&gt;convert_format_ind]));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (EINA_FALSE == evas_object_image_save(im, output_buf, NULL, NULL))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;evas_object_image_save error&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(view-&gt;image_converted_uri, output_buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(im);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;ticks = get_ticks() - ticks_begin;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INF(&quot;Image buffer manipulation: image_sample_util_resize error&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = false;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;free(dest_buff);
&nbsp;&nbsp;&nbsp;dest_buff = NULL;

&nbsp;&nbsp;&nbsp;return result;
}
</pre>

<p class="figure">Figure: Image converter</p> 
<p align="center"><img alt="Image converter" src="../images/mediaapp_image_converter.png" /></p> 

<h3 id="gif" name="gif">GIF Viewer</h3>
<p>This view displays GIF images, and allows the user to change the pixel format. Internally, when the <strong>Next</strong> or <strong>Prev</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_toolbar_button_clicked_cb</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">_change_image</span> method is executed:</p>

<pre class="prettyprint">
static void 
_change_image(gif_viewer_view *this, bool to_next)
{
&nbsp;&nbsp;&nbsp;RETM_IF(NULL == this, &quot;this is NULL&quot;);
&nbsp;&nbsp;&nbsp;unsigned int image_id = this-&gt;image_id;
&nbsp;&nbsp;&nbsp;RETM_IF((to_next &amp;&amp; image_id + 1 &gt;= IMAGES_COUNT), &quot;Out of image container&quot;);
&nbsp;&nbsp;&nbsp;RETM_IF((!to_next &amp;&amp; image_id == 0), &quot;Out of image container&quot;);

&nbsp;&nbsp;&nbsp;if (to_next)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++image_id;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--image_id;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (!ic_load_image(this-&gt;image,  image_file_names[image_id]))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;ic_load_image failed&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;ic_image_set_animated(this-&gt;image);
&nbsp;&nbsp;&nbsp;this-&gt;image_id = image_id;

&nbsp;&nbsp;&nbsp;_update_view_controls(this);
}
</pre>

<p class="figure">Figure: GIF viewer</p> 
<p align="center"><img alt="GIF viewer" src="../images/mediaapp_gif_viewer.png" /></p> 

<h3 id="flip" name="flip">Flip</h3>
<p>This view allows the user to flip and rotate images. Internally, when the <strong>Flip</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_on_button_flip_clicked_cb</span> callback is called:</p>

<pre class="prettyprint">
static void 
_on_button_rotate_clicked_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;RETM_IF(NULL == data, &quot;data is NULL&quot;);
&nbsp;&nbsp;&nbsp;image_flip_rotate_view *view = data;
&nbsp;&nbsp;&nbsp;if (view-&gt;rotate_state + 1 &lt; ROTATE_STATES_MAX)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++(view-&gt;rotate_state);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;rotate_state = ROTATE_STATE_0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;elm_image_orient_set(view-&gt;image_rotate, _convert_to_elm_rotate_state(view-&gt;rotate_state));
&nbsp;&nbsp;&nbsp;_update_rotate_state(view);
&nbsp;&nbsp;&nbsp;_update_label(view);
}
</pre>

<p class="figure">Figure: Flip and rotate view</p> 
<p align="center"><img alt="Flip and rotate view" src="../images/mediaapp_flip_rotate.png" /></p> 

<h3 id="resize" name="resize">Image Resize</h3>

<p>This view allows the user to change the image size. Internally, when the resize slider is changed, the <span style="font-family: Courier New,Courier,monospace;">_slider_drag_stop_cb</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">_update_scale</span> method is executed:</p>

<pre class="prettyprint">
static void 
_update_scale(image_resize_view *view)
{
&nbsp;&nbsp;&nbsp;RETM_IF(NULL == view, &quot;view is NULL&quot;);
&nbsp;&nbsp;&nbsp;Evas_Object *evas_image = elm_image_object_get(view-&gt;image);
&nbsp;&nbsp;&nbsp;double scale = elm_slider_value_get(view-&gt;slider) / DEFAULT_SCALE;
&nbsp;&nbsp;&nbsp;Evas_Coord_Rectangle new_geometry = {};
&nbsp;&nbsp;&nbsp;bool result = ic_calc_image_new_geometry(evas_image, view-&gt;image_scroller, scale, &amp;new_geometry);
&nbsp;&nbsp;&nbsp;RETM_IF(!result, &quot;error: on image new geometry calculation&quot;);

&nbsp;&nbsp;&nbsp;evas_object_image_fill_set(evas_image, 0, 0, new_geometry.w, new_geometry.h);
&nbsp;&nbsp;&nbsp;evas_object_resize(evas_image, new_geometry.w, new_geometry.h);
&nbsp;&nbsp;&nbsp;evas_object_move(evas_image, new_geometry.x, new_geometry.y);
&nbsp;&nbsp;&nbsp;view-&gt;image_scaled_size.w = new_geometry.w;
&nbsp;&nbsp;&nbsp;view-&gt;image_scaled_size.h = new_geometry.h;
}
</pre>

<p class="figure">Figure: Image resize</p> 
<p align="center"><img alt="Image resize" src="../images/mediaapp_image_resize.png" /></p> 

<h3 id="color" name="color">Color Converter</h3>
<p>This view allows the user to change the image pixel format (RGB32, RGB16, YUV420, or YUV422). Internally, when the <strong>Change pixel format</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_toolbar_button_clicked_cb</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">_process_colorspace_convert</span> method is executed:</p>

<pre class="prettyprint">
static bool 
_process_colorspace_convert(color_converter_view *view)
{
&nbsp;&nbsp;&nbsp;long long time_begin = get_ticks();
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == view, false, &quot;view is NULL&quot;);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == view-&gt;image_source, false, &quot;image is NULL&quot;);
&nbsp;&nbsp;&nbsp;Evas_Object* evas_image = elm_image_object_get(view-&gt;image_source);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == evas_image, false, &quot;evas image is NULL&quot;);

&nbsp;&nbsp;&nbsp;free(view-&gt;decoded_buffer);
&nbsp;&nbsp;&nbsp;view-&gt;decoded_buffer = NULL;

&nbsp;&nbsp;&nbsp;int w = 0, h = 0;
&nbsp;&nbsp;&nbsp;evas_object_image_size_get(evas_image, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;RETVM_IF(0 == w * h, false, &quot;wrong size of image: %d x %d&quot;, w, h);

&nbsp;&nbsp;&nbsp;void* src_buff = evas_object_image_data_get(evas_image, EINA_FALSE);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == src_buff, false, &quot;image source buffer is NULL&quot;);

&nbsp;&nbsp;&nbsp;image_util_colorspace_e src_colorspace = SOURCE_COLORSPACE;
&nbsp;&nbsp;&nbsp;image_util_colorspace_e dest_colorspace = colorspaces[view-&gt;color_id_to];
&nbsp;&nbsp;&nbsp;int error = IMAGE_UTIL_ERROR_NONE;
&nbsp;&nbsp;&nbsp;unsigned int dest_size = 0;
&nbsp;&nbsp;&nbsp;error = image_util_calculate_buffer_size(w, h, dest_colorspace, &amp;dest_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(IMAGE_UTIL_ERROR_NONE != error, false, &quot;image_util_calculate_buffer_size error&quot;);

&nbsp;&nbsp;&nbsp;view-&gt;decoded_buffer = malloc(dest_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == view-&gt;decoded_buffer, false, &quot;malloc destination buffer error %d&quot;, dest_size);

&nbsp;&nbsp;&nbsp;error = image_sample_util_convert_colorspace(view-&gt;decoded_buffer, dest_colorspace, src_buff, w, h, src_colorspace);
&nbsp;&nbsp;&nbsp;RETVM_IF(IMAGE_UTIL_ERROR_NONE != error, false, &quot;image_sample_util_convert_colorspace error&quot;);
&nbsp;&nbsp;&nbsp;view-&gt;decode_time = get_ticks() - time_begin;
&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p class="figure">Figure: Color converter</p> 
<p align="center"><img alt="Color converter" src="../images/mediaapp_color_converter.png" /></p>

<h3 id="frame" name="frame">Frame Extractor</h3>
<p>This view allows the user to extract frames from the input video stream. Internally, when the frame slider is changed, the <span style="font-family: Courier New,Courier,monospace;">_sliderbar_changed_cb</span> callback is called and the <span style="font-family: Courier New,Courier,monospace;">frame_extractor_frame_get</span> method is executed:</p>

<pre class="prettyprint">
static inline rgb16
bgra_to_rgb(const bgra32 src)
{
&nbsp;&nbsp;&nbsp;rgb16 result = (rgb16)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((src.r &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_R_SIZE)) &lt;&lt; RGB16_R_SHIFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ((src.g &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_G_SIZE)) &lt;&lt; RGB16_G_SHIFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ((src.b &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_B_SIZE)) &lt;&lt; RGB16_B_SHIFT));

&nbsp;&nbsp;&nbsp;return result;
}

static inline bgra32
rgb_to_bgra(const rgb16 src)
{
&nbsp;&nbsp;&nbsp;bgra32 result = {};
&nbsp;&nbsp;&nbsp;result.r = (uchar)(src &gt;&gt; RGB16_R_SHIFT) &lt;&lt; (RGB32_CHANEL_BIT_SIZE - RGB16_R_SIZE);
&nbsp;&nbsp;&nbsp;result.g = (uchar)(src &gt;&gt; RGB16_G_SHIFT) &lt;&lt; (RGB32_CHANEL_BIT_SIZE - RGB16_G_SIZE);
&nbsp;&nbsp;&nbsp;result.b = (uchar)(src &gt;&gt; RGB16_B_SHIFT) &lt;&lt; (RGB32_CHANEL_BIT_SIZE - RGB16_B_SIZE);
&nbsp;&nbsp;&nbsp;result.a = RGB32_DEFAULT_ALPHA;

&nbsp;&nbsp;&nbsp;return result;
}

static uchar 
clamp(int x)
{
&nbsp;&nbsp;&nbsp;if (x &gt; 255)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 255;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else if (x &lt; 0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 0;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return x;
}

static inline uchar
bgra_to_yuv_y(const bgra32 src)
{
&nbsp;&nbsp;&nbsp;return ((66*src.r + 129*src.g + 25*src.b) &gt;&gt; 8) + 16;
}

static inline uchar
bgra_to_yuv_u(const bgra32 src)
{
&nbsp;&nbsp;&nbsp;return ((-38*src.r + -74*src.g + 112*src.b) &gt;&gt; 8) + 128;
}

static inline uchar 
bgra_to_yuv_v(const bgra32 src)
{
&nbsp;&nbsp;&nbsp;return ((112*src.r + -94*src.g + -18*src.b) &gt;&gt; 8) + 128;
}

static inline uchar 
yuv_to_r(const uchar yuv_y, const uchar yuv_u, const uchar yuv_v)
{
&nbsp;&nbsp;&nbsp;return clamp(yuv_y + 1.402 * (yuv_v - 128));
}

static inline uchar 
yuv_to_g(const uchar yuv_y, const uchar yuv_u, const uchar yuv_v)
{
&nbsp;&nbsp;&nbsp;return clamp(yuv_y - 0.344 * (yuv_u - 128) - 0.714 * (yuv_v - 128));
}

static inline uchar 
yuv_to_b(const uchar yuv_y, const uchar yuv_u, const uchar yuv_v)
{
&nbsp;&nbsp;&nbsp;return clamp(yuv_y + 1.772 * (yuv_u - 128));
}

static void 
_convert_bgra8888_to_yuv420(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int src_stride = (s_size / height);
&nbsp;&nbsp;&nbsp;unsigned int pix_count = width * height;
&nbsp;&nbsp;&nbsp;unsigned int upos = pix_count;
&nbsp;&nbsp;&nbsp;unsigned int vpos = upos + upos / 4;

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; ++y)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const bgra32* src_pixel = (const bgra32*)&nbsp;&amp;(src[y * src_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int dest_line_pos = width * y;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(y % 2))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; x += 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32 pixel = src_pixel[x];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x] = bgra_to_yuv_y(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[upos++] = bgra_to_yuv_u(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[vpos++] = bgra_to_yuv_v(pixel);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel = src_pixel[x + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x + 1] = bgra_to_yuv_y(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; ++x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x] = bgra_to_yuv_y(src_pixel[x]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_bgra8888_to_rgb565(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int src_stride = (s_size / height);
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; ++y)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const bgra32* src_pixel = (const bgra32*)&nbsp;&amp;(src[y * src_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb16* dest_pixel = (rgb16*) &amp;(dest[y * dest_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x&nbsp;&lt; width; ++x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x] = bgra_to_rgb(src_pixel[x]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_rgb565_to_yuv420(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int src_stride = (s_size / height);
&nbsp;&nbsp;&nbsp;unsigned int pix_count = width * height;
&nbsp;&nbsp;&nbsp;unsigned int upos = pix_count;
&nbsp;&nbsp;&nbsp;unsigned int vpos = upos + upos / 4;

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; ++y)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const rgb16* src_pixel = (const rgb16*)&nbsp;&amp;(src[y * src_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int dest_line_pos = width * y;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(y % 2))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; x += 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32 pixel = rgb_to_bgra(src_pixel[x]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x] = bgra_to_yuv_y(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[upos++] = bgra_to_yuv_u(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[vpos++] = bgra_to_yuv_v(pixel);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel = rgb_to_bgra(src_pixel[x + 1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x + 1] = bgra_to_yuv_y(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; ++x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32 pixel = rgb_to_bgra(src_pixel[x]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest[dest_line_pos + x] = bgra_to_yuv_y(pixel);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_rgb565_to_bgra8888(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int src_stride = (s_size / height);
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; ++y)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const rgb16* src_pixel = (const rgb16*)&nbsp;&amp;(src[y * src_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32* dest_pixel = (bgra32*)&nbsp;&amp;(dest[y * dest_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; ++x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x] = rgb_to_bgra(src_pixel[x]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_yuv420_to_rgb565(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int pix_count = width * height;
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; y++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rgb16* dest_pixel = (rgb16*)&nbsp;&amp;(dest[y*dest_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; x++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_y = src[ y*width + x];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_u = src[ (int)(pix_count + (y/2)*(width/2)  + x/2)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_v = src[ (int)(pix_count*1.25 + (y/2)*(width/2) + x/2)];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((yuv_to_r(yuv_y, yuv_u, yuv_v) &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_R_SIZE)) &lt;&lt; RGB16_R_SHIFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ((yuv_to_g(yuv_y, yuv_u, yuv_v) &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_G_SIZE)) &lt;&lt; RGB16_G_SHIFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ((yuv_to_b(yuv_y, yuv_u, yuv_v) &gt;&gt; (RGB32_CHANEL_BIT_SIZE - RGB16_B_SIZE)) &lt;&lt; RGB16_B_SHIFT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_yuv420_to_bgra8888(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int pix_count = width * height;
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; y++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32* dest_pixel = (bgra32*)&nbsp;&amp;(dest[dest_stride * y]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; x++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_y = src[ y*width + x];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_u = src[ (int)(pix_count + (y/2)*(width/2)  + x/2)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uchar yuv_v = src[ (int)(pix_count*1.25 + (y/2)*(width/2) + x/2)];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].r = yuv_to_r(yuv_y, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].g = yuv_to_g(yuv_y, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].b = yuv_to_b(yuv_y, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].a = RGB32_DEFAULT_ALPHA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_yuv422_to_bgra8888(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);
&nbsp;&nbsp;&nbsp;uchar yuv_u, yuv_v, yuv_y1, yuv_y2;
&nbsp;&nbsp;&nbsp;yuv_u = yuv_v = yuv_y1 = yuv_y2 = 0;
&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; y++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32* dest_pixel = (bgra32*) &amp;(dest[dest_stride * y]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uchar * src_line = &amp;(src[2 * y * width]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; x += 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yuv_y1 = src_line[2 * x + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yuv_y2 = src_line[2 * x + 3];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yuv_u = src_line[2 * x];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yuv_v = src_line[2 * x + 2];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].r = yuv_to_r(yuv_y1, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].g = yuv_to_g(yuv_y1, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].b = yuv_to_b(yuv_y1, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].a = RGB32_DEFAULT_ALPHA;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x + 1].r = yuv_to_r(yuv_y2, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x + 1].g = yuv_to_g(yuv_y2, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x + 1].b = yuv_to_b(yuv_y2, yuv_u, yuv_v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x + 1].a = RGB32_DEFAULT_ALPHA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_convert_rgb888_to_bgra8888(uchar *dest, const uchar *src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int width, const int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int d_size, const int s_size)
{
&nbsp;&nbsp;&nbsp;unsigned int src_stride = (s_size / height);
&nbsp;&nbsp;&nbsp;unsigned int dest_stride = (d_size / height);

&nbsp;&nbsp;&nbsp;unsigned int y;
&nbsp;&nbsp;&nbsp;for (y = 0; y &lt; height; ++y)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uchar* src_pixel = &amp;(src[y * src_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgra32* dest_pixel = (bgra32*) &amp;(dest[y * dest_stride]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; width; ++x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].r = src_pixel[RGB24_BPP * x];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].g = src_pixel[RGB24_BPP * x + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].b = src_pixel[RGB24_BPP * x + 2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest_pixel[x].a = RGB32_DEFAULT_ALPHA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

int 
image_sample_util_convert_colorspace(uchar *dest, image_util_colorspace_e dest_colorspace,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const uchar *src, int width, int height,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_util_colorspace_e src_colorspace)
{
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == src, IMAGE_UTIL_ERROR_INVALID_PARAMETER, &quot;source buffer in NULL&quot;);
&nbsp;&nbsp;&nbsp;RETVM_IF(NULL == dest, IMAGE_UTIL_ERROR_INVALID_PARAMETER, &quot;destination buffer in NULL&quot;);
&nbsp;&nbsp;&nbsp;RETVM_IF(width &lt;= 0 || height &lt;= 0, IMAGE_UTIL_ERROR_INVALID_PARAMETER, &quot;width or heightis incorrect&quot;);
&nbsp;&nbsp;&nbsp;int error = IMAGE_UTIL_ERROR_NONE;

&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_BGRA8888 != src_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_RGB565 != src_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_I420 != src_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_UYVY != src_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_RGB888 != src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;src_colorspace not supported yet&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_NOT_SUPPORTED_FORMAT;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_BGRA8888 != dest_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_RGB565 != dest_colorspace
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; IMAGE_UTIL_COLORSPACE_I420 != dest_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;dest_colorspace not supported yet&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_NOT_SUPPORTED_FORMAT;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;unsigned int dest_size = 0;
&nbsp;&nbsp;&nbsp;error = image_util_calculate_buffer_size(width, height, dest_colorspace, &amp;dest_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(IMAGE_UTIL_ERROR_NONE != error, error, &quot;image_util_calculate_buffer_size error&quot;);
&nbsp;&nbsp;&nbsp;unsigned int src_size = 0;
&nbsp;&nbsp;&nbsp;error = image_util_calculate_buffer_size(width, height, src_colorspace, &amp;src_size);
&nbsp;&nbsp;&nbsp;RETVM_IF(IMAGE_UTIL_ERROR_NONE != error, error, &quot;image_util_calculate_buffer_size error&quot;);

&nbsp;&nbsp;&nbsp;if (dest_colorspace == src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(dest, src, src_size);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_BGRA8888 == src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_I420 == dest_colorspace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_bgra8888_to_yuv420(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_bgra8888_to_rgb565(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else if (IMAGE_UTIL_COLORSPACE_RGB565 == src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_I420 == dest_colorspace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_rgb565_to_yuv420(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_rgb565_to_bgra8888(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else if (IMAGE_UTIL_COLORSPACE_I420 == src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_RGB565 == dest_colorspace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_yuv420_to_rgb565(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_yuv420_to_bgra8888(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else if (IMAGE_UTIL_COLORSPACE_UYVY == src_colorspace)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_BGRA8888 == dest_colorspace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_yuv422_to_bgra8888(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;dest_colorspace not supported yet&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_NOT_SUPPORTED_FORMAT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_COLORSPACE_BGRA8888 == dest_colorspace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_convert_rgb888_to_bgra8888(dest, src, width, height, dest_size, src_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERR(&quot;dest_colorspace not supported yet&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return IMAGE_UTIL_ERROR_NOT_SUPPORTED_FORMAT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return error;
}

bool 
frame_extractor_frame_get(const frame_extractor *extractor, unsigned char **frame, int pos)
{
&nbsp;&nbsp;&nbsp;bool result = false;
&nbsp;&nbsp;&nbsp;if (extractor &amp;&amp; frame)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * buf = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int error = METADATA_EXTRACTOR_ERROR_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error = metadata_extractor_get_frame_at_time(extractor-&gt;metadata, pos, false, &amp;buf, &amp;size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (METADATA_EXTRACTOR_ERROR_NONE == error &amp;&amp; buf)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*frame = malloc(size + (extractor-&gt;width * extractor-&gt;height) * ARGB_PIXEL_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*frame)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error = image_sample_util_convert_colorspace(*frame, IMAGE_UTIL_COLORSPACE_BGRA8888, buf,  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractor-&gt;width, extractor-&gt;height, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_UTIL_COLORSPACE_RGB888);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IMAGE_UTIL_ERROR_NONE == error)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(*frame);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*frame = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return result;
}
</pre>

<p class="figure">Figure: Frame Extractor</p> 
<p align="center"><img alt="Frame Extractor" src="../images/mediaapp_frame_extractor.png" /></p>

<h2>Audio</h2>

<h3 id="tone" name="tone">Tone Player</h3>
<p>This view allows the user to play tone sounds from the numeric phone keypad. Internally, when any phone keypad button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_on_keypad_btn_down_cb</span> and <span style="font-family: Courier New,Courier,monospace;">_on_keypad_btn_up_cb</span> callbacks are called and the <span style="font-family: Courier New,Courier,monospace;">_process</span> method is executed:</p>

<pre class="prettyprint">
static void 
_on_keypad_btn_down_cb(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;tone_player_view *view = data;
&nbsp;&nbsp;&nbsp;if (view)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tone_player_stop(view-&gt;tone_handle);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tone_type_e tone = (tone_type_e)evas_object_data_get(obj, BUTTON_DTMF_KEY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tone_player_start(tone, SOUND_TYPE_MEDIA, MAX_TONE_DURATION, &amp;iew-gt;tone_handle);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Tone player</p> 
<p align="center"><img alt="Tone player" src="../images/mediaapp_tone_player.png" /></p>

<pre class="prettyprint">
static void 
_on_keypad_btn_up_cb(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;tone_player_view *view = data;
&nbsp;&nbsp;&nbsp;if (view)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tone_player_stop(view-&gt;tone_handle);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h3 id="inout" name="inout">Audio In Out</h3>
<p>This view allows the user to record sounds with the microphone and play them. Additionally there are options to adjust the channel type and sample rate. Internally, when the <strong>Record</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_audio_in_start_cb</span> callback is called, which prepares the audio stream to be recorded and starts it in a separate thread.</p>

<p class="figure">Figure: Audio in-out</p> 
<p align="center"><img alt="Audio in-out" src="../images/mediaapp_inout.png" /></p>

<pre class="prettyprint">
static void 
_audio_in_start(audio_inout *obj)
{
&nbsp;&nbsp;&nbsp;audio_buffer *buf = obj-&gt;buffer;
&nbsp;&nbsp;&nbsp;char *samples = buf-&gt;samples;
&nbsp;&nbsp;&nbsp;int len = 0;
&nbsp;&nbsp;&nbsp;size_t read_bytes = 0;
&nbsp;&nbsp;&nbsp;size_t last_reported_bytes = 0;

&nbsp;&nbsp;&nbsp;do
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = AUDIO_BUFFER_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (buf-&gt;len + len &gt; buf-&gt;capacity)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = buf-&gt;capacity - buf-&gt;len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (len &gt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int bytes = audio_in_read((audio_in_h)obj-&gt;handle, samples, len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(bytes &gt;= 0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bytes)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;samples += bytes;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf-&gt;len += bytes;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_bytes += bytes;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (read_bytes - last_reported_bytes &gt;= obj-&gt;byte_per_sec * PROGRESS_UPD_PERIOD)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_report_progress(obj, read_bytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_reported_bytes = read_bytes;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} while(!obj-&gt;stop &amp;&amp; len &gt; 0);

&nbsp;&nbsp;&nbsp;_report_progress(obj, read_bytes);
}
</pre>

<p>When input audio is recorded, it can be played in a separate stream in the <span style="font-family: Courier New,Courier,monospace;">_audio_out_start</span> method.</p>

<h3 id="equal" name="equal">Audio Equalizer</h3>

<p>This view allows the user to play an altered frequency response of an audio stream using linear filters. Additionally, there are several pre-defined values to play audio streams. Internally, when the <strong>Play</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_start_player</span> callback is called, which prepares the audio equalizer layout and applies it to a stream.</p>

<p class="figure">Figure: Audio equalizer</p> 
<p align="center"><img alt="Audio equalizer" src="../images/mediaapp_equalizer.png" /></p>

<pre class="prettyprint">
static void 
_set_equalizer_layout(equalizer_view *view, Evas_Object *parent)
{
&nbsp;&nbsp;&nbsp;Evas_Object *box = elm_box_add(parent);
&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(box, EINA_FALSE);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;evas_object_show(box);

&nbsp;&nbsp;&nbsp;int bands_count = 0;
&nbsp;&nbsp;&nbsp;player_audio_effect_get_equalizer_bands_count(view-&gt;player, &amp;bands_count);

&nbsp;&nbsp;&nbsp;view-&gt;bands_count = bands_count;
&nbsp;&nbsp;&nbsp;view-&gt;sliders = calloc(bands_count, sizeof(Evas_Object*));

&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; bands_count; ++i)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int frequency = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int min = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int max = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_audio_effect_get_equalizer_band_frequency(view-&gt;player, i, &amp;frequency);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_audio_effect_get_equalizer_level_range(view-&gt;player, &amp;min, &amp;max);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *item = _add_band_item(view, box, i, frequency, min, max);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_box_pack_end(box, item);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;elm_layout_content_set(parent, &quot;band_content&quot;, box);
}
</pre>

<h3 id="gles" name="gles">Gles Cube Player</h3>

<p>This view demonstrates the usage of the OpenGL&reg; library together with the audio output stream.</p>

<p class="figure">Figure: Gles cube player</p> 
<p align="center"><img alt="Gles cube player" src="../images/mediaapp_gles.png" /></p>

<p>Initialize and render openGL:</p>

<pre class="prettyprint">
void 
_gles_cube_view_glview_init(Evas_Object *obj)
{
&nbsp;&nbsp;&nbsp;gles_cube_view_data *view = evas_object_data_get(obj, GLVIEW_VIEW_DATA_NAME);
&nbsp;&nbsp;&nbsp;RETM_IF(!view, &quot;View data is NULL&quot;);
&nbsp;&nbsp;&nbsp;Evas_GL_API *api = elm_glview_gl_api_get(obj);
&nbsp;&nbsp;&nbsp;RETM_IF(!api, &quot;GL API is NULL&quot;);

&nbsp;&nbsp;&nbsp;view-&gt;shader_ok = color_shader_init(&amp;view-&gt;shader, api);
&nbsp;&nbsp;&nbsp;RETM_IF(!view-&gt;shader_ok, &quot;Shader initialization failed&quot;);

&nbsp;&nbsp;&nbsp;api-&gt;glClearColor(VIEW_BG_COLOR);
&nbsp;&nbsp;&nbsp;api-&gt;glEnable(GL_DEPTH_TEST);
}

void 
_gles_cube_view_glview_render(Evas_Object *obj)
{
&nbsp;&nbsp;&nbsp;gles_cube_view_data *view = evas_object_data_get(obj, GLVIEW_VIEW_DATA_NAME);
&nbsp;&nbsp;&nbsp;RETM_IF(!view, &quot;View data is NULL&quot;);
&nbsp;&nbsp;&nbsp;RETM_IF(!view-&gt;resize_ok, &quot;Viewport is not ready&quot;);
&nbsp;&nbsp;&nbsp;Evas_GL_API *api = elm_glview_gl_api_get(obj);
&nbsp;&nbsp;&nbsp;RETM_IF(!api, &quot;GL API is NULL&quot;);

&nbsp;&nbsp;&nbsp;gl_matrix4 matrix;
&nbsp;&nbsp;&nbsp;gl_matrix4_load_identity(&amp;matrix);
&nbsp;&nbsp;&nbsp;gl_matrix4_translate(&amp;matrix, CUBE_XYZ_POSITION);
&nbsp;&nbsp;&nbsp;gl_matrix4_rotate(&amp;matrix, view-&gt;angle, CUBE_ROTATE_VECTOR);

&nbsp;&nbsp;&nbsp;api-&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

&nbsp;&nbsp;&nbsp;color_shader_activate(&amp;view-&gt;shader, api);
&nbsp;&nbsp;&nbsp;color_shader_load_mv(&amp;view-&gt;shader, api, &amp;matrix);
&nbsp;&nbsp;&nbsp;color_object3d_draw(&amp;CUBE_OBJECT3D, api);
&nbsp;&nbsp;&nbsp;color_shader_deactivate(&amp;view-&gt;shader, api);
}
</pre>

<h2 id="player" name="player">Player</h2>

<h3 id="media" name="media">Media Player</h3>
<p>This view allows the user to play different media sources, such as MP3, AMR, WAV, MP4, and AAC. Internally, when the <strong>Play</strong> button is clicked, the <span style="font-family: Courier New,Courier,monospace;">_start_player</span> callback is called, which prepares the selected media and plays it.</p>

<pre class="prettyprint">
static void 
_start_player(media_player_view *view)
{
&nbsp;&nbsp;&nbsp;player_state_e state;
&nbsp;&nbsp;&nbsp;player_get_state(view-&gt;player, &amp;state);

&nbsp;&nbsp;&nbsp;if (state != PLAYER_STATE_PLAYING)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_start(view-&gt;player);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_is_playing(view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _toolbar_play_stop_btn_upd(view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_disabled_set(view-&gt;progressbar, EINA_FALSE);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ms = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_get_duration(view-&gt;player, &amp;ms);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_slider_min_max_set(view-&gt;progressbar, 0, ms / 1000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_slider_value_set(view-&gt;progressbar, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label_status_set(view, &quot;Playing&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (_is_playing(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_timer_start(view);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Media Player</p> 
<p align="center"><img alt="Media Player" src="../images/mediaapp_mediaplayer.png" /></p>

<h3 id="multi" name="multi">Multi Play</h3>

<p>This view allows the user to play several audio sources simultaneously, such as MP3, AMR, AAC, and WAV. Internally, when each checkbox is checked, a separate player with the selected stream is started.</p>

<p class="figure">Figure: Multi Play</p> 
<p align="center"><img alt="Multi Play" src="../images/mediaapp_multi.png" /></p>

<pre class="prettyprint">
static void 
_on_genlist_item_selected_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *item = (Elm_Object_Item *) event_info;
&nbsp;&nbsp;&nbsp;player_data *player = elm_object_item_data_get(item);
&nbsp;&nbsp;&nbsp;Evas_Object *checkbox = elm_object_item_part_content_get(item, CHECKBOX_PART);

&nbsp;&nbsp;&nbsp;elm_genlist_item_selected_set(item, EINA_FALSE);

&nbsp;&nbsp;&nbsp;assert(checkbox);
&nbsp;&nbsp;&nbsp;assert(player);
&nbsp;&nbsp;&nbsp;if (checkbox &amp;&amp; player)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool state = elm_check_state_get(checkbox);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_check_state_set(checkbox, !state);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state = elm_check_state_get(checkbox);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (state)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_player_start(player);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_player_stop(player);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_genlist_item_fields_update(item, SUBTEXT_PART, ELM_GENLIST_ITEM_FIELD_TEXT);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h3 id="cam_play" name="cam_play">Camera and Player</h3>
<p>This view allows the user to display the camera preview and media player at the same window. Initially, both the camera and the player should be created and initiated:</p>

<pre class="prettyprint">
static player_h 
_create_player(camera_player_view *this)
{
&nbsp;&nbsp;&nbsp;player_h player = NULL;

&nbsp;&nbsp;&nbsp;if (player_create(&amp;player) == PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_sound_type(player, SOUND_TYPE_MEDIA);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_volume(player, 1.0, 1.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_looping(player, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_uri(player, SAMPLEMPEG4);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_uri(player, get_resource_path(SAMPLEMPEG4));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display(player, PLAYER_DISPLAY_TYPE_EVAS, GET_DISPLAY(this->video_rect));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_mode(player, PLAYER_DISPLAY_MODE_FULL_SCREEN);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_visible(player, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_prepare(player);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return player;
}
</pre>

<p>When the <strong>Start</strong> button is clicked, camera streaming and video player streaming start simultaneously:</p>

<pre class="prettyprint">
static void 
_start_camera(camera_player_view *this)
{
&nbsp;&nbsp;&nbsp;if (!this-&gt;camera)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;camera = _create_camera(this);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (this-&gt;camera)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_state_e state;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_get_state(this-&gt;camera, &amp;state);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (state != CAMERA_STATE_PREVIEW)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_start_preview(this-&gt;camera);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_start_player(camera_player_view *this)
{
&nbsp;&nbsp;&nbsp;if (!this-&gt;player)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;player = _create_player(this);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (this-&gt;player)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_state_e state;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_get_state(this-&gt;player, &amp;state);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (state != PLAYER_STATE_PLAYING)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_set_display_visible(this-&gt;player, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;player_start(this-&gt;player);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Camera and player</p> 
<p align="center"><img alt="Camera and player" src="../images/mediaapp_camplay.png" /></p>

<h3 id="vid_play" name="vid_play">Video Recorder and Player</h3>

<p>This view allows the user to record camera streaming and play another video stream at the same time. Initially, both the camera recorder and the player should be created and initiated:</p>

<pre class="prettyprint">
static void 
_create_video_recorder(video_recorder_player_view *view)
{
&nbsp;&nbsp;&nbsp;window_obj *win_obj = view-&gt;app-&gt;win;
&nbsp;&nbsp;&nbsp;Evas_Object *win = win_obj-&gt;win;
&nbsp;&nbsp;&nbsp;if (view-&gt;camera)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_destroy(view-&gt;camera);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (camera_create(CAMERA_DEVICE_CAMERA0, &amp;view-&gt;camera) == CAMERA_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... skip some code

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_create_videorecorder(view-&gt;camera, &amp;view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_file_format(view-&gt;recorder, RECORDER_FILE_FORMAT_3GP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_filename(view-&gt;recorder, get_data_path(RECORDERED_3GP_VIDEO));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_attr_set_time_limit(view-&gt;recorder, limit_seconds);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_limit_reached_cb(view-&gt;recorder, _limit_reached_cb, view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_status_cb(view-&gt;recorder, _record_status_cb, view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_prepare(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Video recorder and player</p> 
<p align="center"><img alt="Video recorder and player" src="../images/mediaapp_vidplayer.png" /></p>

<p>When the <strong>Start</strong> button is clicked, recording a video stream to a file and playing another video stream at the same time begins. The recorded file is played after the recording is finished.</p>

<pre class="prettyprint">
static void 
_stop_video_recorder(video_recorder_player_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_commit(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_unprepare(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_destroy(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;recorder = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_progressbar_value_set(view-&gt;progress_bar, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_record_completed(view);
&nbsp;&nbsp;&nbsp;}
}
static void _on_record_completed(video_recorder_player_view *view)
{
&nbsp;&nbsp;&nbsp;win_set_view_style(view-&gt;app-&gt;win, STYLE_DEFAULT_WINDOW);
&nbsp;&nbsp;&nbsp;Elm_Object_Item *video_player_navi_item = video_player_view_add(view-&gt;app, view-&gt;navi, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_data_path(RECORDERED_3GP_VIDEO), NULL, NULL);
&nbsp;&nbsp;&nbsp;elm_naviframe_item_pop_cb_set(video_player_navi_item, _video_player_navi_item_pop_cb, view);
}
</pre>

<h2 id="recorder" name="recorder">Recorder</h2>

<h3 id="camera" name="camera">Camera Capture</h3>
<p>This view allows the user to capture a separate frame from the camera stream as an image and display it in the saved images. There are numerous settings that can be used to adjust the capturing process and to customize the camera stream style, quality, and filtering. Initially, the camera view should be prepared and started:</p>

<pre class="prettyprint">
static void 
_create_camera(camera_capture_view *view)
{
&nbsp;&nbsp;&nbsp;window_obj *win_obj = view-&gt;app-&gt;win;
&nbsp;&nbsp;&nbsp;Evas_Object *win = win_obj-&gt;win;
&nbsp;&nbsp;&nbsp;if (view-&gt;camera)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_destroy_camera(view);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (camera_create(CAMERA_DEVICE_CAMERA0, &amp;view-&gt;camera) == CAMERA_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = 0, y = 0, w = 0, h = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *edje_layout = elm_layout_edje_get(view-&gt;layout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edje_object_calc_force(edje_layout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_get_geometry_camera_win(view, &amp;x, &amp;y, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;camera = NULL;
&nbsp;&nbsp;&nbsp;}
}
static void _start_camera(camera_capture_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;camera)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_start_preview(view-&gt;camera);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>When the <strong>Capture</strong> button is clicked, it takes a frame shot of the current camera view and places it into a scrollable gallery down the view. </p>

<pre class="prettyprint">
static void 
_on_camera_capture_cb(camera_image_data_s *image, camera_image_data_s *postview, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;camera_image_data_s *thumbnail, void *user_data)
{
&nbsp;&nbsp;&nbsp;camera_capture_view *view = user_data;

&nbsp;&nbsp;&nbsp;if (view)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *image_path = _save_file(view, image);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (image_path)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thumbnail_data *mlt_data = calloc(1, sizeof(thumbnail_data));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mlt_data-&gt;view = view;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mlt_data-&gt;image_path = image_path;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_main_loop_thread_safe_call_async(_on_ecore_main_loop_cb, mlt_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>Each newly created frame can be viewed with the image viewer:</p>

<pre class="prettyprint">
static void 
_on_thumb_clicked_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;thumbnail_data *thumbnail = data;
&nbsp;&nbsp;&nbsp;if (thumbnail)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (capture_image_viewer_add(thumbnail-&gt;view-&gt;app, thumbnail-&gt;view-&gt;navi, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thumbnail-&gt;image_path, _on_capture_image_viewer_del_cb, thumbnail-&gt;view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thumbnail-&gt;view-&gt;activated = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_stop_camera(thumbnail-&gt;view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Camera Capture</p> 
<p align="center"><img alt="Camera Capture" src="../images/mediaapp_camera.png" /></p>

<h3 id="video" name="video">Video Recorder</h3>

<p>This view allows the user to record camera streaming and play the recorded video. There are numerous settings that can be used to adjust recording process and to customize the camera streaming style, quality, and filtering. Initially, the video recorder should be created and prepared:</p>

<p class="figure">Figure: Video recorder</p> 
<p align="center"><img alt="Video recorder" src="../images/mediaapp_video.png" /></p>

<pre class="prettyprint">
static void 
_create_video_recorder(video_recorder_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_destroy_video_recorder(view);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;recorder_create_videorecorder(view-&gt;camera, &amp;view-&gt;recorder);
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_file_format_set(view, RECORDER_FILE_FORMAT_3GP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_attr_set_time_limit(view-&gt;recorder, limit_seconds);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_limit_reached_cb(view-&gt;recorder, _limit_reached_cb, view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_status_cb(view-&gt;recorder, _record_status_cb, view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_prepare(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>When the <strong>Start</strong> button is clicked, it starts to record a video. The recorded video can be played in the Media player.</p>

<pre class="prettyprint">
static void 
_start_video_recorder(video_recorder_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_start(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h3 id="audio" name="audio">Audio Recorder</h3>
<p>This view allows the user to record audio streaming and play the recorded audio. There are several settings that can be used to adjust audio quality and pre-processing. Initially, the audio recorder should be created and prepared:</p>

<pre class="prettyprint">
static void 
_recorder_create(audio_recorder_view *view)
{
&nbsp;&nbsp;&nbsp;if (recorder_create_audiorecorder(&amp;view-&gt;recorder) == RECORDER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_get_supported_codec_list(view);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (view-&gt;codec_list_len)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_codec_set(view, view-&gt;codec_list[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_codec_set(view, RECORDER_AUDIO_CODEC_PCM);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_quality_set(view, AQ_MEDIUM);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_status_cb(view-&gt;recorder, _on_recording_status_cb, view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_set_recording_limit_reached_cb(view-&gt;recorder, _on_recording_limit_reached_cb, view);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_attr_set_audio_channel(view-&gt;recorder, 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_attr_set_audio_device(view-&gt;recorder, RECORDER_AUDIO_DEVICE_MIC);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_attr_set_time_limit(view-&gt;recorder, MAX_TIME);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label_size_set(view, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label_time_set(view, 0);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p class="figure">Figure: Audio recorder</p> 
<p align="center"><img alt="Audio recorder" src="../images/mediaapp_audio_recorder.png" /></p>

<p>When the <strong>Start</strong> button is clicked, it starts to record the audio stream. The recorded audio can be played in the Media player.</p>

<pre class="prettyprint">
static void 
_recorder_start(audio_recorder_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_prepare(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_start(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_recorder_is_recording(view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_item_text_set(view-&gt;ctrl_item, STR_STOP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_recorder_stop(audio_recorder_view *view)
{
&nbsp;&nbsp;&nbsp;if (view-&gt;recorder)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_commit(view-&gt;recorder);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!_recorder_is_recording(view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_item_text_set(view-&gt;ctrl_item, STR_START);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recorder_unprepare(view-&gt;recorder);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label_size_set(view, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_label_time_set(view, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_progressbar_value_set(view-&gt;progressbar, 0.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}

static void 
_on_ctrl_btn_pressed_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;audio_recorder_view *view = data;

&nbsp;&nbsp;&nbsp;if (view)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (_recorder_is_recording(view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_stop(view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_navigate_to_audio_player_view(view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_recorder_start(view);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
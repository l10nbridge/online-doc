<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Data-Control-Consumer Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mn_icon.png"/></p>
	</div>

<!-- ********************************************************************************** -->
<h1>Data-Control-Provider Sample Overview</h1>

<p>The sample demonstrates how to exchange data between a consumer application and a provider service. There are two methods of data exchange:</p>
<ul>
	<li>Map method - using key value pairs;</li>
	<li>Sql method - using sql queries.</li>
</ul>
<p>No user interface is provided as this is a service application that runs in the background. The documentation for the consumer app can be found <a href = "data_control_consumer_sd_mn.htm">here</a>.</p>

<h2>Prerequisites</h2>
<p>To ensure proper application execution, the <span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/datasharing</span> privilege must be set and the following data-control entries must be enabled:</p>
<ul>
	<li><span id = "provider-map-id" style="font-family: Courier New,Courier,monospace">http://data-control-provider.com/datacontrol/provider/data-control-provider</span> with sql type and <span style="font-family: Courier New,Courier,monospace">ReadWrite</span> access rights;</li>
	<li><span id = "provider-sql-id" style="font-family: Courier New,Courier,monospace">http://data-control-provider.com/datacontrol/provider/data-control-providers</span> with map type and <span style="font-family: Courier New,Courier,monospace">ReadWrite</span> access rights.</li>
</ul>

<h2>Implementation</h2>
<h3>Initialization</h3>

<p>The entire application's life-cycle is implemented in the main source file using a common Tizen service structure:</p>
<pre class="prettyprint">
int main(int argc, char* argv[])
{
&nbsp;&nbsp;&nbsp;char ad[50] = {0,};
&nbsp;&nbsp;&nbsp;service_app_lifecycle_callback_s event_callback;
&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL, };

&nbsp;&nbsp;&nbsp;event_callback.create = service_app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = service_app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.app_control = service_app_control;

&nbsp;&nbsp;&nbsp;service_app_add_event_handler(&handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, service_app_low_battery, &ad);
&nbsp;&nbsp;&nbsp;service_app_add_event_handler(&handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, service_app_low_memory, &ad);
&nbsp;&nbsp;&nbsp;service_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, service_app_lang_changed, &ad);
&nbsp;&nbsp;&nbsp;service_app_add_event_handler(&handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, service_app_region_changed, &ad);

&nbsp;&nbsp;&nbsp;return service_app_main(argc, argv, &event_callback, ad);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">service_app_create</span> function is used to initialize the map provider and the sql provider modules.</p>



<h3>The Map module</h3>
<h4>Structure definitions</h4>

<p>The map module uses the structure below to hold its data:</p>
<pre class="prettyprint">
static struct {
&nbsp;&nbsp;&nbsp;data_control_provider_map_cb map_callback; /* Provider callbacks */
&nbsp;&nbsp;&nbsp;Eina_Hash *data_map; /* The map structure */
}
</pre>

<h4>Initialization</h4>

<p>The map module uses the <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> structure to hold data. Note that the stored data will be lost when the provider app is killed. Four callback are used to provide communication with the consumer application. </p>

<pre class="prettyprint">
Eina_Bool map_provider_initialize(void)
{
&nbsp;&nbsp;&nbsp;/* Assigning callback functions to callback structure. */
&nbsp;&nbsp;&nbsp;s_info.map_callback.get_cb = __get_value_request_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.add_cb = __add_value_request_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.remove_cb = __remove_value_request_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.set_cb = __set_value_request_cb;

&nbsp;&nbsp;&nbsp;/* Initialize the map provider using the callback structure. */
&nbsp;&nbsp;&nbsp;int result = data_control_provider_map_register_cb(&s_info.map_callback, NULL);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;s_info.data_map = eina_hash_string_djb2_new(__data_map_free_cb);
&nbsp;&nbsp;&nbsp;/* ... */
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<h4>Callbacks</h4>

<p>The callback invoked when a 'get' request is sent from the consumer app:</p>
<pre class="prettyprint">
static void __get_value_request_cb(int request_id, data_control_h provider, const char *key, void *user_data)
{
&nbsp;&nbsp;&nbsp;int count = 0;
&nbsp;&nbsp;&nbsp;char **entry = __data_map_get(request_id, key, &count); /* Read the data assigned to the 'key' from the hash map. */

&nbsp;&nbsp;&nbsp;int ret = data_control_provider_send_map_get_value_result(request_id, entry, count); /* Send the operation result to the consumer app. */
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when a 'set' request is sent from the consumer app:</p>
<pre class="prettyprint">
static void __set_value_request_cb(int request_id, data_control_h provider, const char *key, const char *old_value, const char *new_value, void *user_data)
{
&nbsp;&nbsp;&nbsp;__data_map_set(request_id, key, old_value, new_value); /* Update the hash map. If there is a 'key' in the hash map and it holds a value equal to 'old_value', the value will be updated to 'new_value'. */

&nbsp;&nbsp;&nbsp;int ret = data_control_provider_send_map_result(request_id); /* Send the operation result to the consumer app. */
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when a 'add' request is sent from the consumer app:</p>
<pre class="prettyprint">
static void __add_value_request_cb(int request_id, data_control_h provider, const char *key, const char *value, void *user_data)
{
&nbsp;&nbsp;&nbsp;int count = __data_map_add(request_id, key, value); /* Add a new value equal 'value' the 'key'. If a key equal to 'key' doesn't exist, a new key will be added. */
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;int ret = data_control_provider_send_map_result(request_id); /* Send the operation result to the consumer app. */
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when a 'remove' request is sent from the consumer app:</p>
<pre class="prettyprint">
static void __remove_value_request_cb(int request_id, data_control_h provider, const char *key, const char *value, void *user_data)
{
&nbsp;&nbsp;&nbsp;__data_map_remove(request_id, key, value); /* Remove 'value' from 'key'. If the key remains empty after this operation, it will be removed as well. */

&nbsp;&nbsp;&nbsp;int ret = data_control_provider_send_map_result(request_id); /* Send the operation result to the consumer app. */
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>


<h4>Eina_Hash functions</h4>
<p>The map provider part of the application uses the <span style="font-family: Courier New,Courier,monospace">Eina_Hash</span> structure to store data. Note that every key in the hash can hold multiple values, so a simple key/value pair is not enough. Every key has an <span style="font-family: Courier New,Courier,monospace">Eina_List</span> assigned as its data. There are five functions in total that allow to interact with the hash map. All of them are invoked by a proper callback.</p>

<p>The function used to add new data to the hash map. As mentioned before, if a key doesn't exist, a new key should be created:</p>
<pre class="prettyprint">
static int __data_map_add(int request_id, const char *key, const char *value)
{
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;entry = (Eina_List *)eina_hash_find(s_info.data_map, key); /* Find an Eina_List assigned to the passed key. */

&nbsp;&nbsp;&nbsp;if (entry) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* If an Eina_List is found, a new value is added to it, and the Eina_Hash key is modified accordingly.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that the data added to the Eina_List is sorted so the eina_hash_list_* group of functions cannot be used. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry = eina_list_sorted_insert(entry, __data_map_item_value_comparator_cb, strdup(value));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... */
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* If an Eina_List is not found, a new list is created. A new key is created with the new list used at its value. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry = eina_list_append(NULL, strdup(value));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... */
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return eina_list_count(entry);
}
</pre>

<p>The function below is a special 'get' function. When 'get' request with a special <a href = "data_control_consumer_sd_mn.htm#consumer-get-all-keys">key</a> is sent from the consumer app, an array of all keys in the hash map are sent back instead of a value array:</p>
<pre class="prettyprint">
static char **__get_all_keys(int *values_count)
{
&nbsp;&nbsp;&nbsp;*values_count = eina_hash_population(s_info.data_map);
&nbsp;&nbsp;&nbsp;char **ret = calloc(*values_count, sizeof(char *));
&nbsp;&nbsp;&nbsp;eina_hash_foreach(s_info.data_map, __get_all_keys_cb, (char **)ret);
&nbsp;&nbsp;&nbsp;return ret;
}
</pre>

<p>The function used to get an array of values held by the given key:</p>
<pre class="prettyprint">
static char **__data_map_get(int request_id, const char *key, int *values_count)
{
&nbsp;&nbsp;&nbsp;/* If the requested key is equal to '#GET_ALL_KEYS', return an array of all available keys. */
&nbsp;&nbsp;&nbsp;if(!__str_cmp_precise(key, GET_ALL_KEYS))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return __get_all_keys(values_count);

&nbsp;&nbsp;&nbsp;/* Find an Eina_List assigned to the given key */
&nbsp;&nbsp;&nbsp;entry = (Eina_List *)eina_hash_find(s_info.data_map, key);
&nbsp;&nbsp;&nbsp;if (!entry) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*values_count = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* If no Eina_List is found, an error message is sent.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that this call will automatically set the <a href = "data_control_consumer_sd_mn.htm#consumer-callback-definitions">provider_ret</a> in the consumer's app callback to false. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_control_provider_send_error(request_id, NO_KEY_FOUND);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* Prepare an array of strings with values assigned to the given key. */
&nbsp;&nbsp;&nbsp;*values_count = eina_list_count(entry);
&nbsp;&nbsp;&nbsp;char **ret = calloc(*values_count, sizeof(char *));

&nbsp;&nbsp;&nbsp;EINA_LIST_FOREACH(entry, l, item)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret[index] = item;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return ret;
}
</pre>

<p>The function used to update the value assigned to the given key:</p>
<pre class="prettyprint">
static Eina_Bool __data_map_set(int request_id, const char *key, const char *old, const char *new)
{
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* Search for the value to modify. */
&nbsp;&nbsp;&nbsp;Eina_List *old_data_list = __search_value(entry, key, old);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* Remove the found value. This is used to simplify the sorted insertion to the Eina_List. */
&nbsp;&nbsp;&nbsp;entry = eina_list_remove_list(entry, old_data_list);
&nbsp;&nbsp;&nbsp;if (!entry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "entry == NULL");

&nbsp;&nbsp;&nbsp;/* Insert the new value. */
&nbsp;&nbsp;&nbsp;entry = eina_list_sorted_insert(entry, __data_map_item_value_comparator_cb, strdup(new));

&nbsp;&nbsp;&nbsp;/* Modify the key. */
&nbsp;&nbsp;&nbsp;if (!eina_hash_modify(s_info.data_map, key, entry)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "Failed to modify a key value pair");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EINA_FALSE;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p>The function used to remove the value assigned to the given key:</p>
<pre class="prettyprint">
static void __data_map_remove(int request_id, const char* key, const char *value)
{
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;if(eina_list_count(entry) > 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry = eina_list_remove_list(entry, old_data_list);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!eina_hash_modify(s_info.data_map, key, entry)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "Failed to modify a key value pair");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* If akey is left empty after the value removal the key should be removed as well. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!eina_hash_del_by_key(s_info.data_map, key)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "Failed to remove a key: %s", key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "Key [%s] removed", key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text = eina_stringshare_printf(KEY_REMOVED, key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_control_provider_send_error(request_id, text);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_stringshare_del(text);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>


<h3>The SQL module</h3>
<h4>Structure definitions</h4>

<p>The map module uses the following structure to hold its data:</p>
<pre class="prettyprint">
static struct {
&nbsp;&nbsp;&nbsp;data_control_provider_sql_cb sql_callback; /* Provider callbacks */
&nbsp;&nbsp;&nbsp;sqlite3 *db; /* The map structure */
} s_info;
</pre>

<h4>Initialization</h4>
<p>The SQL module uses a SQLite database to hold data. As opposed to the map module, the SQL module uses an external file to store the data so it is not lost when the app is killed. Four callback are used to provide communication with the consumer application.</p>

<p>The function below is used to initialize the SQL provider module.</p>
<pre class="prettyprint">
void sql_provider_init(void)
{
&nbsp;&nbsp;&nbsp;int result = __create_database(); /* Create and open a database file */

&nbsp;&nbsp;&nbsp;/* Initialize the callback structure with function pointers */
&nbsp;&nbsp;&nbsp;s_info.sql_callback.select_cb = __select_request_cb;
&nbsp;&nbsp;&nbsp;s_info.sql_callback.insert_cb = __insert_request_cb;
&nbsp;&nbsp;&nbsp;s_info.sql_callback.delete_cb = __delete_request_cb;
&nbsp;&nbsp;&nbsp;s_info.sql_callback.update_cb = __update_request_cb;

&nbsp;&nbsp;&nbsp;/* Register the callbacks */
&nbsp;&nbsp;&nbsp;result = data_control_provider_sql_register_cb(&s_info.sql_callback, NULL);
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<h4>Callbacks</h4>

<p>The callback invoked when an 'insert' request is sent:</p>
<pre class="prettyprint">
static void __insert_request_cb(int request_id, data_control_h provider, bundle *insert_data, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* The insert_data argument contains a list of column name / value pairs. Check the <a href = "data_control_consumer_sd_mn.htm#consumer-sql-insert-request">consumer</a> app documentation for details.
&nbsp;&nbsp;&nbsp;Based on the values stored in the bundle a SQL INSERT query is created. */
&nbsp;&nbsp;&nbsp;command = data_control_provider_create_insert_statement(provider, insert_data);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* The new row is added to the database using standard SQLite API's functions */
&nbsp;&nbsp;&nbsp;ret = sqlite3_exec(s_info.db, command, NULL, NULL, NULL);
&nbsp;&nbsp;&nbsp;/* ... */
&nbsp;&nbsp;&nbsp;inserted_row_id = sqlite3_last_insert_rowid(s_info.db);

&nbsp;&nbsp;&nbsp;/* The operation result is sent back to the consumer application */
&nbsp;&nbsp;&nbsp;ret = data_control_provider_send_insert_result(request_id, inserted_row_id);

&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when a 'delete' request is sent:</p>
<pre class="prettyprint">
static void __delete_request_cb(int request_id, data_control_h provider, const char *where, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* The 'where' text is used to create a SQL DELETE query */
&nbsp;&nbsp;&nbsp;command = data_control_provider_create_delete_statement(provider, where);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* The new row is added to the database using standard SQLite API's functions */
&nbsp;&nbsp;&nbsp;ret = sqlite3_exec(s_info.db, command, NULL, NULL, NULL);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* The operation result is sent back to the consumer application */
&nbsp;&nbsp;&nbsp;ret = data_control_provider_send_delete_result(request_id);
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when a 'select' request is sent:</p>
<pre class="prettyprint">
static void __select_request_cb(int request_id, data_control_h provider, const char **column_list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int column_count, const char *where, const char *order, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* A SQL SELECT query is created using the callback arguments. Note that some of the arguments can be NULL.
&nbsp;&nbsp;&nbsp;The resulting query:
&nbsp;&nbsp;&nbsp;SELECT column_list[0], column_list[1] .. column_list[column_count - 1] FROM Sample_Table WHERE where ORDER BY order;

&nbsp;&nbsp;&nbsp;If the where string is NULL, there is no filter used and if order string is NULL there is no sorting applied.
&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;command = data_control_provider_create_select_statement(provider, column_list, column_count, where, order);
&nbsp;&nbsp;&nbsp;if (!command) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "command == NULL");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "command == %s", command);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* A SQL statement object is created and sent to the consumer application */
&nbsp;&nbsp;&nbsp;ret = sqlite3_prepare_v2(s_info.db, command, strlen(command), &sql_stmt, NULL);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;ret = data_control_provider_send_select_result(request_id, (void *)sql_stmt);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;sqlite3_finalize(sql_stmt);

&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The callback invoked when an 'update' request is sent:</p>
<pre class="prettyprint">
static void __update_request_cb(int request_id, data_control_h provider, bundle *update_data, const char *where, void *user_data)
{
&nbsp;&nbsp;&nbsp;int ret = -1;
&nbsp;&nbsp;&nbsp;char *command = NULL;


&nbsp;&nbsp;&nbsp;/* The SQL query is created using the bundle structure similar to the structure used in add query and where string similar to the one used in the delete query.
&nbsp;&nbsp;&nbsp;The final query will look like this:
&nbsp;&nbsp;&nbsp;UPDATE Sample_Table SET bundle_key1 = bundle_value_1, bundle_key1 = bundle_value_1, ..., columnN = valueN WHERE where

&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;command = data_control_provider_create_update_statement(provider, update_data, where);
&nbsp;&nbsp;&nbsp;if (!command) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "command == NULL");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/* The generated command is then used as a SQLite query */
&nbsp;&nbsp;&nbsp;ret = sqlite3_exec(s_info.db, command, NULL, NULL, NULL);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* After the database update information about the update's result is sent to the consumer app*/
&nbsp;&nbsp;&nbsp;ret = data_control_provider_send_update_result(request_id);
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>
<!-- ********************************************************************************** -->

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>


</body>
</html>

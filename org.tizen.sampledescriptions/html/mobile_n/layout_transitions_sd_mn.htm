<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>Layout Transitions Sample Overview</title>  
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>

  <h1>Layout Transitions Sample Overview</h1> 

  <p>The Layout Transitions sample application demonstrates how you can implement an animated transition between different application views. The application implements 3 different screens: A, B, and C. The animation implementation is based on 3 EFL mechanisms: <span style="font-family: Courier New,Courier,monospace">elm_transitions</span>, <span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span>, and Edje.</p>
  <p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>
  
  <p>The following figure illustrates the main screens of the Layout Transitions.</p>
  <p class="figure">Figure: Layout Transitions screens</p>
  <p align="center"><img alt="Screen-A" src="../images/layout-transitions-screen-a.png"/> <img alt="Screen-B (default)" src="../images/layout-transitions-screen-b.png"/> <img alt="Screen-C" src="../images/layout-transitions-screen-c.png"/></p>
  <p>The application is divided into 3 modules:</p>
  <ul>
	<li>Main module is generated by the Tizen SDK and contains all callbacks from the <span style="font-family: Courier New,Courier,monospace">app_control</span> library necessary to run the application.</li>
	<li>View module is responsible for user interactions and UI creation.</li>
	<li>Animator module is responsible for animations between different views.</li>
  </ul>

<h2>Implementation</h2>
<h3>Main Module</h3>
<p>The main module contains the code automatically generated by the Tizen SDK when you create a new native project with EDJE files. The module initializes an application instance and handles app control event callbacks.</p>
<p>The following updates have been introduced to the main module:</p>

<ul><li>
<p>The main data structure is modified. All pointers to elementary components are placed in an internal <span style="font-family: Courier New,Courier,monospace">s_view_data</span> structure. The module does not access the UI components directly.</p>

<pre class="prettyprint">
typedef struct 
appdata
{
&nbsp;&nbsp;&nbsp;s_view_data view;
} appdata_s;
</pre></li>

<li><p>All functions connected to the UI element creation are placed in the <span style="font-family: Courier New,Courier,monospace">view_init()</span> function from the view module:</p>
<pre class="prettyprint">
static bool 
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;if (!view_init(&amp;ad-&gt;view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;}
}
</pre></li></ul>

<h3>View Module</h3>
<p>The view module implements all UI functionality. The following figure illustrates the application layout structure and components tree.</p>

<p class="figure">Figure: Layout structure and component tree</p>
<p align="center"><img alt="Layout structure and component tree" src="../images/layout-transitions-widget-tree.png"/></p>

<p>To create the view module:</p>
<ol>
<li>
<p>The view is initialized in the <span style="font-family: Courier New,Courier,monospace">view_init()</span> function. Each component is created in a separate function:</p>
<pre class="prettyprint">
bool 
view_init(s_view_data *view)
{
&nbsp;&nbsp;&nbsp;// Create the main window of the application and set its properties
&nbsp;&nbsp;&nbsp;// This is the standard implementation from the UI sample, so it is 
&nbsp;&nbsp;&nbsp;// not described in detail
&nbsp;&nbsp;&nbsp;if (!_create_win(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Create the conformant component
&nbsp;&nbsp;&nbsp;// It is also standard code generated from the UI sample
&nbsp;&nbsp;&nbsp;if (!_create_conformant(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Create the elm_layout component. This layout loads an EDJE file, 
&nbsp;&nbsp;&nbsp;// which contains proper placeholders for the toolbar component and 
&nbsp;&nbsp;&nbsp;// the A, B, and C screens
&nbsp;&nbsp;&nbsp;if (!_create_layout(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Create the toolbar component that is used for switching between the 
&nbsp;&nbsp;&nbsp;// different application views
&nbsp;&nbsp;&nbsp;if (!_create_toolbar(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>To create the toolbar component and its content:</p>

<pre class="prettyprint">
static bool 
_create_toolbar(s_view_data *view)
{
&nbsp;&nbsp;&nbsp;// Create a new elm_toolbar component and set it in the view structure
&nbsp;&nbsp;&nbsp;view-&gt;toolbar = elm_toolbar_add(view-&gt;layout);

&nbsp;&nbsp;&nbsp;// Set the toolbar items&#39; display behavior as always visible and expanded
&nbsp;&nbsp;&nbsp;elm_toolbar_shrink_mode_set(view-&gt;toolbar, ELM_TOOLBAR_SHRINK_EXPAND);

&nbsp;&nbsp;&nbsp;// Set the style of the toolbar chosen from the themes available in Tizen
&nbsp;&nbsp;&nbsp;elm_object_style_set(view-&gt;toolbar, &quot;tabbar&quot;);

&nbsp;&nbsp;&nbsp;// Append new items to the toolbar and connect the &quot;choose&quot; callbacks
&nbsp;&nbsp;&nbsp;view-&gt;screen_a_indice = elm_toolbar_item_append(view-&gt;toolbar, NULL, &quot;Screen A&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_screen_a_activate, view);
&nbsp;&nbsp;&nbsp;view-&gt;screen_b_indice = elm_toolbar_item_append(view-&gt;toolbar, NULL, &quot;Screen B&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_screen_b_activate, view);
&nbsp;&nbsp;&nbsp;view-&gt;screen_c_indice = elm_toolbar_item_append(view-&gt;toolbar, NULL, &quot;Screen C&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_screen_c_activate, view);

&nbsp;&nbsp;&nbsp;// Set selection properties
&nbsp;&nbsp;&nbsp;elm_toolbar_select_mode_set(view-&gt;toolbar, ELM_OBJECT_SELECT_MODE_ALWAYS);
&nbsp;&nbsp;&nbsp;elm_toolbar_item_selected_set(view-&gt;screen_b_indice, EINA_TRUE);

&nbsp;&nbsp;&nbsp;// Place the toolbar component in the layout and set its Evas properties
&nbsp;&nbsp;&nbsp;elm_object_part_content_set(view-&gt;layout, PART_TOOLBAR, view-&gt;toolbar);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(view-&gt;toolbar, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_show(view-&gt;toolbar);
}
</pre>
</li>
<li>
<p>Each view page is created in the <span style="font-family: Courier New,Courier,monospace">_create_view_page()</span> function:</p>

<pre class="prettyprint">
static bool 
_create_view_page(s_view_data *view, page_type_t p_type)
{
&nbsp;&nbsp;&nbsp;// Create a new elm_layout component
&nbsp;&nbsp;&nbsp;page = elm_layout_add(view-&gt;layout);

&nbsp;&nbsp;&nbsp;// Check the page type (A, B, or C) 
&nbsp;&nbsp;&nbsp;// Each is different but uses the same EDJE file to load the layout
&nbsp;&nbsp;&nbsp;switch (p_type)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PAGE_TYPE_A:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load the custom page group for the created EDJE file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!elm_layout_file_set(page, edje_path, GROUP_PAGE_CUSTOM))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the properties of the created page
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_part_text_set(page, PART_PAGE_TITLE, &quot;Screen-A&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_object_signal_emit(page, SIGNAL_SCREEN_A_BG, SIGNAL_SOURCE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;a_page = page;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PAGE_TYPE_B:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load the default page group
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!elm_layout_file_set(page, edje_path, GROUP_PAGE_DEFAULT))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fill the default page with animation type selectors
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!_create_animation_selectors(view))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PAGE_TYPE_C:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Similar content
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:

&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>The default page view consists of labels and 2 sets of <span style="font-family: Courier New,Courier,monospace">elm_radio</span> buttons. The <span style="font-family: Courier New,Courier,monospace">elm_radio</span> selectors are responsible for setting the animation type for the screens A and C. They are created in the <span style="font-family: Courier New,Courier,monospace">_create_animation_selectors()</span>, <span style="font-family: Courier New,Courier,monospace">_fill_animation_selectors()</span>, and <span style="font-family: Courier New,Courier,monospace">_create_radio_button()</span> functions:</p>

<pre class="prettyprint">
static bool 
_create_animation_selectors(s_view_data *view)
{
&nbsp;&nbsp;&nbsp;// Create a container for the first group of the selectors
&nbsp;&nbsp;&nbsp;view-&gt;group_1_box = elm_box_add(view-&gt;b_page);

&nbsp;&nbsp;&nbsp;// Insert the box in the proper swallow parts and set its parameters
&nbsp;&nbsp;&nbsp;elm_object_part_content_set(view-&gt;b_page, PART_PAGE_DEFAULT_ANIM_TYPE_A, view-&gt;group_1_box);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(view-&gt;group_1_box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_show(view-&gt;group_1_box);
&nbsp;&nbsp;&nbsp;elm_box_align_set(view-&gt;group_1_box, 0.5, 0.1);

&nbsp;&nbsp;&nbsp;// Create a container for the second group of the selectors
&nbsp;&nbsp;&nbsp;view-&gt;group_2_box = elm_box_add(view-&gt;b_page);

&nbsp;&nbsp;&nbsp;// Add items to the created containers
&nbsp;&nbsp;&nbsp;if (!_fill_animation_selectors(view))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;}

static bool 
_fill_animation_selectors(s_view_data *view)
{
&nbsp;&nbsp;&nbsp;// Declare helper variables for handling 2 different groups of radio buttons
&nbsp;&nbsp;&nbsp;int r_id_1 = 0;
&nbsp;&nbsp;&nbsp;int r_id_2 = 0;
&nbsp;&nbsp;&nbsp;int i = 0;

&nbsp;&nbsp;&nbsp;// Create the elm_radio component and define the first group of the buttons
&nbsp;&nbsp;&nbsp;view-&gt;radio_gr_1 = __create_radio_button(view, view-&gt;group_1_box, radio_names[0], r_id_1++);
&nbsp;&nbsp;&nbsp;if (!view-&gt;radio_gr_1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;// Create the elm_radio component and define the second group of the buttons
&nbsp;&nbsp;&nbsp;view-&gt;radio_gr_2 = __create_radio_button(view, view-&gt;group_2_box, radio_names[0], r_id_2++);
&nbsp;&nbsp;&nbsp;if (!view-&gt;radio_gr_2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;// Create radio buttons for each type of animation and attach the created components to the group
&nbsp;&nbsp;&nbsp;for (i = 1; i &lt; ANIM_TYPES_CNT; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio = __create_radio_button(view, view-&gt;group_1_box, radio_names[i], r_id_1++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!radio)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_radio_group_add(radio, view-&gt;radio_gr_1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio = __create_radio_button(view, view-&gt;group_2_box, radio_names[i], r_id_2++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!radio)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_radio_group_add(radio, view-&gt;radio_gr_2);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Variable indicating which radio button is checked
&nbsp;&nbsp;&nbsp;elm_radio_value_pointer_set(view-&gt;radio_gr_1, &amp;(view-&gt;actual_indice_scr_a));
&nbsp;&nbsp;&nbsp;elm_radio_value_pointer_set(view-&gt;radio_gr_2, &amp;(view-&gt;actual_indice_scr_c));
}
</pre>
</li>
<li>
<p>The view animations are invoked in callbacks attached to the <span style="font-family: Courier New,Courier,monospace">elm_toolbar</span> component. Each &quot;activate&quot; function calls an external function from the animator module with proper parameters.</p>

<p>The functions for switching the current view between B and C screens are quite similar.</p>

<pre class="prettyprint">
static void 
_screen_a_activate(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;Evas_Object *current_page = NULL;
&nbsp;&nbsp;&nbsp;animator_type_t tmp = ANIMATION_TYPE_NONE;
&nbsp;&nbsp;&nbsp;s_view_data *view = (s_view_data*) data;

&nbsp;&nbsp;&nbsp;// Check the active view type
&nbsp;&nbsp;&nbsp;// If the user clicks the same tab in the toolbar twice, this function must be stopped
&nbsp;&nbsp;&nbsp;if (view-&gt;active_view == ACTIVE_VIEW_TYPE_SCR_A)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// When a specific view is displayed for the first time, a new page must be created
&nbsp;&nbsp;&nbsp;// Implementation is described later
&nbsp;&nbsp;&nbsp;if (!view-&gt;a_page)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!_create_view_page(view, PAGE_TYPE_A))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Unset the current view of the main layout and set a new one
&nbsp;&nbsp;&nbsp;current_page = elm_object_part_content_unset(view-&gt;layout, PART_PAGE);
&nbsp;&nbsp;&nbsp;elm_object_part_content_set(view-&gt;layout, PART_PAGE, view-&gt;a_page);
&nbsp;&nbsp;&nbsp;evas_object_show(view-&gt;a_page);

&nbsp;&nbsp;&nbsp;// Check the selected animation type (implementation is described below)
&nbsp;&nbsp;&nbsp;__set_animations_type(view);

&nbsp;&nbsp;&nbsp;// Invoke the animator function for switching the view
&nbsp;&nbsp;&nbsp;if (view-&gt;animator_scr_a != ANIMATION_TYPE_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = view-&gt;animator_scr_c;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_NONE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animator_page_switch(current_page, view-&gt;a_page, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a, view-&gt;animator_scr_c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = tmp;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// If no animation is selected, hide the visible page to show another screen
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_hide(current_page);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Set the active view type
&nbsp;&nbsp;&nbsp;view-&gt;active_view = ACTIVE_VIEW_TYPE_SCR_A;
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__set_animations_type()</span> function checks which of the radio buttons is selected and sets the valid animation type:</p>

<pre class="prettyprint">
static bool
__set_animations_type(s_view_data *view) 
{
&nbsp;&nbsp;&nbsp;switch (view-&gt;actual_indice_scr_a) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a = ANIMATION_TYPE_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a = ANIMATION_TYPE_WIPE_LEFT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a = ANIMATION_TYPE_SPLIT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a = ANIMATION_TYPE_FADE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_a = ANIMATION_TYPE_RESIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;switch (view-&gt;actual_indice_scr_c) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_WIPE_RIGHT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_SPLIT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_FADE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view-&gt;animator_scr_c = ANIMATION_TYPE_RESIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>

<h3>Animator Module</h3>
<p>The animator module is responsible for smooth transitions between the screens. The 3 different methods provided by the EFL and Elementary APIs are used to demonstrate how the view can be changed:</p>
<ul>
	<li><span style="font-family: Courier New,Courier,monospace">elm_transitions</span></li>
	<li><span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span></li>
	<li>Animations in the EDJE file</li>
</ul>

<h4>Using the elm_transition</h4>
<p>The Elementary transition mechanism is used to prepare a wipe animation. Only the current page pointer is needed to create this animation. The <span style="font-family: Courier New,Courier,monospace">Elm_Transit_Effect_Wipe_Dir</span> parameter is used to select the wipe direction. If the next page is screen A, the wipe direction is set to <span style="font-family: Courier New,Courier,monospace">ELM_TRANSIT_EFFECT_WIPE_DIR_LEFT</span>, otherwise the <span style="font-family: Courier New,Courier,monospace">dir</span> value is equal to <span style="font-family: Courier New,Courier,monospace">ELM_TRANSIT_EFFECT_WIPE_DIR_RIGHT</span>.</p>

<pre class="prettyprint">
static void 
_start_wipe_animation(Evas_Object *c_page, Elm_Transit_Effect_Wipe_Dir dir)
{
&nbsp;&nbsp;&nbsp;// Create a new Elm_Transit object
&nbsp;&nbsp;&nbsp;Elm_Transit *c_page_transit = NULL;
&nbsp;&nbsp;&nbsp;c_page_transit = elm_transit_add();

&nbsp;&nbsp;&nbsp;// Add the Evas_Object to be animated
&nbsp;&nbsp;&nbsp;elm_transit_object_add(c_page_transit, c_page);
&nbsp;&nbsp;&nbsp;// Set the animation effect
&nbsp;&nbsp;&nbsp;elm_transit_effect_wipe_add(c_page_transit, ELM_TRANSIT_EFFECT_WIPE_TYPE_HIDE, dir);
&nbsp;&nbsp;&nbsp;// Set the animation duration
&nbsp;&nbsp;&nbsp;elm_transit_duration_set(c_page_transit, 0.5);
&nbsp;&nbsp;&nbsp;// Add a callback which is invoked when the Elm_Transit object is deleted 
&nbsp;&nbsp;&nbsp;// (it means the end of the animation)
&nbsp;&nbsp;&nbsp;elm_transit_del_cb_set(c_page_transit, _transit_current_del_cb, c_page);
&nbsp;&nbsp;&nbsp;// Start the animation
&nbsp;&nbsp;&nbsp;elm_transit_go(c_page_transit);
}
</pre>


<h4>Using the Ecore_Animator</h4>
<p>The <span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span> is used for resize and fade animations. The following example shows the resize animation. The fade animation is similar, and its implementation is omitted. The <span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span> mechanism requires a callback, which is invoked when a new animator object is created.</p>
<p>To create a resize animation:</p>
<ol>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">_start_resize_animation()</span> function creates a new object and sets parameters for the callback which changes the object properties.</p>

<pre class="prettyprint">
static void 
_start_resize_animation(Evas_Object *c_page, Evas_Object *n_page)
{
&nbsp;&nbsp;&nbsp;Ecore_Animator *animator = NULL;
&nbsp;&nbsp;&nbsp;animation_data_t *anim_data = NULL;

&nbsp;&nbsp;&nbsp;// Get the data necessary for the page animation
&nbsp;&nbsp;&nbsp;// Animation logic must know the current size and position of the resized page
&nbsp;&nbsp;&nbsp;evas_object_geometry_get(c_page, &amp;x, &amp;y, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;anim_data = (animation_data_t*) malloc(sizeof(*anim_data));

&nbsp;&nbsp;&nbsp;// Set the obtained data in the animation data structure
&nbsp;&nbsp;&nbsp;anim_data-&gt;c_obj = c_page;
&nbsp;&nbsp;&nbsp;anim_data-&gt;n_obj = n_page;
&nbsp;&nbsp;&nbsp;anim_data-&gt;x = x;
&nbsp;&nbsp;&nbsp;anim_data-&gt;y = y;
&nbsp;&nbsp;&nbsp;anim_data-&gt;w = w;
&nbsp;&nbsp;&nbsp;anim_data-&gt;h = h;

&nbsp;&nbsp;&nbsp;// Create the animation object and pass a callback function which is invoked in the animation loop
&nbsp;&nbsp;&nbsp;animator = ecore_animator_timeline_add(0.5, _resize_animator_timeline_cb, anim_data);
}
</pre>
</li>
<li>
<p>The implementation for the callback which animates the transit between the pages takes 2 parameters: the data pointer which is passed when the animator object is created and the position value. It is a double value range from 0.0 to 1.0, and it is used to acquire the progress of the current animation.</p>

<pre class="prettyprint">
static Eina_Bool 
_resize_animator_timeline_cb(void *data, double pos)
{
&nbsp;&nbsp;&nbsp;// Resize the animation: maximize the next page and minimize the current one
&nbsp;&nbsp;&nbsp;// Second parameter is needed with the value opposite to the pos value
&nbsp;&nbsp;&nbsp;double frame = 1.0 - pos;
&nbsp;&nbsp;&nbsp;animation_data_t *anim_data = (animation_data_t*) data;

&nbsp;&nbsp;&nbsp;// Set new size and position values for the current page
&nbsp;&nbsp;&nbsp;new_c_w = anim_data-&gt;w * frame;
&nbsp;&nbsp;&nbsp;new_c_h = anim_data-&gt;h * frame;
&nbsp;&nbsp;&nbsp;new_c_x = (anim_data-&gt;x + (double)(anim_data-&gt;w - new_c_w)/2);
&nbsp;&nbsp;&nbsp;new_c_y = (anim_data-&gt;y + (double)(anim_data-&gt;h - new_c_h)/2);

&nbsp;&nbsp;&nbsp;// Set new size and position values for the next page
&nbsp;&nbsp;&nbsp;new_n_w = anim_data-&gt;w * pos;
&nbsp;&nbsp;&nbsp;new_n_h = anim_data-&gt;h * pos;
&nbsp;&nbsp;&nbsp;new_n_x = (anim_data-&gt;x + (double)(anim_data-&gt;w - new_n_w)/2);
&nbsp;&nbsp;&nbsp;new_n_y = (anim_data-&gt;y + (double)(anim_data-&gt;h - new_n_h)/2);

&nbsp;&nbsp;&nbsp;// Use new values to change the parameters of the Evas_Object
&nbsp;&nbsp;&nbsp;evas_object_resize(anim_data-&gt;c_obj, new_c_w, new_c_h);

&nbsp;&nbsp;&nbsp;// Animation must resize the object from the center of the screen, so it 
&nbsp;&nbsp;&nbsp;// must be moved after it is resized
&nbsp;&nbsp;&nbsp;evas_object_move(anim_data-&gt;c_obj, new_c_x, new_c_y);

&nbsp;&nbsp;&nbsp;// Make a couple of additional changes to smoothen the disappearing effect
&nbsp;&nbsp;&nbsp;evas_object_color_set(anim_data-&gt;c_obj, 255, 255, 255, 255 * frame);

&nbsp;&nbsp;&nbsp;// Use the same functions for the next page animation
&nbsp;&nbsp;&nbsp;evas_object_resize(anim_data-&gt;n_obj, new_n_w, new_n_h);
&nbsp;&nbsp;&nbsp;evas_object_move(anim_data-&gt;n_obj, new_n_x, new_n_y);
&nbsp;&nbsp;&nbsp;evas_object_color_set(anim_data-&gt;n_obj, 255, 255, 255, 255 * pos);

&nbsp;&nbsp;&nbsp;// If the pos parameter equals 1.0, it is the last animation tick, so the 
&nbsp;&nbsp;&nbsp;// animation data is freed and the last properties for the next page are set
&nbsp;&nbsp;&nbsp;if (pos == 1.0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_hide(anim_data-&gt;c_obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_color_set(anim_data-&gt;c_obj, 255, 255, 255, 255);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(anim_data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ECORE_CALLBACK_CANCEL;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ol>

<h4>Using EDJE for Animations</h4>
<p>If the Edje API is used for the animation, all logic responsible for changing the state of the view is implemented in the <span style="font-family: Courier New,Courier,monospace">.edc</span> script file. To start the animation, the <span style="font-family: Courier New,Courier,monospace"> elm_object_signal_emit()</span> function is used. If the application must be informed of the end of the animation, an event listener must be set for a proper signal.</p>

<pre class="prettyprint">
static void 
_start_split_animation(Evas_Object *c_page, Evas_Object *n_page)
{
&nbsp;&nbsp;&nbsp;// Send the signal to the EDJE layout file
&nbsp;&nbsp;&nbsp;elm_object_signal_emit(c_page, SIGNAL_SPLIT_HORIZONTAL, SIGNAL_SOURCE);
&nbsp;&nbsp;&nbsp;// Add an event listener for the animation done signal from the EDJE layout
&nbsp;&nbsp;&nbsp;elm_object_signal_callback_add(c_page, SIGNAL_SPLIT_ANIM_DONE, SIGNAL_SOURCE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_split_anim_done_cb, c_page);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">_split_anim_done_cb()</span> callback function is used only to hide the current page when the animation is finished.</p>

<p>The implementation of the animation in the EDJE layout file is very simple. If the EDJE file consists of parts, you only need to define the custom states for them and programs that react for proper events.</p>
<p>The split animation splits the page horizontally and moves the parts from the top of the screen up and parts from the bottom of the screen down. The EDJE file for the screen B consists of:</p>
<ul>
	<li>Part for the main title at the top of the page</li>
	<li>Labels for the &quot;Screen-A&quot; and &quot;Screen-C&quot; animation types</li>
	<li>Swallow parts for the <span style="font-family: Courier New,Courier,monospace">elm_hoversel</span> components</li>
</ul>

<p>The following example describes the animation implementation for the main title. The implementation for other parts is similar.</p>
<pre class="prettyprint">
part 
{
&nbsp;&nbsp;&nbsp;name: PART_PAGE_TITLE;
&nbsp;&nbsp;&nbsp;type: TEXT;
&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Default state of the part defines the initial position and size of the part
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.0 0.05;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 1.0 0.25;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;description 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state: &quot;split_animation&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit: &quot;default&quot; 0.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// In a split animation state, the part moves up the screen, so the 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// relative parameters are negative
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel1 {relative: 0.0 -0.05;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel2 {relative: 1.0 -0.25;}
&nbsp;&nbsp;&nbsp;}
}
</pre>


<p>To change the state of the part and animate its position change, a program is used in the EDJE file:</p>

<pre class="prettyprint">
program 
{
&nbsp;&nbsp;&nbsp;name: &quot;split_anim_start&quot;;
&nbsp;&nbsp;&nbsp;// Program is executed when the EDJE file receives the SIGNAL_SPLIT_HORIZONTAL 
&nbsp;&nbsp;&nbsp;// signal from the SIGNAL_SOURCE
&nbsp;&nbsp;&nbsp;signal: SIGNAL_SPLIT_HORIZONTAL;
&nbsp;&nbsp;&nbsp;source: SIGNAL_SOURCE;
&nbsp;&nbsp;&nbsp;// Define the program action. In this case, STATE_SET means that the state of the 
&nbsp;&nbsp;&nbsp;// part is changed to &quot;split_animation&quot; 0.0
&nbsp;&nbsp;&nbsp;action: STATE_SET &quot;split_animation&quot; 0.0;
&nbsp;&nbsp;&nbsp;// Define the program target
&nbsp;&nbsp;&nbsp;target: PART_PAGE_TITLE;
&nbsp;&nbsp;&nbsp;// Define the program to be called after the &quot;split_anim_start&quot; program
&nbsp;&nbsp;&nbsp;after: &quot;animation_done&quot;;
&nbsp;&nbsp;&nbsp;// Set the animation type to DECELERATE and its duration time to 0.5 seconds
&nbsp;&nbsp;&nbsp;transition: DECELERATE 0.5;
}
</pre>


<p>Each program defined in the EDJE file can perform only 1 action. If 1 program must be connected to more than 1 action property, the <span style="font-family: Courier New,Courier,monospace">after</span> element must be used to define the next action. In this sample, <span style="font-family: Courier New,Courier,monospace">after</span> invokes the <span style="font-family: Courier New,Courier,monospace">animation_done</span> program:</p>

<pre class="prettyprint">
program 
{
&nbsp;&nbsp;&nbsp;name: &quot;animation_done&quot;;
&nbsp;&nbsp;&nbsp;// This action emits a signal to inform that the animation handled in the animator module is finished
&nbsp;&nbsp;&nbsp;action: SIGNAL_EMIT SIGNAL_SPLIT_ANIM_DONE SIGNAL_SOURCE;

}
</pre>


<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Data-Control-Consumer Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mn_icon.png"/></p>
	</div>

	<h1>Data-Control-Consumer Sample Overview</h1>

	<p>
		The sample demonstrates how to exchange data between a consumer application and a provider service. There are two methods of data exchange:
		<ul>
			<li>Map method - using key value pairs;</li>
			<li>Sql method - using sql queries.</li>
		</ul>
	</p>

	<p>The figures below illustrate the application's view.</p>
	<p id="app-screenshot" class="figure">Figure: Data-Control-Consumer application screens.</p>
	<p style="text-align:center;">
		<img alt="The 'Map' view" height="364" hspace="20" src="../images/data_control_consumer/data_control_consumer_view_map.png" />
		<img alt="The 'Sql' view" height="364" hspace="20" src="../images/data_control_consumer/data_control_consumer_view_sql.png" />
	</p>
	<p>The sample application's user interface consists of two views:</p>
		<ul>
			<li>Map view - allows to use the 'map' communication method;</li>
			<li>Sql view - allows to use the 'sql' communication method.</li>
		</ul>

	<p>Both views are divided into two sections:</p>
	<ul>
		<li>Input - allows the user to send a request to the provider application;</li>
		<li>Output - displays the data received from the provider application.</li>
	</ul>

	<p>The structure of the user interface is depicted below.</p>
	<p id="ui-struct-map" class="figure">Figure: Data-Control-Consumer map view layout structure.</p>
	<p style="text-align:center;">
		<img alt="Data-Control-Consumer map layout structure " hspace="80" height="550" src="../images/data_control_consumer/data-control-consumer-map-layout.png" />
	</p>
	<br/>
	<p id="ui-struct-sql" class="figure">Figure: Data-Control-Consumer slq view layout structure.</p>
	<p style="text-align:center;">
		<img alt="Data-Control-Consumer sql layout structure " hspace="80" height="550" src="../images/data_control_consumer/data-control-consumer-sql-layout.png" />
	</p>

	<p> The application's workflow can be divided into the following pipelines:</p>
		<ul>
			<li>application initialization;</li>
			<li>map request and response;</li>
			<li>sql request and response.</li>
		</ul>
	</p>

	<p id="ui-struct" class="figure">Figure: Data-Control-Consumer application workflow.</p>
	<p style="text-align:center;">
		<img alt="Data-Control-Consumer application workflow" hspace="80" height="550" src="../images/data_control_consumer/data-control-consumer-workflow.png" />
	</p>

	<h3>Prerequisites</h3>

		<ul>
			<li>The provider's app ID must be obtained.</li>
			<li>Privileges required:</li>
			<ul>
				<li>http://tizen.org/privilege/datasharing;</li>
				<li>http://tizen.org/privilege/appmanager.launch.</li>
			</ul>
		</ul>

	<h2>Implementation</h2>

	<h3>GUI</h3>

	<p>The GUI was created using the WYSWIG UI-Builder editor which is a part of the Tizen SDK.</p>
	<p>A GUI project consist of the following elements:</p>
	<ul>
		<li>app.xml file - contains base UI information;</li>
		<li>layout/layout.tuml file - contains the layout structure (widget positions, callback names etc.);</li>
		<li>src/managed folder - contains the *.c and *.h files generated by the UI-Builder. This folder is created when the application is built and removed when the 'clean' option is used. It is also updated when the layout.tuml file is saved. Contents of this folder mustn't be modified manually;</li>
		<li>src/event_handler folder - contains the event handlers code generated by the UI-Builder. The UI-Builder creates stubs of callback functions that can be edited by the user. </li>
	</ul>

	<h4>Layout editor</h4>
	<p>The user can create the UI using the WYSWIG editor. Widgets can be added and modified using drag&drop. The parameters of the selected widget can be adjusted using the panel on the right (check the UI-Builder documentation for details). There are two project templates for UI-Builder applications: single-view and navigation. The data-control-consumer app is created using the navigation template. The UI uses an elm_conformant widget as root. This is created by default for an UI-Builder application and cannot be changed. An elm_naviframe is used as the conformant's <a href = "#ui-struct">layout</a>. The naviframe can switch between two views: 'Map' and 'Sql'. </p>

	<p class="figure">Figure: UI-Builder View display</p>
	<p style="text-align:center;">
		<img alt="UI-Builder View display" src="../images/data_control_consumer/Data-Control-Consumer-UI-Builder-views.png" />
	</p>

	<p>Note that there are three views available. The first one is the naviframe while the second and third contain the displayed pages. The first view doesn't allow the user to add any widgets using drag&drop. In this view you can select one of the remaining views to be used as the default content pushed to the naviframe.</p>

	<p class="figure">Figure: The naviframe view</p>
	<p id="ID" style="text-align:center;">
		<img alt="Naviframe view" height="364" hspace="20" src="../images/data_control_consumer/data_control_consumer_naviframe_view.png" />
	</p>

	<h4>Connections</h4>
	<p>In order to design the application's view switching, the connections are used. You can access them via the 'Storyboard' tab of the UI-Builder (check Tizen SDK help for details).</p>

	<p class="figure">Figure: UI-Builder connections view</p>
<p id="UI-Builder-connections-view" style="text-align:center;">
	<img alt="UI-Builder connections view" height="550" hspace="20" src="../images/data_control_consumer/data-control-consumer-UI-Builder-connections.png" />
</p>

	<p>The view1 (the Naviframe view) is connected with the view2. This indicates that the view2 is used as the naviframe's default view. When the user adds a connection between other views it will be displayed here. Note that a new callback code will be created (file  will be created if required) in <span style="font-family: Courier New,Courier,monospace">src/managed/connection</span> folder. Also a 'pre' and 'post' functions will be added to one of the files in <span style="font-family: Courier New,Courier,monospace">src/event_handler</span> folder.</p>

	<p>On view change, the below callback function is invoked.</p>
	<pre class="prettyprint">
void view2_connection_to_sql_button_onclicked(uib_view2_view_context *vc, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;view2_to_sql_button_onclicked(vc, obj, event_info);
&nbsp;&nbsp;&nbsp;Elm_Object_Item *navi_item = change_page(vc->parent, "SQL", NULL, NULL, "view3", NULL);
&nbsp;&nbsp;&nbsp;view2_to_sql_button_onclicked_post(navi_item, vc, obj, event_info);
}
	</pre>
	<p>The <span style="font-family: Courier New,Courier,monospace">change_page()</span> function uses the <span style="font-family: Courier New,Courier,monospace">elm_naviframe_item_push()</span> to switch the views. Note that there is no reverse connection from view3 to view2. Instead there is a callback function added to the <span style="font-family: Courier New,Courier,monospace">to_map_button</span> widget that invokes <span style="font-family: Courier New,Courier,monospace">elm_naviframe_item_pop()</span> function, which avoids recurring pages stacking.</p>

<h4>Event handlers</h4>
<p>The event handler callback stubs are created using the WYSWIG editor</p>
<p class="figure">Figure: Default event_handler name</p>
<p id="callback-function" style="text-align:center;">
	<img alt="Default event_handler name" height="550" hspace="20" src="../images/data_control_consumer/data-control-consumer-ui-builder-event-handler.png" />
</p>

<p class="figure">Figure: Final name of the callback function</p>
<p id="final-callback-function" style="text-align:center;">
	<img alt="Final name of the callback function" height="100" hspace="20" src="../images/data_control_consumer/data-control-consumer-ui-builder-event-handler-final.png" />
</p>

<p>Note that the callback's name is followed by the view's name. This is a standard behaviour of the UI-Builder and cannot be changed. After the function stub creation is completed, the user can modify the callback's source code.</p>


<h2>Implementation</h2>

<h3>Type definitions</h3>

<pre id="app_data" class="prettyprint">
/* Base data structure. By default containing the application's main window. */
struct _app_data {
&nbsp;&nbsp;&nbsp;window_obj *win;
};

typedef struct _app_data app_data;
</pre>


<h4>Managed content</h4>
<p>Managed content is the part of the source code that is automatically created by the UI-Builder. This code should not be modified by the user as it is altered by the tool each time the project is built.</p>

<pre class="prettyprint">
/*Base application structure*/
typedef struct
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *bg;
&nbsp;&nbsp;&nbsp;Evas_Object *conformant;
&nbsp;&nbsp;&nbsp;Evas_Object *layout;
} window_obj;
</pre>

<pre class="prettyprint">
/*Base view's layout structure*/
typedef struct _uib_view_context
{
&nbsp;&nbsp;&nbsp;Evas_Object* 	parent;
&nbsp;&nbsp;&nbsp;Evas_Object* 	root_container;
&nbsp;&nbsp;&nbsp;const char*  	view_name;
} uib_view_context;
</pre>



<!-- ********************************************************************************** -->
<pre class="prettyprint">
/*Structure used to store the view1's content*/
typedef struct _uib_view1_view_context {

&nbsp;&nbsp;&nbsp;/* view's parent object - the Naviframe widget */
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;/* root container UI Component of this view */
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;/* view class name */
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;/* control context to control this view */
&nbsp;&nbsp;&nbsp;struct _uib_view1_control_context *cc;

&nbsp;&nbsp;&nbsp;/* UI Components in this view */
&nbsp;&nbsp;&nbsp;Evas_Object *naviframe1;
} uib_view1_view_context;
</pre>

<pre class="prettyprint">
/*Structure used to store the view2's content*/
typedef struct _uib_view2_view_context {

&nbsp;&nbsp;&nbsp;/* view's parent object - the Naviframe widget */
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;/* root container UI Component of this view */
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;/* view class name */
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;/* control context to control this view */
&nbsp;&nbsp;&nbsp;struct _uib_view2_control_context *cc;

&nbsp;&nbsp;&nbsp;/* UI Components in this view */
&nbsp;&nbsp;&nbsp;Evas_Object *grid1;
&nbsp;&nbsp;&nbsp;Evas_Object *to_sql_button;
&nbsp;&nbsp;&nbsp;Evas_Object *key_label;
&nbsp;&nbsp;&nbsp;Evas_Object *key_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *old_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list_label;
&nbsp;&nbsp;&nbsp;Evas_Object *old_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *new_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *new_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *box1;
&nbsp;&nbsp;&nbsp;Evas_Object *get_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *set_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *add_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *remove_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *get_keys_button;
} uib_view2_view_context;
</pre>

<pre class="prettyprint">
/*Structure used to store the view2's content*/
typedef struct _uib_view3_view_context {

&nbsp;&nbsp;&nbsp;/* view's parent object - the Naviframe widget */
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;/* root container UI Component of this view */
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;/* view class name */
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;/* control context to control this view */
&nbsp;&nbsp;&nbsp;struct _uib_view3_control_context *cc;

&nbsp;&nbsp;&nbsp;/* UI Components in this view */
&nbsp;&nbsp;&nbsp;Evas_Object *grid1;
&nbsp;&nbsp;&nbsp;Evas_Object *to_map_button;
&nbsp;&nbsp;&nbsp;Evas_Object *where_label;
&nbsp;&nbsp;&nbsp;Evas_Object *where_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *column_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list;
&nbsp;&nbsp;&nbsp;Evas_Object *data_label;
&nbsp;&nbsp;&nbsp;Evas_Object *column_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *select_button;
&nbsp;&nbsp;&nbsp;Evas_Object *insert_button;
&nbsp;&nbsp;&nbsp;Evas_Object *set_button;
&nbsp;&nbsp;&nbsp;Evas_Object *delete_button;
&nbsp;&nbsp;&nbsp;Evas_Object *column_name_label;
&nbsp;&nbsp;&nbsp;Evas_Object *column_name_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *order_none_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *order_asc_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *order_dsc_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *sort_column_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *title_label;
} uib_view3_view_context;
</pre>

<pre class="prettyprint">
/*Structure that stores the view layout structures*/
typedef struct _uib_view_data {
&nbsp;&nbsp;&nbsp;Evas_Object* win;

&nbsp;&nbsp;&nbsp;uib_view_context* view1;
&nbsp;&nbsp;&nbsp;uib_view_context* view2;
&nbsp;&nbsp;&nbsp;uib_view_context* view3;
} uib_view_data;
</pre>

<p>Note that the <span style="font-family: Courier New,Courier,monospace">uib_view_context</span> is used here while the view's content uses the <span style="font-family: Courier New,Courier,monospace">uib_view1_view_context, uib_view2_view_context, uib_view3_view_context</span> structures. A type-cast between <span style="font-family: Courier New,Courier,monospace">uib_view_context</span> and view structures is often used in UI-Builder code.</p>

<pre id = "map_structure" class="prettyprint">
/*Structure used by the 'map' part of the consumer application*/
static struct {
&nbsp;&nbsp;&nbsp;data_control_map_response_cb map_callback;
&nbsp;&nbsp;&nbsp;data_control_h provider;

&nbsp;&nbsp;&nbsp;On_New_Data_Recieved_Cb new_data_recived_cb;
&nbsp;&nbsp;&nbsp;error_recived_cb_t error_recived_cb;

&nbsp;&nbsp;&nbsp;char *last_key_used;
} s_info
</pre>


<h3 id="app-init">Application initialization</h3>

<p>The entire application's life-cycle is implemented in the main source file using a common Tizen application structure: </p>

<pre class="prettyprint">
int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;int result = 0;
&nbsp;&nbsp;&nbsp;app_data *app = app_create();
&nbsp;&nbsp;&nbsp;if (app)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = app_run(app, argc, argv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app_destroy(app);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return result;
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">app_create()</span> function is mainly used to initialize the base <a href="#app_data">app_data</a> structure.</p>
<pre class="prettyprint">
app_data *app_create(void)
{
&nbsp;&nbsp;&nbsp;base_scale_set();
&nbsp;&nbsp;&nbsp;return calloc(1, sizeof(app_data));
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">app_run()</span> function is used to initialize the application's callbacks and run the standard Tizen app loop.</p>
<pre class="prettyprint">
int app_run(app_data *app, int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s cbs =
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.create = _on_create_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.terminate = _on_terminate_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pause = _on_pause_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.resume = _on_resume_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.app_control = _on_app_control_cb,
&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL, };

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, _on_low_battery_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, _on_low_memory_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, _on_device_orientation_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, _on_language_changed_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, _on_region_format_changed_cb, app);

&nbsp;&nbsp;&nbsp;return ui_app_main(argc, argv, &cbs, app);
}
</pre>

<h3>Data exchange with the provider application</h3>
<p>The communication between the consumer and the provider can be done using either the 'sql' or the 'map' method. While the data used by the map and sql methods has a different structure (hash map and database), the data exchange implementation in both cases is very similar:</p>
<ul>
	<li>data consumer - send request;</li>
	<li>data provider - send response or an error message;</li>
	<li>data consumer - react to the data received;</li>
	<li>data consumer - update the UI.</li>
</ul>

<h4>Map</h4>
<h5>Initialization:</h5>

<p>In order to achieve communication with the provider app, the correct provider app ID must be set. The ID can be found in the provider's manifest. The <span style="font-family: Courier New,Courier,monospace">data_control_map_response_cb</span> must be filled with correct functions.</p>

<pre class="prettyprint">

void map_consumer_init(On_New_Data_Recieved_Cb new_data_recived_cb, error_recived_cb_t error_recived_cb)
{
&nbsp;&nbsp;&nbsp;const char *provider_id = "http://data-control-provider.com/datacontrol/provider/data-control-provider"; /* The provider ID */
&nbsp;&nbsp;&nbsp;const char *data_id = "table";
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;/* Create data control handler */
&nbsp;&nbsp;&nbsp;ret = data_control_map_create(&(s_info.provider));
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* Setting the provider ID*/
&nbsp;&nbsp;&nbsp;ret = data_control_map_set_provider_id(s_info.provider, provider_id);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* Setting the data ID */
&nbsp;&nbsp;&nbsp;ret = data_control_map_set_data_id(s_info.provider, data_id);
&nbsp;&nbsp;&nbsp;/* ... */

&nbsp;&nbsp;&nbsp;/* Response callbacks */
&nbsp;&nbsp;&nbsp;s_info.map_callback.get_cb = __map_get_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.set_cb = __map_set_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.add_cb = __map_add_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.remove_cb = __map_remove_response_cb;

&nbsp;&nbsp;&nbsp;/* Register response callback */
&nbsp;&nbsp;&nbsp;ret = data_control_map_register_response_cb(s_info.provider, &s_info.map_callback, NULL);
&nbsp;&nbsp;&nbsp;/* ... /
}
</pre>

<p>To provide full communication between the map consumer and the provider, four request functions and four callbacks have to be implemented.</p>

<h5>Request functions:</h5>
There are four request functions:

<ul>
	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_add(s_info.provider, key, value, &req_id);</span> - this function is used to add new values to the provider's hash map. If the map doesn't contain the searched key, a new one should be created. Note that one key can hold multiple values. The key string is taken from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">key_entry</a></span> widget and the value from <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">new_value_entry</a></span> widget.</li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_get(s_info.provider, key, &req_id);</span> - this function is used to get the values held by the given key. The key string is taken from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">key_entry</a></span> widget.</li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_set(s_info.provider, key, old, new, &req_id);</span> - this function is used to update the given value held by the given key. If there is no value equal to <span style="font-family: Courier New,Courier,monospace">old</span>, an error message should be provided. The key string is taken from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">key_entry</a></span> widget, the 'old' string from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">old_value_entry</a></span> widget and the 'new' string from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">new_value_entry</a></span> widget.</li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_remove(s_info.provider, key, value, &req_id);</span> - this function is used to remove the given value held by the given key. If a key is empty after this operation, it should be removed as well. If there is no value equal to <span style="font-family: Courier New,Courier,monospace">value</span> or key equal to <span style="font-family: Courier New,Courier,monospace">key</span>, an error message should be provided. The key string is taken from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">key_entry</a></span> widget and the value from <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">new_value_entry</a></span> widget.</li>
</ul>

<p>Note that there is one extra button in the <a href="#ui-struct-map">map view</a>. The <span style="font-family: Courier New,Courier,monospace">Keys</span> button sends a special get request using a "#GET_ALL_KEYS" key. In this case value received from the provider will contain all keys stored by the provider app.</p>

<p>The above functions are invoked by click events of the <span style="font-family: Courier New,Courier,monospace">get_data_button</span>, <span style="font-family: Courier New,Courier,monospace">set_data_button</span>, <span style="font-family: Courier New,Courier,monospace">remove_data_button</span> and <span style="font-family: Courier New,Courier,monospace">add_data_button</span> buttons placed in the <a href="#ui-struct-map">map view</a>. The above functions are used to send requests to the provider app. The provider app should send a response. Based on the response type, one of the below callbacks is invoked.</p>

<h5>Callback definitions:</h5>

<pre class="prettyprint">
static void __map_get_response_cb(int request_id, data_control_h provider, char **ret_value_list, int ret_value_count, bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>
<p>The above callback is invoked when a get request is sent. The values assigned to a given key are passed in the <span style="font-family: Courier New,Courier,monospace">ret_value_list</span> string array. If there was an error, the <span style="font-family: Courier New,Courier,monospace">provider_ret</span> will be set to false and an error message will be provided.</p>

<pre class="prettyprint">
static void __map_set_response_cb(int request_id, data_control_h provider, bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<pre class="prettyprint">
static void __map_add_response_cb(int request_id, data_control_h provider, bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<pre class="prettyprint">
static void __map_remove_response_cb(int request_id, data_control_h provider, bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;/* ... */
}
</pre>

<p>The set, add and remove callbacks all work in the same way. They are used to inform if a given operation was successfull (<span style="font-family: Courier New,Courier,monospace">provider_ret == true</span>) or not. If an error in the communication occured, the <span style="font-family: Courier New,Courier,monospace">error</span> parameter should contain the error message. Note that in every callback except for the get one the get request is invoked. This way the UI can be updated with the modified hash map. Note that when error information is received, the function pointed by <span style="font-family: Courier New,Courier,monospace"><a href="#map_structure">error_recived_cb()</a></span> is invoked and a popup with the error message will be displayed.</p>

<!-- ********************************************************************************** -->

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

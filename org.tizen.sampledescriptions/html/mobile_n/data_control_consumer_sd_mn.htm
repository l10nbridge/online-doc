<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Data-Control-Consumer Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation"></div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>

	<h1>Data-Control-Consumer Sample Overview</h1>

	<p>The Data-Control-Consumer sample application demonstrates how you can exchange data between a consumer application and a provider service using:</p>
		<ul>
			<li>Map method (key-value pairs)</li>
			<li>SQL method (SQL queries)</li>
		</ul>

	<p>The following figure illustrates the main views of the Data-Control-Consumer.</p>
	<p id="app-screenshot" class="figure">Figure: Data-Control-Consumer screens</p>
	<p style="text-align:center;">
		<img alt="Data-Control-Consumer screens" src="../images/data_control_consumer_view_map.png" />
		<img alt="Data-Control-Consumer screens" src="../images/data_control_consumer_view_sql.png" />
	</p>
	<p>The sample application user interface consists of 2 views, which allow you to use the different communication methods (map and SQL). Both views are divided into 2 areas:</p>
	<ul>
		<li>Input: Allows the user to send a request to the provider application.</li>
		<li>Output: Displays the data received from the provider application.</li>
	</ul>

	<p>The structure of the user interface is depicted in the following figures.</p>
	<p id="ui-struct-map" class="figure">Figure: Map view layout structure</p>
	<p style="text-align:center;">
		<img alt="Map view layout structure" src="../images/data-control-consumer-map-layout.png" />
	</p>
	<br/>
	<p id="ui-struct-sql" class="figure">Figure: SQL view layout structure</p>
	<p style="text-align:center;">
		<img alt="SQL view layout structure" src="../images/data-control-consumer-sql-layout.png" />
	</p>

	<p>The application workflow can be divided into the following pipelines:</p>
		<ul>
			<li>Application initialization</li>
			<li>Map request and response</li>
			<li>SQL request and response</li>
		</ul>
		
<p>The following figure describes the workflow.</p>

	<p id="ui-struct" class="figure">Figure: Application workflow</p>
	<p style="text-align:center;">
		<img alt="Application workflow" src="../images/data-control-consumer-workflow.png" />
	</p>

	<h2>Prerequisites</h2>

		<ul>
			<li>The provider app ID must be obtained.</li>
			<li>To ensure proper application execution, the following privileges must be set:
			<ul>
				<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/datasharing</span></li>
				<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/appmanager.launch</span></li>
			</ul></li>
		</ul>

	<h2>Implementation</h2>

	<h3>Type Definitions</h3>
<p>The main data structure is used as a placeholder for the application main window:</p>
	
<pre id="app_data" class="prettyprint">
// Base data structure, by default containing the application main window
struct 
_app_data 
{
&nbsp;&nbsp;&nbsp;window_obj *win;
};

typedef struct _app_data app_data;
</pre>

<p>The managed content is the part of the source code that is automatically created by the UI Builder. You must not modify this code, as it is altered by the tool each time the project is built.</p>

<pre class="prettyprint">
// Base application structure
typedef struct
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *bg;
&nbsp;&nbsp;&nbsp;Evas_Object *conformant;
&nbsp;&nbsp;&nbsp;Evas_Object *layout;
} window_obj;

// Base view layout structure
typedef struct 
_uib_view_context
{
&nbsp;&nbsp;&nbsp;Evas_Object* parent;
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;const char* view_name;
} uib_view_context;

// Structure used to store the view1 content
typedef struct 
_uib_view1_view_context 
{
&nbsp;&nbsp;&nbsp;// View&#39;s parent object - the naviframe component
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;// Root container UI component of this view
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;// View class name
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;// Control context to control this view
&nbsp;&nbsp;&nbsp;struct _uib_view1_control_context *cc;

&nbsp;&nbsp;&nbsp;// UI components in this view
&nbsp;&nbsp;&nbsp;Evas_Object *naviframe1;
} uib_view1_view_context;

// Structure used to store the view2 content
typedef struct 
_uib_view2_view_context 
{
&nbsp;&nbsp;&nbsp;// View&#39;s parent object - the naviframe component
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;// Root container UI component of this view
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;// View class name
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;// Control context to control this view
&nbsp;&nbsp;&nbsp;struct _uib_view2_control_context *cc;

&nbsp;&nbsp;&nbsp;// UI components in this view
&nbsp;&nbsp;&nbsp;Evas_Object *grid1;
&nbsp;&nbsp;&nbsp;Evas_Object *to_sql_button;
&nbsp;&nbsp;&nbsp;Evas_Object *key_label;
&nbsp;&nbsp;&nbsp;Evas_Object *key_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *old_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list_label;
&nbsp;&nbsp;&nbsp;Evas_Object *old_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *new_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *new_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *box1;
&nbsp;&nbsp;&nbsp;Evas_Object *get_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *set_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *add_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *remove_data_button;
&nbsp;&nbsp;&nbsp;Evas_Object *get_keys_button;
} uib_view2_view_context;

// Structure used to store the view3 content
typedef struct 
_uib_view3_view_context 
{
&nbsp;&nbsp;&nbsp;// View&#39;s parent object - the naviframe component
&nbsp;&nbsp;&nbsp;Evas_Object *parent;
&nbsp;&nbsp;&nbsp;// Root container UI component of this view
&nbsp;&nbsp;&nbsp;Evas_Object* root_container;
&nbsp;&nbsp;&nbsp;// View class name
&nbsp;&nbsp;&nbsp;const char *view_name;
&nbsp;&nbsp;&nbsp;// Control context to control this view
&nbsp;&nbsp;&nbsp;struct _uib_view3_control_context *cc;

&nbsp;&nbsp;&nbsp;// UI components in this view
&nbsp;&nbsp;&nbsp;Evas_Object *grid1;
&nbsp;&nbsp;&nbsp;Evas_Object *to_map_button;
&nbsp;&nbsp;&nbsp;Evas_Object *where_label;
&nbsp;&nbsp;&nbsp;Evas_Object *where_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *column_value_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *data_list;
&nbsp;&nbsp;&nbsp;Evas_Object *data_label;
&nbsp;&nbsp;&nbsp;Evas_Object *column_value_label;
&nbsp;&nbsp;&nbsp;Evas_Object *select_button;
&nbsp;&nbsp;&nbsp;Evas_Object *insert_button;
&nbsp;&nbsp;&nbsp;Evas_Object *set_button;
&nbsp;&nbsp;&nbsp;Evas_Object *delete_button;
&nbsp;&nbsp;&nbsp;Evas_Object *column_name_label;
&nbsp;&nbsp;&nbsp;Evas_Object *column_name_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *order_none_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *order_asc_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *order_dsc_radio;
&nbsp;&nbsp;&nbsp;Evas_Object *sort_column_entry;
&nbsp;&nbsp;&nbsp;Evas_Object *title_label;
} uib_view3_view_context;

// Structure that stores the view layout structures
typedef struct 
_uib_view_data 
{
&nbsp;&nbsp;&nbsp;Evas_Object* win;

&nbsp;&nbsp;&nbsp;uib_view_context* view1;
&nbsp;&nbsp;&nbsp;uib_view_context* view2;
&nbsp;&nbsp;&nbsp;uib_view_context* view3;
} uib_view_data;
</pre>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">The <span style="font-family: Courier New,Courier,monospace">uib_view_context</span> instance is used for the view layouts while the views&#39; content uses the <span style="font-family: Courier New,Courier,monospace">uib_view1_view_context</span>, <span style="font-family: Courier New,Courier,monospace">uib_view2_view_context</span>, and <span style="font-family: Courier New,Courier,monospace">uib_view3_view_context</span> structures. A type-cast between <span style="font-family: Courier New,Courier,monospace">uib_view_context</span> and view structures is often used in the UI Builder code.</td> 
    </tr> 
   </tbody> 
  </table>  

<p>The following structure is used for the MAP view:</p>  
  
<pre id = "map_structure" class="prettyprint">
// Structure used by the map part of the consumer application
static struct 
{
&nbsp;&nbsp;&nbsp;data_control_map_response_cb map_callback;
&nbsp;&nbsp;&nbsp;data_control_h provider;

&nbsp;&nbsp;&nbsp;On_New_Data_Received_Cb new_data_received_cb;
&nbsp;&nbsp;&nbsp;error_received_cb_t error_received_cb;

&nbsp;&nbsp;&nbsp;char *last_key_used;
} s_info
</pre>


<h3 id="app-init">Application Initialization</h3>

<p>The application life-cycle is implemented in the main source file using a common Tizen application structure:</p>

<pre class="prettyprint">
int 
main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;int result = 0;
&nbsp;&nbsp;&nbsp;app_data *app = app_create();
&nbsp;&nbsp;&nbsp;if (app)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = app_run(app, argc, argv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app_destroy(app);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return result;
}
</pre>

<ul><li>
<p>The <span style="font-family: Courier New,Courier,monospace">app_create()</span> function is mainly used to initialize the base <a href="#app_data">app_data</a> structure:</p>
<pre class="prettyprint">
app_data 
*app_create(void)
{
&nbsp;&nbsp;&nbsp;base_scale_set();

&nbsp;&nbsp;&nbsp;return calloc(1, sizeof(app_data));
}
</pre></li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">app_run()</span> function is used to initialize the application callbacks and run the standard Tizen application loop:</p>
<pre class="prettyprint">
int 
app_run(app_data *app, int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s cbs =
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.create = _on_create_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.terminate = _on_terminate_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.pause = _on_pause_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.resume = _on_resume_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.app_control = _on_app_control_cb,
&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;app_event_handler_h handlers[5] = {NULL,};

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_low_battery_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_low_memory_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APP_EVENT_DEVICE_ORIENTATION_CHANGED, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_device_orientation_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_language_changed_cb, app);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_REGION_FORMAT_CHANGED], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APP_EVENT_REGION_FORMAT_CHANGED, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_region_format_changed_cb, app);

&nbsp;&nbsp;&nbsp;return ui_app_main(argc, argv, &amp;cbs, app);
}
</pre></li></ul>

<h3>User Interface</h3>

	<p>The user interface is created using the WYSIWYG UI Builder editor provided with the Tizen SDK. A GUI project consist of the following elements:</p>
	<ul>
		<li><span style="font-family: Courier New,Courier,monospace">app.xml</span> file contains the base UI information.</li>
		<li><span style="font-family: Courier New,Courier,monospace">layout/layout.tuml</span> file contains the layout structure (such as UI component positions and callback names).</li>
		<li><span style="font-family: Courier New,Courier,monospace">src/managed</span> folder contains the <span style="font-family: Courier New,Courier,monospace">*.c</span> and <span style="font-family: Courier New,Courier,monospace">*.h</span> files generated by the UI Builder. This folder is created when the application is built and removed when the <span style="font-family: Courier New,Courier,monospace">clean</span> option is used. It is also updated when the <span style="font-family: Courier New,Courier,monospace">layout.tuml</span> file is saved. 
		  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">Do not modify the content of this folder manually.</td> 
    </tr> 
   </tbody> 
  </table>  </li>
		<li><span style="font-family: Courier New,Courier,monospace">src/event_handler</span> folder contains the event handler code generated by the UI Builder. The UI Builder creates stubs of callback functions that you can edit.</li>
	</ul>

	<h4>Layout Editor</h4>
	<p>You can create the UI using the WYSIWYG editor, which allows you to add and modify UI components using drag and drop. The parameters of the selected component can be adjusted using the <strong>Properties</strong> view. For more information on the UI Builder, see <a href="../../../org.tizen.devtools/html/native_tools/uibuilder_n.htm">UI Builder</a>.</p>
<p>There are 2 project templates for UI Builder applications: single-view and navigation. The data-control-consumer application uses the navigation template. The UI uses an <span style="font-family: Courier New,Courier,monospace">elm_conformant</span> component as a root. This is created by default for a UI Builder application and cannot be changed. An <span style="font-family: Courier New,Courier,monospace">elm_naviframe</span> component is used as the conformant&#39;s <a href = "#ui-struct-map">layout</a>. The naviframe can switch between 2 views: Map and SQL.</p>

	<p class="figure">Figure: UI Builder View display</p>
	<p style="text-align:center;">
		<img alt="UI Builder View display" src="../images/data-control-consumer-views.png" />
	</p>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">3 views are actually available. The first one is the naviframe while the second and third contain the displayed pages (map and SQL). You cannot add any widgets to the first view using drag and drop. In this view, you can only select one of the remaining views to be used as the default content pushed to the naviframe.</td> 
    </tr> 
   </tbody> 
  </table>  	


	<p class="figure">Figure: Naviframe view</p>
	<p id="ID" style="text-align:center;">
		<img alt="Naviframe view" src="../images/data_control_consumer_naviframe_view.png" />
	</p>

	<h4>Connections</h4>
	<p>To design the application view switching mechanism, connections are used. You can access them through the <a href="../../../org.tizen.devtools/html/native_tools/storyboard_n.htm">Storyboard</a> tab of the UI Builder.</p>

	<p class="figure">Figure: UI Builder Storyboard tab</p>
<p id="UI-Builder-connections-view" style="text-align:center;">
	<img alt="UI Builder Storyboard tab" src="../images/data-control-consumer-connections.png" />
</p>

	<p>The view1 (the Naviframe view) is connected with the view2, indicating that the view2 is used as the naviframe default view. When you add a connection between other views, it is displayed here.</p>
<p>When a new connection is created, new callback code is also created in the <span style="font-family: Courier New,Courier,monospace">src/managed/connection</span> folder (a file is created, if required). In addition, <span style="font-family: Courier New,Courier,monospace">pre</span> and <span style="font-family: Courier New,Courier,monospace">post</span> functions are added to one of the files in the <span style="font-family: Courier New,Courier,monospace">src/event_handler</span> folder.</p>

	<p>When the view changes, the following callback function is invoked:</p>
	<pre class="prettyprint">
void 
view2_connection_to_sql_button_onclicked(uib_view2_view_context *vc, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;view2_to_sql_button_onclicked(vc, obj, event_info);
&nbsp;&nbsp;&nbsp;Elm_Object_Item *navi_item = change_page(vc-&gt;parent, &quot;SQL&quot;, NULL, NULL, &quot;view3&quot;, NULL);
&nbsp;&nbsp;&nbsp;view2_to_sql_button_onclicked_post(navi_item, vc, obj, event_info);
}
</pre>
	<p>The <span style="font-family: Courier New,Courier,monospace">change_page()</span> function uses the <span style="font-family: Courier New,Courier,monospace">elm_naviframe_item_push()</span> function to switch the views. There is no reverse connection from view3 to view2 to avoid recurring page stacking. Instead, there is a callback function added to the <span style="font-family: Courier New,Courier,monospace">to_map_button</span> component that invokes the <span style="font-family: Courier New,Courier,monospace">elm_naviframe_item_pop()</span> function.</p>

<h4>Event Handlers</h4>
<p>The event handler callback stubs are created using the WYSIWYG editor.</p>

<p class="figure">Figure: Default event handler name</p>
<p id="callback-function" style="text-align:center;">
	<img alt="Default event handler name" src="../images/data-control-consumer-event-handler.png" />
</p>

<p>The callback name is preceded by the view name. This is a standard behavior of the UI Builder and cannot be changed. After the function stub creation is completed, you can modify the callback source code.</p>

<p class="figure">Figure: Final name of the callback function</p>
<p id="final-callback-function" style="text-align:center;">
	<img alt="Final name of the callback function" src="../images/data-control-consumer-event-handler-final.png" />
</p>

<h3>Data Exchange with the Provider Service</h3>
<p>The communication between the consumer and the provider can be done using either the SQL or map method. While the data used by the map and SQL methods has a different structure (hash map and database), the data exchange implementation in both cases is very similar:</p>
<ol>
	<li>Data consumer sends a request.</li>
	<li>Data provider sends a response or an error message.</li>
	<li>Data consumer reacts to the received data.</li>
	<li>Data consumer updates the UI.</li>
</ol>

<h4>Implementing the Map Method</h4>

<p>To provide full communication between the map consumer and the provider, you must initialize some data and implement 4 request functions and 4 callbacks:</p>

<ul>
<li>Initialize the map communication method.

<p>To achieve communication with the provider service, the correct <a href = "data_control_provider_sd_mn.htm#provider-map-id">provider application ID</a> must be set. The ID can be found in the provider&#39;s manifest file. The <span style="font-family: Courier New,Courier,monospace">data_control_map_response_cb</span> structure must be filled with the correct functions.</p>

<pre class="prettyprint">
void 
map_consumer_init(On_New_Data_Received_Cb new_data_received_cb, error_received_cb_t error_received_cb)
{
&nbsp;&nbsp;&nbsp;// Provider ID
&nbsp;&nbsp;&nbsp;const char *provider_id = &quot;http://data-control-provider.com/datacontrol/provider/data-control-provider&quot;; 
&nbsp;&nbsp;&nbsp;const char *data_id = &quot;table&quot;;
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;// Create data control handler
&nbsp;&nbsp;&nbsp;ret = data_control_map_create(&amp;(s_info.provider));

&nbsp;&nbsp;&nbsp;// Set the provider ID
&nbsp;&nbsp;&nbsp;ret = data_control_map_set_provider_id(s_info.provider, provider_id);

&nbsp;&nbsp;&nbsp;// Set the data ID
&nbsp;&nbsp;&nbsp;ret = data_control_map_set_data_id(s_info.provider, data_id);

&nbsp;&nbsp;&nbsp;// Response callbacks
&nbsp;&nbsp;&nbsp;s_info.map_callback.get_cb = __map_get_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.set_cb = __map_set_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.add_cb = __map_add_response_cb;
&nbsp;&nbsp;&nbsp;s_info.map_callback.remove_cb = __map_remove_response_cb;

&nbsp;&nbsp;&nbsp;// Register response callbacks
&nbsp;&nbsp;&nbsp;ret = data_control_map_register_response_cb(s_info.provider, &amp;s_info.map_callback, NULL);
}
</pre></li>

<li>Implement the request functions.

<p>The request functions are invoked by click events of the <span style="font-family: Courier New,Courier,monospace">get_data_button</span>, <span style="font-family: Courier New,Courier,monospace">set_data_button</span>, <span style="font-family: Courier New,Courier,monospace">remove_data_button</span> and <span style="font-family: Courier New,Courier,monospace">add_data_button</span> buttons placed in the <a href="#ui-struct-map">map view</a>. The functions are used to send requests to the provider service, which must send a response. Based on the response type, a specific callback is invoked.</p>

<p id="consumer-get-all-keys">The map view has an extra <span style="font-family: Courier New,Courier,monospace">get_keys_button</span> button, which sends a special get request using a <span style="font-family: Courier New,Courier,monospace">#GET_ALL_KEYS</span> key. In this case, the value received from the provider contains all keys stored by the provider service.</p>

<p>The following request functions are needed:</p>

<ul>
	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_add()</span>
<p>This function adds new values to the provider hash map. If the map does not contain the searched key, a new one must be created.</p>
<p>Note that 1 key can hold multiple values. The key string is taken from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">key_entry</a></span> UI component and the value from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">new_value_entry</a></span> UI component.</p></li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_get()</span>
<p>This function gets the values held by the given key. The key string is taken from the <span style="font-family: Courier New,Courier,monospace">key_entry</span> UI component.</p></li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_set()</span>
<p>This function updates the given value held by the given key. If there is no value equal to <span style="font-family: Courier New,Courier,monospace">old</span>, an error message must be provided.</p>
<p>The key string is taken from the <span style="font-family: Courier New,Courier,monospace">key_entry</span> UI component, the <span style="font-family: Courier New,Courier,monospace">old</span> string from the <span style="font-family: Courier New,Courier,monospace"><a href="#ui-struct-map">old_value_entry</a></span> UI component, and the <span style="font-family: Courier New,Courier,monospace">new</span> string from the <span style="font-family: Courier New,Courier,monospace">new_value_entry</span> UI component.</p></li>

	<li><span style="font-family: Courier New,Courier,monospace">data_control_map_remove()</span>
<p>This function removes the given value held by the given key. If a key is empty after this operation, it must be removed as well. If there is no value equal to <span style="font-family: Courier New,Courier,monospace">value</span> or key equal to <span style="font-family: Courier New,Courier,monospace">key</span>, an error message must be provided.</p>
<p>The key string is taken from the <span style="font-family: Courier New,Courier,monospace">key_entry</span> UI component and the value from the <span style="font-family: Courier New,Courier,monospace">new_value_entry</span> UI component.</p></li>
</ul></li>

<li id="consumer-callback-definitions">Implement the callbacks.

<p>Each callback is invoked as a result of a request function implemented above:</p>
<ul><li>
<p>The <span style="font-family: Courier New,Courier,monospace">__map_get_response_cb()</span> callback is invoked when a get request is sent. The values assigned to a given key are passed in the <span style="font-family: Courier New,Courier,monospace">ret_value_list</span> string array. If there was an error, the <span style="font-family: Courier New,Courier,monospace">provider_ret</span> is set to <span style="font-family: Courier New,Courier,monospace">false</span> and an error message is provided.</p>

<pre class="prettyprint">
static void 
__map_get_response_cb(int request_id, data_control_h provider, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char **ret_value_list, int ret_value_count, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}
</pre></li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__map_set_response_cb()</span>, <span style="font-family: Courier New,Courier,monospace">__map_add_response_cb()</span>, and <span style="font-family: Courier New,Courier,monospace">__map_remove_response_cb()</span> callbacks work the same way. If a given operation was successful, the <span style="font-family: Courier New,Courier,monospace">provider_ret</span> is set to <span style="font-family: Courier New,Courier,monospace">true</span>. If an error in the communication occurred, the <span style="font-family: Courier New,Courier,monospace">error</span> parameter contains the error message.</p>
<pre class="prettyprint">
static void 
__map_set_response_cb(int request_id, data_control_h provider, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}

static void 
__map_add_response_cb(int request_id, data_control_h provider, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}

static void 
__map_remove_response_cb(int request_id, data_control_h provider, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_ret, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}
</pre></li></ul>

<p>In every callback (except <span style="font-family: Courier New,Courier,monospace">__map_get_response_cb()</span>), the get request function is invoked. This way the UI can be updated with the modified hash map.</p>
<p>When error information is received, the function pointed by <span style="font-family: Courier New,Courier,monospace"><a href="#map_structure">error_received_cb()</a></span> is invoked and a popup with the error message is displayed.</p>
</li></ul>

<h4>Implementing the SQL Method</h4>

<p>To provide full communication between the SQL consumer and the provider, you must initialize some data and implement 4 request functions and 4 callbacks:</p>

<ul>
<li>Initialize the SQL communication method.

<p>To achieve communication with the provider service:</p>

<ul><li>Create a provider handle: 
<pre class="prettyprint">
data_control_sql_create(&amp;s_info.provider);
</pre></li>
<li>Set a valid <a href = "data_control_provider_sd_mn.htm#provider-sql-id"><span style="font-family: Courier New,Courier,monospace">provider_id</span></a> and <span style="font-family: Courier New,Courier,monospace">data_id</span>:
<pre class="prettyprint">
data_control_sql_set_provider_id(s_info.provider, provider_id);
data_control_sql_set_data_id(s_info.provider, data_id);
</pre></li></ul></li>


<li>Implement the request functions.

<p>The request functions are invoked by click events of the <span style="font-family: Courier New,Courier,monospace">select_button</span>, <span style="font-family: Courier New,Courier,monospace">insert_button</span>, <span style="font-family: Courier New,Courier,monospace">set_button</span> and <span style="font-family: Courier New,Courier,monospace">delete_button</span> buttons placed in the <a href="#ui-struct-sql">SQL view</a>. The functions are used to send requests to the provider service, which must send a response. Based on the response type, a specific callback is invoked.</p>

<p>The following request functions are needed:</p>

<ul>
	<li>Select request
<p>This function reads data from the database:</p>
<ul><li><p>The <span style="font-family: Courier New,Courier,monospace">column_list</span> parameter is an array of strings used as the text after the SELECT keyword in a SQL query. The <span style="font-family: Courier New,Courier,monospace"><a href = "#ui-struct-sql">column_name_entry</a></span> entry field in the SQL view can be used as the input for the <span style="font-family: Courier New,Courier,monospace">column_list</span>. However, note that the string from the entry has to be converted (using the <span style="font-family: Courier New,Courier,monospace">elm_entry_markup_to_utf8()</span> function) from markup to the UTF-8 format. If not, some characters, such as &#39;&lt;&#39;, cannot be used. After the conversion, &#39;\n&#39; can be used as a delimiter when the text from the entry field is transformed into the array of strings.</p></li>
<li><p>The <span style="font-family: Courier New,Courier,monospace">column_count</span> variable is the count of the <span style="font-family: Courier New,Courier,monospace">column_list</span> elements.</p></li>
<li><p>The <span style="font-family: Courier New,Courier,monospace">where</span> parameter is a string, which can contain any correct SQL WHERE entry. The <span style="font-family: Courier New,Courier,monospace"><a href = "#ui-struct-sql">where_entry</a></span> entry field is used to provide an input for this parameter. This text (like any text from an entry widget) has to be converted to UTF-8 as well.</p></li>
<li><p>If one of the sort methods is chosen using the radio buttons, a column name has to be provided using the <span style="font-family: Courier New,Courier,monospace"><a href = "#ui-struct-sql">sort_column_entry</a></span> field. The <span style="font-family: Courier New,Courier,monospace">order</span> parameter is a concatenation of the <span style="font-family: Courier New,Courier,monospace">sort_column_entry</span> string and an appropriate sort text, such as <span style="font-family: Courier New,Courier,monospace">Num ASC</span>.</p></li></ul>
<pre class="prettyprint">
data_control_sql_select(data_control_h provider, char **column_list, int column_count, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *where, const char *order, int *request_id);
</pre></li>

	<li id="consumer-sql-insert-request">Insert request
<p>This function uses a <span style="font-family: Courier New,Courier,monospace">bundle</span> structure to generate a SQL query.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">column_name_entry</span> and <span style="font-family: Courier New,Courier,monospace"><a href = "#ui-struct-sql">column_value_entry</a></span> entries are used to provide input. The obtained strings are then tokenized and added to the bundle as a key-value pair. The first line of the <span style="font-family: Courier New,Courier,monospace">column_name_entry</span> and  the first line of the <span style="font-family: Courier New,Courier,monospace">column_value_entry</span> are used as the first pair, and so on.</p></li>

	<li>Delete request
<p>This function uses only the <span style="font-family: Courier New,Courier,monospace">where</span> string described earlier. Every line in the database which meets the provided condition is removed.</p></li>

	<li>Update request
<p>This function modifies a set of rows.</p>
<p>Every row that meets the <span style="font-family: Courier New,Courier,monospace">where</span> condition is updated. To update the given fields of a row, a bundle is used in the same way as in the insert request.</p></li>
</ul></li>


<li>Implement the callbacks.

<pre class="prettyprint">
// Set the callback pointers
s_info.sql_callback.delete_cb = __sql_delete_response_cb;
s_info.sql_callback.insert_cb = __sql_insert_response_cb;
s_info.sql_callback.select_cb = __sql_select_response_cb;
s_info.sql_callback.update_cb = __sql_update_response_cb;

// Register the callbacks
ret = data_control_sql_register_response_cb(s_info.provider, &amp;s_info.sql_callback, NULL);
</pre>

<p>Each callback is invoked as a result of a request function implemented above:</p>
<ul><li>
<p>The <span style="font-family: Courier New,Courier,monospace">__sql_select_response_cb()</span> function is used when the SELECT response is invoked.</p>
<p>This function uses the <span style="font-family: Courier New,Courier,monospace">cursor</span> parameter to pass the response. The <span style="font-family: Courier New,Courier,monospace">cursor</span> parameter is a <span style="font-family: Courier New,Courier,monospace">result_set_cursor</span> structure used to represent a SQL result set. It can be enumerated to obtain every row in the result. The result is then transformed to an array of strings and sent to the view module so that the UI can be updated. The <span style="font-family: Courier New,Courier,monospace">provider_result</span> boolean value is used to define whether the data is successfully processed.</p>

<pre class="prettyprint">
static void 
__sql_select_response_cb(int request_id, data_control_h provider, result_set_cursor cursor, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_result, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Iterate through all rows received from the provider
&nbsp;&nbsp;&nbsp;while (data_control_sql_step_next(cursor) == DATA_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!columns)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the columns names for the current row; it is assumed that 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// columns names are the same in every row so this function is invoked only once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// __column_list_get() returns the names in one properly formatted string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns = __column_list_get(cursor);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// __sql_row_get() returns the content of the row as one properly formatted string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row = __sql_row_get(cursor); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = eina_list_append(response, row);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Received data is sent to the view module
&nbsp;&nbsp;&nbsp;if (s_info.new_data_received)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.new_data_received(columns, response);
}
</pre>

<p>The following function is a helper used in the SELECT response. The row pointed at the result cursor is taken as the parameter. The function returns a string containing the row&#39;s values. The values are formatted based on their type.</p>

<pre class="prettyprint">
static const char 
*__sql_row_get(result_set_cursor cursor)
{
&nbsp;&nbsp;&nbsp;// Get the current row&#39;s column count
&nbsp;&nbsp;&nbsp;column_count = data_control_sql_get_column_count(cursor); 

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; column_count; ++i) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the column type (types available: DATA_CONTROL_SQL_COLUMN_TYPE_INT64,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DATA_CONTROL_SQL_COLUMN_TYPE_DOUBLE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DATA_CONTROL_SQL_COLUMN_TYPE_TEXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DATA_CONTROL_SQL_COLUMN_TYPE_BLOB)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_control_sql_get_column_item_type(cursor, i, &amp;type);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Based on the column type, the given field&#39;s data is appended to the output string
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>The <span style="font-family: Courier New,Courier,monospace">__sql_delete_response_cb</span>, <span style="font-family: Courier New,Courier,monospace">__sql_insert_response_cb</span>, and <span style="font-family: Courier New,Courier,monospace">__sql_update_response_cb</span> functions are used only to provide information about the result of respective requests.</p>

<pre class="prettyprint">
static void 
__sql_delete_response_cb(int request_id, data_control_h provider, bool provider_result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}

static void 
__sql_insert_response_cb(int request_id, data_control_h provider, long long inserted_row_id, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool provider_result, const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}

static void 
__sql_update_response_cb(int request_id, data_control_h provider, bool provider_result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *error, void *user_data)
{
&nbsp;&nbsp;&nbsp;// Take action
}
</pre></li></ul>

<p>Every callback uses the <span style="font-family: Courier New,Courier,monospace">provider_result</span> parameter to provide information about any erroneous situation (such as incorrect WHERE filter). In such case, the parameter equals <span style="font-family: Courier New,Courier,monospace">false</span> and the <span style="font-family: Courier New,Courier,monospace">error</span> parameter contains the error information. In an error situation, the <span style="font-family: Courier New,Courier,monospace">s_info.info_received</span> function pointer is invoked, and the call is used to display a popup with the error message.</p>
</li></ul>


<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

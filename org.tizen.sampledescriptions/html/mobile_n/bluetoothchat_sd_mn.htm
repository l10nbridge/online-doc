<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Bluetooth Chat Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>	

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>
  <h1>Bluetooth Chat Sample Overview</h1>

<p>The Bluetooth Chat sample application demonstrates how you can send and receive data between 2 devices.</p>

<p>The following figure illustrates the screens of the sample application.</p>

<p class="figure">Figure: Bluetooth Chat screens</p>
<p align="center"><img alt="Bluetooth screens" src="../images/bluetoothchat_mn1.png" /> <img alt="Bluetooth screens" src="../images/bluetoothchat_mn2.png" /></p>

<p>The main screen has 2 buttons for finding devices (<strong>Search friends</strong>) and creating a server (<strong>Wait a friend</strong>). The chat room screen is created with the <a href="../mobile_n/ui_message_bubble_sd_mn.htm">[UI Sample] MessageBubble</a> sample application.</p> 

<h2 id="implementation" name="implementation">Implementation</h2>

<p>After a button click, the application calls the <span style="font-family: Courier New,Courier,monospace">bt_mgr_initialize()</span> function, and checks whether Bluetooth is on or off. If Bluetooth is off, the application calls the Bluetooth ON/OFF application to switch Bluetooth on.</p>
<p class="figure">Figure: Bluetooth ON/OFF application</p>

<p align="center"><img alt="Bluetooth ON/OFF application" src="../images/bluetoothchat_mn3.png" /> <img alt="Bluetooth ON/OFF application" src="../images/bluetoothchat_mn4.png" /></p>

<p>If the <span style="font-family: Courier New,Courier,monospace">bt_mgr_initialize()</span> function is called and Bluetooth is on, the application draws proper layouts according to its current role (client or server):</p>
<pre class="prettyprint">
void 
bt_mgr_initialize(void *data, bt_mgr_type type)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = NULL;
&nbsp;&nbsp;&nbsp;bt_adapter_state_e bt_ad_state = BT_ADAPTER_DISABLED;
&nbsp;&nbsp;&nbsp;bt_adapter_visibility_mode_e bt_ad_visibility = BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE;
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;int duration = 1;

&nbsp;&nbsp;&nbsp;ad = (appdata_s *)data;
&nbsp;&nbsp;&nbsp;ret_if(!ad);

&nbsp;&nbsp;&nbsp;ret = bt_initialize();
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;ret = bt_adapter_get_state(&amp;bt_ad_state);
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;if (bt_ad_state == BT_ADAPTER_DISABLED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_onoff_operation();
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (type) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_MGR_SEARCH:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_search_layout_create(ad);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_MGR_WAIT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_get_visibility(&amp;bt_ad_visibility, &amp;duration);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;Failed to get the adapter visibility&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_ad_visibility != BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_server_layout_create(ad);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_visibility_operation_set();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
static void 
_onoff_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;

&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;ret_if(!service);

&nbsp;&nbsp;&nbsp;app_control_set_operation(service, &quot;APP_CONTROL_OPERATION_SETTING_BT_ENABLE&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);
&nbsp;&nbsp;&nbsp;if (ret != APP_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;Failed to relaunch Bluetooth On/off app&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
}
</pre>

<h3 id="client" name="client">Client</h3>

<p>To start the client application, click <strong>Search Friends</strong>. The client draws its own layout by the <span style="font-family: Courier New,Courier,monospace">_search_layout_create()</span> function, which is called by the <span style="font-family: Courier New,Courier,monospace">bt_mgr_initialize()</span> function. The layout is a list of the found devices.</p>
<pre class="prettyprint">
static void 
_search_layout_create(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ret_if(!ad);
&nbsp;&nbsp;&nbsp;ret_if(!ad-&gt;navi);

&nbsp;&nbsp;&nbsp;ad-&gt;role = BT_SOCKET_CLIENT;

&nbsp;&nbsp;&nbsp;s_info.list = elm_list_add(ad-&gt;navi);
&nbsp;&nbsp;&nbsp;ret_if(!s_info.list);

&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(s_info.list, EVAS_CALLBACK_DEL, _on_search_del_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(s_info.list, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(s_info.list, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;elm_list_go(s_info.list);
&nbsp;&nbsp;&nbsp;elm_naviframe_item_push(ad-&gt;navi, &quot;Search Friends&quot;, NULL, NULL, s_info.list, NULL);

&nbsp;&nbsp;&nbsp;ret = bt_socket_set_connection_state_changed_cb(_socket_conn_state_changed_cb, ad);
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;_discovery_start(ad);
}
</pre>

<p>While drawing the list, the application starts finding devices with the <span style="font-family: Courier New,Courier,monospace">_discovery_start()</span> function. Set the device discovery state changed callback, and update the list whenever a new device is found.</p>
<pre class="prettyprint">
static void 
_discovery_start(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;bt_error_e ret = BT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;ret_if(!ad);
&nbsp;&nbsp;&nbsp;ret_if(ad-&gt;bt);

&nbsp;&nbsp;&nbsp;ad-&gt;bt = TRUE;

&nbsp;&nbsp;&nbsp;ret = bt_adapter_set_device_discovery_state_changed_cb(_adapter_discovery_state_changed_cb, ad);
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;ret = bt_adapter_start_device_discovery();
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);
}

static void 
_adapter_discovery_state_changed_cb(int result, bt_adapter_device_discovery_state_e discovery_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s *discovery_info, void *user_data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = NULL;
&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s *new_device_info = NULL;
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ad = (appdata_s *)user_data;
&nbsp;&nbsp;&nbsp;ret_if(!ad);

&nbsp;&nbsp;&nbsp;ret_if(!s_info.list);
&nbsp;&nbsp;&nbsp;ret_if(result != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;switch (discovery_state) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_STARTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;BT_ADAPTER_DEVICE_DISCOVERY_STARTED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FINISHED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;BT_ADAPTER_DEVICE_DISCOVERY_FINISHED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_unset_device_discovery_state_changed_cb();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;[BT_ADAPTER_DEVICE_DISCOVERY_FINISHED] Failed to unset the state discovery cb&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;bt = FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FOUND:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;BT_ADAPTER_DEVICE_DISCOVERY_FOUND&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discovery_info != NULL &amp;&amp; s_info.list != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info = malloc(sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_device_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;Device Name is: %s&quot;, discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_device_info, discovery_info, sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_address = strdup(discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_name = strdup(discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_list_item_append(s_info.list, new_device_info-&gt;remote_name, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL, NULL, _click_friend_item_cb, new_device_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_list_go(s_info.list);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>If an item on the list is clicked, the application starts to bond with the target device, and requests to connect to the target server:</p>
<pre class="prettyprint">
static void 
_socket_conn_state_changed_cb(int result, bt_socket_connection_state_e connection_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_socket_connection_s *connection, void *user_data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = (appdata_s *)user_data;
&nbsp;&nbsp;&nbsp;ret_if(!ad);

&nbsp;&nbsp;&nbsp;ret_if(result != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;if (connection_state == BT_SOCKET_CONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;Connected %d %d&quot;, ad-&gt;socket_fd, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;role = connection-&gt;local_role;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;socket_fd = connection-&gt;socket_fd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_naviframe_item_pop(ad-&gt;navi);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_chat_room_layout_create(ad);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s_info.noti) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.noti);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.noti = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;socket_fd = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;Disconnected&quot;);
&nbsp;&nbsp;&nbsp;}
}

static void 
_device_bond_created_cb(int result, bt_device_info_s *device_info, void *user_data)
{
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;Failed result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto DEL_NOTI;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (device_info != NULL &amp;&amp;
&nbsp;&nbsp;&nbsp;!strncmp(device_info-&gt;remote_address, s_info.info-&gt;remote_address, strlen(device_info-&gt;remote_address))) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_socket_connect_rfcomm(s_info.info-&gt;remote_address, BT_MGR_UUID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;[bt_socket_listen_and_accept_rfcomm] Failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto DEL_NOTI;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_D(&quot;[bond create cb] Bonded with another device&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto DEL_NOTI;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;DEL_NOTI:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s_info.noti) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.noti);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.noti = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
}
</pre>
<p>When the application is successfully connected with the target, the <span style="font-family: Courier New,Courier,monospace">_socket_conn_state_changed_cb()</span> function is called and the application moves to the chat room layout by calling the <span style="font-family: Courier New,Courier,monospace">_bt_chat_room_layout_create()</span> function.</p>


<h3 id="server" name="server">Server</h3>

<p>To start the server application, click <strong>Wait a friend</strong>. The role of this application is making a server for chatting, and waiting for a client. Before drawing the proper layout, the application checks whether the device is discoverable by using the <span style="font-family: Courier New,Courier,monospace">_search_layout_create()</span> function. If the device is not discoverable, the application calls the Bluetooth Visibility application.</p>
<pre class="prettyprint">
static void 
_visibility_operation_set(void)
{
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;ret_if(!service);

&nbsp;&nbsp;&nbsp;app_control_set_operation(service, &quot;APP_CONTROL_OPERATION_SETTING_BT_VISIBILITY&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);
&nbsp;&nbsp;&nbsp;if (ret != APP_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;Failed to relaunch Bluetooth Visibility app&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
}
</pre>

<p>A server application also registers the callback for detecting the state of the socket connection. The callback function is same as that of the client. The application creates a server, and when the socket connection state changes to <span style="font-family: Courier New,Courier,monospace">BT_SOCKET_CONNECTED</span>, it moves to the chat room layout.</p>
<pre class="prettyprint">
static void 
_server_layout_create(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;Evas_Object *layout = NULL;
&nbsp;&nbsp;&nbsp;Evas_Object *progress = NULL;
&nbsp;&nbsp;&nbsp;char edj_path[PATH_MAX] = {0,};

&nbsp;&nbsp;&nbsp;ad-&gt;role = BT_SOCKET_SERVER;

&nbsp;&nbsp;&nbsp;app_resource_get(CREATE_SERVER, edj_path, (int)PATH_MAX);
&nbsp;&nbsp;&nbsp;layout = elm_layout_add(ad-&gt;navi);
&nbsp;&nbsp;&nbsp;goto_if(!layout, ERROR);
&nbsp;&nbsp;&nbsp;elm_layout_file_set(layout, edj_path, &quot;create_server&quot;);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(layout, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);

&nbsp;&nbsp;&nbsp;progress = elm_progressbar_add(layout);
&nbsp;&nbsp;&nbsp;goto_if(!progress, ERROR);
&nbsp;&nbsp;&nbsp;elm_object_style_set(progress, &quot;process_large&quot;);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_min_set(progress, 100, 100);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(progress, 0.5, 0.5);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(progress, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;elm_progressbar_pulse(progress, EINA_TRUE);

&nbsp;&nbsp;&nbsp;elm_object_part_content_set(layout, &quot;progress&quot;, progress);

&nbsp;&nbsp;&nbsp;elm_naviframe_item_push(ad-&gt;navi, &quot;Wait a Friend&quot;, NULL, NULL, layout, NULL);

&nbsp;&nbsp;&nbsp;_server_create(ad);

&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (layout) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(layout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layout = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (progress) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(progress);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;progress = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
}
</pre>


<h3 id="chatroom" name="chatroom">Chat Room</h3>
<p>To implement the chat room layout and send a message:</p>
<ol>

<li>Draw the layout:
<pre class="prettyprint">
static Evas_Object 
*_main_view_create(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;Evas_Object *main_scroller = NULL;
&nbsp;&nbsp;&nbsp;Evas_Object *input_field_table = NULL;

&nbsp;&nbsp;&nbsp;retv_if(!ad, NULL);

&nbsp;&nbsp;&nbsp;main_scroller = elm_scroller_add(ad-&gt;navi);
&nbsp;&nbsp;&nbsp;goto_if(!main_scroller, ERROR);
&nbsp;&nbsp;&nbsp;elm_scroller_bounce_set(main_scroller, EINA_FALSE, EINA_TRUE);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(main_scroller, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(main_scroller, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;evas_object_show(main_scroller);

&nbsp;&nbsp;&nbsp;s_info.main_box = elm_box_add(main_scroller);
&nbsp;&nbsp;&nbsp;goto_if(!s_info.main_box, ERROR);
&nbsp;&nbsp;&nbsp;elm_box_align_set(s_info.main_box, 0, 0);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(s_info.main_box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_show(s_info.main_box);

&nbsp;&nbsp;&nbsp;s_info.bubble_scroller = elm_scroller_add(s_info.main_box);
&nbsp;&nbsp;&nbsp;goto_if(!s_info.bubble_scroller, ERROR);
&nbsp;&nbsp;&nbsp;elm_scroller_bounce_set(s_info.bubble_scroller, EINA_FALSE, EINA_TRUE);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(s_info.bubble_scroller, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(s_info.bubble_scroller, EVAS_HINT_FILL, EVAS_HINT_FILL);

&nbsp;&nbsp;&nbsp;s_info.bubble_box = elm_box_add(s_info.bubble_scroller);
&nbsp;&nbsp;&nbsp;goto_if(!s_info.bubble_box, ERROR);
&nbsp;&nbsp;&nbsp;elm_box_align_set(s_info.bubble_box, 0, 0);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(s_info.bubble_box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_show(s_info.bubble_box);
&nbsp;&nbsp;&nbsp;elm_box_padding_set(s_info.bubble_box, ELM_SCALE_SIZE(10), ELM_SCALE_SIZE(15));

&nbsp;&nbsp;&nbsp;elm_object_content_set(s_info.bubble_scroller, s_info.bubble_box);
&nbsp;&nbsp;&nbsp;evas_object_show(s_info.bubble_scroller);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(s_info.main_box, s_info.bubble_scroller);

&nbsp;&nbsp;&nbsp;input_field_table = _input_field_table_create(ad);
&nbsp;&nbsp;&nbsp;goto_if(!input_field_table, ERROR);
&nbsp;&nbsp;&nbsp;evas_object_show(input_field_table);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(s_info.main_box, input_field_table);
&nbsp;&nbsp;&nbsp;elm_object_content_set(main_scroller, s_info.main_box);

&nbsp;&nbsp;&nbsp;return main_scroller;

&nbsp;&nbsp;&nbsp;ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (main_scroller) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(main_scroller);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_scroller = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (input_field_table) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(input_field_table);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input_field_table = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
}

static void 
_on_main_scroller_del_cb(void *data, Evas *e, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;if (s_info.main_box) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.main_box);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.main_box = NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (s_info.bubble_scroller) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.bubble_scroller);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.bubble_scroller = NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (s_info.bubble_box) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.bubble_box);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.bubble_box = NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (s_info.input_field_entry) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(s_info.input_field_entry);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_info.input_field_entry = NULL;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>Manage the connection state changes: 
<pre class="prettyprint">
static void 
_socket_conn_state_changed_cb(int result, bt_socket_connection_state_e connection_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_socket_connection_s *connection, void *user_data)
{
&nbsp;&nbsp;&nbsp;Evas_Object *noti = NULL;
&nbsp;&nbsp;&nbsp;appdata_s *ad = NULL;

&nbsp;&nbsp;&nbsp;ad = (appdata_s *)user_data;
&nbsp;&nbsp;&nbsp;ret_if(!ad);
&nbsp;&nbsp;&nbsp;ret_if(result != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;_D(&quot;[_socket_conn_state_changed_cb] Changed&quot;);
&nbsp;&nbsp;&nbsp;if (connection_state == BT_SOCKET_DISCONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_I(&quot;[_socket_conn_state_changed_cb] Disconnected&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;socket_fd = -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noti = bt_noti_popup_create(ad-&gt;navi, &quot;Disconnected with the Friend&quot;, EINA_FALSE);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>Receive the data:
<pre class="prettyprint">
static void 
_socket_data_received_cb(bt_socket_received_data_s *data, void *user_data)
{
&nbsp;&nbsp;&nbsp;Evas_Object *bubble_table = NULL;
&nbsp;&nbsp;&nbsp;char *message = NULL;

&nbsp;&nbsp;&nbsp;ret_if(!data);

&nbsp;&nbsp;&nbsp;message = strndup(data-&gt;data, data-&gt;data_size);
&nbsp;&nbsp;&nbsp;goto_if(!message, ERROR);

&nbsp;&nbsp;&nbsp;bubble_table = _bubble_table_create(s_info.bubble_box, MESSAGE_BUBBLE_RECEIVE, message, _current_time_get());
&nbsp;&nbsp;&nbsp;goto_if(!bubble_table, ERROR);

&nbsp;&nbsp;&nbsp;evas_object_show(bubble_table);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(s_info.bubble_box, bubble_table);

&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(s_info.bubble_box, EVAS_CALLBACK_RESIZE, _bubble_box_resize_cb, NULL);

&nbsp;&nbsp;&nbsp;free(message);

&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bubble_table) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_del(bubble_table);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bubble_table = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (message) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(message);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
}
</pre>

<p>The chat room is created by calling the <span style="font-family: Courier New,Courier,monospace">bt_chat_room_layout_create()</span> function. The function draws the layout for chatting, and unsets the connection state change callback and reregisters it. It also registers the data received callback. When the message is received from the target, the application makes a message bubble for a new message.</p>
<pre class="prettyprint">
void 
bt_chat_room_layout_create(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;Evas_Object *main_scroller = NULL;
&nbsp;&nbsp;&nbsp;int ret = -1;

&nbsp;&nbsp;&nbsp;bt_socket_set_data_received_cb(_socket_data_received_cb, NULL);

&nbsp;&nbsp;&nbsp;ret = bt_socket_unset_connection_state_changed_cb();
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;ret = bt_socket_set_connection_state_changed_cb(_socket_conn_state_changed_cb, ad);
&nbsp;&nbsp;&nbsp;ret_if(ret != BT_ERROR_NONE);

&nbsp;&nbsp;&nbsp;main_scroller = _main_view_create(ad);
&nbsp;&nbsp;&nbsp;ret_if(!main_scroller);

&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(main_scroller, EVAS_CALLBACK_DEL, _on_main_scroller_del_cb, NULL);
&nbsp;&nbsp;&nbsp;elm_naviframe_item_push(ad-&gt;navi, &quot;Chatting&quot;, NULL, NULL, main_scroller, NULL);
}
</pre>
</li>

<li>Send a message:
<pre class="prettyprint">
static void 
_message_send(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;Evas_Object *bubble_table = NULL;
&nbsp;&nbsp;&nbsp;Evas_Object *noti = NULL;
&nbsp;&nbsp;&nbsp;const char *main_text = NULL;
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;ret_if(!ad);
&nbsp;&nbsp;&nbsp;ret_if(!s_info.input_field_entry);

&nbsp;&nbsp;&nbsp;main_text = elm_entry_entry_get(s_info.input_field_entry);
&nbsp;&nbsp;&nbsp;ret_if(!main_text || (strlen(main_text) == 0));

&nbsp;&nbsp;&nbsp;ret = bt_socket_send_data(ad-&gt;socket_fd, main_text, strlen(main_text)+1);
&nbsp;&nbsp;&nbsp;if (ret == -1) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_E(&quot;[bt_socket_send_data] send to fail : %s&quot;, main_text);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noti = bt_noti_popup_create(ad-&gt;navi, &quot;Send Failed&quot;, EINA_FALSE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_show(noti);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bubble_table = _bubble_table_create(s_info.bubble_box, MESSAGE_BUBBLE_SENT, elm_entry_entry_get(s_info.input_field_entry), _current_time_get());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret_if(!bubble_table);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_show(bubble_table);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_box_pack_end(s_info.bubble_box, bubble_table);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_entry_entry_set(s_info.input_field_entry, &quot;&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(s_info.bubble_box, EVAS_CALLBACK_RESIZE, _bubble_box_resize_cb, NULL);
&nbsp;&nbsp;&nbsp;}
}
</pre>
<p>When the user clicks <strong>SEND</strong>, the message on the input area is sent to the target device. If sending is successful, the application makes a message bubble for the sent message.</p>
</li>
</ol>



<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

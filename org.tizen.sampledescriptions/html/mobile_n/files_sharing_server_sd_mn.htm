<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>

	<title>Files-Sharing Server Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>

  <h1>Files Sharing Server Sample Overview</h1>

  <p>The Files Sharing Server sample application demonstrates how you can use Bluetooth OPP (Object Push Profile) API to receive files from other devices.</p>
  <p>The following figure illustrates the application view:</p>
  <p class="figure">Figure: Main view</p>
  <p align="center"><img alt="Main view" src="../images/files_sharing_server_main_view.png" border="1"/>
  </p>

  <h2>Prerequisites</h2>
  <p>To ensure proper application execution, the following privileges and features must be set:</p>
  <ul>
    <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/mediastorage</span>,</li>
	<li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/privilege/bluetooth</span>,</li>
    <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth</span>,</li>
    <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/network.bluetooth.opp</span>.</li>
  </ul>
  <p>Additional prerequisites:</p>
  <ul>
    <li>Bluetooth adapter should be switched on,</li>
    <li>connection with another device should be available.</li>
  </ul>

<h2>Implementation</h2>
<p>The following figure illustrates the application structure:</p>
<p class="figure">Figure: Main view</p>
<p align="center"> <img alt="Sample structure" src="../images/files_sharing_server_structure.png" /></p>
<p>The application uses a simple MVC (Model-View-Controller) architectural pattern. The application model consists of a media and Bluetooth module.</p>

<h3>Controller</h3>
<p>The controller module connects the view and the model. It delivers the following set of functions:</p>
<pre class="prettyprint">
/*Function initializes all application modules and event listeners.*/
bool controller_init_application_modules(app_data_t *ad)
{
&nbsp;&nbsp;&nbsp;ad->vd = view_init();
&nbsp;&nbsp;&nbsp;if (!ad->vd)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
&nbsp;&nbsp;&nbsp;ad->md = model_init();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling*/
&nbsp;&nbsp;&nbsp;__controller_init_events(ad);
&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<pre class="prettyprint">
/*Event handlers are stored in an Eina_List which is used to release allocated memory on application terminate event.*/
static void __controller_init_events(app_data_t *ad)
{
&nbsp;&nbsp;&nbsp;ad->app_events = eina_list_append(ad->app_events,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_handler_add(app_utils_get_event_type(EVENT_CONNECTION_REQUEST),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__controller_handle_connection_request_event, ad));
&nbsp;&nbsp;&nbsp;ad->app_events = eina_list_append(ad->app_events,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_handler_add(app_utils_get_event_type(EVENT_TRANSFER_IN_PROGRESS),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__controller_handle_transfer_in_progress_event, ad));
&nbsp;&nbsp;&nbsp;ad->app_events = eina_list_append(ad->app_events,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_handler_add(app_utils_get_event_type(EVENT_ACCEPT_BUTTON_CLICKED),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__controller_handle_accept_button_clicked_event, ad));
&nbsp;&nbsp;&nbsp;ad->app_events = eina_list_append(ad->app_events,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_handler_add(app_utils_get_event_type(EVENT_REJECT_BUTTON_CLICKED),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__controller_handle_reject_button_clicked_event, ad));
&nbsp;&nbsp;&nbsp;ad->app_events = eina_list_append(ad->app_events,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_handler_add(app_utils_get_event_type(EVENT_TRANSFER_STARTED),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__controller_handle_transfer_started_event, ad));
}
</pre>

<p>The event listeners described above are used to accept a file transfer, update the sending progress and handle user interaction. When the application receives the connection request from another device, custom event defined in the <span st="font-family: Courier New,Courier,monospace">app_utils.c</span> file is emitted. Callback function invoked in that case changes the state of the accept button.</p>

<pre class="prettyprint">
/*Callback enables the accept button.*/
static Eina_Bool __controller_handle_connection_request_event(void *data, int type, void *event)
{
&nbsp;&nbsp;&nbsp;app_data_t *ad = (app_data_t *) data;
&nbsp;&nbsp;&nbsp;if (!ad)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
&nbsp;&nbsp;&nbsp;view_enable_accept_button(ad->vd);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p> When the accept button is enabled, the user can press it to confirm the files transfer. The <span style="font-family: Courier New,Courier,monospace">__controller_handle_accept_button_clicked_event()</span> function listed below changes the view state and starts the exchange process.</p>

<pre class="prettyprint">
static Eina_Bool __controller_handle_accept_button_clicked_event(void *data, int type, void *event)
{
&nbsp;&nbsp;&nbsp;app_data_t *ad = (app_data_t *) data;
&nbsp;&nbsp;&nbsp;bt_module_transfer_accept(ad->md);
&nbsp;&nbsp;&nbsp;view_disable_accept_button(ad->vd);
&nbsp;&nbsp;&nbsp;view_enable_reject_button(ad->vd);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p>The <span st="font-family: Courier New,Courier,monospace">__controller_handle_transfer_started_event()</span> callback function is used to create an item in the received files list. It is called when a new file transfer starts.</p>

<pre class="prettyprint">
static Eina_Bool __controller_handle_transfer_started_event(void *data, int type, void *event)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *new_item = NULL;
&nbsp;&nbsp;&nbsp;app_data_t *ad = (app_data_t *) data;
&nbsp;&nbsp;&nbsp;file_t *recv_file = (file_t *) event;
&nbsp;&nbsp;&nbsp;if (!ad || !recv_file)
&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;/*Error handling*/
&nbsp;&nbsp;&nbsp;/*Adding new item into the files list.*/
&nbsp;&nbsp;&nbsp;new_item = view_append_new_file(ad->vd, recv_file->file_name, &(recv_file->progress));
&nbsp;&nbsp;&nbsp;if (!new_item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
&nbsp;&nbsp;&nbsp;/*Bind the model with the view. New item is used later to update the sending progress.*/
&nbsp;&nbsp;&nbsp;file_data_set(recv_file, (void *) new_item);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p>The <span st="font-family: Courier New,Courier,monospace">__controller_handle_transfer_in_progress_event()</span> function is used to update the sending progress for each file. It is called when the <span st="font-family: Courier New,Courier,monospace">bt_module</span> emits the signal for item update. It uses the data stored in the internal <span st="font-family: Courier New,Courier,monospace">file</span> object.

<pre class="prettyprint">
static Eina_Bool __controller_handle_transfer_in_progress_event(void *data, int type, void *event)
{
&nbsp;&nbsp;&nbsp;app_data_t *ad = (app_data_t *) data;
&nbsp;&nbsp;&nbsp;file_t *file = (file_t *) event;
&nbsp;&nbsp;&nbsp;if(!file || !ad)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling*/
&nbsp;&nbsp;&nbsp;view_update_progress((Elm_Object_Item *) file->data, (double) file->progress / 100.0);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>

<p>When transfer starts, the application enables the reject button. It can be used by the user to stop the files exchange.</p>

<pre class="prettyprint">
static Eina_Bool __controller_handle_reject_button_clicked_event(void *data, int type, void *event)
{
&nbsp;&nbsp;&nbsp;app_data_t *ad = (app_data_t *) data;
&nbsp;&nbsp;&nbsp;if (!ad)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
&nbsp;&nbsp;&nbsp;bt_module_transfer_reject(ad->md);
&nbsp;&nbsp;&nbsp;view_disable_reject_button(ad->vd);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>
<h3>View</h3>
<p>The following figure illustrates the application views:</p>
<p class="figure">Figure: Files Sharing Server Screens</p>
<p align="center"><img alt="" src="../images/files_sharing_server-help_text.png" border="1"/> <img alt="" src="../images/files_sharing_server_accept_button_enable.png" border="1"/> <img alt="" src="../images/files_sharing_server_received_list.png" border="1"/>

<p>The view of the sample application is initialized by the controller module. It calls the <span style="font-family: Courier New,Courier,monospace">view_init()</span> function to initialize all view objects and data.</p>
<pre class="prettyprint">
view_data_t *view_init(void)
{
&nbsp;&nbsp;&nbsp;view_data_t *vd = NULL;
&nbsp;&nbsp;&nbsp;vd = (view_data_t *)malloc(sizeof(view_data_t));
&nbsp;&nbsp;&nbsp;if (!vd)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Create window, conformant and layout. Code for that objects are generated by the SDK.*/
&nbsp;&nbsp;&nbsp;/*...*/

&nbsp;&nbsp;&nbsp;if (!__view_create_files_list(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;if (!__view_init_buttons(vd))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Show help text and disable buttons.*/
&nbsp;&nbsp;&nbsp;view_show_help(vd);
&nbsp;&nbsp;&nbsp;view_disable_accept_button(vd);
&nbsp;&nbsp;&nbsp;view_disable_reject_button(vd);
&nbsp;&nbsp;&nbsp;evas_object_show(vd->win);
&nbsp;&nbsp;&nbsp;return vd;
}
</pre>
<p>The most important part of the view is the received files list. It shows all files obtained by the Bluetooth OPP protocol as well as the current status of the files transfer. To add a new file to the list, <span style="font-family: Courier New,Courier,monospace">view_append_new_file()</span> function is used.</p>

<pre class="prettyprint">
Elm_Object_Item *view_append_new_file(view_data_t *vd, const char *file_name, int *progress)
{
&nbsp;&nbsp;&nbsp;struct _list_data_s *list_data_s = NULL;
&nbsp;&nbsp;&nbsp;Elm_Object_Item *new_item = NULL;

&nbsp;&nbsp;&nbsp;if (!vd || !file_name || !progress)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;list_data_s = (struct _list_data_s *)malloc(sizeof(struct _list_data_s));
&nbsp;&nbsp;&nbsp;if (!list_data_s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*List_data_s structure is used to pass one more parameter to the genlist item creation callback.*/
&nbsp;&nbsp;&nbsp;list_data_s->file_name = file_name;
&nbsp;&nbsp;&nbsp;list_data_s->progress = progress;

&nbsp;&nbsp;&nbsp;/*Use elm_gengrid API to add a new file.*/
&nbsp;&nbsp;&nbsp;new_item = elm_genlist_item_append(vd->files_list, vd->gic,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)list_data_s, NULL, ELM_GENLIST_ITEM_NONE, NULL, NULL);

&nbsp;&nbsp;&nbsp;if (!new_item)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
&nbsp;&nbsp;&nbsp;return new_item;
}
</pre>

<p>The function described above calls <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> function, which uses a callback from the genlist constructor to create the item's <span style="font-family: Courier New,Courier,monospace">Evas_Object</span>. Callback presented below creates the item's content.</p>

<pre class="prettyprint">
static Evas_Object *__view_set_file_item_content_cb(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;if (!strncmp(part, FILE_LIST_ITEM_CONTENT, strlen(part)) &&
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen(part) == strlen(FILE_LIST_ITEM_CONTENT))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return __view_create_file_list_item(obj, data);

&nbsp;&nbsp;&nbsp;return NULL;
}
</pre>


<pre class="prettyprint">
static Evas_Object *__view_create_file_list_item(Evas_Object *parent, struct _list_data_s *list_data_s)
{
&nbsp;&nbsp;&nbsp;Evas_Object *item_ly = NULL;
&nbsp;&nbsp;&nbsp;Evas_Object *progressbar = NULL;
&nbsp;&nbsp;&nbsp;char edj_path[PATH_MAX] = {0, };
&nbsp;&nbsp;&nbsp;char buf[64] = {0, };

&nbsp;&nbsp;&nbsp;if (!parent || !list_data_s || !list_data_s->file_name || !list_data_s->progress)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Create item layout*/
&nbsp;&nbsp;&nbsp;item_ly = elm_layout_add(parent);
&nbsp;&nbsp;&nbsp;if (!item_ly)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Get the path to the EDJE layout*/
&nbsp;&nbsp;&nbsp;app_utils_get_resource(EDJ_FILE, edj_path, (int)PATH_MAX);

&nbsp;&nbsp;&nbsp;/*Create progressbar widget*/
&nbsp;&nbsp;&nbsp;progressbar = elm_progressbar_add(parent);
&nbsp;&nbsp;&nbsp;if (!progressbar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Set initial values.*/
&nbsp;&nbsp;&nbsp;elm_progressbar_value_set(progressbar, (double)(*(list_data_s->progress)) / 100.0);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(progressbar, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);

&nbsp;&nbsp;&nbsp;/*Show the file name and the sending progress*/
&nbsp;&nbsp;&nbsp;elm_object_part_text_set(item_ly, PART_ITEM_TITLE, list_data_s->file_name);
&nbsp;&nbsp;&nbsp;snprintf(buf, sizeof(buf), "%d %%", *(list_data_s->progress));
&nbsp;&nbsp;&nbsp;elm_object_part_text_set(item_ly, PART_ITEM_PROGRESS, buf);

&nbsp;&nbsp;&nbsp;elm_object_part_content_set(item_ly, PART_ITEM_CONTENT, progressbar);
&nbsp;&nbsp;&nbsp;evas_object_show(item_ly);
&nbsp;&nbsp;&nbsp;return item_ly;
}
</pre>

<p>Each item consists of an <span style="font-family: Courier New,Courier,monospace">elm_progressbar</span> widget, file name and progress text. To update mentioned content, <span style="font-family: Courier New,Courier,monospace">view_update_progress()</span> function is used.</p>

<pre class="prettyprint">
void view_update_progress(Elm_Object_Item *it, double progress)
{
&nbsp;&nbsp;&nbsp;Evas_Object *item_ly = NULL;
&nbsp;&nbsp;&nbsp;Evas_Object *progressbar = NULL;
&nbsp;&nbsp;&nbsp;char buf[64] = {0, };

&nbsp;&nbsp;&nbsp;if (!it)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Erorr handling.*/

&nbsp;&nbsp;&nbsp;item_ly = elm_object_item_part_content_get(it, FILE_LIST_ITEM_CONTENT);
&nbsp;&nbsp;&nbsp;if (!item_ly) /*It is not an error. If the item_ly == NULL it means that it is not visible in the genlist so it should not be updated.*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;/*Get the reference to the elm_progressbar widget.*/
&nbsp;&nbsp;&nbsp;progressbar = elm_object_part_content_get(item_ly, PART_ITEM_CONTENT);
&nbsp;&nbsp;&nbsp;/*Save the progress in the buffer.*/
&nbsp;&nbsp;&nbsp;snprintf(buf, sizeof(buf), "%d %%", (int) (progress * 100));
&nbsp;&nbsp;&nbsp;/*Update progress text*/
&nbsp;&nbsp;&nbsp;elm_object_part_text_set(item_ly, PART_ITEM_PROGRESS, buf);
&nbsp;&nbsp;&nbsp;/*Update progressbar value*/
&nbsp;&nbsp;&nbsp;elm_progressbar_value_set(progressbar, progress);
}
</pre>
<p>File list items are deleted automatically by the <span style="font-family: Courier New,Courier,monospace">elm_genlist</span> API when application is terminated. Delete function is also called during the list scroll when items are not longer visible. In both cases additional data must be released.</p>

<pre class="prettyprint">
static void __view_del_file_item_cb(void *data, Evas_Object *obj)
{
&nbsp;&nbsp;&nbsp;struct _list_data_s *list_data_s = (struct _list_data_s *)data;
&nbsp;&nbsp;&nbsp;if (!list_data_s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling*/
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;free(list_data_s);
}
</pre>

<h3>Model</h3>
<p>The application's model consists of three sub-modules: Model, File and the Bluetooth module. The main tasks are presented in the picture below:</p>
<p align="center"><img alt="Model tasks" src="../images/files_sharing_server_model_tasks.png"/>
<p>The model's data is represented by the <span style="font-family: Courier New,Courier,monospace">model_data_t</span> structure, which is allocated in the <span style="font-family: Courier New,Courier,monospace">model_init()</span> function, called by the controller when the application is created.</p>

<pre class="prettyprint">
struct _model_data_t {
&nbsp;&nbsp;&nbsp;Eina_List *files_list;
&nbsp;&nbsp;&nbsp;int transfer_id;
};
typedef struct _model_data_t model_data_t;
</pre>

<pre class="prettyprint">
extern model_data_t *model_init(void)
{
&nbsp;&nbsp;&nbsp;model_data_t *md = NULL;
&nbsp;&nbsp;&nbsp;md = (model_data_t *)malloc(sizeof(model_data_t));
&nbsp;&nbsp;&nbsp;md->files_list = NULL;

&nbsp;&nbsp;&nbsp;if (!bt_module_init())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;return md;
}
</pre>

<p>The model object destructor is called on <span style="font-family: Courier New,Courier,monospace">app_terminate()</span> by the constructor and releases all allocated data.</p>
<pre class="prettyprint">
extern void model_deinit(model_data_t *md)
{
&nbsp;&nbsp;&nbsp;file_t *file = NULL;

&nbsp;&nbsp;&nbsp;if (!md || !md->files_list)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling*/

&nbsp;&nbsp;&nbsp;EINA_LIST_FREE (md->files_list, file)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_delete(file);

&nbsp;&nbsp;&nbsp;free(md);
&nbsp;&nbsp;&nbsp;bt_module_deinit();
}
</pre>

<p>Bluetooth initialization is described below:</p>

<pre class="prettyprint">
bool bt_module_init(void)
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;char *directory = NULL;

&nbsp;&nbsp;&nbsp;/*Set storage directory for received files*/
&nbsp;&nbsp;&nbsp;storage_get_directory(0, STORAGE_DIRECTORY_DOWNLOADS, &directory);
&nbsp;&nbsp;&nbsp;if(!directory)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Initialize Bluetooth.*/
&nbsp;&nbsp;&nbsp;ret = bt_initialize();
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Initialize the Bluetooth OPP server and set callbacks invoked when connection is requested.*/
&nbsp;&nbsp;&nbsp;ret = bt_opp_server_initialize_by_connection_request(directory, __bt_connection_request_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;free(directory);
&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>All initialized modules must be released when they are no longer needed. In case of this sample application, it is called on <span style="font-family: Courier New,Courier,monospace">app_terminate</span> event.</p>

<pre class="prettyprint">
void bt_module_deinit(void)
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;ret = bt_opp_server_deinitialize();
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;ret = bt_deinitialize();
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
}
</pre>

<p>If another device starts to send files using the Bluetooth OPP protocol, the request callback is invoked. In this sample application, <span style="font-family: Courier New,Courier,monospace">Ecore Events</span> mechanism is used to inform the controller about actions from other modules. This approach was chosen to avoid static data structures declared in each module.</p>

<pre class="prettyprint">
static void __bt_connection_request_cb(const char *remote_addr, void *data)
{
&nbsp;&nbsp;&nbsp;ecore_event_add(app_utils_get_event_type(EVENT_CONNECTION_REQUEST), NULL, NULL, NULL);
}
</pre>

<p>After receiving a request event, controller changes the state of the view to enable the accept button. When the user taps it, <span style="font-family: Courier New,Courier,monospace">bt_module_transfer_accept()</span> function is called. It accepts the connection and starts the files transfer. It is also used to set callback functions which inform the application about the progress changes and transfer finished events.</p>

</p><pre class="prettyprint">
void bt_module_transfer_accept(model_data_t *md)
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;if (!md)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;ret = bt_opp_server_accept(__bt_transfer_progress_cb, __bt_transfer_finished_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL, md, &(md->transfer_id));

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/
}
</pre>

<p> The <span style="font-family: Courier New,Courier,monospace">__bt_transfer_progress_cb()</span> function is used to update the received file progress and distinguish new files transfer.
For that purpose, the <span style="font-family: Courier New,Courier,monospace">transfer_in_progress</span> flag is declared in the static memory. It is reset by the <span style="font-family: Courier New,Courier,monospace">__bt_transfer_finished_cb()</span> callback function.</p>

</p><pre class="prettyprint">
static void __bt_transfer_progress_cb(const char *file, long long size, int percent, void *user_data)
{
&nbsp;&nbsp;&nbsp;model_data_t *md = (model_data_t *)user_data;
&nbsp;&nbsp;&nbsp;static file_t *recv_file = NULL;

&nbsp;&nbsp;&nbsp;if (!md)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Error handling.*/

&nbsp;&nbsp;&nbsp;/*Receive new file. In that case EVENT_TRANSFER_STARTED is emitted and it is handled by the controller
&nbsp;&nbsp;&nbsp;to add new file item into the files list.*/
&nbsp;&nbsp;&nbsp;if (!transfer_in_progres) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Create a new file object.*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recv_file = file_create(md, strdup(file), NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Pass the created file to the controller module. New genlist item is created based on the file.*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecore_event_add(app_utils_get_event_type(EVENT_TRANSFER_STARTED), recv_file, __bt_transfer_started_end_cb, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*Change the flag to true. It will be reset when the transfer of the file is completed.*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transfer_in_progres = true;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;/*Update the progress of the received file.*/
&nbsp;&nbsp;&nbsp;file_update_progress(recv_file, percent);
&nbsp;&nbsp;&nbsp;/*Pass the received file to the controller. It is used to update the progressbar widget for a specific file in the received files list.*/
&nbsp;&nbsp;&nbsp;ecore_event_add(app_utils_get_event_type(EVENT_TRANSFER_IN_PROGRESS), recv_file, __bt_transfer_in_progress_end_cb, NULL);
}
</pre>

<p>Transfer finished callback is used to change the value of the <span style="font-family: Courier New,Courier,monospace">transfer_in_progress</span> flag.</p>

</p><pre class="prettyprint">
static void __bt_transfer_finished_cb(int result, const char *file, long long size, void *user_data)
{
&nbsp;&nbsp;&nbsp;transfer_in_progres = false;
}
</pre>

<p>All helper function used in the sample application are implemented in the <span style="font-family: Courier New,Courier,monospace">app_utils.c</span> file. The most important function in this module initializes new <span style="font-family: Courier New,Courier,monospace">Ecore Callbacks</span> used by the controller.</p>

</p><pre class="prettyprint">
typedef enum {
&nbsp;&nbsp;&nbsp;EVENT_CONNECTION_REQUEST = 0,
&nbsp;&nbsp;&nbsp;EVENT_TRANSFER_IN_PROGRESS,
&nbsp;&nbsp;&nbsp;EVENT_ACCEPT_BUTTON_CLICKED,
&nbsp;&nbsp;&nbsp;EVENT_REJECT_BUTTON_CLICKED,
&nbsp;&nbsp;&nbsp;EVENT_TRANSFER_STARTED,
} event_type_t;
</pre>

</p><pre class="prettyprint">
extern int app_utils_get_event_type(event_type_t event)
{
&nbsp;&nbsp;&nbsp;int i = 0;

&nbsp;&nbsp;&nbsp;if (!initialized) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialized = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i < APP_EVENTS_COUNT; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr_custom_events[i] = ecore_event_type_new();
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return arr_custom_events[event];
}
</pre>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

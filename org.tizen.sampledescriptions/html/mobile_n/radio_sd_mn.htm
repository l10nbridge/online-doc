<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../css/snippet.css" />
	<script type="text/javascript" src="../scripts/snippet.js"></script>
	<script type="text/javascript" src="../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../scripts/search.js" charset="utf-8"></script>
	<title>Radio Sample Overview</title>
</head>

<body class="no-toc" onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
</div>

<div id="container"><div id="contents"><div class="content">
	<div id="profile">
		<p><img alt="Mobile native" src="../images/mobile_s_n.png"/></p>
	</div>
  <h1>Radio Sample Overview</h1>

<p>The Radio sample application demonstrates how you can create an application using the <a href="../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__RADIO__MODULE.html">Radio</a> API. The application has been designed as multi-threaded to avoid main rendering loop lockups in case of multiple frequency set commands. It takes some time for the radio hardware to set itself up.</p>
<p>For information on creating the sample application project in the IDE, see <a href="../cover_page.htm#create">Creating Sample Applications</a>.</p>

<p>The following figure illustrates the main screens of the Radio.</p>

  <p class="figure">Figure: Radio screens</p>
  <p align="center">
    <img alt="Radio screens" src="../images/radio_screen_0.png" /> <img alt="List of known frequencies" src="../images/radio_screen_1.png" />
  </p>

<p>The application opens with the main screen showing an old style radio view. To use the radio:</p>

<ul>
<li>To switch the radio on and of, click <strong>ON/OFF</strong>.</li>
<li>To scan for the strongest station frequencies, click <strong>SCAN</strong>.
<p>The buttons on the screen are disabled during scanning. When the scan is completed (and buttons reactivate), press the <strong>MENU</strong> key to open the frequency list, and select the frequency to listen to. The frequency list is a simple menu containing a list of scanned frequencies.</p>
<p>Scanning switches the radio off, so switch it back on manually afterwards.</p>
</li>
<li>To change the frequency manually, use the dial or let the radio seek the station by clicking <strong>SEEK -</strong> or <strong>SEEK +</strong>. 
<p>Use the signal strength indicator to help with tuning the radio.</p></li></ul>


<h2>Prerequisites</h2>
<p>To ensure proper application execution, the following feature must be enabled:</p>
<ul>
 <li><span style="font-family: Courier New,Courier,monospace">http://tizen.org/feature/fmradio</span></li>
</ul>

<h2>Implementation</h2>

<h3>Main Controller</h3>

<p>This module defines 2 important functions:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace">__radio_cb()</span>: Reacts to radio module change events and sets up the application view accordingly.

<p>The following events are handled:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_SCAN_END</span>: When the scan command is completed, you must unlock the UI and update the list of known frequencies.</li>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_SCAN_UPDATE</span>: During the scan command execution, each time the device finds a station signal, the UI frequency display is updated.</li>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_SEEK_END</span>: When the seek command is completed, you must update the interface state, for example, the frequency the device is set to.</li>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_RSSI_UPDATE</span>: This event is related to the radio module&#39;s internal timer; use it to read RSSI and update the UI accordingly.</li>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_INTERRUPTION</span>: When something unpredicted occurs during radio operation, you must react to it.</li>
<li><span style="font-family: Courier New,Courier,monospace">RADIO_EVENT_FREQ_SET</span>: This event occurs when the desired frequency has been set using the frequency dial.</li>
</ul>

<pre class="prettyprint">
static void 
__radio_cb(radio_event event)
{
&nbsp;&nbsp;&nbsp;// Define the variables

&nbsp;&nbsp;&nbsp;switch (event) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_SCAN_END:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_controller_get_known_stations(&amp;stations_arr, &amp;stations_arr_len) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stations_arr_len &gt; 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; stations_arr_len; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_add_station(stations_arr[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_lock_ui(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_on_off(radio_controller_is_on());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_scanning(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_controller_is_muted(&amp;muted))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_muted(muted);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_seeking(false, false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_seeking(false, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_SCAN_UPDATE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__setup_ui_freq();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_SEEK_END:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_lock_ui(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_on_off(radio_controller_is_on());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_scanning(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_controller_is_muted(&amp;muted))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_muted(muted);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_seeking(false, false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_seeking(false, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__setup_ui_freq();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_RSSI_UPDATE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__setup_ui_rssi();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_INTERRUPTION:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_controller_set_on(false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__setup_ui();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RADIO_EVENT_FREQ_SET:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li><span style="font-family: Courier New,Courier,monospace">__ui_cb()</span>: Invokes radio module functions depending on the user interface selections.
<p>The following events are communicated from the view module to the main controller:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">UI_EVENT_FREQ_CHANGE</span>: Generated multiple times as the user rotates the dial.
<p>The event contains information about the selected frequency, and is used to ask the radio controller to set it.</p></li>
<li><span style="font-family: Courier New,Courier,monospace">UI_EVENT_FREQ_CHANGE_END</span>: Generated when the user has stopped and released the frequency dial.
<p>The UI is updated and the current device frequency is displayed.</p></li>
<li><span style="font-family: Courier New,Courier,monospace">UI_EVENT_STATION_SELECTION</span>: Generated when the user selects a frequency from the frequency list.</li>
<li><span style="font-family: Courier New,Courier,monospace">UI_EVENT_BUTTON_ACTIVATE</span> and <span style="font-family: Courier New,Courier,monospace">UI_EVENT_BUTTON_DEACTIVATE</span>: Generated when the user toggles one of the following panel buttons.
<p>The radio controller function associated with the selected button is called.</p>
	<ul>
	<li><span style="font-family: Courier New,Courier,monospace">UI_ELEMENT_ON_OFF_BUTTON</span>: Switches the radio on or off.</li>
	<li><span style="font-family: Courier New,Courier,monospace">UI_ELEMENT_MUTE_BUTTON</span>: Mutes or unmutes the radio. 
	<p>The radio mute state is preserved during scans.</p></li>
	<li><span style="font-family: Courier New,Courier,monospace">UI_ELEMENT_SCAN_BUTTON</span>: Begins the scan command and automatically switches the radio off.
	<p>This process takes some time as the whole frequency range is checked for stations.</p></li>
	<li><span style="font-family: Courier New,Courier,monospace">UI_ELEMENT_SEEK_MINUS_BUTTON</span> and <span style="font-family: Courier New,Courier,monospace">UI_ELEMENT_SEEK_PLUS_BUTTON</span>: Begins the seek command by gradually decreasing or increasing the frequency.
	<p>The seek process is similar to a scan, but stops on the first found station.</p></li>
	</ul>
</li>
</ul>

<pre class="prettyprint">
static void 
__ui_cb(ui_event event, ui_element element, const void *data)
{
&nbsp;&nbsp;&nbsp;// Define the variables
&nbsp;&nbsp;&nbsp;bool activate_button = (event == UI_EVENT_BUTTON_ACTIVATE);

&nbsp;&nbsp;&nbsp;if (event == UI_EVENT_FREQ_CHANGE &amp;&amp; data) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frequency = (float)(*(double *)data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!radio_controller_set_frequency(frequency * 1000.0))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (event == UI_EVENT_FREQ_CHANGE_END) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__setup_ui_freq();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (event == UI_EVENT_STATION_SELECTION &amp;&amp; data) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected_station = *(int *)data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_controller_get_known_stations(&amp;stations_arr, &amp;stations_arr_len) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected_station &gt;= 0 &amp;&amp; selected_station &lt; stations_arr_len) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_controller_set_frequency(stations_arr[selected_station])) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_frequency((float)stations_arr[selected_station] / 1000.0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (event == UI_EVENT_BUTTON_ACTIVATE || event == UI_EVENT_BUTTON_DEACTIVATE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (element) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case UI_ELEMENT_ON_OFF_BUTTON:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((result_ok = radio_controller_set_on(activate_button)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_on_off(activate_button);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case UI_ELEMENT_MUTE_BUTTON:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((result_ok = radio_controller_mute(activate_button)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_muted(activate_button);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case UI_ELEMENT_SCAN_BUTTON:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((result_ok = radio_controller_start_scan(activate_button))) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (activate_button) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_clear_stations();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_lock_ui(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_scanning(activate_button);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case UI_ELEMENT_SEEK_MINUS_BUTTON:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case UI_ELEMENT_SEEK_PLUS_BUTTON:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!activate_button) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_ok = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((result_ok = radio_controller_start_seek(element == UI_ELEMENT_SEEK_PLUS_BUTTON))) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_show_seeking(true, element == UI_ELEMENT_SEEK_PLUS_BUTTON);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view_lock_ui(true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre>
</li></ul>

<h3>Radio Controller</h3>

<p>The radio controller module is the essence of the application.</p>

<p>To manage the radio controller:</p>
<ul>
<li>Initialize the radio controller.
<p>The <span style="font-family: Courier New,Courier,monospace">radio_controller_init()</span>
function is used to obtain handles for the radio resource and timer as well as to set callbacks for the following events:</p>
<ul>
<li>Scan command completion event</li>
<li>Radio operation interruption event</li>
<li>Timer timeout event (used to periodically poll for the RSSI)</li>
</ul>

<pre class="prettyprint">
bool 
radio_controller_init(radio_cb cb)
{
&nbsp;&nbsp;&nbsp;// Common code

&nbsp;&nbsp;&nbsp;ret = radio_create(&amp;radio_data.handle);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;ret = radio_set_scan_completed_cb(radio_data.handle, __radio_scan_completed_cb, NULL);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;ret = radio_set_interrupted_cb(radio_data.handle, __radio_interrupted_cb, NULL);
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;radio_data.tim = ecore_timer_add(RSSI_POLL_INTERVAL, __rssi_tim_cb, NULL);
&nbsp;&nbsp;&nbsp;// Error handling and common code
}
</pre>
</li>
<li>Switch the radio on and off.
<p>The <span style="font-family: Courier New,Courier,monospace">radio_controller_set_on()</span>
function uses API calls to <span style="font-family: Courier New,Courier,monospace">radio_start()</span> and
<span style="font-family: Courier New,Courier,monospace">radio_stop()</span>.</p>

<pre class="prettyprint">
bool 
radio_controller_set_on(bool on_off)
{
&nbsp;&nbsp;&nbsp;int res = RADIO_ERROR_NONE;

&nbsp;&nbsp;&nbsp;if (on_off) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = radio_start(radio_data.handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.state = RADIO_STATE_PLAYING;

&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res = radio_stop(radio_data.handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.state = RADIO_STATE_READY;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Set the frequency:
<ul>
<li>The <span style="font-family: Courier New,Courier,monospace">radio_controller_set_frequency()</span> function uses an Ecore thread to set up the selected frequency. Such an approach is used because this operation takes a long time to complete. Calling the <span style="font-family: Courier New,Courier,monospace">radio_set_frequency()</span> function directly blocks the main event loop.</li>
<li>The <span style="font-family: Courier New,Courier,monospace">__thread_function()</span> function is called in the context of another thread. This prevents a UI lockup and allows for fluent frequency change.</li>
<li>The <span style="font-family: Courier New,Courier,monospace">__thread_end_cb()</span> function is called when the thread has finished. Since it is called in the context of the main thread, it is possible to invoke a callback function and update the UI.</li></ul>

<pre class="prettyprint">
bool 
radio_controller_set_frequency(int freq)
{
&nbsp;&nbsp;&nbsp;if (!radio_data.thread_h &amp;&amp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(__radio_is_in_state(RADIO_STATE_PLAYING) || __radio_is_in_state(RADIO_STATE_READY))) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.thread_h = ecore_thread_run(__thread_function, __thread_end_cb, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL, (void *)freq);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (radio_data.thread_h != NULL);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return false;
}

static void 
__thread_function(void *frequency, Ecore_Thread *thread)
{
&nbsp;&nbsp;&nbsp;radio_set_frequency(radio_data.handle, (int)frequency);
}

static void 
__thread_end_cb(void *data, Ecore_Thread *thread)
{
&nbsp;&nbsp;&nbsp;if (radio_data.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.cb(RADIO_EVENT_FREQ_SET);

&nbsp;&nbsp;&nbsp;radio_data.thread_h = NULL;
}
</pre>
</li>
<li>Scan for radio channels:
<ol>
<li>Start the scan.
<p>The <span style="font-family: Courier New,Courier,monospace">radio_controller_start_scan()</span> function issues an asynchronous scan command. This automatically switches the radio off.</p>

<pre class="prettyprint">
bool 
radio_controller_start_scan(bool start_stop)
{
&nbsp;&nbsp;&nbsp;int ret = RADIO_ERROR_NONE;

&nbsp;&nbsp;&nbsp;if (radio_data.thread_h != NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (start_stop) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!radio_controller_set_on(false))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = radio_scan_start(radio_data.handle, __radio_scan_updated_cb, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (RADIO_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.known_freq_ix = 0;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = radio_scan_stop(radio_data.handle, __radio_scan_stopped_cb, NULL);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (RADIO_ERROR_NONE != ret)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Update the scan result. 
<p>Each time a radio station frequency is found, the <span style="font-family: Courier New,Courier,monospace">__radio_scan_updated_cb()</span> callback is invoked. The callback is used to update the scanned frequencies list.</p>

<pre class="prettyprint">
static void 
__radio_scan_updated_cb(int frequency, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (radio_data.known_freq_ix &lt; KNOWN_STATIONS_MAX) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.known_freq[radio_data.known_freq_ix++] = frequency;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (radio_data.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.cb(RADIO_EVENT_SCAN_UPDATE);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>Once the scan is completed, the <span style="font-family: Courier New,Courier,monospace">__radio_scan_completed_cb()</span> callback function is invoked.</p>

<pre class="prettyprint">
static void 
__radio_scan_completed_cb(void *user_data)
{
&nbsp;&nbsp;&nbsp;if (radio_data.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.cb(RADIO_EVENT_SCAN_END);
}
</pre>
</li>
</ol>
</li>
<li>Set the radio to mute:
<pre class="prettyprint">
bool 
radio_controller_mute(bool mute)
{
&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_set_mute(radio_data.handle, mute));
}
</pre>
</li>
<li>Look for channels.
<p>The <span style="font-family: Courier New,Courier,monospace">radio_controller_start_seek()</span> function runs an asynchronous command which finds the nearest channel (in sense of frequency). The <span style="font-family: Courier New,Courier,monospace">__radio_seek_completed_cb()</span> callback function is invoked when the operation is complete.</p>

<pre class="prettyprint">
bool 
radio_controller_start_seek(bool up_down)
{
&nbsp;&nbsp;&nbsp;if (__radio_is_in_state(RADIO_STATE_SCANNING) || !radio_controller_set_on(true))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;if (up_down) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_seek_up(radio_data.handle, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__radio_seek_completed_cb, NULL));
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_seek_down(radio_data.handle, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__radio_seek_completed_cb, NULL));
&nbsp;&nbsp;&nbsp;}
}

static void 
__radio_seek_completed_cb(int frequency, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (radio_data.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.cb(RADIO_EVENT_SEEK_END);
}
</pre>
</li>
<li>Update the signal strength information.
<p>The <span style="font-family: Courier New,Courier,monospace">__rssi_tim_cb()</span> function is the poll timer timeout event callback. Whenever it is called, it notifies the <span style="font-family: Courier New,Courier,monospace">main controller</span> module to update itself on a RSSI status.</p>

<pre class="prettyprint">
static Eina_Bool 
__rssi_tim_cb(void *data)
{
&nbsp;&nbsp;&nbsp;if (radio_data.cb)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radio_data.cb(RADIO_EVENT_RSSI_UPDATE);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>
</li>
<li>Get information about the radio using the following getter functions.
<ul>
<li>Check whether the radio is on:
<pre class="prettyprint">
bool 
radio_controller_is_on(void)
{
&nbsp;&nbsp;&nbsp;return __radio_is_in_state(RADIO_STATE_PLAYING);
}
</pre>
</li>
<li>Check whether the radio is muted:
<pre class="prettyprint">
bool 
radio_controller_is_muted(bool *muted)
{
&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_is_muted(radio_data.handle, muted));
}
</pre>
</li>
<li>Get the signal strength:
<p>The signal strength is linearized in the dBm domain. The range is from -128 to 128 dBm.</p>

<pre class="prettyprint">
bool 
radio_controller_get_rssi(float *strength)
{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;if (RADIO_ERROR_NONE != radio_get_signal_strength(radio_data.handle, &amp;dBm))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;

&nbsp;&nbsp;&nbsp;*strength = (float)(dBm + 128.0) / (2.0 * 128.0);

&nbsp;&nbsp;&nbsp;if (*strength &lt;= 0.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*strength = 0.0;

&nbsp;&nbsp;&nbsp;if (*strength &gt;= 1.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*strength = 1.0;

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Get the current radio frequency:
<pre class="prettyprint">
bool 
radio_controller_get_freq(int *freq)
{
&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_get_frequency(radio_data.handle, freq));
}
</pre>
</li>
<li>Get the frequency range the radio can operate on:
<pre class="prettyprint">
bool 
radio_controller_get_freq_range(int *freq_min, int *freq_max)
{
&nbsp;&nbsp;&nbsp;return (RADIO_ERROR_NONE == radio_get_frequency_range(radio_data.handle, freq_min, freq_max));
}
</pre>
</li>
</ul>
</li>
</ul>

<script type="text/javascript" src="../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Connection: Managing Modem Data Connections</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
		   <li><a href="#init">Initializing Connections</a></li>
		   <li><a href="#detail">Getting the Network Connection Details</a></li>
		   <li><a href="#info">Getting the Connection Information</a></li>
		   <li><a href="#register">Registering the Property Change Callback</a></li>
		   <li>IP sockets
		   <ul class="toc">
		   		<li><a href="#socket_init">Initializing a Socket</a></li>
				<li><a href="#socket_family">Retrieving the Address Family</a></li>
				<li><a href="#socket_create">Creating the Socket and Managing the Remote Host Connection</a></li>
			</ul></li>	
		</ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/network/connection_n.htm">Connection Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__CONNECTION__MODULE.html">Connection API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__CONNECTION__MODULE.html">Connection API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Connection: Managing Modem Data Connections</h1>

  
<p>This tutorial demonstrates how you can get the network connection information, such as default gateway and proxy configuration, IPv4 and IPv6 addresses, cellular connection state, and data transfer statistics.</p>

 <h2>Warm-up</h2>
 <p>Become familiar with the Connection API basics by learning about:</p>
	 <ul>
		  <li><a href="#init">Initializing Connections</a>
		  <p>Initialize the connection module for use.</p></li>
		  <li><a href="#detail">Getting the Network Connection Details</a>
		  <p>Get the current connection type, IP address, and proxy information.</p></li>
		  <li><a href="#info">Getting the Connection Information</a>
		  <p>Obtain cellular and Wi-Fi connection information with data transfer statistics, such as the amount of total sent/received data and last sent/received data.</p></li>
		   <li><a href="#register">Registering the Property Change Callback</a>
		  <p>Register a callback for receiving notifications about connection property changes.</p></li>
		  <li>IP sockets
		  	<ul>
				<li><a href="#socket_init">Initializing a Socket</a>
				<p>Initialize a socket for use and check the default connection.</p></li>
				<li><a href="#socket_family">Retrieving the Address Family</a>
				<p>Get the IP addresses for the hostname.</p></li>
				<li><a href="#socket_create">Creating the Socket and Managing the Remote Host Connection</a>
				<p>Create the socket, and communicate with the remote host.</p></li>
			</ul>
		</li>
	  </ul>
	

 <h2 id="init" name="init">Initializing Connections</h2>
 
 
<p>To use the functions and data types of the Connection API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__CONNECTION__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__CONNECTION__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;net_connection.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;net_connection.h&gt;
</pre>
 <p>To be able to use all connection functions, you must create a handle that contains information about the connection. Use the <span style="font-family: Courier New,Courier,monospace;">connection</span> static variable that stores the connection handle.</p>
   <pre class="prettyprint">static connection_h connection;</pre>
   
    <p>Create the connection handle using the <span style="font-family: Courier New,Courier,monospace;">connection_create()</span> function that allows you to obtain the connection state and data transfer information.</p>
   <pre class="prettyprint">int error_code;
 
error_code = connection_create(&amp;connection);
if (error_code != CONNECTION_ERROR_NONE)
&nbsp;&nbsp;&nbsp;return;</pre>
   
    <p>Destroy the created connection handle when you do not need it anymore. </p>
   <pre class="prettyprint">connection_destroy(connection);</pre>

 <h2 id="detail" name="detail">Getting the Network Connection Details</h2>

<p>To get the type of the current connection, IP address, and proxy information, the Connection API supports the following network types:</p>
<ul><li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_DISCONNECTED</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_WIFI</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_CELLULAR</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_ETHERNET</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_BT</span></li>
</ul>

<p>The Connection API supports both IPv4 and IPv6 with the following address types:</p>
<ul><li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_ADDRESS_FAMILY_IPV4</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_ADDRESS_FAMILY_IPV6</span></li></ul>
<p>In this tutorial, an IPv4 address is retrieved.</p>

<ol>
<li>To get the type of the current profile for data connection, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_type()</span> function:

<pre class="prettyprint">
int error_code;
connection_type_e net_state;
error_code = connection_get_type(connection, &amp;net_state);
if (error_code == CONNECTION_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Network connection type : %d&quot;, net_state);
}</pre>
<p>You can also use the <span style="font-family: Courier New,Courier,monospace;">connection_set_type_changed_cb()</span> function to register a callback function that is called when the connection type changes.</p>

<pre class="prettyprint">
connection_set_type_changed_cb(connection, __connection_changed_cb, NULL);
</pre>

<p>When the connection type changes, the <span style="font-family: Courier New,Courier,monospace;">__connection_changed_cb()</span> function is invoked.</p>

<pre class="prettyprint">
static void __connection_changed_cb(connection_type_e type, void* user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, "Type changed callback, connection type : %d", type);
}</pre></li>

<li>To get the connection IPv4 address, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_ip_address()</span> function. The IP address is printed using dlog util, or shown to the user in another way. 
<p>Finally, free the memory allocated for the <span style="font-family: Courier New,Courier,monospace;">ip_addr</span> temporary variable.</p>

<pre class="prettyprint">
char *ip_addr = NULL;
error_code = connection_get_ip_address(connection, CONNECTION_ADDRESS_FAMILY_IPV4, &amp;ip_addr);
if (error_code == CONNECTION_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;IP address : %s&quot;, ip_addr);
&nbsp;&nbsp;&nbsp;free(ip_addr);
}</pre></li>

<li>To get the connection proxy information, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_proxy()</span> function. The proxy address is printed. 
<p>Finally, free the memory allocated for the <span style="font-family: Courier New,Courier,monospace;">proxy_addr</span> variable.</p>

<pre class="prettyprint">error_code = connection_get_proxy(connection, address_family, &amp;proxy_addr);
if (error_code == CONNECTION_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Proxy address : %s&quot;, proxy_addr);
&nbsp;&nbsp;&nbsp;free(proxy_addr); 
}</pre></li></ol>

 <h2 id="info" name="info">Getting the Connection Information</h2>

<p>To obtain cellular and Wi-Fi connection information with data transfer statistics, such as the amount of total sent or received data and last sent or received data (only Wi-Fi and cellular statistics information is supported):</p>

<ol><li>To get the cellular connection state, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_cellular_state()</span> function. There are 6 states in which the network connection can be:

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_OUT_OF_SERVICE</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_FLIGHT_MODE</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_ROAMING_OFF</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_CALL_ONLY_AVAILABLE</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_AVAILABLE</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_CELLULAR_STATE_CONNECTED</span></li>
</ul>

<p>In the example, using a <span style="font-family: Courier New,Courier,monospace;">switch</span> statement, the cellular state is shown.</p>

<pre class="prettyprint">connection_cellular_state_e cellular_state;
connection_get_cellular_state(connection, &amp;cellular_state);
switch (cellular_state) 
{
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_OUT_OF_SERVICE: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Out of service&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_FLIGHT_MODE: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Flight mode&quot;);   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_ROAMING_OFF: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Roaming is turned off&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_CALL_ONLY_AVAILABLE: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Call only&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_AVAILABLE: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Available&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_CELLULAR_STATE_CONNECTED: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Connected&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;default: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;error&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
}
</pre></li>

<li>To get the Wi-Fi connection state, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_wifi_state()</span> function. There are 3 states in which the Wi-Fi connection can be:

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_WIFI_STATE_DEACTIVATED</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_WIFI_STATE_DISCONNECTED</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_WIFI_STATE_CONNECTED</span></li>
</ul>

<p>In the example, using a <span style="font-family: Courier New,Courier,monospace;">switch</span> statement, the <span style="font-family: Courier New,Courier,monospace;">wifi_state</span> enumeration variable is shown.</p>

<pre class="prettyprint">connection_wifi_state_e wifi_state;
connection_get_wifi_state(connection, &amp;wifi_state);
switch (wifi_state) 
{
&nbsp;&nbsp;&nbsp;case CONNECTION_WIFI_STATE_DEACTIVATED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Deactivated state&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_WIFI_STATE_DISCONNECTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Disconnected state&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case CONNECTION_WIFI_STATE_CONNECTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Connected state&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;error&quot;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
}
</pre></li>

<li>Get connection statistics.

<p>Connection statistics include the amount of total sent and received data and the last sent and received data. To read the statistics, use the <span style="font-family: Courier New,Courier,monospace;">connection_get_statistics()</span> function. The function arguments determine which statistics are received, and for which connection type.</p>

<p>Statistics are identified by the following constants:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_STATISTICS_TYPE_LAST_RECEIVED_DATA</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_STATISTICS_TYPE_LAST_SENT_DATA</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_STATISTICS_TYPE_TOTAL_RECEIVED_DATA</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_STATISTICS_TYPE_TOTAL_SENT_DATA</span></li>
</ul>

<p>Use the following constants to set the connection type:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_WIFI</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">CONNECTION_TYPE_CELLULAR</span></li>
</ul>

<p>The code below reads all statistics for cellular and WiFi connections.</p>

<pre class="prettyprint">long long last_received_size;
error_code = connection_get_statistics(connection, CONNECTION_TYPE_CELLULAR, CONNECTION_STATISTICS_TYPE_LAST_RECEIVED_DATA, &amp; last_received_size);
// Handle statistics
 
long long last_sent_size;
error_code = connection_get_statistics(connection, CONNECTION_TYPE_CELLULAR, CONNECTION_STATISTICS_TYPE_LAST_SENT_DATA, &amp; last_sent_size);
// Handle statistics
 
long long total_received_size;
error_code = connection_get_statistics(connection, CONNECTION_TYPE_CELLULAR, CONNECTION_STATISTICS_TYPE_TOTAL_RECEIVED_DATA, &amp; total_received_size);
// Handle statistics
 
long long total_sent_size;
error_code = connection_get_statistics(connection, CONNECTION_TYPE_CELLULAR, CONNECTION_STATISTICS_TYPE_TOTAL_SENT_DATA, &amp; total_sent_size);
// Handle statistics
 
error_code = connection_get_statistics(connection, CONNECTION_TYPE_WIFI, CONNECTION_STATISTICS_TYPE_LAST_RECEIVED_DATA, &amp; last_received_size);
// Handle statistics
 
error_code = connection_get_statistics(connection, CONNECTION_TYPE_WIFI, CONNECTION_STATISTICS_TYPE_LAST_SENT_DATA, &amp; last_sent_size);
// Handle statistics
 
error_code = connection_get_statistics(connection, CONNECTION_TYPE_WIFI, CONNECTION_STATISTICS_TYPE_TOTAL_RECEIVED_DATA, &amp; total_received_size);
// Handle statistics
 
error_code = connection_get_statistics(connection, CONNECTION_TYPE_WIFI, CONNECTION_STATISTICS_TYPE_TOTAL_SENT_DATA, &amp; total_sent_size);
// Handle statistics</pre></li></ol>

 <h2 id="register" name="register">Registering the Property Change Callback</h2>

<p>To register callback functions that are called when information changes:</p>

<ol><li>Define callback functions.

<p>In this tutorial, the callbacks registered are the <span style="font-family: Courier New,Courier,monospace;">__ip_changed_cb()</span> and <span style="font-family: Courier New,Courier,monospace;">__proxy_changed_cb()</span> functions, used for address changes. In case of an address change, an information message is printed in the file (or shown to the user in another way). The message contains information on which address has been changed and what the new value is.</p>

<pre class="prettyprint">static void __ip_changed_cb(const char* ipv4_address, const char* ipv6_address, void* user_data) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;%s callback, IPv4 address : %s, IPv6 address : %s&quot;, (char *)user_data, ipv4_address, (ipv6_address ? ipv6_address : &quot;NULL&quot;));
}
 
static void __proxy_changed_cb(const char* ipv4_address, const char* ipv6_address, void* user_data) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;%s callback, IPv4 address : %s, IPv6 address : %s&quot;, (char *)user_data, ipv4_address, (ipv6_address ? ipv6_address : &quot;NULL&quot;));
}
</pre></li>

<li>Register the defined callback functions.

<p>You have to register the previously defined callback functions. The <span style="font-family: Courier New,Courier,monospace;">connection_set_ip_address_changed_cb()</span> and <span style="font-family: Courier New,Courier,monospace;">connection_set_proxy_address_changed_cb()</span> functions are used to register the <span style="font-family: Courier New,Courier,monospace;">__ip_changed_cb()</span> and <span style="font-family: Courier New,Courier,monospace;">__proxy_changed_cb()</span> functions called when the IP address or the proxy address is changed, respectively. The last parameter (<span style="font-family: Courier New,Courier,monospace;">user_data</span>) is set to a message which is printed in the callback.</p>

<pre class="prettyprint">error_code = connection_set_ip_address_changed_cb(connection, __ip_changed_cb, &quot;IP addr changed:&quot;);
if (error_code != CONNECTION_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling
}
error_code = connection_set_proxy_address_changed_cb(connection, __proxy_changed_cb, &quot;Proxy IP addr changed:&quot;);
if (error_code != CONNECTION_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre></li>

<li>Unregister the callback functions.

<p>When the callback functions are not needed any more, unregister them using the <span style="font-family: Courier New,Courier,monospace;">connection_unset_network_state_changed_cb()</span> function.</p>

<pre class="prettyprint">error_code = connection_unset_ip_address_changed_cb(connection);
if (error_code != CONNECTION_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling
}
  
error_code = connection_unset_proxy_address_changed_cb(connection);
if (error_code != CONNECTION_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre></li></ol>

<h2 id="socket_init" name="socket_init">Initializing a Socket</h2>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">Before executing an application that uses socket connections, add a smack policy. For example:
	 <p><span style="font-family: Courier New,Courier,monospace;">chsmack -e connman &lt;Application executable path&gt;</span></p>
</td> 
    </tr> 
   </tbody> 
  </table>

<p>To initialize a socket for use:</p>
<ol>
<li>Declare the necessary variables:
<pre class="prettyprint">
int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;int rv = 0;
&nbsp;&nbsp;&nbsp;int ip_type = -1;
&nbsp;&nbsp;&nbsp;char user_url[100] = {0,};
&nbsp;&nbsp;&nbsp;char user_port[10] = {0,};
&nbsp;&nbsp;&nbsp;char user_msg[200] = {0,};
&nbsp;&nbsp;&nbsp;char *local_ipv4 = NULL;
&nbsp;&nbsp;&nbsp;char *local_ipv6 = NULL;
&nbsp;&nbsp;&nbsp;char *interface_name = NULL;

&nbsp;&nbsp;&nbsp;connection_type_e net_state;
&nbsp;&nbsp;&nbsp;connection_h connection = NULL;
&nbsp;&nbsp;&nbsp;connection_profile_h profile_h = NULL;

&nbsp;&nbsp;&nbsp;// Input the URL and message to be sent
</pre></li>
<li>Include the required header files and <a href="#init">create a connection handle</a>.
</li>
<li>Check whether the default connection is available:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;connection_type_e net_state;

&nbsp;&nbsp;&nbsp;rv = connection_get_type(connection, &amp;net_state);
&nbsp;&nbsp;&nbsp;if (rv != CONNECTION_ERROR_NONE || net_state == CONNECTION_TYPE_DISCONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Not connected %d\n&quot;, rv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection_destroy(connection);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}
</pre>
</li>
<li>Check the address type of the default connection. 
<p>The address type can be IPv4 or IPv6.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;int ip_type = -1;
&nbsp;&nbsp;&nbsp;char *local_ipv4 = NULL;
&nbsp;&nbsp;&nbsp;char *local_ipv6 = NULL;
&nbsp;&nbsp;&nbsp;connection_profile_h profile_h = NULL;

&nbsp;&nbsp;&nbsp;rv = connection_get_current_profile(connection, &amp;profile_h);
&nbsp;&nbsp;&nbsp;if (rv != CONNECTION_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Fail to get profile handle %d\n&quot;, rv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection_destroy(connection);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;rv = connection_profile_get_ip_address(profile_h, CONNECTION_ADDRESS_FAMILY_IPV6, &amp;local_ipv6);
&nbsp;&nbsp;&nbsp;if (rv == CONNECTION_ERROR_NONE &amp;&amp; g_strcmp0(local_ipv6, &quot;::&quot;) != 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_type = CONNECTION_ADDRESS_FAMILY_IPV6;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;IPv6 address : %s\n&quot;, local_ipv6);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// If both IPv4 and IPv6 types are set, the IPv4 type is used as default here
&nbsp;&nbsp;&nbsp;rv = connection_profile_get_ip_address(profile_h, CONNECTION_ADDRESS_FAMILY_IPV4, &amp;local_ipv4);
&nbsp;&nbsp;&nbsp;if (rv == CONNECTION_ERROR_NONE &amp;&amp; g_strcmp0(local_ipv4, &amp;0.0.0.0&amp;) != 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_type = CONNECTION_ADDRESS_FAMILY_IPV4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;IPv4 address : %s\n&quot;, local_ipv4);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (ip_type != CONNECTION_ADDRESS_FAMILY_IPV6 &amp;&amp; ip_type != CONNECTION_ADDRESS_FAMILY_IPV4) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;No IP address!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto done;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;connection_profile_get_network_interface_name(profile_h, &amp;interface_name);
&nbsp;&nbsp;&nbsp;printf(&quot;Interface Name:%s\n&quot;, interface_name);
}
</pre>
</li>
</ol>

<h2 id="socket_family" name="socket_family">Retrieving the Address Family</h2>

<p>To get the IP addresses for the hostname to connect:</p>
<ol>
<li>Define the user URL and the message to be sent:
<pre class="prettyprint">
int main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;// Initialize the socket

&nbsp;&nbsp;&nbsp;printf(&quot;Enter the URL and Port: &quot;);
&nbsp;&nbsp;&nbsp;rv = scanf(&quot;%s %s&quot;, user_url, user_port);

&nbsp;&nbsp;&nbsp;if (rv &lt;= 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;scanf() fail %d\n&quot;, rv);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;printf(&quot;Enter the message to send : &quot;);
&nbsp;&nbsp;&nbsp;rv = scanf(&quot;%s&quot;, user_msg);

&nbsp;&nbsp;&nbsp;if (rv &lt;= 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;scanf() fail %d\n&quot;, rv);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}
</pre>
</li>
<li>Retrieve the IP addresses:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;struct sockaddr_in6 *addr6;
&nbsp;&nbsp;&nbsp;struct addrinfo hints;
&nbsp;&nbsp;&nbsp;struct addrinfo *result;
&nbsp;&nbsp;&nbsp;char user_url[100] = {0,};
&nbsp;&nbsp;&nbsp;char user_port[10] = {0,};

&nbsp;&nbsp;&nbsp;memset(&amp;hints, 0x00, sizeof(struct addrinfo));

&nbsp;&nbsp;&nbsp;hints.ai_family = PF_UNSPEC;
&nbsp;&nbsp;&nbsp;hints.ai_socktype = SOCK_STREAM;
&nbsp;&nbsp;&nbsp;hints.ai_protocol = IPPROTO_TCP;

&nbsp;&nbsp;&nbsp;if (getaddrinfo(user_url, user_port, &amp;hints, &amp;result) != 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;getaddrinfo() error\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto done;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ol>

<h2 id="socket_create" name="socket_create">Creating the Socket and Managing the Remote Host Connection</h2>

<p>To create the socket and connect to a remote host:</p>
<ol>
<li>Find the proper address family and create the socket: 
<pre class="prettyprint">
int sockfd = -1;
struct addrinfo *rp;

rp = result;

for (rp = result; rp != NULL; rp = rp-&gt;ai_next) 
{
&nbsp;&nbsp;&nbsp;if (rp-&gt;ai_family == AF_INET &amp;&amp; ip_type == CONNECTION_ADDRESS_FAMILY_IPV4) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &gt; 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;socket error\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto done;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;IPv4\n&quot;);

&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (rp-&gt;ai_family == AF_INET6 &amp;&amp; ip_type == CONNECTION_ADDRESS_FAMILY_IPV6) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((sockfd = socket(AF_INET6, SOCK_STREAM, 0)) &lt; 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;socket error\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto done;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("IPv6\n");
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>Connect to the remote host:
<ul>
<li>Use the IPv4 socket: 
<pre class="prettyprint">
if (connect(sockfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) &lt; 0) 
{
&nbsp;&nbsp;&nbsp;printf(&quot;connect() error: %s\n&quot;, strerror(errno));
&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;close(sockfd);
&nbsp;&nbsp;&nbsp;goto done;
}
</pre>
</li>
<li>Use the IPv6 socket.
<p>The interface index is needed for the IPv6 connection.</p>
<pre class="prettyprint">
char *interface_name = NULL;

connection_profile_get_network_interface_name(profile_h, &amp;interface_name);
printf(&quot;Interface Name:%s\n&quot;, interface_name);

addr6 = (struct sockaddr_in6 *)rp-&gt;ai_addr;
addr6-&gt;sin6_scope_id = if_nametoindex(interface_name);

if ((sockfd = connect(sockfd, (struct sockaddr *)addr6, rp-&gt;ai_addrlen)) &lt; 0) 
{
&nbsp;&nbsp;&nbsp;printf(&quot;connect() error: %s\n&quot;, strerror(errno));
&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;close(sockfd);
&nbsp;&nbsp;&nbsp;goto done;
}
</pre>
</li>
</ul>
</li>
<li>Manage messages:
<ul><li>Send a message to the remote host:
<pre class="prettyprint">
if ((count = write(sockfd, user_msg, 200)) &lt; 0) 
{
&nbsp;&nbsp;&nbsp;printf(&quot;write() error: %s\n&quot;, strerror(errno));

&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;close(sockfd);

&nbsp;&nbsp;&nbsp;goto done;
}
printf(&quot;Sent count: %d, msg: %s\n&quot;, count, user_msg);
</pre>
</li>
<li>Read a message from the remote host:
<pre class="prettyprint">
char buf[257];
memset(buf, 0x00, 257);

if ((count = read(sockfd, buf, 256)) &lt; 0) 
{
&nbsp;&nbsp;&nbsp;printf(&quot;read() error: %s\n&quot;, strerror(errno));

&nbsp;&nbsp;&nbsp;freeaddrinfo(result);
&nbsp;&nbsp;&nbsp;close(sockfd);

&nbsp;&nbsp;&nbsp;goto done;
}
buf[count] = &#39;\0&#39;;
printf(&quot;\nRead: %s\n&quot;, buf);
</pre>
</li></ul></li>
<li>Close the socket and release the resources: 
<pre class="prettyprint">
freeaddrinfo(result);
close(sockfd);

done:
&nbsp;&nbsp;&nbsp;connection_profile_destroy(profile_h);
&nbsp;&nbsp;&nbsp;connection_destroy(connection);

&nbsp;&nbsp;&nbsp;g_free(local_ipv6);
&nbsp;&nbsp;&nbsp;g_free(local_ipv4);
&nbsp;&nbsp;&nbsp;g_free(interface_name);

&nbsp;&nbsp;&nbsp;return 0;
</pre>
</li>
</ol>


<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

 </body>
</html>
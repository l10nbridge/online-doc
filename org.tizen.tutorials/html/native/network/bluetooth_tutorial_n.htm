<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Bluetooth: Managing Bluetooth Devices</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a class="opensection" href="#init">Initializing Bluetooth</a></li>
			<li><a class="opensection" href="#enable">Enabling and Disabling Bluetooth</a></li>
			<li><a class="opensection" href="#state">Initializing Bluetooth and Checking the Adapter State</a></li>
			<li><a class="opensection" href="#find">Finding Other Devices</a></li>
			<li>Serial Port Profile (SPP)
			<ul class="toc">
			<li><a class="opensection" href="#connect">Connecting to Other Devices Using SPP</a></li>
			<li><a class="opensection" href="#exchange">Exchanging Data Using SPP</a></li>
			<li><a class="opensection" href="#disconnect">Disconnecting from the Connected Device Using SPP</a></li>
			</ul></li>
			<li>Object Push Profile (OPP)
			<ul class="toc"><li><a class="opensection" href="#exc">Exchanging Data Using OPP</a></li>
			</ul></li>
			<li><a class="opensection" href="#release">Releasing All Resources</a></li>
		</ul>       
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/network/bluetooth_n.htm">Bluetooth Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth API</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Bluetooth: Managing Bluetooth Devices</h1>
  <div class="cont"><div class="static-cont">	
  
<p>This tutorial demonstrates how you can use Bluetooth connections.</p>

 <h2>Warm-up</h2>
 <p>Become familiar with the Bluetooth API basics by learning about:</p>
			<ul>
				<li><a class="opensection" href="#init">Initializing Bluetooth</a>
				<p>Initialize Bluetooth for use.</p></li>
				<li><a class="opensection" href="#enable">Enabling and Disabling Bluetooth</a>
				<p>Enable or disable Bluetooth. </p></li>
				<li><a class="opensection" href="#state">Initializing Bluetooth and Checking the Adapter State</a>
				<p>Initialize Bluetooth and check the Bluetooth adapter state.</p></li>
				<li><a class="opensection" href="#find">Finding Other Devices</a>
				<p>Find other devices using Bluetooth.</p></li>
				<li>Serial Port Profile (SPP)
				<ul>
				<li><a class="opensection" href="#connect">Connecting to Other Devices Using SPP</a>
				<p>Connect to other devices through SPP.</p></li>
				<li><a class="opensection" href="#exchange">Exchanging Data Using SPP</a>
				<p>Exchange data between devices through SPP.</p></li>
				<li><a class="opensection" href="#disconnect">Disconnecting from the Connected Device Using SPP</a>
				<p>Disconnect from the connected devices.</p></li>
				</ul></li>
				<li>Object Push Profile (OPP)
				<ul><li><a class="opensection" href="#exc">Exchanging Data Using OPP</a>
				<p>Exchange data between devices through OPP.</p></li>
				</ul></li>
				<li><a class="opensection" href="#release">Releasing All Resources</a>
				<p>Release all resources related to using the Bluetooth connection.</p></li>
			</ul>		

<div class="devicespecs-util mt5 clfix">
		<ul class="dutil">
			<li><a href="#" class="showA">Show All</a></li>
			<li class="none"><a href="#" class="hideA">Hide All</a></li>
		</ul>
	</div>

		<ul class="devicespecifications">
		<li>
			<div class="devicespec-tit">
 <h2 id="init" name="init" class="items-tit-h2">Initializing Bluetooth</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
			
<p>To initialize Bluetooth:</p>
<ol>
<li>			
<p>To use the functions and data types of the <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth</a> API, include the <span style="font-family: Courier New,Courier,monospace">&lt;bluetooth.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
</pre></li>				
<li>			
<p>Initialize Bluetooth:</p>
<pre class="prettyprint">
#include &lt;dlog.h&gt;

bt_error_e ret;

ret = bt_initialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_initialize] Failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}</pre></li></ol>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="enable" name="enable" class="items-tit-h2">Enabling and Disabling Bluetooth</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
			
<p>To enable or disable Bluetooth:</p>
			
<p>No Bluetooth API is provided to enable or disable Bluetooth. Use the Bluetooth ON/OFF application illustrated in the following figure (off screen on the left and on screen on the right).</p>

    <p class="figure">Figure: Bluetooth ON/OFF application</p> 
  <p style="text-align:center;"><img alt="Bluetooth ON/OFF application" src="../../images/bluetooth_onoff.png" /></p> 

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int bt_onoff_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service,  &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service,  &quot;application/x-bluetooth-on-off&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}</pre>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="state" name="state" class="items-tit-h2">Initializing Bluetooth and Checking the Adapter State</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To communicate with other devices using Bluetooth, learn how to check the Bluetooth adapter state:</p>

<ol><li>Check, whether the Bluetooth adapter is enabled on your device:
<pre class="prettyprint">bt_adapter_state_e adapter_state;
 
// Check whether the Bluetooth Service is enabled
ret = bt_adapter_get_state(&amp;adapter_state);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_get_state] Failed&quot;);

&nbsp;&nbsp;&nbsp;return;
}
// If the Bluetooth Service is not enabled
if (adapter_state == BT_ADAPTER_DISABLED) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Bluetooth adapter is not enabled. You should enable Bluetooth!!&quot;);
}</pre>
<p>Register the Bluetooth state change callback function in order to receive information about Bluetooth state changes.</p></li>

<li>Define and register the Bluetooth adapter state callback function to get notified when the Bluetooth adapter has enabled or disabled:
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
#include &lt;dlog.h&gt; 

bt_error_e ret;

void adapter_state_changed_cb(int result, bt_adapter_state_e adapter_state, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_state_changed_cb] Failed! result=%d&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (adapter_state == BT_ADAPTER_ENABLED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is enabled!&quot;);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get information about Bluetooth adapter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_address = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_address(&amp;local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter address: %s.&quot;, local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_address)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_address); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_name(&amp;local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter name: %s.&quot;, local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_name)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_name); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Visibility mode of the Bluetooth device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_visibility_mode_e mode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Duration until the visibility mode is changed so that other devices cannot find your device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int duration = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_visibility(&amp;mode, &amp;duration);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (mode) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: NON_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: GENERAL_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_LIMITED_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: LIMITED_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is disabled!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// When you try to get device information
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by invoking bt_adapter_get_name(), bt_adapter_get_address(), or bt_adapter_get_visibility(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// BT_ERROR_NOT_ENABLED will occur
&nbsp;&nbsp;&nbsp;}
}
ret = bt_adapter_set_state_changed_cb(adapter_state_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_state_changed_cb()] Failed.&quot;);
}
</pre></li>
</ol>

	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="find" name="find" class="items-tit-h2">Finding Other Devices</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To find remote Bluetooth devices either through device discovery or querying bonded devices:</p>

<h3>Defining and Registering the Discovery State Callback Function</h3>
<p>Discovering available Bluetooth-enabled devices is the first step to communicating with remote devices. There are 2 types of Bluetooth devices: classic Bluetooth devices and Bluetooth LE devices. Both device types use their own APIs to discover devices of the same type.</p>
<p>Define a callback with the following function signature to get information about a specific device type:</p>
<pre class="prettyprint">typedef void(* bt_adapter_device_discovery_state_changed_cb)(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_state_e discovery_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s *discovery_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data);
typedef void (*bt_adapter_le_device_discovery_state_changed_cb)(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_state_e discovery_state,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_info_s *discovery_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data);
</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">result</span>, specifies the result of the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_start_device_discover()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_stop_device_discovery()</span> function in classic Bluetooth, or the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_start_discover_device()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_device_discovery()</span> function in Bluetooth LE.</p>

<p>This discovery start functions for the 2 types are declared as follows:</p>
<pre class="prettyprint">// Classic Bluetooth
int bt_adapter_start_device_discovery(void);
int bt_adapter_stop_device_discovery(void);

// Bluetooth LE
int bt_adapter_le_start_device_discovery(void);
int bt_adapter_le_stop_device_discovery(void);
</pre>
 
<p>If discovering Bluetooth succeeds, you will receive the <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_NONE</span> result as the first parameter in your <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_changed_cb()</span> (classic Bluetooth)  or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_changed_cb()</span> (Bluetooth LE) callback function. If your device did not start to discover devices due to an error, then the result code will be <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_TIMEOUT</span>.</p>
<p>If stopping the discovery succeeds, you can also receive <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_CANCELLED</span>.</p>

<p>The values in <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_e</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_e</span> (Bluetooth LE) are as follows:</p>

<table> 
   <caption>
     Table: Discovery states 
   </caption> 
   <tbody> 
    <tr> 
     <th>Discovery state</th> 
     <th>Description</th> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span></td> 
     <td>When discovery is started</td> 
    </tr> 
     <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_FINISHED</span></td> 
     <td>When discovery is finished</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span></td> 
     <td>When a device is found</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span></td> 
     <td>When LE discovery is started</td> 
    </tr> 
     <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_FINISHED</span></td> 
     <td>When LE discovery is finished</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span></td> 
     <td>When an LE device is found</td> 
    </tr> 	
   </tbody> 
  </table>
	
	
	
<p>When your implemented callback function is first called, the second parameter, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span>, is <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>. This indicates that device discovery has begun.</p>
<p>Each time you find a remote Bluetooth device, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span> will be in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span> state.</p>
<p>At the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span> state, you can get some information about a discovered device, such as the device MAC address, name, class, rssi (received signal strength indicator), and bonding state. Using this information, you can connect to the discovered device.</p>
<p><span style="font-family: Courier New,Courier,monospace;">discovery_info</span> is a NULL value in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FINISHED</span>, or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FINISHED</span> state.</p>
<p>An example implementation for classic Bluetooth (Bluetooth LE usage is the same):</p>
<pre class="prettyprint">#include &lt;glib.h&gt; // For GList
void adapter_device_discovery_state_changed_cb(int result, bt_adapter_device_discovery_state_e discovery_state, bt_adapter_device_discovery_info_s *discovery_info, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_device_discovery_state_changed_cb] Failed! result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;GList** searched_device_list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;switch (discovery_state) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_STARTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_STARTED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FINISHED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FINISHED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FOUND:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FOUND&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discovery_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Address: %s&quot;, discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Name is: %s&quot;, discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s * new_device_info = malloc(sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_device_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_device_info, discovery_info, sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_address = strdup(discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_name = strdup(discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searched_device_list = g_list_append(*searched_device_list, (gpointer)new_device_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}</pre>

<p>Register the callback for classic Bluetooth (Bluetooth LE usage is the same):</p>
<pre class="prettyprint">GList *devices_list = NULL;
ret = bt_adapter_set_device_discovery_state_changed_cb(
adapter_device_discovery_state_changed_cb, (void*)&amp;devices_list);

if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_device_discovery_state_changed_cb] Failed.&quot;);
}</pre>

<h3>Finding Other Bluetooth Devices</h3>
<p>If you want to stop the device discovery, call <span style="font-family: Courier New,Courier,monospace;">bt_adapter_stop_device_discovery()</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_device_discovery()</span> (Bluetooth LE).</p>
<p>A remote Bluetooth device will respond to the request if it is enabled and in a discovery mode. Classic Bluetooth and Bluetooth LE usages are the same.</p>
<pre class="prettyprint">
// Classic Bluetooth
ret = bt_adapter_start_discover_device(type);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_start_discover_device] Failed.&quot;);
}</pre>

<h3>Enabling Discovery</h3>
<p>For other devices to find your device, your device must be discoverable.</p>
<p>To check the current visibility of your device, do the following:</p>
<pre class="prettyprint">
// Visibility mode of the Bluetooth device
bt_adapter_visibility_mode_e mode;
// Duration until the visibility mode is changed so that other devices cannot find your device
int duration = 1;
bt_adapter_get_visibility(&amp;mode, &amp;duration);
if (mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is not discoverable.&quot;);
} 
else if (mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable. No time limit.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable for a set period of time.&quot;);
}</pre>

<p>To change the visibility mode, use the Bluetooth visibility setting application (shown below with the initial screen on the left and the visibility setting screen on the right).</p>

<p style="text-align:center;"><img alt="Bluetooth visibility setting application" src="../../images/bluetooth_visibility.png" /></p>

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int bt_set_visibility_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service,  &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service,  &quot;application/x-bluetooth-visibility&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}</pre>

<p>If you want to get a notification when the visibility is changed after 90 seconds, you must implement the following callback and register it.</p>
<pre class="prettyprint">typedef void(* bt_adapter_visibility_mode_changed_cb)(int result, bt_adapter_visibility_mode_e visibility_mode, void *user_data)</pre>
<p>An example implementation:</p>
<pre class="prettyprint">void adapter_visibility_mode_changed_cb(int result, bt_adapter_visibility_mode_e visibility_mode, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] None discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] General discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] Limited discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;}
}</pre>
<p>Register the callback:</p>
<pre class="prettyprint">ret = bt_adapter_set_visibility_mode_changed_cb(adapter_visibility_mode_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_visibility_mode_changed_cb] Failed.&quot;);
}</pre>

<h3>Querying Bonded Devices</h3>
<p>Before trying to find the remote devices nearby, you can query the list of bonded devices to get the basic information (such as device address and name) your device has stored for the bonded devices. In order to get all bonded devices, call <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span>. You can get information about bonded devices in <span style="font-family: Courier New,Courier,monospace;">bt_adapter_bonded_device_cb()</span>, which you need to call for each bonded device.</p>
<p><span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> is declared as follows:</p>
<pre class="prettyprint">int bt_adapter_foreach_bonded_device(bt_adapter_bonded_device_cb foreach_cb, void *user_data)</pre>
<p>The callback function is declared as follows:</p>
<pre class="prettyprint">typedef bool(* bt_adapter_bonded_device_cb)(bt_device_info_s *device_info, void *user_data)</pre>
<p>You can get information (such as the device name, service list, and Mac address) about the bonded device.</p>
<p>To continue performing iterations, your implemented callback function must return <span style="font-family: Courier New,Courier,monospace;">true</span>. Otherwise, it returns <span style="font-family: Courier New,Courier,monospace;">false</span> and stops performing additional iterations.</p>
<p>The following code sample describes how to query bonded devices and how to discover a desired device.</p>
<pre class="prettyprint">// Server address for connecting
char *bt_server_address = NULL;
const char *remote_server_name = &quot;server device&quot;;
 
bool adapter_bonded_device_cb(bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (device_info == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (!strcmp(device_info-&gt;remote_name, (char*)user_data)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The server device is found in bonded device list. address(%s)&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_server_address = strdup(device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If you want to stop iterating, you can return &quot;false&quot;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;// Get information about bonded device
&nbsp;&nbsp;&nbsp;int count_of_bonded_device = 1;
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Get information about the bonded device(%d)&quot;, count_of_bonded_device);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote address = %s.&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote name = %s.&quot;, device_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service count = %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bonded?? %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;connected?? %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;authorized?? %d.&quot;, device_info-&gt;is_authorized);
 
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_device_class %d.&quot;, device_info-&gt;bt_class.major_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;minor_device_class %d.&quot;, device_info-&gt;bt_class.minor_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_service_class_mask %d.&quot;, device_info-&gt;bt_class.major_service_class_mask);
&nbsp;&nbsp;&nbsp;count_of_bonded_device++;
&nbsp;&nbsp;&nbsp;// Keep iterating
&nbsp;&nbsp;&nbsp;return true;
}

ret = bt_adapter_foreach_bonded_device(adapter_bonded_device_cb, remote_server_name);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_foreach_bonded_device] Failed!&quot;);
}

if (bt_server_address != NULL)
&nbsp;&nbsp;&nbsp;free(bt_server_address);
</pre>

<h3>Requesting Bonding with a Remote Bluetooth Device</h3>
<p>You already got information about a remote device through device discovery or querying a bonded device. You can request to bond with that device using the <span style="font-family: Courier New,Courier,monospace;">bt_device_create_bond()</span> function. If you want to cancel bonding, call <span style="font-family: Courier New,Courier,monospace;">bt_device_cancel_bonding()</span>.</p>
<p>To get notified when the bonding has finished, register a <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function using the <span style="font-family: Courier New,Courier,monospace;">bt_device_set_bond_created_cb()</span> function. From this callback, you can get the service list that the remote Bluetooth device provides and the service uuid from that service list.</p>
<p>The example below shows how to implement a <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function and bond with a remote Bluetooth device.</p>

<pre class="prettyprint">void device_bond_created_cb(int result, bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_bond_created_cb] Failed. result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (device_info != NULL &amp;&amp; !strcmp(device_info-&gt;remote_address, remote_server_address)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: A bond with chat_server is created.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: The number of service - %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_bonded - %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_connected - %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Callback: A bond with another device is created.&quot;);
&nbsp;&nbsp;&nbsp;}
}

// You can get bt_server_address from bt_adapter_bonded_device_cb() or bt_device_service_searched_cb()
// device_info-&gt;remote_address in bt_adapter_bonded_device_cb()
// sdp_info-&gt;remote_address in bt_device_service_searched_cb()
 
ret = bt_device_set_bond_created_cb(device_bond_created_cb, bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_set_bond_created_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_device_create_bond(bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_create_bond] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_device_create_bond] succeeded. device_bond_created_cb callback will be called.&quot;);
}</pre>
<p>After that, the remote device is included in the bonded device list. So next time you do not need to find it again. Without finding, you can get information (such as address and name) by querying the bonded device.</p>
<p>You can verify the bonding by calling the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> function.</p>
<p>If you want to remove the device from the bonded list, call the <span style="font-family: Courier New,Courier,monospace;">bt_device_destroy_bond()</span> function.</p>

	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="connect" name="connect" class="items-tit-h2">Connecting to Other Devices Using SPP</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
			
<p>To connect to other devices:</p>			
<h3>Connecting as a Server</h3>
<p>If you want your device to work as a server, establish a connection using an RFCOMM socket.</p>
<p>To establish a connection, create a RFCOMM Bluetooth socket using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function. It has the following signature:</p>
<pre class="prettyprint">int bt_socket_create_rfcomm(const char *port_uuid, int *socket_fd)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">port_uuid</span>, uniquely identifies which service to provide. It is the UUID of the service. This UUID must match for the connection to be accepted. The second parameter, <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, is the RFCOMM socket ID as an output parameter.</p>
<p>The example below shows how to make an rfcomm socket with the Bluetooth API.</p>
<pre class="prettyprint">const char* my_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
int server_socket_fd = -1;
bt_error_e ret;
 
ret = bt_socket_create_rfcomm(my_uuid, &amp;server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_socket_create_rfcomm() failed.&quot;);
}</pre>
<p>To listen for an incoming connection, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_listen_and_accept_rfcomm()</span> function.</p>
<p>This function is declared as follows:</p>
<pre class="prettyprint">int bt_socket_listen_and_accept_rfcomm(int socket_fd, int max_pending_connections)</pre>

<ul class="ul"><li><span style="font-family: Courier New,Courier,monospace;">int socket_fd</span>: socket fd passed from <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span>, which starts listening</li>
<li><span style="font-family: Courier New,Courier,monospace;">int max_pending_connections</span>: maximum number of pending connections that a Bluetooth server can store</li></ul>


<p>You can be notified about which device connects to your device by using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function.</p>

<p>The callback function is declared as follows:</p>
<pre class="prettyprint">typedef void (* bt_socket_connection_state_changed_cb) (int result, bt_socket_connection_state_e connection_state, bt_socket_connection_s *connection, void *user_data)</pre>

<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">result</span>, is the change in the connection state. The second parameter, <span style="font-family: Courier New,Courier,monospace;">connection_state</span>, is the connection state, itself, either <span style="font-family: Courier New,Courier,monospace;">BT_SOCKET_CONNECTED</span> or <span style="font-family: Courier New,Courier,monospace;">BT_SOCKET_DISCONNECTED</span>. The third parameter is the pointer to the structure <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s</span>, which can specify an RFCOMM Bluetooth socket. The <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s</span> structure contains <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, role (client or server), and the opposite Bluetooth device&#39;s MAC address. The fourth parameter, <span style="font-family: Courier New,Courier,monospace;">user_data</span>, is user-defined data.</p>

<p>The example below shows how to implement a callback function and start listening for Bluetooth client devices.</p>
<pre class="prettyprint">void socket_connection_state_changed(int result, bt_socket_connection_state_e connection_state, bt_socket_connection_s *connection, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[socket_connection_state_changed_cb] Failed. result =%d.&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (connection_state == BT_SOCKET_CONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Connected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of connection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Role of connection - %d.&quot;, connection-&gt;local_role);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// socket_fd is used for sending data and disconnecting a device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_socket_fd = connection-&gt;socket_fd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Disconnected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of disconnection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
 
bt_error_e ret;
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_socket_listen_and_accept_rfcomm(server_socket_fd, 5);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
&nbsp;&nbsp;&nbsp;// Waiting for incoming connections
}</pre>
<p>If you do not want to accept any other connections or provide a service, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> function.</p>

<h3>Connecting as a Client</h3>
<p>Set up the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function that is called when your device is connected to a Bluetooth server device.</p>


  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">When you connect to a Bluetooth server device, keep the server socket fd from <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s-&gt;socket_fd</span> in <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span>.</td>
    </tr> 
   </tbody> 
  </table> 
  
<p>Request a connection to the Bluetooth server. The server socket fd is used when you send data or disconnect.</p>
<pre class="prettyprint">bt_socket_connect_rfcomm (const char *remote_address, const char *remote_port_uuid)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">remote_address</span>, is the address of the remote device. You can get this from the <span style="font-family: Courier New,Courier,monospace;">bt_device_info_s</span> structure.</p>

<p>The second parameter, <span style="font-family: Courier New,Courier,monospace;">remote_port_uuid</span>, is the UUID for the specific RFCOMM-based service on a remote device.</p>
<p>This remote_port_uuid must match the UUID used by the server device in the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function.</p>

<p>The example below shows how to connect to a specific RFCOMM-based service on a remote device.</p>

<pre class="prettyprint">const char *service_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
 
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_socket_connect_rfcomm(bt_server_address, service_uuid);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_connect_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_connect_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
}</pre>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="exchange" name="exchange" class="items-tit-h2">Exchanging Data Using SPP</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To share data between devices after establishing a connection:</p>
<ol><li><p>To write data, use the <span style="font-family: Courier New,Courier,monospace;">bt_socket_send_data()</span> function.</p>
<p>This function is declared as follows:</p>
<pre class="prettyprint">int bt_socket_send_data(int socket_fd, const char *data, int length)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, is the socket ID from the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function. The second parameter, <span style="font-family: Courier New,Courier,monospace;">data</span>, is the data to write. The third parameter, <span style="font-family: Courier New,Courier,monospace;">length</span>, is the data length.</p></li>
<li><p>To read data from other devices, you must set up the <span style="font-family: Courier New,Courier,monospace;">bt_socket_data_received_cb()</span> callback that will be invoked when your device receives data from other Bluetooth devices.</p>
<p>To register a <span style="font-family: Courier New,Courier,monospace;">bt_socket_data_received_cb()</span> callback function, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_set_data_received_cb()</span> function. The callback function is declared as follows:</p>
<pre class="prettyprint">typedef void bt_socket_data_received_cb(bt_socket_received_data_s* data, void* user_data)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">data</span>, is the pointer to the structure <span style="font-family: Courier New,Courier,monospace;">bt_socket_received_data_s</span> that can specify received data, data size, and socket fd. The second parameter, <span style="font-family: Courier New,Courier,monospace;">user_data</span>, is user data. This callback will be called whenever your device receives data from other Bluetooth devices. You can read the data in the callback.</p>

<pre class="prettyprint">bt_error_e ret;
char data[] = &quot;Sending test&quot;;
int client_socket_fd = 0;

void bt_socket_data_received_cb(bt_socket_received_data_s* data, void* user_data)
{
&nbsp;&nbsp;&nbsp;if (data == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;No received data!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Socket fd: %d&quot;, data-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Data: %s&quot;, data-&gt;data);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Size: %d&quot;, data-&gt;data_size);
}
ret = bt_socket_set_data_received_cb(bt_socket_data_received_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_data_received_cb] regist to fail.&quot;);
}
ret = bt_socket_send_data(client_socket_fd, data, sizeof(data));
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_send_data] failed.&quot;);
}</pre>

</li></ol>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="disconnect" name="disconnect" class="items-tit-h2">Disconnecting from the Connected Device Using SPP</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To disconnect from a device, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_socket_disconnect_rfcomm()</span> function:</p>

<ol><li>Disconnect the Bluetooth server:
<pre class="prettyprint">bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from output of bt_socket_create_rfcomm()
ret = bt_socket_destroy_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. socket_fd = %d&quot;, server_socket_fd);
}</pre></li>

<li>Disconnect the Bluetooth client:
<pre class="prettyprint">bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from bt_socket_connection_state_changed_cb()
ret = bt_socket_disconnect_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed. server_socket_fd = %d.&quot;, server_socket_fd);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. server_socket_fd = %d.&quot;, server_socket_fd);
}</pre></li></ol>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="exc" name="exc" class="items-tit-h2">Exchanging Data Using OPP</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 

<p>To exchange data with Object Push Profile (OPP):</p>			
			
<p>The OPP is a basic profile for sending objects, such as pictures, virtual business cards, or schedules. The sender, which is a client, always initiates the transactions (called &quot;push&quot;), not the receiver, which is a server.</p>

<h3>Server Role</h3>
<p>The API has a server role to initialize the status of an OPP server device.</p>
<pre class="prettyprint">
bt_error_e ret;

char *directory = NULL;
storage_get_directory(0, STORAGE_DIRECTORY_DOWNLOADS, &amp;directory);
void connection_requested_cb_for_opp_server(const char *remote_address, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}
ret = bt_opp_server_initialize_by_connection_request (directory, connection_requested_cb_for_opp_server, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_initialize_by_connection_request] Failed.&quot;);
}
free(directory);
</pre>
<p>This function initializes the OPP server device requested by the <span style="font-family: Courier New,Courier,monospace;">bt_opp_server_push_requested_cb()</span>. The <span style="font-family: Courier New,Courier,monospace;">bt_opp_server_connection_requested_cb</span> function is called when an OPP connection is requested.</p>

<p>When a client requests a file push, the server can accept or reject it using the following functions:</p>
<pre class="prettyprint">
bt_error_e ret;
const char file_name [18] = &quot;tempfile&quot;;

void bt_opp_server_transfer_progress_cb_for_opp(const char *file, long long size, int percent, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
}

void bt_opp_server_transfer_finished_cb_for_opp(int result, const char *file, long long size, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
}

ret = bt_opp_server_accept(bt_opp_server_transfer_progress_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_opp_server_transfer_finished_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_name, NULL, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_accept] Failed.&quot;);
}

ret = bt_opp_server_reject();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_reject] Failed.&quot;);
}
</pre>

<h3>Client Role</h3>
<p>Initialize the client using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_initialize()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;

ret = bt_opp_client_initialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
<p>You can get the information of a file that can be sent to the server device using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_add_file()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char *resource_path = NULL;
char caller_id_path[1024] = {&#39;\0&#39;, };

resource_path = app_get_resource_path();
snprintf(caller_id_path, sizeof(caller_id_path)-1, &quot;%s/image1.jpg&quot;, resource_path);
free(resource_path);

ret = bt_opp_client_add_file(caller_id_path);

if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_add_file() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
<p>You can send the files to the server using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_push_files()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char remote_addr[18] = REMOTE_DEVICE_MAC_ADDRESS;

void __bt_opp_client_push_responded_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}

void __bt_opp_client_push_progress_cb(const char *file,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long long size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int percent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, (long)size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
}
void __bt_opp_client_push_finished_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}
ret = bt_opp_client_push_files(remote_addr, __bt_opp_client_push_responded_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_progress_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_finished_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_client_push_files] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_opp_client_push_files] Succeeded.&quot;);
}
</pre>

<p>After the push is finished by the client, call the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_clear_files()</span> and <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_deinitialize()</span> to release the Bluetooth resources related to the OPP client:</p>
<pre class="prettyprint">
bt_error_e ret;

// Delete file info
ret = bt_opp_client_clear_files();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_clear_files() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}

ret = bt_opp_client_deinitialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;ERR(&quot;bt_opp_client_initialize &quot;);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize Failed.&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
	</div>
		</li>
		<li>
			<div class="devicespec-tit">
 <h2 id="release" name="release" class="items-tit-h2">Releasing All Resources</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To release all Bluetooth resources, call the <span style="font-family: Courier New,Courier,monospace;">bt_deinitialize()</span> function:</p>
<pre class="prettyprint">
// Unregister callbacks
bt_adapter_unset_state_changed_cb();
bt_adapter_unset_device_discovery_state_changed_cb();
bt_device_unset_service_searched_cb();
bt_socket_unset_data_received_cb();
bt_socket_unset_connection_state_changed_cb();
 
// Release resources

// Deinitialize Bluetooth
ret = bt_deinitialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_deinitialize] Failed.&quot;);
}</pre>

	</div>
		</li>
	
	</ul>	
</div>				
</div>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

 </body>
</html>

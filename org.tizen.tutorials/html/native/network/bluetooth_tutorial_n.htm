<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Bluetooth: Managing Bluetooth Devices</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#init">Initializing Bluetooth</a></li>
			<li><a href="#enable">Enabling and Disabling Bluetooth</a></li>
			<li><a href="#state">Initializing Bluetooth and Checking the Adapter State</a></li>
			<li><a href="#find">Finding Other Devices</a></li>
			<li>Serial Port Profile (SPP)
				<ul class="toc">
					<li><a href="#connect">Connecting to Other Devices Using SPP</a></li>
					<li><a href="#exchange">Exchanging Data Using SPP</a></li>
					<li><a href="#disconnect">Disconnecting from the Connected Device Using SPP</a></li>
				</ul>
			</li>
			<li><a href="#gatt">Performing GATT Operations</a></li>
			<li>Object Push Profile (OPP)
				<ul class="toc">
					<li><a href="#exc">Exchanging Data Using OPP</a></li>
				</ul>
			</li>
			<li>Bluetooth LE 
				<ul class="toc">
					<li><a href="#le_adapter">Enabling the Bluetooth LE Adapter and Checking its State</a></li>
					<li><a href="#le_scan">Managing Bluetooth LE Scans</a></li>
					<li><a href="#add_adv_data">Adding Advertising Data to the LE Advertisement</a></li>
					<li><a href="#set_adv_conn">Setting the Advertising Connectable Mode</a></li>
					<li><a href="#set_adv_mode">Setting the LE Advertising Mode</a></li>
					<li><a href="#start_adv">Starting Advertising</a></li>
				</ul>
			</li>		
			<li><a href="#release">Releasing All Resources</a></li>
		</ul>       
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/network/bluetooth_n.htm">Bluetooth Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Bluetooth: Managing Bluetooth Devices</h1>

  
<p>This tutorial demonstrates how you can use Bluetooth connections.</p>

 <h2>Warm-up</h2>
 <p>Become familiar with the Bluetooth API basics by learning about:</p>
			<ul>
				<li><a href="#init">Initializing Bluetooth</a>
				<p>Initialize Bluetooth for use.</p></li>
				<li><a href="#enable">Enabling and Disabling Bluetooth</a>
				<p>Enable or disable Bluetooth. </p></li>
				<li><a href="#state">Initializing Bluetooth and Checking the Adapter State</a>
				<p>Initialize Bluetooth and check the Bluetooth adapter state.</p></li>
				<li><a href="#find">Finding Other Devices</a>
				<p>Find other devices using Bluetooth.</p></li>
				<li>Serial Port Profile (SPP)
				<ul>
					<li><a href="#connect">Connecting to Other Devices Using SPP</a>
					<p>Connect to other devices through SPP.</p></li>
					<li><a href="#exchange">Exchanging Data Using SPP</a>
					<p>Exchange data between devices through SPP.</p></li>
					<li><a href="#disconnect">Disconnecting from the Connected Device Using SPP</a>
					<p>Disconnect from the connected devices.</p></li>
				</ul></li>
				<li><a href="#gatt">Performing GATT Operations</a>
				<p>Create a client to connect to a remote service, get service details, and read and set service attributes.</p></li>
				<li>Object Push Profile (OPP)
				<ul>
					<li><a href="#exc">Exchanging Data Using OPP</a>
					<p>Exchange data between devices through OPP.</p></li>
				</ul></li>
				<li>Bluetooth LE 
				<ul>
					
					<li><a href="#le_adapter">Enabling the Bluetooth LE Adapter and Checking its State</a>
					<p>Ensure that the Bluetooth LE (BLE) adapter is enabled.</p></li>
					<li><a href="#le_scan">Managing Bluetooth LE Scans</a>
					<p>Start the scan, handle the scanning results, and stop the scan.</p></li>
					<li><a href="#add_adv_data">Adding Advertising Data to the LE Advertisement</a>
					<p>Add advertising data to an LE advertisement or a scan result.</p></li>
					<li><a href="#set_adv_conn">Setting the Advertising Connectable Mode</a>
					<p>Define whether the advertising type is connectable or non-connectable.</p></li>
					<li><a href="#set_adv_mode">Setting the LE Advertising Mode</a>
					<p>Control the advertising power and latency.</p></li>
					<li><a href="#start_adv">Starting Advertising</a> 
					<p>Start advertising with the advertising parameters.</p></li>
				</ul></li>
				
				<li><a href="#release">Releasing All Resources</a>
				<p>Release all resources related to using the Bluetooth connection.</p></li>
			</ul>		

 <h2 id="init" name="init">Initializing Bluetooth</h2>
			
<p>To initialize Bluetooth:</p>
<ol>
<li>			
<p>To use the functions and data types of the Bluetooth API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;bluetooth.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
</pre></li>				
<li>			
<p>Initialize Bluetooth:</p>
<pre class="prettyprint">
#include &lt;dlog.h&gt;

bt_error_e ret;

ret = bt_initialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_initialize] Failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}</pre></li></ol>

 <h2 id="enable" name="enable">Enabling and Disabling Bluetooth</h2>
			
<p>To enable or disable Bluetooth:</p>
			
<p>No Bluetooth API is provided to enable or disable Bluetooth. Use the Bluetooth ON/OFF application illustrated in the following figure (off screen on the left and on screen on the right).</p>

  <p class="figure">Figure: Bluetooth ON/OFF application</p> 
  <p align="center"><img alt="Bluetooth ON/OFF application" src="../../images/bluetooth_onoff.png" /></p> 

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int bt_onoff_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service,  &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service,  &quot;application/x-bluetooth-on-off&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}</pre>

 <h2 id="state" name="state">Initializing Bluetooth and Checking the Adapter State</h2>

<p>To communicate with other devices using Bluetooth, learn how to check the Bluetooth adapter state:</p>

<ol><li>Check, whether the Bluetooth adapter is enabled on your device:
<pre class="prettyprint">bt_adapter_state_e adapter_state;
 
// Check whether the Bluetooth Service is enabled
ret = bt_adapter_get_state(&amp;adapter_state);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_get_state] Failed&quot;);

&nbsp;&nbsp;&nbsp;return;
}
// If the Bluetooth Service is not enabled
if (adapter_state == BT_ADAPTER_DISABLED) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Bluetooth adapter is not enabled. You should enable Bluetooth!!&quot;);
}</pre>
<p>Register the Bluetooth state change callback function in order to receive information about Bluetooth state changes.</p></li>

<li>Define and register the Bluetooth adapter state callback function to get notified when the Bluetooth adapter has enabled or disabled:
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
#include &lt;dlog.h&gt; 

bt_error_e ret;

void adapter_state_changed_cb(int result, bt_adapter_state_e adapter_state, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_state_changed_cb] Failed! result=%d&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (adapter_state == BT_ADAPTER_ENABLED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is enabled!&quot;);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get information about Bluetooth adapter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_address = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_address(&amp;local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter address: %s.&quot;, local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_address)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_address); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_name(&amp;local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter name: %s.&quot;, local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_name)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_name); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Visibility mode of the Bluetooth device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_visibility_mode_e mode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Duration until the visibility mode is changed so that other devices cannot find your device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int duration = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_visibility(&amp;mode, &amp;duration);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (mode) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: NON_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: GENERAL_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_LIMITED_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Visibility: LIMITED_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is disabled!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// When you try to get device information
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by invoking bt_adapter_get_name(), bt_adapter_get_address(), or bt_adapter_get_visibility(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// BT_ERROR_NOT_ENABLED will occur
&nbsp;&nbsp;&nbsp;}
}
ret = bt_adapter_set_state_changed_cb(adapter_state_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_state_changed_cb()] Failed.&quot;);
}
</pre></li>
</ol>

 <h2 id="find" name="find">Finding Other Devices</h2>

<p>To find remote Bluetooth devices either through device discovery or querying bonded devices:</p>

<h3>Defining and Registering the Discovery State Callback Function</h3>
<p>Discovering available Bluetooth-enabled devices is the first step to communicating with remote devices. There are 2 types of Bluetooth devices: classic Bluetooth devices and Bluetooth LE devices. Both device types use their own APIs to discover devices of the same type.</p>
<p>Define a callback with the following function signature to get information about a specific device type:</p>
<pre class="prettyprint">typedef void(* bt_adapter_device_discovery_state_changed_cb)(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_state_e discovery_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s *discovery_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data);
typedef void (*bt_adapter_le_device_discovery_state_changed_cb)(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_state_e discovery_state,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_info_s *discovery_info,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data);
</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">result</span>, specifies the result of the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_start_device_discover()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_stop_device_discovery()</span> function in classic Bluetooth, or the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_start_discover_device()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_device_discovery()</span> function in Bluetooth LE.</p>

<p>This discovery start functions for the 2 types are declared as follows:</p>
<pre class="prettyprint">// Classic Bluetooth
int bt_adapter_start_device_discovery(void);
int bt_adapter_stop_device_discovery(void);

// Bluetooth LE
int bt_adapter_le_start_device_discovery(void);
int bt_adapter_le_stop_device_discovery(void);
</pre>
 
<p>If discovering Bluetooth succeeds, you will receive the <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_NONE</span> result as the first parameter in your <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_changed_cb()</span> (classic Bluetooth)  or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_changed_cb()</span> (Bluetooth LE) callback function. If your device did not start to discover devices due to an error, then the result code will be <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_TIMEOUT</span>.</p>
<p>If stopping the discovery succeeds, you can also receive <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_CANCELLED</span>.</p>

<p>The values in <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_e</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_e</span> (Bluetooth LE) are as follows:</p>

<table> 
   <caption>
     Table: Discovery states 
   </caption> 
   <tbody> 
    <tr> 
     <th>Discovery state</th> 
     <th>Description</th> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span></td> 
     <td>When discovery is started</td> 
    </tr> 
     <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_FINISHED</span></td> 
     <td>When discovery is finished</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span></td> 
     <td>When a device is found</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span></td> 
     <td>When LE discovery is started</td> 
    </tr> 
     <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_FINISHED</span></td> 
     <td>When LE discovery is finished</td> 
    </tr> 
    <tr> 
     <td><span style="font-family: Courier New,Courier,monospace">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span></td> 
     <td>When an LE device is found</td> 
    </tr> 	
   </tbody> 
  </table>
	
	
	
<p>When your implemented callback function is first called, the second parameter, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span>, is <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>. This indicates that device discovery has begun.</p>
<p>Each time you find a remote Bluetooth device, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span> will be in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span> state.</p>
<p>At the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span> state, you can get some information about a discovered device, such as the device MAC address, name, class, rssi (received signal strength indicator), and bonding state. Using this information, you can connect to the discovered device.</p>
<p><span style="font-family: Courier New,Courier,monospace;">discovery_info</span> is a NULL value in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FINISHED</span>, or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FINISHED</span> state.</p>
<p>An example implementation for classic Bluetooth (Bluetooth LE usage is the same):</p>
<pre class="prettyprint">#include &lt;glib.h&gt; // For GList
void adapter_device_discovery_state_changed_cb(int result, bt_adapter_device_discovery_state_e discovery_state, bt_adapter_device_discovery_info_s *discovery_info, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_device_discovery_state_changed_cb] Failed! result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;GList** searched_device_list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;switch (discovery_state) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_STARTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_STARTED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FINISHED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FINISHED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FOUND:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FOUND&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discovery_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Address: %s&quot;, discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Name is: %s&quot;, discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s * new_device_info = malloc(sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_device_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_device_info, discovery_info, sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_address = strdup(discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_name = strdup(discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searched_device_list = g_list_append(*searched_device_list, (gpointer)new_device_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}</pre>

<p>Register the callback for classic Bluetooth (Bluetooth LE usage is the same):</p>
<pre class="prettyprint">GList *devices_list = NULL;
ret = bt_adapter_set_device_discovery_state_changed_cb(
adapter_device_discovery_state_changed_cb, (void*)&amp;devices_list);

if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_device_discovery_state_changed_cb] Failed.&quot;);
}</pre>

<h3>Finding Other Bluetooth Devices</h3>
<p>If you want to stop the device discovery, call <span style="font-family: Courier New,Courier,monospace;">bt_adapter_stop_device_discovery()</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_device_discovery()</span> (Bluetooth LE).</p>
<p>A remote Bluetooth device will respond to the request if it is enabled and in a discovery mode. Classic Bluetooth and Bluetooth LE usages are the same.</p>
<pre class="prettyprint">
// Classic Bluetooth
ret = bt_adapter_start_device_discovery();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_start_device_discovery] Failed.&quot;);
}</pre>

<h3>Enabling Discovery</h3>
<p>For other devices to find your device, your device must be discoverable.</p>
<p>To check the current visibility of your device, do the following:</p>
<pre class="prettyprint">
// Visibility mode of the Bluetooth device
bt_adapter_visibility_mode_e mode;
// Duration until the visibility mode is changed so that other devices cannot find your device
int duration = 1;
bt_adapter_get_visibility(&amp;mode, &amp;duration);
if (mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is not discoverable.&quot;);
} 
else if (mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable. No time limit.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable for a set period of time.&quot;);
}</pre>

<p>To change the visibility mode, use the Bluetooth visibility setting application (shown below with the initial screen on the left and the visibility setting screen on the right).</p>
<p class="figure">Figure: Bluetooth visibility setting application</p>
<p align="center"><img alt="Bluetooth visibility setting application" src="../../images/bluetooth_visibility.png" /></p>

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int bt_set_visibility_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service,  &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service,  &quot;application/x-bluetooth-visibility&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}</pre>

<p>If you want to get a notification when the visibility is changed after 90 seconds, you must implement the following callback and register it.</p>
<pre class="prettyprint">typedef void(* bt_adapter_visibility_mode_changed_cb)(int result, bt_adapter_visibility_mode_e visibility_mode, void *user_data)</pre>
<p>An example implementation:</p>
<pre class="prettyprint">void adapter_visibility_mode_changed_cb(int result, bt_adapter_visibility_mode_e visibility_mode, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] None discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] General discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] Limited discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;}
}</pre>
<p>Register the callback:</p>
<pre class="prettyprint">ret = bt_adapter_set_visibility_mode_changed_cb(adapter_visibility_mode_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_visibility_mode_changed_cb] Failed.&quot;);
}</pre>

<h3>Querying Bonded Devices</h3>
<p>Before trying to find the remote devices nearby, you can query the list of bonded devices to get the basic information (such as device address and name) your device has stored for the bonded devices. In order to get all bonded devices, call <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span>. You can get information about bonded devices in <span style="font-family: Courier New,Courier,monospace;">bt_adapter_bonded_device_cb()</span>, which you need to call for each bonded device.</p>
<p><span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> is declared as follows:</p>
<pre class="prettyprint">int bt_adapter_foreach_bonded_device(bt_adapter_bonded_device_cb foreach_cb, void *user_data)</pre>
<p>The callback function is declared as follows:</p>
<pre class="prettyprint">typedef bool(* bt_adapter_bonded_device_cb)(bt_device_info_s *device_info, void *user_data)</pre>
<p>You can get information (such as the device name, service list, and Mac address) about the bonded device.</p>
<p>To continue performing iterations, your implemented callback function must return <span style="font-family: Courier New,Courier,monospace;">true</span>. Otherwise, it returns <span style="font-family: Courier New,Courier,monospace;">false</span> and stops performing additional iterations.</p>
<p>The following code sample describes how to query bonded devices and how to discover a desired device.</p>
<pre class="prettyprint">// Server address for connecting
char *bt_server_address = NULL;
const char *remote_server_name = &quot;server device&quot;;
 
bool adapter_bonded_device_cb(bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (device_info == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (!strcmp(device_info-&gt;remote_name, (char*)user_data)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The server device is found in bonded device list. address(%s)&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_server_address = strdup(device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If you want to stop iterating, you can return &quot;false&quot;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;// Get information about bonded device
&nbsp;&nbsp;&nbsp;int count_of_bonded_device = 1;
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Get information about the bonded device(%d)&quot;, count_of_bonded_device);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote address = %s.&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote name = %s.&quot;, device_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service count = %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bonded?? %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;connected?? %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;authorized?? %d.&quot;, device_info-&gt;is_authorized);
 
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_device_class %d.&quot;, device_info-&gt;bt_class.major_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;minor_device_class %d.&quot;, device_info-&gt;bt_class.minor_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_service_class_mask %d.&quot;, device_info-&gt;bt_class.major_service_class_mask);
&nbsp;&nbsp;&nbsp;count_of_bonded_device++;
&nbsp;&nbsp;&nbsp;// Keep iterating
&nbsp;&nbsp;&nbsp;return true;
}

ret = bt_adapter_foreach_bonded_device(adapter_bonded_device_cb, remote_server_name);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_foreach_bonded_device] Failed!&quot;);
}

if (bt_server_address != NULL)
&nbsp;&nbsp;&nbsp;free(bt_server_address);
</pre>

<h3>Requesting Bonding with a Remote Bluetooth Device</h3>
<p>You already got information about a remote device through device discovery or querying a bonded device. You can request to bond with that device using the <span style="font-family: Courier New,Courier,monospace;">bt_device_create_bond()</span> function. If you want to cancel bonding, call <span style="font-family: Courier New,Courier,monospace;">bt_device_cancel_bonding()</span>.</p>
<p>To get notified when the bonding has finished, register a <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function using the <span style="font-family: Courier New,Courier,monospace;">bt_device_set_bond_created_cb()</span> function. From this callback, you can get the service list that the remote Bluetooth device provides and the service UUID from that service list.</p>
<p>The example below shows how to implement a <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function and bond with a remote Bluetooth device.</p>

<pre class="prettyprint">void device_bond_created_cb(int result, bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_bond_created_cb] Failed. result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (device_info != NULL &amp;&amp; !strcmp(device_info-&gt;remote_address, remote_server_address)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: A bond with chat_server is created.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: The number of service - %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_bonded - %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_connected - %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Callback: A bond with another device is created.&quot;);
&nbsp;&nbsp;&nbsp;}
}

// You can get bt_server_address from bt_adapter_bonded_device_cb() or bt_device_service_searched_cb()
// device_info-&gt;remote_address in bt_adapter_bonded_device_cb()
// sdp_info-&gt;remote_address in bt_device_service_searched_cb()
 
ret = bt_device_set_bond_created_cb(device_bond_created_cb, bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_set_bond_created_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_device_create_bond(bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_create_bond] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_device_create_bond] succeeded. device_bond_created_cb callback will be called.&quot;);
}</pre>
<p>After that, the remote device is included in the bonded device list. So next time you do not need to find it again. Without finding, you can get information (such as address and name) by querying the bonded device.</p>
<p>You can verify the bonding by calling the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> function.</p>
<p>If you want to remove the device from the bonded list, call the <span style="font-family: Courier New,Courier,monospace;">bt_device_destroy_bond()</span> function.</p>

 <h2 id="connect" name="connect">Connecting to Other Devices Using SPP</h2>
			
<p>To connect to other devices:</p>			
<h3>Connecting as a Server</h3>
<p>If you want your device to work as a server, establish a connection using an RFCOMM socket.</p>
<p>To establish a connection, create a RFCOMM Bluetooth socket using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function. It has the following signature:</p>
<pre class="prettyprint">int bt_socket_create_rfcomm(const char *port_uuid, int *socket_fd)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">port_uuid</span>, uniquely identifies which service to provide. It is the UUID of the service. This UUID must match for the connection to be accepted. The second parameter, <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, is the RFCOMM socket ID as an output parameter.</p>
<p>The example below shows how to make an rfcomm socket with the Bluetooth API.</p>
<pre class="prettyprint">const char* my_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
int server_socket_fd = -1;
bt_error_e ret;
 
ret = bt_socket_create_rfcomm(my_uuid, &amp;server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_socket_create_rfcomm() failed.&quot;);
}</pre>
<p>To listen for an incoming connection, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_listen_and_accept_rfcomm()</span> function.</p>
<p>This function is declared as follows:</p>
<pre class="prettyprint">int bt_socket_listen_and_accept_rfcomm(int socket_fd, int max_pending_connections)</pre>

<ul><li><span style="font-family: Courier New,Courier,monospace;">int socket_fd</span>: socket fd passed from <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span>, which starts listening</li>
<li><span style="font-family: Courier New,Courier,monospace;">int max_pending_connections</span>: maximum number of pending connections that a Bluetooth server can store</li></ul>


<p>You can be notified about which device connects to your device by using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function.</p>

<p>The callback function is declared as follows:</p>
<pre class="prettyprint">typedef void (* bt_socket_connection_state_changed_cb) (int result, bt_socket_connection_state_e connection_state, bt_socket_connection_s *connection, void *user_data)</pre>

<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">result</span>, is the change in the connection state. The second parameter, <span style="font-family: Courier New,Courier,monospace;">connection_state</span>, is the connection state, itself, either <span style="font-family: Courier New,Courier,monospace;">BT_SOCKET_CONNECTED</span> or <span style="font-family: Courier New,Courier,monospace;">BT_SOCKET_DISCONNECTED</span>. The third parameter is the pointer to the structure <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s</span>, which can specify an RFCOMM Bluetooth socket. The <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s</span> structure contains <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, role (client or server), and the opposite Bluetooth device&#39;s MAC address. The fourth parameter, <span style="font-family: Courier New,Courier,monospace;">user_data</span>, is user-defined data.</p>

<p>The example below shows how to implement a callback function and start listening for Bluetooth client devices.</p>
<pre class="prettyprint">void socket_connection_state_changed(int result, bt_socket_connection_state_e connection_state, bt_socket_connection_s *connection, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[socket_connection_state_changed_cb] Failed. result =%d.&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (connection_state == BT_SOCKET_CONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Connected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of connection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Role of connection - %d.&quot;, connection-&gt;local_role);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// socket_fd is used for sending data and disconnecting a device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_socket_fd = connection-&gt;socket_fd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Disconnected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of disconnection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
 
bt_error_e ret;
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_socket_listen_and_accept_rfcomm(server_socket_fd, 5);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
&nbsp;&nbsp;&nbsp;// Waiting for incoming connections
}</pre>
<p>If you do not want to accept any other connections or provide a service, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> function.</p>

<h3>Connecting as a Client</h3>
<p>Set up the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function that is called when your device is connected to a Bluetooth server device.</p>


  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">When you connect to a Bluetooth server device, keep the server socket fd from <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s-&gt;socket_fd</span> in <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span>.</td> 
    </tr> 
   </tbody> 
  </table> 
  
<p>Request a connection to the Bluetooth server. The server socket fd is used when you send data or disconnect.</p>
<pre class="prettyprint">bt_socket_connect_rfcomm (const char *remote_address, const char *remote_port_uuid)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">remote_address</span>, is the address of the remote device. You can get this from the <span style="font-family: Courier New,Courier,monospace;">bt_device_info_s</span> structure.</p>

<p>The second parameter, <span style="font-family: Courier New,Courier,monospace;">remote_port_uuid</span>, is the UUID for the specific RFCOMM-based service on a remote device.</p>
<p>This remote_port_uuid must match the UUID used by the server device in the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function.</p>

<p>The example below shows how to connect to a specific RFCOMM-based service on a remote device.</p>

<pre class="prettyprint">const char *service_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
 
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_socket_connect_rfcomm(bt_server_address, service_uuid);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_connect_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_connect_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
}</pre>

 <h2 id="exchange" name="exchange">Exchanging Data Using SPP</h2>

<p>To share data between devices after establishing a connection:</p>
<ol><li><p>To write data, use the <span style="font-family: Courier New,Courier,monospace;">bt_socket_send_data()</span> function.</p>
<p>This function is declared as follows:</p>
<pre class="prettyprint">int bt_socket_send_data(int socket_fd, const char *data, int length)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">socket_fd</span>, is the socket ID from the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_state_changed_cb()</span> function. The second parameter, <span style="font-family: Courier New,Courier,monospace;">data</span>, is the data to write. The third parameter, <span style="font-family: Courier New,Courier,monospace;">length</span>, is the data length.</p></li>
<li><p>To read data from other devices, you must set up the <span style="font-family: Courier New,Courier,monospace;">bt_socket_data_received_cb()</span> callback that will be invoked when your device receives data from other Bluetooth devices.</p>
<p>To register a <span style="font-family: Courier New,Courier,monospace;">bt_socket_data_received_cb()</span> callback function, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_set_data_received_cb()</span> function. The callback function is declared as follows:</p>
<pre class="prettyprint">typedef void bt_socket_data_received_cb(bt_socket_received_data_s* data, void* user_data)</pre>
<p>The first parameter, <span style="font-family: Courier New,Courier,monospace;">data</span>, is the pointer to the structure <span style="font-family: Courier New,Courier,monospace;">bt_socket_received_data_s</span> that can specify received data, data size, and socket fd. The second parameter, <span style="font-family: Courier New,Courier,monospace;">user_data</span>, is user data. This callback will be called whenever your device receives data from other Bluetooth devices. You can read the data in the callback.</p>

<pre class="prettyprint">bt_error_e ret;
char data[] = &quot;Sending test&quot;;
int client_socket_fd = 0;

void bt_socket_data_received_cb(bt_socket_received_data_s* data, void* user_data)
{
&nbsp;&nbsp;&nbsp;if (data == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;No received data!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Socket fd: %d&quot;, data-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Data: %s&quot;, data-&gt;data);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Size: %d&quot;, data-&gt;data_size);
}
ret = bt_socket_set_data_received_cb(bt_socket_data_received_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_data_received_cb] regist to fail.&quot;);
}
ret = bt_socket_send_data(client_socket_fd, data, sizeof(data));
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_send_data] failed.&quot;);
}</pre>

</li></ol>

 <h2 id="disconnect" name="disconnect">Disconnecting from the Connected Device Using SPP</h2>

<p>To disconnect from a device, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> or <span style="font-family: Courier New,Courier,monospace;">bt_socket_disconnect_rfcomm()</span> function:</p>

<ol><li>Disconnect the Bluetooth server:
<pre class="prettyprint">bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from output of bt_socket_create_rfcomm()
ret = bt_socket_destroy_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. socket_fd = %d&quot;, server_socket_fd);
}</pre></li>

<li>Disconnect the Bluetooth client:
<pre class="prettyprint">bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from bt_socket_connection_state_changed_cb()
ret = bt_socket_disconnect_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed. server_socket_fd = %d.&quot;, server_socket_fd);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. server_socket_fd = %d.&quot;, server_socket_fd);
}</pre></li></ol>

<h2 id="gatt" name="gatt">Performing GATT Operations</h2>
<p>To perform GATT operations:</p>
<ol>
<li>Register a callback for connection state changes:
<pre class="prettyprint">
int ret = 0;
// Register for GATT connection callback
void __bt_gatt_connection_state_changed_cb(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool connected, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (connected)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE connected&quot;);
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE disconnected&quot;);
}
ret = bt_gatt_set_connection_state_changed_cb(__bt_gatt_connection_state_changed_cb, NULL);
</pre></li>

<li>Create a client to connect to the remote service device:
<pre class="prettyprint">
int ret = 0;

ret = bt_gatt_client_create(remote_addr, &amp;client);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
break;
</pre>

</li>
<li>Discover the service, characteristics, and descriptors of the remote service:
<ol type="a"><li>Discover the service:
<pre class="prettyprint">
int ret = 0;

ret = bt_gatt_client_foreach_services(client,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_foreach_svc_cb, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)test_id);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;fail&quot;);
}
break;
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_svc_cb()</span> callback to initiate the service characteristics discovery:
<pre class="prettyprint">
bool __bt_gatt_client_foreach_svc_cb(int total, int index, bt_gatt_h svc_handle, void *data)
{
&nbsp;&nbsp;&nbsp;int test_id = (int)data;
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;char *str = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(svc_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid_specification_name(uuid, &amp;str);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[%d / %d] %s (%s)&quot;, index, total, str ? str : &quot;Unknown&quot;, uuid);

&nbsp;&nbsp;&nbsp;g_free(str);
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;if (test_id == BT_UNIT_TEST_FUNCTION_GATT_CLIENT_PRINT_ALL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_service_foreach_characteristics(svc_handle,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_foreach_chr_cb, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)test_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_foreach_characteristics is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_chr_cb()</span> callback to discover the characteristic descriptors:
<pre class="prettyprint">
bool __bt_gatt_client_foreach_chr_cb(int total, int index, bt_gatt_h chr_handle, void *data)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;char *str = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(chr_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid_specification_name(uuid, &amp;str);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;\t[%d / %d] %s (%s)&quot;, index, total, str ? str : &quot;Unknown&quot;, uuid);
&nbsp;&nbsp;&nbsp;__bt_gatt_client_print_value(chr_handle);

&nbsp;&nbsp;&nbsp;g_free(str);
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_characteristic_foreach_descriptors(chr_handle,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_foreach_desc_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_foreach_descriptors is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_desc_cb()</span> callback to get the descriptor data: 
<pre class="prettyprint">
bool __bt_gatt_client_foreach_desc_cb(int total, int index, bt_gatt_h desc_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;char *str = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(desc_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid_specification_name(uuid, &amp;str);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;\t\t[%d / %d] %s (%s)&quot;, index, total, str ? str : &quot;Unknown&quot;, uuid);
&nbsp;&nbsp;&nbsp;__bt_gatt_client_print_value(desc_handle);

&nbsp;&nbsp;&nbsp;g_free(str);
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>
</li>
<li>Read the value of the given attribute handle:
<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;char *svc_uuid = NULL;
&nbsp;&nbsp;&nbsp;char *chr_uuid = NULL;
&nbsp;&nbsp;&nbsp;char *desc_uuid = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h svc = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h chr = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h desc = NULL;

&nbsp;&nbsp;&nbsp;if (g_test_param.param_count &lt; 2) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Input parameters first&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;svc_uuid = g_test_param.params[0];
&nbsp;&nbsp;&nbsp;chr_uuid = g_test_param.params[1];

&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (g_test_param.param_count &gt; 2) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc_uuid = g_test_param.params[2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_characteristic_get_descriptor(chr, desc_uuid, &amp;desc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_descriptor is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_read_value(desc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_read_complete_cb, NULL);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_read_value(chr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_read_complete_cb, NULL);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_read_value is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
}
</pre> 
<p>After the reading operation is complete, use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_read_complete_cb()</span> callback to handle values:</p>
<pre class="prettyprint">
void __bt_gatt_client_read_complete_cb(int result, bt_gatt_h gatt_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;char *str = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(gatt_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid_specification_name(uuid, &amp;str);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Read %s for %s (%s)&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result == BT_ERROR_NONE ? &quot;Success&quot; : &quot;Fail&quot;, str ? str : &quot;Unknown&quot;, uuid);

&nbsp;&nbsp;&nbsp;g_free(str);
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;__bt_gatt_client_print_value(gatt_handle);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>
<li>Set a value for the given attribute handle:

<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;char *svc_uuid = NULL;
&nbsp;&nbsp;&nbsp;char *chr_uuid = NULL;
&nbsp;&nbsp;&nbsp;char *desc_uuid = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h svc = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h chr = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h desc = NULL;

&nbsp;&nbsp;&nbsp;if (g_test_param.param_count &lt; 2) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Input parameters first&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;svc_uuid = g_test_param.params[0];
&nbsp;&nbsp;&nbsp;chr_uuid = g_test_param.params[1];

&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (g_test_param.param_count &gt; 2) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc_uuid = g_test_param.params[2];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_characteristic_get_descriptor(chr, desc_uuid, &amp;desc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_descriptor is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = __bt_gatt_client_set_value(g_test_param.params[3],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_test_param.params[4], desc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_set_value is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_write_value(desc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_write_complete_cb, NULL);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = __bt_gatt_client_set_value(g_test_param.params[2], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_test_param.params[3], chr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_set_value is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_write_value(chr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_write_complete_cb, NULL);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_write_value is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
}
</pre>
<p>After the writing operation is complete, use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_write_complete_cb()</span> callback to finish the task:</p>
<pre class="prettyprint">
void __bt_gatt_client_write_complete_cb(int result, bt_gatt_h gatt_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;char *str = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(gatt_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid_specification_name(uuid, &amp;str);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Write %s for %s (%s)&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result == BT_ERROR_NONE ? &quot;Success&quot; : &quot;Fail&quot;, str ? str : &quot;Unknown&quot;, uuid);

&nbsp;&nbsp;&nbsp;g_free(str);
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>
<li>When you no longer need the client, disconnect from the remote service and destroy the client:
<pre class="prettyprint">
int ret = 0;

ret = bt_gatt_client_destroy(client);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
client = NULL;
break;
</pre></li>
</ol>


 <h2 id="exc" name="exc">Exchanging Data Using OPP</h2>

<p>To exchange data with Object Push Profile (OPP):</p>			
			
<p>The OPP is a basic profile for sending objects, such as pictures, virtual business cards, or schedules. The sender, which is a client, always initiates the transactions (called &quot;push&quot;), not the receiver, which is a server.</p>

<h3>Server Role</h3>
<p>The API has a server role to initialize the status of an OPP server device.</p>
<pre class="prettyprint">
bt_error_e ret;
char *directory = NULL;
storage_get_directory(0, STORAGE_DIRECTORY_DOWNLOADS, &amp;directory);

void connection_requested_cb_for_opp_server(const char *remote_address, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}
ret = bt_opp_server_initialize_by_connection_request(directory, connection_requested_cb_for_opp_server, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_initialize_by_connection_request] Failed.&quot;);
}
free(directory);
</pre>
<p>This function initializes the OPP server device requested by the <span style="font-family: Courier New,Courier,monospace;">bt_opp_server_push_requested_cb()</span>. The <span style="font-family: Courier New,Courier,monospace;">bt_opp_server_connection_requested_cb</span> function is called when an OPP connection is requested.</p>

<p>When a client requests a file push, the server can accept or reject it using the following functions:</p>
<pre class="prettyprint">
bt_error_e ret;
const char file_name [18] = &quot;tempfile&quot;;

void bt_opp_server_transfer_progress_cb_for_opp(const char *file, long long size, int percent, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
}

void bt_opp_server_transfer_finished_cb_for_opp(int result, const char *file, long long size, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
}

ret = bt_opp_server_accept(bt_opp_server_transfer_progress_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_opp_server_transfer_finished_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_name, NULL, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_accept] Failed.&quot;);
}

ret = bt_opp_server_reject();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_reject] Failed.&quot;);
}
</pre>

<h3>Client Role</h3>
<p>Initialize the client using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_initialize()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;

ret = bt_opp_client_initialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
<p>You can get the information of a file that can be sent to the server device using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_add_file()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char *resource_path = NULL;
char caller_id_path[1024] = {&#39;\0&#39;, };

resource_path = app_get_resource_path();
snprintf(caller_id_path, sizeof(caller_id_path)-1, &quot;%s/image1.jpg&quot;, resource_path);
free(resource_path);

ret = bt_opp_client_add_file(caller_id_path);

if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_add_file() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
<p>You can send the files to the server using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_push_files()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char remote_addr[18] = REMOTE_DEVICE_MAC_ADDRESS;

void __bt_opp_client_push_responded_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}

void __bt_opp_client_push_progress_cb(const char *file,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long long size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int percent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, (long)size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
}
void __bt_opp_client_push_finished_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}
ret = bt_opp_client_push_files(remote_addr, __bt_opp_client_push_responded_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_progress_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_finished_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_client_push_files] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_opp_client_push_files] Succeeded.&quot;);
}
</pre>

<p>After the push is finished by the client, call the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_clear_files()</span> and <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_deinitialize()</span> to release the Bluetooth resources related to the OPP client:</p>
<pre class="prettyprint">
bt_error_e ret;

// Delete file info
ret = bt_opp_client_clear_files();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_clear_files() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}

ret = bt_opp_client_deinitialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;ERR(&quot;bt_opp_client_initialize &quot;);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize Failed.&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>

	
	
	<h2 id="le_adapter" name="le_adapter">Enabling the Bluetooth LE Adapter and Checking its State</h2>
	
	<p>In order to communicate with the remote device or to perform BLE (Bluetooth LE) operations on the local device, the LE adapter must be enabled. The device user can enable or disable BLE in the device with an ON/OFF button. The procedure applies to both basic rate and enhanced data rate (BR/EDR).</p>

  <p class="figure">Figure: Bluetooth ON/OFF button</p> 
  <p align="center"><img alt="Bluetooth ON/OFF button" src="../../images/bluetooth_onoff.png" /></p> 	
	
	<p>To check whether the BLE adapter is enabled, retrieve the adapter state:</p>
	
<pre class="prettyprint">
bt_adapter_le_state_e  le_adapter_state;
// Check whether BLE is enabled
ret = bt_adapter_get_le_state(&amp;le_adapter_state);

if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_get_state] Failed&quot;);

&nbsp;&nbsp;&nbsp;return;
}

// If the Bluetooth service is disabled
if (le_adapter_state == BT_ADAPTER_DISABLED) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Bluetooth LE adapter is not enabled. You should enable Bluetooth!!&quot;);
}
</pre>
<p>To monitor the changes in the LE adapter and BLE states, define and register the appropriate callback functions.</p>

	
	<h2 id="le_scan" name="le_scan">Managing Bluetooth LE Scans</h2>
	
	<p>To discover nearby LE devices, perform a scan:</p>
	<ol>
	<li>
	<p>To start the BLE scan:</p>
	
<pre class="prettyprint">
int main()
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_start_scan(__bt_adapter_le_scan_result_cb, NULL);

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_start_scan] Failed.&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return;
}
</pre>
	</li>
	
	<li><p>Use a registered callback to retrieve the scan results. The callback contains information of all the LE scanned devices, such as the device names, scanned devices' transmission level, service data list, appearance of the devices, and manufacture data of the devices.</p>
	<p>To handle the scan result:</p>
	
	<pre class="prettyprint">
int ret;

void __bt_adapter_le_scan_result_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_scan_result_info_s *info, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;bt_adapter_le_packet_type_e pkt_type = BT_ADAPTER_LE_PACKET_ADVERTISING;

&nbsp;&nbsp;&nbsp;if (info == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print T(DLOG_INFO, LOG_TAG, &quot;No discovery_info!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (info-&gt;adv_data_len &gt; 31 || info-&gt;scan_data_len &gt; 31) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;###################&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_stop_scan();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;###################&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 2; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char **uuids;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *device_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int tx_power_level;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_service_data_s *data_list;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int appearance;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int manufacturer_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *manufacturer_data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int manufacturer_data_len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkt_type += i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pkt_type == BT_ADAPTER_LE_PACKET_ADVERTISING &amp;&amp; info-&gt;adv_data == NULL) continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pkt_type == BT_ADAPTER_LE_PACKET_SCAN_RESPONSE &amp;&amp; info-&gt;scan_data == NULL) break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_uuids(info, pkt_type, &amp;uuids, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;UUID[%d] = %s&quot;, i + 1, uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_device_name(info, pkt_type, &amp;device_name) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;Device name = %s&quot;, device_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(device_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_tx_power_level(info, pkt_type, &amp;tx_power_level) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;TX Power level = %d&quot;, tx_power_level);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_solicitation_uuids(info, pkt_type, &amp;uuids, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;Solicitation UUID[%d] = %s&quot;, i + 1, uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_data_list(info, pkt_type, &amp;data_list, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;Service Data[%d] = [0x%2.2X%2.2X:0x%.2X...]&quot;, i + 1, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_list[i].service_uuid[0], data_list[i].service_uuid[1], data_list[i].service_data[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_free_service_data_list(data_list, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_appearance(info, pkt_type, &amp;appearance) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;Appearance = %d&quot;, appearance);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_manufacturer_data(info, pkt_type, &amp;manufacturer_id, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;manufacturer_data, &amp;manufacturer_data_len) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLOG_PRINT(DLOG_INFO, LOG_TAG, &quot;Manufacturer data[ID:%.4X, 0x%.2X%.2X...(len:%d)]&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id, manufacturer_data[0], manufacturer_data[1], manufacturer_data_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(manufacturer_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

</li>

<li>
	<p>To stop the BLE scan:</p>
<pre class="prettyprint">
int main()
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_stop_scan();

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_stop_scan] Failed.&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return;
}
</pre>	
</li>
</ol>

	
	<h2 id="add_adv_data" name="add_adv_data">Adding Advertising Data to the LE Advertisement</h2> 
	
	<p>LE advertising data can be added to the LE advertisement or the scan response data. You can add various information, such as the device name, service UUID, service solicitation UUID, advertising appearance, advertising transmission power level, device name, and manufacturer data.</p>
<p>To add the advertising data:</p>

<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL, };
static int advertiser_index = 0;

int le_add_advertising_data()
{
&nbsp;&nbsp;&nbsp;int adv_data_type = 3; // Default all
&nbsp;&nbsp;&nbsp;int manufacturer_id = 117;
&nbsp;&nbsp;&nbsp;char *manufacture = NULL;
&nbsp;&nbsp;&nbsp;char manufacture_0[] = {0x0, 0x0, 0x0, 0x0};
&nbsp;&nbsp;&nbsp;char manufacture_1[] = {0x01, 0x01, 0x01, 0x01};
&nbsp;&nbsp;&nbsp;char manufacture_2[] = {0x02, 0x02, 0x02, 0x02};
&nbsp;&nbsp;&nbsp;char manufacture_3[] = {0x03, 0x03, 0x03, 0x03};
&nbsp;&nbsp;&nbsp;char service_data[] = {0x01, 0x02, 0x03};
&nbsp;&nbsp;&nbsp;const char *time_svc_uuid_16 = &quot;1805&quot;;
&nbsp;&nbsp;&nbsp;const char *battery_svc_uuid_16 = &quot;180f&quot;;
&nbsp;&nbsp;&nbsp;const char *heart_rate_svc_uuid_16 = &quot;180d&quot;;
&nbsp;&nbsp;&nbsp;const char *immediate_alert_svc_uuid_16 = &quot;1802&quot;;
&nbsp;&nbsp;&nbsp;const char *ancs_uuid_128 = &quot;7905F431-B5CE-4E99-A40F-4B1E122D00D0&quot;;
&nbsp;&nbsp;&nbsp;int appearance = 192;  // 192 is a generic watch

&nbsp;&nbsp;&nbsp;advertiser = advertiser_list[advertiser_index];

&nbsp;&nbsp;&nbsp;if (advertiser == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_clear_advertising_data(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;clear advertising data [0x%04x]&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_clear_advertising_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;clear scan response data [0x%04x]&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (g_test_param.param_count &gt; 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adv_data_type = atoi(g_test_param.params[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;switch (adv_data_type) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: // Service UUID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING,  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;battery_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacture = manufacture_0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: // Service solicitation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heart_rate_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;dd service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;immediate_alert_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacture = manufacture_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: // Appearance &amp; TX power level
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_appearance(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appearance);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add appearance data [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_tx_power_level(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;add appearance data [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacture = manufacture_2;		
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: // All
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;battery_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heart_rate_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;immediate_alert_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_appearance(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appearance);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add appearance data [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_tx_power_level(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add tx_power_level [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacture = manufacture_3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: // ANCS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ancs_uuid_128);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_device_name(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;set device name [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;No adv data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// Default scan response data 
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_service_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16, service_data, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(service_data));
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_data [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_advertising_device_name(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, true);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;set device name [0x%04x]&quot;, ret);

&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_add_advertising_manufacturer_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id, ;manufacture, sizeof(manufacture_0));
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add manufacturer data [0x%04x]&quot;, ret);
}
</pre>

	
	<h2 id="set_adv_conn" name="set_adv_conn">Setting the Advertising Connectable Mode</h2>

	<p>When advertising to the remote device, use the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_set_advertising_connectable()</span> function to define whether the advertising type is connectable or non-connectable:</p>

<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL,};
static int advertiser_index = 0;
int type = BT_ADAPTER_LE_ADVERTISING_CONNECTABLE;

advertiser = advertiser_list[advertiser_index];

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

if (g_test_param.param_count &gt; 0) 
{
&nbsp;&nbsp;&nbsp;type = atoi(g_test_param.params[0]);
&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
}

ret = bt_adapter_le_set_advertising_connectable(advertiser, type);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add scan response data [0x%04x]&quot;, ret);
</pre>
	
	<h2 id="set_adv_mode" name="set_adv_mode">Setting the LE Advertising Mode</h2>
	
<p>The advertising mode controls the advertising power and latency, and can be set to the balanced, low latency, or low energy advertising mode.</p>

<p>To set the advertising mode:</p>


<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL,};
static int advertiser_index = 0;

int mode = BT_ADAPTER_LE_ADVERTISING_MODE_BALANCED;

advertiser = advertiser_list[advertiser_index];

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

if (g_test_param.param_count &gt; 0) 
{
&nbsp;&nbsp;&nbsp;mode = atoi(g_test_param.params[0]);
&nbsp;&nbsp;&nbsp;__bt_free_test_param(&amp;g_test_param);
}

ret = bt_adapter_le_set_advertising_mode(advertiser, mode);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add scan response data [0x%04x]&quot;, ret);
</pre>
	
	<h2 id="start_adv" name="start_adv">Starting Advertising</h2>
	
<p>To start advertising with the given advertiser and advertising parameters information, use the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_start_advertising_new()</span> function:</p>

<pre class="prettyprint">
bt_adapter_le_advertising_state_changed_cb cb;

if (advertiser_index == 0) cb = __bt_adapter_le_advertising_state_changed_cb;
else if (advertiser_index == 0) cb = __bt_adapter_le_advertising_state_changed_cb_2;
else cb = __bt_adapter_le_advertising_state_changed_cb_3;

advertiser = advertiser_list[advertiser_index];
advertiser_index++;
advertiser_index %= 3;

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

ret = bt_adapter_le_start_advertising_new(advertiser, cb, NULL);
if (ret &lt; BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;failed with [0x%04x]&quot;, ret);
</pre>
	
	

 <h2 id="release" name="release">Releasing All Resources</h2>

<p>To release all Bluetooth resources, call the <span style="font-family: Courier New,Courier,monospace;">bt_deinitialize()</span> function:</p>
<pre class="prettyprint">
// Unregister callbacks
bt_adapter_unset_state_changed_cb();
bt_adapter_unset_device_discovery_state_changed_cb();
bt_device_unset_service_searched_cb();
bt_socket_unset_data_received_cb();
bt_socket_unset_connection_state_changed_cb();
 
// Release resources

// Deinitialize Bluetooth
ret = bt_deinitialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_deinitialize] Failed.&quot;);
}</pre>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

 </body>
</html>
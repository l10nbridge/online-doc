<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Bluetooth: Managing Bluetooth Devices</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#init">Initializing Bluetooth</a></li>
			<li><a href="#enable">Enabling and Disabling Bluetooth</a></li>
			<li><a href="#state">Checking the Bluetooth Adapter State</a></li>
			<li><a href="#find">Finding Other Devices</a></li>
			<li>Serial Port Profile (SPP) operations
				<ul class="toc">
					<li><a href="#connect">Connecting to Other Devices Using SPP</a></li>
					<li><a href="#exchange">Exchanging Data Using SPP</a></li>
					<li><a href="#disconnect">Disconnecting from the Connected Device Using SPP</a></li>
				</ul>
			</li>
			<li>Bluetooth GATT operations
				<ul class="toc">
					<li><a href="#pre_gatt">Handling GATT Operation Preconditions</a></li>
					<li><a href="#gatt">Managing the GATT Client Operations</a></li>
					<li><a href="#gatt_getter">Managing Common Getter GATT Operations</a></li>
					<li><a href="#gatt_setter">Managing Common Setter GATT Operations</a></li>
				</ul>
			</li>
			<li>Object Push Profile (OPP) operations
				<ul class="toc">
					<li><a href="#exc">Exchanging Data Using OPP</a></li>
				</ul>
			</li>
			<li>Bluetooth LE operations
				<ul class="toc">
					<li><a href="#le_scan">Managing Bluetooth LE Scans</a></li>
					<li><a href="#le_discovery">Discovering Bluetooth LE Devices</a></li>
					<li><a href="#add_adv_data">Adding Advertising Data to the LE Advertisement</a></li>
					<li><a href="#set_adv_conn">Setting the LE Advertising Connectable Mode</a></li>
					<li><a href="#set_adv_mode">Setting the LE Advertising Mode</a></li>
					<li><a href="#start_adv">Starting and Stopping LE Advertising</a></li>
				</ul>
			</li>		
			<li><a href="#release">Releasing All Resources</a></li>
		</ul>       
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/network/bluetooth_n.htm">Bluetooth Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">Bluetooth API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Bluetooth: Managing Bluetooth Devices</h1>

  
<p>This tutorial demonstrates how you can use Bluetooth connections.</p>

 <h2>Warm-up</h2>
 <p>Become familiar with the Bluetooth API basics by learning about:</p>
			<ul>
				<li><a href="#init">Initializing Bluetooth</a>
				<p>Initialize Bluetooth for use.</p></li>
				<li><a href="#enable">Enabling and Disabling Bluetooth</a>
				<p>Enable or disable Bluetooth.</p></li>
				<li><a href="#state">Checking the Bluetooth Adapter State</a>
				<p>Check the Bluetooth adapter state.</p></li>
				<li><a href="#find">Finding Other Devices</a>
				<p>Find other devices using Bluetooth.</p></li>
				<li>Serial Port Profile (SPP) operations
				<ul>
					<li><a href="#connect">Connecting to Other Devices Using SPP</a>
					<p>Connect to other devices through SPP.</p></li>
					<li><a href="#exchange">Exchanging Data Using SPP</a>
					<p>Exchange data between devices through SPP.</p></li>
					<li><a href="#disconnect">Disconnecting from the Connected Device Using SPP</a>
					<p>Disconnect from the connected devices.</p></li>
				</ul></li>
				<li>Bluetooth GATT operations
				<ul>
					<li><a href="#pre_gatt">Handling GATT Operation Preconditions</a>
					<p>Connect to the BLE target before using the GATT APIs.</p></li>
					<li><a href="#gatt">Managing the GATT Client Operations</a>
					<p>Create a GATT client to connect to a remote service, get service details, read and set service attributes, and set and release callbacks when the characteristic value changes.</p></li>
					<li><a href="#gatt_getter">Managing Common Getter GATT Operations</a>
                    <p>Get information used commonly in client GATT operations.</p></li>
					<li><a href="#gatt_setter">Managing Common Setter GATT Operations</a>
                    <p>Set the properties and values of GATT attributes.</p></li>
				</ul></li>
				<li>Object Push Profile (OPP) operations
				<ul>
					<li><a href="#exc">Exchanging Data Using OPP</a>
					<p>Exchange data between devices through OPP.</p></li>
				</ul></li>
				<li>Bluetooth LE operations
				<ul>
					<li><a href="#le_scan">Managing Bluetooth LE Scans</a>
					<p>Start the LE scan, handle the scanning results, and stop the scan.</p></li>
					<li><a href="#le_discovery">Discovering Bluetooth LE Devices</a>
                    <p>Discover nearby Bluetooth LE-enabled devices</p></li>
					<li><a href="#add_adv_data">Adding Advertising Data to the LE Advertisement</a>
					<p>Add advertising data to an LE advertisement or scan result.</p></li>
					<li><a href="#set_adv_conn">Setting the LE Advertising Connectable Mode</a>
					<p>Define whether the LE advertising type is connectable or non-connectable.</p></li>
					<li><a href="#set_adv_mode">Setting the LE Advertising Mode</a>
					<p>Control the LE advertising power and latency.</p></li>
					<li><a href="#start_adv">Starting and Stopping LE Advertising</a> 
					<p>Start and stop LE advertising with the advertising parameters.</p></li>
				</ul></li>
				
				<li><a href="#release">Releasing All Resources</a>
				<p>Release all resources related to using Bluetooth connections.</p></li>
			</ul>		

 <h2 id="init" name="init">Initializing Bluetooth</h2>
			
<p>To initialize Bluetooth:</p>
<ol>
<li>			
<p>To use the functions and data types of the Bluetooth API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__BLUETOOTH__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;bluetooth.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
</pre></li>				
<li>			
<p>Initialize Bluetooth:</p>
<pre class="prettyprint">
#include &lt;dlog.h&gt;

bt_error_e ret;

ret = bt_initialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_initialize] Failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
</pre></li></ol>

 <h2 id="enable" name="enable">Enabling and Disabling Bluetooth</h2>
			
<p>To allow the user to enable or disable Bluetooth, use the application control to display the Bluetooth activation settings.</p>
<p>The Bluetooth API does not contain functions for enabling or disabling Bluetooth. You must display the Bluetooth activation settings application to allow the user to toggle the Bluetooth state.</p>
		
<p>No Bluetooth API is provided to enable or disable Bluetooth. Use the Bluetooth ON/OFF application illustrated in the following figure (off screen on the left and on screen on the right).</p>

  <p class="figure">Figure: Bluetooth activation settings application (off screen on the left and on screen on the right)</p> 
  <p align="center"><img alt="Bluetooth activation settings application (off screen on the left and on screen on the right)" src="../../images/bluetooth_onoff.png" /></p> 

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int 
bt_onoff_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service, &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service, &quot;application/x-bluetooth-on-off&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}
</pre>

 <h2 id="state" name="state">Checking the Bluetooth Adapter State</h2>

<p>To communicate with other devices using Bluetooth, learn how to check the Bluetooth adapter state:</p>

<ol><li>Check whether the Bluetooth adapter is enabled on your device:
<pre class="prettyprint">
bt_adapter_state_e adapter_state;
 
// Check whether the Bluetooth adapter is enabled
ret = bt_adapter_get_state(&amp;adapter_state);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_get_state] Failed&quot;);

&nbsp;&nbsp;&nbsp;return;
}
// If the Bluetooth adapter is not enabled
if (adapter_state == BT_ADAPTER_DISABLED) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Bluetooth adapter is not enabled. You should enable Bluetooth!!&quot;);
}
</pre>
</li>

<li>To monitor changes in the Bluetooth adapter state, define and register the Bluetooth adapter state callback function:
<pre class="prettyprint">
#include &lt;bluetooth.h&gt;
#include &lt;dlog.h&gt; 

bt_error_e ret;

void 
adapter_state_changed_cb(int result, bt_adapter_state_e adapter_state, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_state_changed_cb] Failed! result=%d&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (adapter_state == BT_ADAPTER_ENABLED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is enabled!&quot;);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get information about Bluetooth adapter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_address = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_address(&amp;local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter address: %s.&quot;, local_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_address)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_address); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *local_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_name(&amp;local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Adapter name: %s.&quot;, local_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (local_name)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(local_name); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Visibility mode of the Bluetooth device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_visibility_mode_e mode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Duration until the visibility mode is changed so that other devices cannot find your device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int duration = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_get_visibility(&amp;mode, &amp;duration);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (mode) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;[adapter_state_changed_cb] Visibility: NON_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;[adapter_state_changed_cb] Visibility: GENERAL_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_VISIBILITY_MODE_LIMITED_DISCOVERABLE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;[adapter_state_changed_cb] Visibility: LIMITED_DISCOVERABLE&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[adapter_state_changed_cb] Bluetooth is disabled!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// When you try to get device information
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by invoking bt_adapter_get_name(), bt_adapter_get_address(), or bt_adapter_get_visibility(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// BT_ERROR_NOT_ENABLED occurs
&nbsp;&nbsp;&nbsp;}
}
ret = bt_adapter_set_state_changed_cb(adapter_state_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_state_changed_cb()] Failed.&quot;);
}
</pre></li>
</ol>

 <h2 id="find" name="find">Finding Other Devices</h2>

<p>To find remote Bluetooth devices either through device discovery or querying bonded devices:</p>
<ul>
<li>Define and register the discovery state callback function.
<ol>
<li>
<p>Discovering available Bluetooth-enabled devices is the first step to communicating with remote devices. There are 2 types of Bluetooth devices: classic Bluetooth devices and Bluetooth LE devices. Both device types use their own APIs to discover devices of the same type.</p>

<p>Declare the discovery start functions for the 2 types.</p>
<pre class="prettyprint">// Classic Bluetooth
int bt_adapter_start_device_discovery(void);
int bt_adapter_stop_device_discovery(void);

// Bluetooth LE
int bt_adapter_le_start_device_discovery(void);
int bt_adapter_le_stop_device_discovery(void);
</pre>
 </li>
 <li>
<p>If discovering Bluetooth succeeds, you receive the <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_NONE</span> result as the first parameter in your <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_changed_cb()</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_changed_cb()</span> (Bluetooth LE) callback function. If your device did not start to discover devices due to an error, the result code is <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_TIMEOUT</span>. If stopping the discovery succeeds, you can also receive <span style="font-family: Courier New,Courier,monospace;">BT_ERROR_CANCELLED</span>.</p>
</li>
<li>
<p>When your implemented callback function is first called, the second parameter, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span>, is <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>. This indicates that device discovery has begun.</p>
<p>The discovery states are values of the enumerations <span style="font-family: Courier New,Courier,monospace;">bt_adapter_device_discovery_state_e</span> (classic Bluetooth) (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__MODULE.html#gaae6b21353576e515e5bb1e76d25472bd">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__MODULE.html#gaae6b21353576e515e5bb1e76d25472bd">wearable</a> applications) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_device_discovery_state_e</span> (Bluetooth LE) (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__NETWORK__BLUETOOTH__ADAPTER__LE__MODULE.html#ga4b90a954c6cfb51b60d520c114d8f62d">mobile</a> applications).</p>
<p>Each time you find a remote Bluetooth device, <span style="font-family: Courier New,Courier,monospace;">discovery_state</span> is in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FOUND</span> or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND</span> state. At this state you can get some information about a discovered device, such as the device MAC address, name, class, rssi (received signal strength indicator), and bonding state. Using this information, you can connect to the discovered device.</p>
<p><span style="font-family: Courier New,Courier,monospace;">discovery_info</span> is a NULL value in the <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED</span>, <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_DEVICE_DISCOVERY_FINISHED</span>, or <span style="font-family: Courier New,Courier,monospace;">BT_ADAPTER_LE_DEVICE_DISCOVERY_FINISHED</span> state.</p>
<p>The following example shows the implementation for classic Bluetooth. Bluetooth LE usage is the same.</p>
<pre class="prettyprint">#include &lt;glib.h&gt; // For GList
void 
adapter_device_discovery_state_changed_cb(int result, bt_adapter_device_discovery_state_e discovery_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s *discovery_info, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[adapter_device_discovery_state_changed_cb] Failed! result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;GList** searched_device_list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;switch (discovery_state) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_STARTED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_STARTED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FINISHED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FINISHED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case BT_ADAPTER_DEVICE_DISCOVERY_FOUND:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;BT_ADAPTER_DEVICE_DISCOVERY_FOUND&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discovery_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Address: %s&quot;, discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device Name is: %s&quot;, discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_device_discovery_info_s * new_device_info = malloc(sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_device_info != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(new_device_info, discovery_info, sizeof(bt_adapter_device_discovery_info_s));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_address = strdup(discovery_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_device_info-&gt;remote_name = strdup(discovery_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*searched_device_list = g_list_append(*searched_device_list, (gpointer)new_device_info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}</pre>
</li>
<li>
<p>Register the callback for classic Bluetooth. Bluetooth LE usage is the same.</p>
<pre class="prettyprint">GList *devices_list = NULL;
ret = bt_adapter_set_device_discovery_state_changed_cb(adapter_device_discovery_state_changed_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)&amp;devices_list);

if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_device_discovery_state_changed_cb] Failed.&quot;);
}</pre>
</li>
</ol>
</li>
<li>Find other Bluetooth devices.
<p>If you want to stop the device discovery, call the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_stop_device_discovery()</span> (classic Bluetooth) or <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_device_discovery()</span> (Bluetooth LE) function.</p>
<p>A remote Bluetooth device responds to the request if it is enabled and in a discovery mode. Classic Bluetooth and Bluetooth LE usages are the same.</p>
<pre class="prettyprint">
// Classic Bluetooth
ret = bt_adapter_start_device_discovery();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_start_device_discovery] Failed.&quot;);
}</pre>

</li>

<li>Enable discovery.
<ol>
<li>
<p>Check the current visibility of your device. For other devices to find your device, your device must be discoverable.</p>
<pre class="prettyprint">
// Visibility mode of the Bluetooth device
bt_adapter_visibility_mode_e mode;
// Duration until the visibility mode is changed so that other devices cannot find your device
int duration = 1;
bt_adapter_get_visibility(&amp;mode, &amp;duration);
if (mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is not discoverable.&quot;);
} 
else if (mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable. No time limit.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The device is discoverable for a set period of time.&quot;);
}</pre>
</li>
<li>
<p>To change the visibility mode, use the Bluetooth visibility setting application (shown below with the initial screen on the left and the visibility setting screen on the right).</p>
<p class="figure">Figure: Bluetooth visibility setting application</p>
<p align="center"><img alt="Bluetooth visibility setting application" src="../../images/bluetooth_visibility.png" /></p>

<pre class="prettyprint">
#include &lt;app_control.h&gt;
#include &lt;dlog.h&gt;

int 
bt_set_visibility_operation(void)
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;app_control_h service = NULL;
&nbsp;&nbsp;&nbsp;app_control_create(&amp;service);
&nbsp;&nbsp;&nbsp;if (service == NULL)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service_create failed!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;app_control_set_operation(service,  &quot;http://tizen.org/appcontrol/operation/edit&quot;);
&nbsp;&nbsp;&nbsp;app_control_set_mime(service,  &quot;application/x-bluetooth-visibility&quot;);
&nbsp;&nbsp;&nbsp;ret = app_control_send_launch_request(service, NULL, NULL);

&nbsp;&nbsp;&nbsp;app_control_destroy(service);
&nbsp;&nbsp;&nbsp;if (ret == APP_CONTROL_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Succeeded to Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Failed to relaunch Bluetooth On/Off app!\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return 0;
}</pre>
</li>
<li>
<p>To get a notification when the visibility is changed after 90 seconds, implement the following callback:</p>
<pre class="prettyprint">
void 
adapter_visibility_mode_changed_cb(int result, bt_adapter_visibility_mode_e visibility_mode, void* user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_NON_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] None discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (visibility_mode == BT_ADAPTER_VISIBILITY_MODE_GENERAL_DISCOVERABLE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] General discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[visibility_mode_changed_cb] Limited discoverable mode!&quot;);
&nbsp;&nbsp;&nbsp;}
}</pre>
</li>
<li>
<p>Register the callback:</p>
<pre class="prettyprint">ret = bt_adapter_set_visibility_mode_changed_cb(adapter_visibility_mode_changed_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_set_visibility_mode_changed_cb] Failed.&quot;);
}</pre>
</li>
</ol>
</li>
<li>Query bonded devices.
<ol>
<li>
<p>Before trying to find the remote devices nearby, you can query the list of bonded devices to get the basic information (such as device address and name) your device has stored for the bonded devices. To get all bonded devices, call the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> function. You can get information about bonded devices in the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_bonded_device_cb()</span> callback function, which you need to call for each bonded device.</p>
<p>Declare the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> function.</p>
<pre class="prettyprint">int bt_adapter_foreach_bonded_device(bt_adapter_bonded_device_cb foreach_cb, void *user_data)</pre>
<p>You can get information (such as the device name, service list, and Mac address) about the bonded device.</p>
<p>To continue performing iterations, your implemented callback function must return <span style="font-family: Courier New,Courier,monospace;">true</span>. Otherwise, it returns <span style="font-family: Courier New,Courier,monospace;">false</span> and stops performing additional iterations.</p>
<p>The following example describes how to query bonded devices and how to discover a desired device.</p>
<pre class="prettyprint">// Server address for connecting
char *bt_server_address = NULL;
const char *remote_server_name = &quot;server device&quot;;
 
bool 
adapter_bonded_device_cb(bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (device_info == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (!strcmp(device_info-&gt;remote_name, (char*)user_data)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;The server device is found in bonded device list. address(%s)&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_server_address = strdup(device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If you want to stop iterating, you can return &quot;false&quot;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;// Get information about bonded device
&nbsp;&nbsp;&nbsp;int count_of_bonded_device = 1;
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Get information about the bonded device(%d)&quot;, count_of_bonded_device);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote address = %s.&quot;, device_info-&gt;remote_address);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote name = %s.&quot;, device_info-&gt;remote_name);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;service count = %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bonded?? %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;connected?? %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;authorized?? %d.&quot;, device_info-&gt;is_authorized);
 
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_device_class %d.&quot;, device_info-&gt;bt_class.major_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;minor_device_class %d.&quot;, device_info-&gt;bt_class.minor_device_class);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;major_service_class_mask %d.&quot;, device_info-&gt;bt_class.major_service_class_mask);
&nbsp;&nbsp;&nbsp;count_of_bonded_device++;

&nbsp;&nbsp;&nbsp;// Keep iterating

&nbsp;&nbsp;&nbsp;return true;
}

ret = bt_adapter_foreach_bonded_device(adapter_bonded_device_cb, remote_server_name);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_foreach_bonded_device] Failed!&quot;);
}

if (bt_server_address != NULL)
&nbsp;&nbsp;&nbsp;free(bt_server_address);
</pre>
</li>
</ol>
</li>

<li>Request bonding with a remote Bluetooth device.
<ol>
<li>
<p>You can request to bond with a remote device using the <span style="font-family: Courier New,Courier,monospace;">bt_device_create_bond()</span> function. If you want to cancel bonding, call the <span style="font-family: Courier New,Courier,monospace;">bt_device_cancel_bonding()</span> function.</p>
<p>To get notified when the bonding has finished, register a <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function using the <span style="font-family: Courier New,Courier,monospace;">bt_device_set_bond_created_cb()</span> function. From this callback, you can get the service list that the remote Bluetooth device provides and the service UUID from that service list.</p>
<p>The following example shows how to implement the <span style="font-family: Courier New,Courier,monospace;">bt_device_bond_created_cb()</span> callback function and bond with a remote Bluetooth device.</p>
<pre class="prettyprint">
void 
device_bond_created_cb(int result, bt_device_info_s *device_info, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_bond_created_cb] Failed. result(%d).&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (device_info != NULL &amp;&amp; !strcmp(device_info-&gt;remote_address, remote_server_address)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: A bond with chat_server is created.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: The number of service - %d.&quot;, device_info-&gt;service_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_bonded - %d.&quot;, device_info-&gt;is_bonded);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: is_connected - %d.&quot;, device_info-&gt;is_connected);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Callback: A bond with another device is created.&quot;);
&nbsp;&nbsp;&nbsp;}
}

// You can get bt_server_address from bt_adapter_bonded_device_cb() or bt_device_service_searched_cb()
// device_info-&gt;remote_address in bt_adapter_bonded_device_cb()
// sdp_info-&gt;remote_address in bt_device_service_searched_cb()
 
ret = bt_device_set_bond_created_cb(device_bond_created_cb, bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_set_bond_created_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_device_create_bond(bt_server_address);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_device_create_bond] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_device_create_bond] succeeded. device_bond_created_cb callback will be called.&quot;);
}</pre>
</li>
<li>
<p>After that, the remote device is included in the bonded device list. Next time you do not need to find it again. Without finding, you can get information (such as address and name) by querying the bonded device.</p>
<p>You can verify the bonding by calling the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_foreach_bonded_device()</span> function. To remove the device from the bonded list, call the <span style="font-family: Courier New,Courier,monospace;">bt_device_destroy_bond()</span> function.</p>
</li>
</ol>
</li>
</ul>

 <h2 id="connect" name="connect">Connecting to Other Devices Using SPP</h2>
			
<p>To connect to other devices:</p>			
<ul>
<li>Connect as a server:
<ol>
<li>
<p>To establish a connection with your device acting as a server, create an RFCOMM Bluetooth socket using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function.</p>
<p>The first parameter is the UUID of the service, which uniquely identifies which service to provide. The UUID must match with the UUID in the client&#39;s incoming connection for the connection to be accepted. The second parameter is the RFCOMM socket file descriptor as an output parameter.</p>
<pre class="prettyprint">
const char* my_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
int server_socket_fd = -1;
bt_error_e ret;
 
ret = bt_socket_create_rfcomm(my_uuid, &amp;server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_socket_create_rfcomm() failed.&quot;);
}
</pre>
</li>
<li>
<p>To listen for an incoming connection from a client, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_listen_and_accept_rfcomm()</span> function. The first parameter is the socket file descriptor passed from <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span>, defining the socket that starts listening. The second parameter is the maximum number of pending connections that a Bluetooth server can store.</p>
<pre class="prettyprint">
ret = bt_socket_listen_and_accept_rfcomm(server_socket_fd, 5);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_listen_and_accept_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
&nbsp;&nbsp;&nbsp;// Waiting for incoming connections
}
</pre>
</li>
<li>
<p>Register the socket connection state change callback using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_set_connection_state_changed_cb()</span> function.</p>
<p>The callback in invoked whenever the connection state changes (for example, when a client connects to your service). In its parameters, the callback provides the result of the connection state change, the new connection state, and a pointer to the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s</span> structure (in <a href="../../../../org.tizen.native.mobile.apireference/structbt__socket__connection__s.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/structbt__socket__connection__s.html">wearable</a> applications) that specifies the details of the connection, including the client device MAC address.</p>
<pre class="prettyprint">
void 
socket_connection_state_changed(int result, bt_socket_connection_state_e connection_state,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_socket_connection_s *connection, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[socket_connection_state_changed_cb] Failed. result =%d.&quot;, result);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;if (connection_state == BT_SOCKET_CONNECTED) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Connected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of connection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Role of connection - %d.&quot;, connection-&gt;local_role);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// socket_fd is used for sending data and disconnecting a device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_socket_fd = connection-&gt;socket_fd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Disconnected.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection != NULL) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Socket of disconnection - %d.&quot;, connection-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: Address of connection - %s.&quot;, connection-&gt;remote_address);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Callback: No connection data&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
 
bt_error_e ret;
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
</pre>

<p>When you no longer want to accept any other connections or provide a service, call the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> function.</p>
</li>
</ol>
</li>

<li>Connect as a client:
<ol>
<li>Define and register the socket connection state change callback using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_set_connection_state_changed_cb()</span> function.
<p>The callback in invoked whenever the connection state changes (for example, when you connect to the server device). </p>
<pre class="prettyprint">
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
</pre>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">When you connect to a Bluetooth server device, retrieve the server socket file descriptor (<span style="font-family: Courier New,Courier,monospace;">bt_socket_connection_s->socket_fd</span>) in the callback and store it for later use. You need the file descriptor when sending data or disconnecting from the service.</td> 
    </tr> 
   </tbody> 
  </table> 
 </li>
 <li>
<p>Request a connection to the Bluetooth server using the <span style="font-family: Courier New,Courier,monospace;">bt_socket_connect_rfcomm()</span> function.</p>
<p>The first parameter is the address of the remote device. You can get it from the <span style="font-family: Courier New,Courier,monospace;">bt_device_info_s</span> structure (in <a href="../../../../org.tizen.native.mobile.apireference/structbt__device__info__s.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/structbt__device__info__s.html">wearable</a> applications), which is returned in a callback after you bond with the server device or query a previously bonded device. The second parameter is the UUID for the specific RFCOMM-based service on a remote device. The UUID must match the UUID used by the server device in the <span style="font-family: Courier New,Courier,monospace;">bt_socket_create_rfcomm()</span> function.</p>
<pre class="prettyprint">
const char *service_uuid=&quot;00001101-0000-1000-8000-00805F9B34FB&quot;;
 
ret = bt_socket_set_connection_state_changed_cb(socket_connection_state_changed, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_set_connection_state_changed_cb] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
}
 
ret = bt_socket_connect_rfcomm(bt_server_address, service_uuid);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_connect_rfcomm] failed.&quot;);

&nbsp;&nbsp;&nbsp;return;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_connect_rfcomm] Succeeded. bt_socket_connection_state_changed_cb will be called.&quot;);
}
</pre>
</li>
</ol>
</li>
</ul>

 <h2 id="exchange" name="exchange">Exchanging Data Using SPP</h2>

<p>To share data between devices after establishing a connection:</p>
<ol><li><p>To write data, use the <span style="font-family: Courier New,Courier,monospace;">bt_socket_send_data()</span> function. The first parameter is the socket file descriptor from the socket connection state change callback, the second parameter is the data to be sent, and the third parameter is the data length.</p>
<pre class="prettyprint">
bt_error_e ret;
char data[] = &quot;Sending test&quot;;
int client_socket_fd = 0;

ret = bt_socket_send_data(client_socket_fd, data, sizeof(data));
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_send_data] failed.&quot;);
}
</pre>
</li>
<li><p>To read data from other devices, you must set up the data received callback, which is invoked when your device receives data from other Bluetooth devices.</p>
<p>Use the <span style="font-family: Courier New,Courier,monospace;">bt_socket_set_data_received_cb()</span> function to register the data received callback. In the callback, the first parameter is a pointer to the <span style="font-family: Courier New,Courier,monospace;">bt_socket_received_data_s</span> structure (in <a href="../../../../org.tizen.native.mobile.apireference/structbt__socket__received__data__s.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/structbt__socket__received__data__s.html">wearable</a> applications) that can specify the received data, data size, and socket file descriptor.</p>

<pre class="prettyprint">
bt_error_e ret;

void 
bt_socket_data_received_cb(bt_socket_received_data_s* data, void* user_data)
{
&nbsp;&nbsp;&nbsp;if (data == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;No received data!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Socket fd: %d&quot;, data-&gt;socket_fd);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Data: %s&quot;, data-&gt;data);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Size: %d&quot;, data-&gt;data_size);
}

ret = bt_socket_set_data_received_cb(bt_socket_data_received_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_data_received_cb] regist to fail.&quot;);
}
</pre>

</li></ol>

 <h2 id="disconnect" name="disconnect">Disconnecting from the Connected Device Using SPP</h2>

<p>To disconnect from a device:</p>

<ul><li>If your device is a Bluetooth server, disconnect from the client with the <span style="font-family: Courier New,Courier,monospace;">bt_socket_destroy_rfcomm()</span> function: 
<pre class="prettyprint">
bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from output of bt_socket_create_rfcomm()
ret = bt_socket_destroy_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. socket_fd = %d&quot;, server_socket_fd);
}
</pre></li>

<li>If your device is a Bluetooth client, disconnect from the server with the <span style="font-family: Courier New,Courier,monospace;">bt_socket_disconnect_rfcomm()</span> function: 
<pre class="prettyprint">
bt_error_e ret;
 
// You can get &quot;server_socket_fd&quot; from bt_socket_connection_state_changed_cb()
ret = bt_socket_disconnect_rfcomm(server_socket_fd);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Failed. server_socket_fd = %d.&quot;, server_socket_fd);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_socket_destroy_rfcomm] Succeeded. server_socket_fd = %d.&quot;, server_socket_fd);
}
</pre></li></ul>

<h2 id="pre_gatt" name="pre_gatt">Handling GATT Operation Preconditions</h2>

<p>Before you can use the GATT APIs, you must successfully connect to the BLE target.</p>
<p>To connect to the BLE target:</p>
<pre class="prettyprint">
int ret = BT_ERROR_NONE;
// For information on the callback, see <a href="#le_scan">Managing Bluetooth LE Scans</a>
ret = bt_adapter_le_start_scan(__bt_adapter_le_scan_result_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_start_scan] Failed.&quot;);
}
// Wait while the system searches for the LE target you want to connect to
// If you find the LE target you want, stop the scan
ret = bt_adapter_le_stop_scan();

ret = bt_gatt_connect(ADDRESS_BLE_DEVICE_YOU_WANT, false);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to connect LE device.&quot;);
}
</pre>

<h2 id="gatt" name="gatt">Managing the GATT Client Operations</h2>
<p>To perform GATT client operations:</p>
<ol>
<li>Register a callback for connection state changes:
<pre class="prettyprint">
int ret = 0;
// Register for GATT connection callback
void
__bt_gatt_connection_state_changed_cb(int result, bool connected, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (connected)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE connected&quot;);
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE disconnected&quot;);
}

ret = bt_gatt_set_connection_state_changed_cb(__bt_gatt_connection_state_changed_cb, NULL);
</pre></li>

<li>Create a client to connect to a remote service device:
<pre class="prettyprint">
int ret = 0;

ret = bt_gatt_client_create(remote_addr, &amp;client);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

return;
</pre>
</li>

<li>Get the address of the remote device:
<pre class="prettyprint">
int ret = 0;
char *addr = NULL;

ret = bt_gatt_client_get_remote_address(client, &amp;addr);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

return;
</pre>
</li>

<li>Discover the service, characteristics, and descriptors of the remote service:
<ol type="a"><li>Discover the service:
<pre class="prettyprint">
int ret = 0;

ret = bt_gatt_client_foreach_services(client, __bt_gatt_client_foreach_svc_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;fail&quot;);
}

return;
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_svc_cb()</span> callback to initiate the service characteristics discovery:
<pre class="prettyprint">
bool 
__bt_gatt_client_foreach_svc_cb(int total, int index, bt_gatt_h svc_handle, void *data)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *uuid = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(svc_handle, &amp;uuid);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[%d / %d] uuid : (%s)&quot;, index, total, uuid);

&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_service_foreach_characteristics(svc_handle,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_foreach_chr_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_foreach_characteristics is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_chr_cb()</span> callback to discover the characteristic descriptors:
<pre class="prettyprint">
bool 
__bt_gatt_client_foreach_chr_cb(int total, int index, bt_gatt_h chr_handle, void *data)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *uuid = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(chr_handle, &amp;uuid);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;\t[%d / %d] uuid : (%s)&quot;, index, total, uuid);

&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_characteristic_foreach_descriptors(chr_handle,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_gatt_client_foreach_desc_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_foreach_descriptors is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_foreach_desc_cb()</span> callback to get the descriptor data: 
<pre class="prettyprint">
bool 
__bt_gatt_client_foreach_desc_cb(int total, int index, bt_gatt_h desc_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(desc_handle, &amp;uuid);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;\t\t[%d / %d] uuid : (%s)&quot;, index, total, uuid);

&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>
</li>
<li>Read the value of the given attribute handle:
<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level
char *desc_uuid = &quot;00002902-0000-1000-8000-00805f9b34fb&quot;; // Client characteristic configuration
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;
bt_gatt_h desc = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_characteristic_get_descriptor(chr, desc_uuid, &amp;desc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_descriptor is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_client_read_value(desc, __bt_gatt_client_read_complete_cb, NULL);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_read_value is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}
</pre> 
<p>After the reading operation is complete, use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_read_complete_cb()</span> callback to handle values:</p>
<pre class="prettyprint">
void 
__bt_gatt_client_read_complete_cb(int result, bt_gatt_h gatt_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(gatt_handle, &amp;uuid);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Read %s for uuid : (%s)&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result == BT_ERROR_NONE ? &quot;Success&quot; : &quot;Fail&quot;, uuid);

&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;if (result != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>
<li>Set a value for the given attribute handle:

<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level
char *desc_uuid = &quot;00002902-0000-1000-8000-00805f9b34fb&quot;; // Client characteristic configuration
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;
bt_gatt_h desc = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_characteristic_get_descriptor(chr, desc_uuid, &amp;desc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_descriptor is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = __bt_gatt_client_set_value(&quot;int32&quot;, &quot;1234&quot;, desc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_set_value is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_client_write_value(desc, __bt_gatt_client_write_complete_cb, NULL);

if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_write_value is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">__bt_gatt_client_set_value()</span> function is defined below:</p>
<pre class="prettyprint">
int 
__bt_gatt_client_set_value(char *type, char *value, bt_gatt_h h)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;int s_val;
&nbsp;&nbsp;&nbsp;unsigned int u_val;
&nbsp;&nbsp;&nbsp;char *buf;
&nbsp;&nbsp;&nbsp;int len;

&nbsp;&nbsp;&nbsp;if (strcasecmp(type, &quot;int8&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_val = atoi(value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;s_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 1;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;int16&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_val = atoi(value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;s_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 2;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;int32&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_val = atoi(value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;s_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 4;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;uint8&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_val = strtoul(value, NULL, 10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;u_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 1;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;uint16&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_val = strtoul(value, NULL, 10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;u_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 2;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;uint32&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_val = strtoul(value, NULL, 10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = (char *)&amp;u_val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = 4;
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (strcasecmp(type, &quot;str&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len = strlen(buf);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return BT_ERROR_INVALID_PARAMETER;

&nbsp;&nbsp;&nbsp;ret = bt_gatt_set_value(h, buf, len);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TC_PRT(&quot;bt_gatt_set_value is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
<p>After the writing operation is complete, use the <span style="font-family: Courier New,Courier,monospace;">bt_gatt_client_write_complete_cb()</span> callback to finish the task:</p>
<pre class="prettyprint">
void 
__bt_gatt_client_write_complete_cb(int result, bt_gatt_h gatt_handle, void *data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(gatt_handle, &amp;uuid);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Write %s for uuid : (%s)&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result == BT_ERROR_NONE ? &quot;Success&quot; : &quot;Fail&quot;, uuid);

&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>
<li>Register a callback function to be invoked when the characteristic value changes on the remote device:

<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;;
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;;
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_client_set_characteristic_value_changed_cb(chr, __bt_gatt_client_value_changed_cb, NULL);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_set_characteristic_value_changed_cb is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
<p>After registering the callback operation, use the <span style="font-family: Courier New,Courier,monospace;">__bt_gatt_client_value_changed_cb()</span> callback to display the changed value:</p>
<pre class="prettyprint">
void 
__bt_gatt_client_value_changed_cb(bt_gatt_h chr, char *value, int len, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *uuid = NULL;
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;bt_gatt_get_uuid(chr, &amp;uuid);

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Value changed for [%s]&quot;, uuid);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;len [%d]&quot;, len);
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; len; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;value %u&quot;, value[i]);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;g_free(uuid);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
<p>When you no longer need the value change notifications, unregister the callback.</p>

<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}

ret = bt_gatt_client_unset_characteristic_value_changed_cb(chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_unset_characteristic_value_changed_cb is failed : %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>

<li>When you no longer need the client, unregister the connection state change callback, disconnect from the remote service, and destroy the client:
<pre class="prettyprint">
int ret = 0;

// Unregister the GATT connection callback
ret = bt_gatt_unset_connection_state_changed_cb();

// Destroy the client
ret = bt_gatt_client_destroy(client);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
client = NULL;

return;
</pre>
</li>
</ol>



<h2 id="gatt_getter" name="gatt_getter">Managing Common GATT Getter Operations</h2>
<p>To perform getter operations for client-related information:</p>
<ul>
<li>Get the type of a service, characteristic, or descriptor handle:
<pre class="prettyprint">
int ret = 0;
bt_gatt_h gatt_handle = NULL;
bt_gatt_type_e gatt_type;

// Handle is already created for service/characteristic/descriptor

ret = bt_gatt_get_type(gatt_handle, &amp;gatt_type);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_get_type is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the UUID of a service, characteristic, or descriptor handle:
<pre class="prettyprint">
int ret = 0;
bt_gatt_h gatt_handle = NULL;
char *uuid = NULL;

// Handle is already created for service/characteristic/descriptor

ret = bt_gatt_get_uuid(gatt_handle, &amp;uuid);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_get_uuid is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the value of a characteristic or descriptor handle:
<pre class="prettyprint">
int ret = 0;
int len = 0;
bt_gatt_h gatt_handle = NULL;
char *value = NULL;

// Handle is already created for characteristic/descriptor

ret = bt_gatt_get_value(gatt_handle, &amp;value, &amp;len);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_get_value is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the value of a characteristic or descriptor handle as an <span style="font-family: Courier New,Courier,monospace;">integer</span> type:
<pre class="prettyprint">
int ret = 0;
int offset = 0;
bt_data_type_int_e type;
bt_gatt_h gatt_handle = NULL;
int value;

// Assuming all the input parameters (gatt_handle, type, and offset) are available

ret = bt_gatt_get_int_value(gatt_handle, type, offset, &amp;value);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_get_int_value is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the value of a characteristic or descriptor handle as a <span style="font-family: Courier New,Courier,monospace;">float</span> type:
<pre class="prettyprint">
int ret = 0;
int offset = 0;
bt_data_type_float_e type;
bt_gatt_h gatt_handle = NULL;
float value;

// Assuming all the input parameters (gatt_handle, type, and offset) are available

ret = bt_gatt_get_float_value(gatt_handle, type, offset, &amp;value);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_get_float_value is failed : %d&quot;, ret);
}
</pre></li>

<li>Get a service handle with a specific UUID:
<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
bt_gatt_h svc = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);
}
</pre></li>

<li>Get a characteristic handle with a specific UUID:
<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;break;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);
}
</pre></li>

<li>Get a descriptor handle with a specific UUID:
<pre class="prettyprint">
char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level
char *desc_uuid = &quot;00002902-0000-1000-8000-00805f9b34fb&quot;; // Client characteristic configuration
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;
bt_gatt_h desc = NULL;

ret = bt_gatt_client_get_service(client, svc_uuid, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_client_get_service is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;break;
}

ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_characteristic is failed : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;break;
}

ret = bt_gatt_characteristic_get_descriptor(chr, desc_uuid, &amp;desc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_descriptor is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the properties using the characteristic handle:
<pre class="prettyprint">
bt_gatt_h chr = NULL;
int properties;

// Get the characteristic handle using bt_gatt_service_get_characteristic()

ret = bt_gatt_characteristic_get_properties(chr, &amp;properties);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_properties is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the service handle to which the specified characteristic belongs:
<pre class="prettyprint">
bt_gatt_h svc = NULL;
bt_gatt_h chr = NULL;
// chr = Assuming characteristic handle is already available

ret = bt_gatt_characteristic_get_service(chr, &amp;svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_service is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the characteristic handle to which the specified descriptor belongs:
<pre class="prettyprint">
bt_gatt_h chr = NULL;
bt_gatt_h dsc = NULL;
// dsc = Assuming descriptor handle is already available

ret = bt_gatt_descriptor_get_characteristic(dsc, &amp;chr);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_descriptor_get_characteristic is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the client handle to which the specified service belongs:
<pre class="prettyprint">
bt_gatt_h svc = NULL;
bt_gatt_client_h client = NULL;
// svc = Assuming service handle is already available

ret = bt_gatt_service_get_client(svc, &amp;client);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_client is failed : %d&quot;, ret);
}
</pre></li>

<li>Get the write type of the specified characteristic:
<pre class="prettyprint">
bt_gatt_h chr = NULL;
bt_gatt_write_type_e write_type;
// svc = Assuming characteristic handle is already available

ret = bt_gatt_characteristic_get_write_type(chr, &amp;write_type);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_characteristic_get_write_type is failed : %d&quot;, ret);
}
</pre></li>

<li>Get an included service&#39;s handle with a specific UUID:
<pre class="prettyprint">
bt_gatt_h svc = NULL;
bt_gatt_h included_svc = NULL;
char *uuid = NULL;
bt_gatt_write_type_e write_type = NULL;
// svc = Assuming service handle and UUID are already available

ret = bt_gatt_service_get_included_service(svc, uuid, &amp;included_svc);
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;bt_gatt_service_get_included_service is failed : %d&quot;, ret);
}
</pre></li>

</ul>

<h2 id="gatt_setter" name="gatt_setter">Managing Common GATT Setter Operations</h2>


<p>To set the client properties and attribute values:</p>
<ul>

<li>Set or update the characteristic value (<span style="font-family: Courier New,Courier,monospace">unit8</span> or <span style="font-family: Courier New,Courier,monospace">char</span> type value):
<pre class="prettyprint">
int ret = 0;
char char_value[1] = {1 + (rand()%100)};
bt_gatt_h characteristic_handle = NULL;

// For client, the characteristic handle is retrieved from the client created using gatt_client_create()
// by using bt_gatt_service_get_characteristic()

ret = bt_gatt_set_value(characteristic_handle, char_value, 1);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
</pre></li>

<li>Set or update the characteristic value (<span style="font-family: Courier New,Courier,monospace">integer</span> type value):
<pre class="prettyprint">
int ret = 0;
int char_value = 60 + (rand()%60);
bt_gatt_h characteristic_handle = NULL;

// For client, the characteristic handle is retrieved from the client created using gatt_client_create()
// by using bt_gatt_service_get_characteristic()

ret = bt_gatt_set_int_value(characteristic_handle, BT_DATA_TYPE_UINT16, char_value, 1);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
</pre></li>

<li>Set or update the characteristic value (<span style="font-family: Courier New,Courier,monospace">float</span> type value):
<pre class="prettyprint">
int ret = 0;
bt_gatt_h characteristic_handle = NULL;

// For client, the characteristic handle is retrieved from the client created using gatt_client_create()
// by using bt_gatt_service_get_characteristic()

// Here the char value is, value: 123 exponent -2
ret = bt_gatt_set_float_value(characteristic_handle, BT_DATA_TYPE_FLOAT, 123, -2, 1);
if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);
</pre></li>

<li>Set the characteristic write type:
<pre class="prettyprint">
void 
__write_completed_cb(int result, bt_gatt_h request_handle, void *user_data) 
{
&nbsp;&nbsp;if (result != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Write request failed&quot;);
}

int 
main()
{
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;bt_gatt_h svc = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h battery_svc = NULL;
&nbsp;&nbsp;&nbsp;bt_gatt_h control_point = NULL;
&nbsp;&nbsp;&nbsp;char *svc_uuid = &quot;0000180f-0000-1000-8000-00805f9b34fb&quot;; // Battery service
&nbsp;&nbsp;&nbsp;char *chr_uuid = &quot;00002a19-0000-1000-8000-00805f9b34fb&quot;; // Battery level

&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_get_service(client, svc_uuid, &amp;battery_svc);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_service_get_characteristic(svc, chr_uuid, &amp;control_point);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_characteristic_set_write_type(control_point, BT_GATT_WRITE_TYPE_WRITE);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_set_value(control_point, value, len);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

&nbsp;&nbsp;&nbsp;ret = bt_gatt_client_write_value(control_point, __write_completed_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret == BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Success&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre></li>
</ul>


  <h2 id="exc" name="exc">Exchanging Data Using OPP</h2>	
			
<p>The OPP is a basic profile for sending objects, such as pictures, virtual business cards, or schedules. The sender, which is a client, always initiates the transactions (called &quot;push&quot;), not the receiver, which is a server.</p>
<p>To exchange data with Object Push Profile (OPP):</p>	
<ul>
<li>Exchange data in a server role:
<ol>
<li>
<p>Initialize the OPP server to be ready for client connections using the <span style="font-family: Courier New,Courier,monospace">bt_opp_server_initialize_by_connection_request()</span> function.</p>
<p>The second parameter defines a callback that is invoked whenever a client requests an OPP connection to the server.
</p>
<pre class="prettyprint">
bt_error_e ret;
char *directory = NULL;
storage_get_directory(0, STORAGE_DIRECTORY_DOWNLOADS, &amp;directory);

void 
connection_requested_cb_for_opp_server(const char *remote_address, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}

ret = bt_opp_server_initialize_by_connection_request(directory, connection_requested_cb_for_opp_server, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_initialize_by_connection_request] Failed.&quot;);
}
free(directory);
</pre>
</li>
<li>
<p>When a client requests a file push, accept or reject it using the following functions:</p>
<pre class="prettyprint">
bt_error_e ret;
const char file_name [18] = &quot;tempfile&quot;;

void 
bt_opp_server_transfer_progress_cb_for_opp(const char *file, long long size, int percent, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
}

void 
bt_opp_server_transfer_finished_cb_for_opp(int result, const char *file, long long size, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, size);
}

ret = bt_opp_server_accept(bt_opp_server_transfer_progress_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_opp_server_transfer_finished_cb_for_opp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_name, NULL, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_accept] Failed.&quot;);
}

ret = bt_opp_server_reject();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_server_reject] Failed.&quot;);
}
</pre>
</li>
</ol>
</li>
<li>Exchange data in a client role:
<ol>
<li>
<p>Initialize the client using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_initialize()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;

ret = bt_opp_client_initialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
</li>
<li>
<p>Define the information of the file that can be sent to the server device using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_add_file()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char *resource_path = NULL;
char caller_id_path[1024] = {&#39;\0&#39;, };

resource_path = app_get_resource_path();
snprintf(caller_id_path, sizeof(caller_id_path)-1, &quot;%s/image1.jpg&quot;, resource_path);
free(resource_path);

ret = bt_opp_client_add_file(caller_id_path);

if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_add_file() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
</li>
<li>
<p>Send the file to the server using the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_push_files()</span> function:</p>
<pre class="prettyprint">
bt_error_e ret;
char remote_addr[18] = REMOTE_DEVICE_MAC_ADDRESS;

void 
__bt_opp_client_push_responded_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}

void 
__bt_opp_client_push_progress_cb(const char *file,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long long size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int percent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;size: %ld&quot;, (long)size);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;percent: %d&quot;, percent);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;file: %s&quot;, file);
}

void 
__bt_opp_client_push_finished_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *remote_address,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;result: %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;remote_address: %s&quot;, remote_address);
}

ret = bt_opp_client_push_files(remote_addr, __bt_opp_client_push_responded_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_progress_cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__bt_opp_client_push_finished_cb, NULL);
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_opp_client_push_files] Failed.&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;[bt_opp_client_push_files] Succeeded.&quot;);
}
</pre>
</li>
<li>
<p>After the push is finished by the client, call the <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_clear_files()</span> and <span style="font-family: Courier New,Courier,monospace;">bt_opp_client_deinitialize()</span> to release the Bluetooth resources related to the OPP client:</p>
<pre class="prettyprint">
bt_error_e ret;

// Delete file info
ret = bt_opp_client_clear_files();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_clear_files() fail&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}

ret = bt_opp_client_deinitialize();
if (ret != BLUETOOTH_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;ERR(&quot;bt_opp_client_initialize &quot;);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;bt_opp_client_initialize Failed.&quot;);

&nbsp;&nbsp;&nbsp;return -1;
}
</pre>
</li>
</ol>
</li>
</ul>


	<h2 id="le_scan" name="le_scan">Managing Bluetooth LE Scans</h2>
	
	<p>To discover nearby LE devices, perform an LE scan operation:</p>
	<ol>
	<li>
	<p>To start the BLE scan:</p>
	
<pre class="prettyprint">
int 
main()
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_start_scan(__bt_adapter_le_scan_result_cb, NULL);

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_start_scan] Failed.&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return;
}
</pre>
	</li>
	
	<li><p>Use the callback defined in the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_start_scan()</span> function to retrieve the scan results. The callback contains information of all the LE scanned devices, such as the device names, scanned devices' transmission level, service data list, appearance of the devices, and manufacture data of the devices.</p>
	<p>To handle the scan result:</p>
	
	<pre class="prettyprint">
int ret, i;

void 
__bt_adapter_le_scan_result_cb(int result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_scan_result_info_s *info, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;bt_adapter_le_packet_type_e pkt_type = BT_ADAPTER_LE_PACKET_ADVERTISING;

&nbsp;&nbsp;&nbsp;if (info == NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;No discovery_info!&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (info-&gt;adv_data_len &gt; 31 || info-&gt;scan_data_len &gt; 31) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;###################&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_stop_scan();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print (DLOG_INFO, LOG_TAG, &quot;###################&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 2; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char **uuids;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *device_name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int tx_power_level;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_service_data_s *data_list;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int appearance;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int manufacturer_id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *manufacturer_data;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int manufacturer_data_len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkt_type += i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pkt_type == BT_ADAPTER_LE_PACKET_ADVERTISING &amp;&amp; info-&gt;adv_data == NULL) continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pkt_type == BT_ADAPTER_LE_PACKET_SCAN_RESPONSE &amp;&amp; info-&gt;scan_data == NULL) break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_uuids(info, pkt_type, &amp;uuids, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;UUID[%d] = %s&quot;, i + 1, uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_device_name(info, pkt_type, &amp;device_name) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Device name = %s&quot;, device_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(device_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_tx_power_level(info, pkt_type, &amp;tx_power_level) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;TX Power level = %d&quot;, tx_power_level);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_solicitation_uuids(info, pkt_type, &amp;uuids, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Solicitation UUID[%d] = %s&quot;, i + 1, uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(uuids);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_service_data_list(info, pkt_type, &amp;data_list, &amp;count) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; count; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Service Data[%d] = [0x%2.2X%2.2X:0x%.2X...]&quot;, i + 1, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_list[i].service_uuid[0], data_list[i].service_uuid[1], data_list[i].service_data[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_free_service_data_list(data_list, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_appearance(info, pkt_type, &amp;appearance) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Appearance = %d&quot;, appearance);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bt_adapter_le_get_scan_result_manufacturer_data(info, pkt_type, &amp;manufacturer_id, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;manufacturer_data, &amp;manufacturer_data_len) == BT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Manufacturer data[ID:%.4X, 0x%.2X%.2X...(len:%d)]&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id, manufacturer_data[0], manufacturer_data[1], manufacturer_data_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_free(manufacturer_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

</li>

<li>
	<p>To stop the BLE scan operation:</p>
<pre class="prettyprint">
int 
main()
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_stop_scan();

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_stop_scan] Failed.&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return;
}
</pre>	
</li>
</ol>

<h2 id="le_discovery" name="le_discovery">Discovering Bluetooth LE Devices</h2>

<p>Perform the LE discovery operation to discover nearby Bluetooth LE devices. You can register and unregister a callback for the LE discovery operation through the set and unset callback functions. The registered device discovery callback provides details of the discovered devices and the state of the discovery (started, finished, found).</p>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">The APIs used in this use case are deprecated since Tizen 2.3.1. For scanning nearby BLE devices in Tizen 2.3.1 and later, see <a href="#le_scan">Managing Bluetooth LE Scans</a>.</td> 
    </tr> 
   </tbody> 
  </table>  

<p>To start the BLE discovery operation:</p>

<pre class="prettyprint">
static void 
__bt_adapter_le_device_discovery_state_changed_cb(int result, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_state_e discovery_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_device_discovery_info_s *discovery_info, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (discovery_info == NULL &amp;&amp; discovery_state == BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;No discovery_info!.&quot;);

&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;if (discovery_state != BT_ADAPTER_LE_DEVICE_DISCOVERY_FOUND) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;LE discovery %s&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discovery_state == BT_ADAPTER_LE_DEVICE_DISCOVERY_STARTED? &quot;Started&quot; : &quot;Finished&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;%s Adv %d Scan resp %d RSSI %d Addr_type %d&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discovery_info-&gt;remote_address, discovery_info-&gt;adv_data_len, discovery_info-&gt;scan_data_len, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discovery_info-&gt;rssi, discovery_info-&gt;address_type);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discovery_info-&gt;adv_data_len &gt; 31 || discovery_info-&gt;scan_data_len &gt; 31)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_stop_device_discovery();
&nbsp;&nbsp;&nbsp;}
}

int 
main()
{
&nbsp;&nbsp;&nbsp;int ret = BT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_set_device_discovery_state_changed_cb(__bt_adapter_le_device_discovery_state_changed_cb, NULL);

&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_start_device_discovery();

&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_start_device_discovery] Failed.&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// To unset the LE device discovery state change callback
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_unset_device_discovery_state_changed_cb();

&nbsp;&nbsp;&nbsp;return;
}
</pre>
	
	<h2 id="add_adv_data" name="add_adv_data">Adding Advertising Data to the LE Advertisement</h2> 
	
	<p>LE advertising data can be added to the LE advertisement or the scan response data. You can add various information, such as the device name, service UUID, service solicitation UUID, advertising appearance, advertising transmission power level, device name, and manufacturer data.</p>
	<p>To add the advertising data:</p>
<ol>
<li>
<p>Create an advertiser and add the advertising data to it:</p>

<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL,};
static int advertiser_index = 0;

int manufacturer_id = 117;
char *manufacture = NULL;
char manufacture_0[] = {0x0, 0x0, 0x0, 0x0};
char manufacture_1[] = {0x01, 0x01, 0x01, 0x01};
char manufacture_2[] = {0x02, 0x02, 0x02, 0x02};
char manufacture_3[] = {0x03, 0x03, 0x03, 0x03};
char service_data[] = {0x01, 0x02, 0x03};
const char *time_svc_uuid_16 = &quot;1805&quot;;
const char *battery_svc_uuid_16 = &quot;180f&quot;;
const char *heart_rate_svc_uuid_16 = &quot;180d&quot;;
const char *immediate_alert_svc_uuid_16 = &quot;1802&quot;;
const char *ancs_uuid_128 = &quot;7905F431-B5CE-4E99-A40F-4B1E122D00D0&quot;;
int appearance = 192;  // 192 is a generic watch

advertiser = advertiser_list[advertiser_index];

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
} 
else 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_clear_advertising_data(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;clear advertising data [0x%04x]&quot;, ret);
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_clear_advertising_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE);
&nbsp;&nbsp;&nbsp;if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;clear scan response data [0x%04x]&quot;, ret);
}

ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

ret = bt_adapter_le_add_advertising_service_uuid(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;battery_svc_uuid_16);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_uuid [0x%04x]&quot;, ret);

ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BT_ADAPTER_LE_PACKET_ADVERTISING,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heart_rate_svc_uuid_16);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

ret = bt_adapter_le_add_advertising_service_solicitation_uuid(advertiser, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BT_ADAPTER_LE_PACKET_ADVERTISING,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;immediate_alert_svc_uuid_16);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_solicitation_uuid [0x%04x]&quot;, ret);

ret = bt_adapter_le_set_advertising_appearance(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, appearance);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add appearance data [0x%04x]&quot;, ret);

ret = bt_adapter_le_set_advertising_tx_power_level(advertiser, BT_ADAPTER_LE_PACKET_ADVERTISING, true);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add tx_power_level [0x%04x]&quot;, ret);

manufacture = manufacture_3;

// Default scan response data 
ret = bt_adapter_le_add_advertising_service_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_svc_uuid_16, service_data, sizeof(service_data));
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add service_data [0x%04x]&quot;, ret);

ret = bt_adapter_le_set_advertising_device_name(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, true);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;set device name [0x%04x]&quot;, ret);

ret = bt_adapter_le_add_advertising_manufacturer_data(advertiser, BT_ADAPTER_LE_PACKET_SCAN_RESPONSE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer_id, manufacture, sizeof(manufacture_0));
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add manufacturer data [0x%04x]&quot;, ret);
</pre>
</li>
<li>
<p>When you are done, destroy the LE advertiser:</p>
<pre class="prettyprint">
int ret = BT_ERROR_NONE;
ret = bt_adapter_le_destroy_advertiser(advertiser);
 
if (ret != BT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_adapter_le_destroy_advertiser] Failed.&quot;);
}

return;
</pre>
</li>
</ol>
	
	<h2 id="set_adv_conn" name="set_adv_conn">Setting the LE Advertising Connectable Mode</h2>

	<p>When advertising to a remote device, use the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_set_advertising_connectable()</span> function to define whether the advertising type is connectable or non-connectable:</p>

<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL,};
static int advertiser_index = 0;
int type = BT_ADAPTER_LE_ADVERTISING_CONNECTABLE;

advertiser = advertiser_list[advertiser_index];

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

ret = bt_adapter_le_set_advertising_connectable(advertiser, type);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add scan response data [0x%04x]&quot;, ret);
</pre>
	
	<h2 id="set_adv_mode" name="set_adv_mode">Setting the LE Advertising Mode</h2>
	
<p>The advertising mode controls the advertising power and latency, and can be set to be balanced, low latency, or low energy.</p>

<p>To set the advertising mode:</p>


<pre class="prettyprint">
static bt_advertiser_h advertiser = NULL;
static bt_advertiser_h advertiser_list[3] = {NULL,};
static int advertiser_index = 0;

int mode = BT_ADAPTER_LE_ADVERTISING_MODE_BALANCED;

advertiser = advertiser_list[advertiser_index];

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

ret = bt_adapter_le_set_advertising_mode(advertiser, mode);
if (ret != BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;add scan response data [0x%04x]&quot;, ret);
</pre>
	
	<h2 id="start_adv" name="start_adv">Starting and Stopping LE Advertising</h2>
<p>To manage advertising:</p>
<ol>
<li>
<p>To start advertising with the given advertiser and advertising parameters information, use the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_start_advertising_new()</span> function:</p>

<pre class="prettyprint">
static void 
__bt_adapter_le_advertising_state_changed_cb(int result, bt_advertiser_h advertiser, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_advertising_state_e adv_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Result : %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertiser : %p&quot;, advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertising %s [%d]&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adv_state == BT_ADAPTER_LE_ADVERTISING_STARTED ? &quot;started&quot; : &quot;stopped&quot;, adv_state);
}

static void 
__bt_adapter_le_advertising_state_changed_cb_2(int result, bt_advertiser_h advertiser, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_advertising_state_e adv_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Result : %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertiser : %p&quot;, advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertising %s [%d]&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adv_state == BT_ADAPTER_LE_ADVERTISING_STARTED ? &quot;started&quot; : &quot;stopped&quot;, adv_state);
}

static void 
__bt_adapter_le_advertising_state_changed_cb_3(int result, bt_advertiser_h advertiser, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bt_adapter_le_advertising_state_e adv_state, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Result : %d&quot;, result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertiser : %p&quot;, advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;Advertising %s [%d]&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adv_state == BT_ADAPTER_LE_ADVERTISING_STARTED ? &quot;started&quot; : &quot;stopped&quot;, adv_state);
}

bt_adapter_le_advertising_state_changed_cb cb;

if (advertiser_index == 0) cb = __bt_adapter_le_advertising_state_changed_cb;
else if (advertiser_index == 1) cb = __bt_adapter_le_advertising_state_changed_cb_2;
else cb = __bt_adapter_le_advertising_state_changed_cb_3;

advertiser = advertiser_list[advertiser_index];
advertiser_index++;
advertiser_index %= 3;

if (advertiser == NULL) 
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_create_advertiser(&amp;advertiser);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;created le advertiser(%d)&quot;, ret);
&nbsp;&nbsp;&nbsp;advertiser_list[advertiser_index] = advertiser;
}

ret = bt_adapter_le_start_advertising_new(advertiser, cb, NULL);
if (ret &lt; BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;failed with [0x%04x]&quot;, ret);
</pre>
</li>
<li>
<p>To stop advertising with the given advertiser, use the <span style="font-family: Courier New,Courier,monospace;">bt_adapter_le_stop_advertising()</span> function:</p>

<pre class="prettyprint">
if (advertiser != NULL)
{
&nbsp;&nbsp;&nbsp;ret = bt_adapter_le_stop_advertising(advertiser);
&nbsp;&nbsp;&nbsp;if (ret &lt; BT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;failed with [0x%04x]&quot;, ret);
}
</pre></li>
</ol>
	

 <h2 id="release" name="release">Releasing All Resources</h2>

<p>To release all Bluetooth resources, call the <span style="font-family: Courier New,Courier,monospace;">bt_deinitialize()</span> function:</p>
<pre class="prettyprint">
// Unregister callbacks
bt_adapter_unset_state_changed_cb();
bt_adapter_unset_device_discovery_state_changed_cb();
bt_device_unset_service_searched_cb();
bt_socket_unset_data_received_cb();
bt_socket_unset_connection_state_changed_cb();
 
// Release resources

// Deinitialize Bluetooth
ret = bt_deinitialize();
if (ret != BT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;[bt_deinitialize] Failed.&quot;);
}</pre>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

 </body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>STT: Recognizing Speech</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#create">Creating and Destroying STT Handles</a></li>
			<li><a href="#set">Setting and Unsetting Callbacks</a></li>
			<li><a href="#get">Getting Information</a></li>
			<li><a href="#prepare">Connecting and Disconnecting the STT</a></li>
			<li><a href="#option">Setting Options and Controlling Recording</a>
			</li>
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/uix/stt_n.htm">STT Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">STT API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">STT API for Wearable Native</a></li>
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>STT: Recognizing Speech</h1>


<p>This tutorial demonstrates how you can recognize sound data recorded by user and send the result as text.</p>  

				
<h2>Warm-up</h2>
<p>Become familiar with the STT API basics by learning about:</p>
	<ul>
		<li><a href="#create">Creating and Destroying STT Handles</a>
		<p>Create and destroy the STT handle.</p></li>

		<li><a href="#set">Setting and Unsetting Callbacks</a>
		<p>Set and unset callbacks for obtaining notifications about recognition results, state changes, and errors.</p></li>

		<li><a href="#get">Getting Information</a>
		<p>Get information that includes, for example, language and state.</p></li>

		<li><a href="#prepare">Connecting and Disconnecting the STT</a>
		<p>Connect and disconnect the STT.</p></li>

		<li><a href="#option">Setting Options and Controlling Recording</a>
		<p>Set the options and control recording for the STT.</p></li>
	</ul>

<h2 id="create" name="create">Creating and Destroying STT Handles</h2>

<p>To create and destroy STT handles:</p>
<ol><li>To use the features of the STT (speech-to-text) API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file in your application:
<pre class="prettyprint">
#include &lt;stt.h&gt;</pre>
</li>			
<li><p>To use the STT library, create an STT handle. The STT handle is used for other STT functions as a parameter. After creating the handle, the STT state is changed to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_CREATED</span>.</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">STT is not thread-safe and depends on the ecore main loop. Therefore, you must have the ecore main loop. Do not use STT in a thread.</td> 
		</tr> 
	   </tbody> 
	  </table> 

<pre class="prettyprint">
void create_stt_handle()
{
&nbsp;&nbsp;&nbsp;stt_h stt;
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_create(&amp;stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != result)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
<li><p>When you do not need the STT library anymore, destroy the STT handle using the <span style="font-family: Courier New,Courier,monospace;">stt_destroy()</span> function:</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">Do not use the <span style="font-family: Courier New,Courier,monospace;">stt_destroy()</span> function within the callback function, or the <span style="font-family: Courier New,Courier,monospace;">stt_destroy()</span> function fails and returns <span style="font-family: Courier New,Courier,monospace;">STT_ERROR_OPERATION_FAILED</span>.</td> 
		</tr> 
	   </tbody> 
	  </table> 

<pre class="prettyprint">
void destroy_stt_handle(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_destroy(stt); // stt is the STT handle
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != result)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre></li> </ol>

<h2 id="set" name="set" >Setting and Unsetting Callbacks</h2>

<p>To set and unset callbacks:</p>
<ol><li>To use the features of the STT (speech-to-text) API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file in your application. The enum values for the callback function parameter are defined in the header file, as well as the parameter details.
<pre class="prettyprint">
#include &lt;stt.h&gt;</pre>
</li>
<li><p>The STT API provides various callback functions used to get the information including the recognition result, state changes, language changes, and errors. Call the callback functions in the <span style="font-family: Courier New,Courier,monospace;">STT_STATE_CREATED</span> state.</p>

<p>You can use the following callbacks:</p>
<ul>
<li>State changed
<p>If you set the state changed callback for the STT, it is invoked when a state is changed by the STT.</p>
<pre class="prettyprint">
void state_changed_cb(stt_h stt, stt_state_e previous, stt_state_e current, void* user_data)
{ 
&nbsp;&nbsp;&nbsp;// Your code 
}
void set_state_changed_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_state_changed_cb(stt, state_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling 
&nbsp;&nbsp;&nbsp;}
}
void unset_state_changed_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unset_state_changed_cb(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>Default language changed
<p>The default language of the STT is changed either when the system language is changed, or through the STT settings. You can get the notification of this change if you set a callback for it.</p>
<pre class="prettyprint">
void default_language_changed_cb(stt_h stt, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char* previous_language,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char* current_language, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void* user_data)
{
&nbsp;&nbsp;&nbsp;// Your code 
}
void set_default_language_changed_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_default_language_changed_cb(stt, default_language_changed_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
void unset_default_language_changed_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unset_default_language_changed_cb(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Recognition result 
<p>To get the STT recognition result, set the recognition result callback function.</p>
<p>The <span style="font-family: Courier New,Courier,monospace;">stt_foreach_detailed_result()</span> function retrieves the time stamp of the current recognition result, so it can be called within the <span style="font-family: Courier New,Courier,monospace;">stt_recognition_result_cb()</span> callback function.</p>
<pre class="prettyprint">
bool result_time_cb(stt_h stt, int index, stt_result_time_event_e event, const char* text,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long start_time, long end_time, void* user_data)
{
&nbsp;&nbsp;&nbsp;// Your code 
}

void recognition_result_cb(stt_h stt, stt_result_event_e event, const char** data, int 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_count, const char* msg, void* user_data)
{
&nbsp;&nbsp;&nbsp;// If you want to get time info of result 
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_foreach_detailed_result(stt, result_time_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// Your code 
}

void set_recognition_result_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_recognition_result_cb(stt, recognition_result_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}

void unset_recognition_result_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unset_recognition_result_cb(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Error
<p>When an error occurs, the STT library sends an error message using a callback function:</p>
<pre class="prettyprint">
void error_cb(stt_h stt, stt_error_e reason, void* user_data)
{
&nbsp;&nbsp;&nbsp;// Your code 
}

void set_error_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_error_cb(stt, error_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}

void unset_error_cb(stt_h stt)
{
&nbsp;&nbsp;&nbsp;Int ret;
&nbsp;&nbsp;&nbsp;Ret = stt_unset_error_cb(stt);
&nbsp;&nbsp;&nbsp;If (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ul></li></ol> 

<h2 id="get" name="get">Getting Information</h2>

<p>To get information of the current STT state and the languages used:</p>
<ol><li>To use the features of the STT (speech-to-text) API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file in your application:
<pre class="prettyprint">
#include &lt;stt.h&gt;</pre>
</li>
<li><p>You can obtain the current STT state, the list of supported languages, and the current language:</p>
<ul>
<li>Get the current state.
<p>The STT state is changed by other functions. It is also applied as a precondition for each function. Get the current state using the <span style="font-family: Courier New,Courier,monospace;">stt_get_state()</span> function.</p>
<pre class="prettyprint">
void get_state(stt_h stt)
{
&nbsp;&nbsp;&nbsp;stt_state_e current_state;
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_get_state(stt, &amp;current_state);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Obtain a list of languages supported by the STT using the <span style="font-family: Courier New,Courier,monospace;">stt_foreach_supported_languages()</span> function. The <span style="font-family: Courier New,Courier,monospace;">stt_supported_language_cb</span> callback is invoked for each supported language repeatedly. You can continue or stop getting the supported languages through the return value of the callback function.
<pre class="prettyprint">
bool supported_language_cb(stt_h stt, const char* language, void* user_data)
{
&nbsp;&nbsp;&nbsp;return true; // Get next supported language 

&nbsp;&nbsp;&nbsp;return false; // Stop 
}

void get_supported_language(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_foreach_supported_languages(stt, supported_language_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Get the default language using the <span style="font-family: Courier New,Courier,monospace;">stt_get_default_language()</span> function. The recognition of the STT works for this default language if you do not set the language as a parameter of the <span style="font-family: Courier New,Courier,monospace;">stt_start()</span> function. You can get a notification about the default language by changing the callback function that changes the default language.
<pre class="prettyprint">
void get_default_language(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char* default_lang = NULL;
&nbsp;&nbsp;&nbsp;ret = stt_get_default_language(stt, &amp;default_lang);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Obtain a list of engines supported by the STT using the <span style="font-family: Courier New,Courier,monospace;">stt_foreach_supported_engines()</span> function. When this function is called, the <span style="font-family: Courier New,Courier,monospace;">stt_supported_engine_cb</span> callback is invoked repeatedly for each supported engine. You can continue or stop getting the supported engine through the return value of the callback function.
<pre class="prettyprint">
bool supported_engine_cb(stt_h stt, const char* engine_id, const char* engine_name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void* user_data)
{
&nbsp;&nbsp;&nbsp;return true; // Get next supported language 

&nbsp;&nbsp;&nbsp;return false; // Stop 
}

void get_supported_engine(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_foreach_supported_engines(stt, supported_engine_cb, NULL);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Get or set the current engine, which is used for the STT recognition, using the <span style="font-family: Courier New,Courier,monospace;">stt_set_engine()</span> and <span style="font-family: Courier New,Courier,monospace;">stt_get_engine()</span> functions.
<p>The supported language, silence detection, and supported recognition types depend on the STT engine.</p>
<pre class="prettyprint">
// Get the engine 
void get_current_engine(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char* current_engine_id = NULL;
&nbsp;&nbsp;&nbsp;ret = stt_get_engine(stt, &amp;current_engine_id);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}

// Set the engine 
void set_current_engine(stt_h stt, const char* engine_id)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_engine(stt, engine_id);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Get the supported recognition types. Check whether the recognition type defined in the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file is supported.
<p>The normal recognition type, <span style="font-family: Courier New,Courier,monospace;">STT_RECOGNITION_TYPE_FREE</span>, means that the whole recognition result is sent at the end of recognition and that the STT engine supports it. To get a partial recognition result, use the <span style="font-family: Courier New,Courier,monospace;">STT_RECOGNITION_TYPE_FREE_PARTIAL</span> recognition type, if it is supported by the current engine.</p>
<pre class="prettyprint">
void check_supported_recognition_type(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;bool support;
&nbsp;&nbsp;&nbsp;ret = stt_is_recognition_type_supported(stt, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STT_RECOGNITION_TYPE_FREE_PARTIAL, &amp;support);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ul></li></ol>

<h2 id="prepare" name="prepare">Connecting and Disconnecting the STT</h2>

<p>To operate the STT:</p>
		<ol><li>To use the features of the STT (speech-to-text) API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file in your application:
		<pre class="prettyprint">
#include &lt;stt.h&gt;</pre>
		</li>
		<li><p>After you create the STT handle, connect the background STT daemon:</p>
		<ul>
		<li>
		<p>The <span style="font-family: Courier New,Courier,monospace;">stt_prepare()</span> function is asynchronous and the STT state changes to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span>:</p>

<pre class="prettyprint">
void prepare_for_stt(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_prepare(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}</pre>

		<table class="note"> 
			   <tbody> 
				<tr> 
				 <th class="note">Note</th> 
				</tr> 
				<tr> 
				 <td class="note">If you get the error callback after calling the <span style="font-family: Courier New,Courier,monospace;">stt_prepare()</span> function, STT is not available.</td> 
				</tr> 
			   </tbody> 
			  </table> 
		</li>
		<li>
		<p>The <span style="font-family: Courier New,Courier,monospace;">stt_unprepare()</span> function disconnects the STT, and the state is changed to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_CREATED</span>:</p>

		<pre class="prettyprint">void unprepared_for_stt(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unprepare(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}</pre>
		</li>
		</ul>
		</li>
		</ol>

<h2 id="option" name="option">Setting Options and Controlling Recording</h2>

<p>To set the STT options and control recording:</p>
<ol><li>To use the features of the STT (speech-to-text) API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__UIX__STT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__UIX__STT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace;">&lt;stt.h&gt;</span> header file in your application:
<pre class="prettyprint">
#include &lt;stt.h&gt;</pre>
</li>
<li><p>You can set the following STT options:</p>
<ul>
<li>Set silence detection.
<p>After the STT starts recognizing sound, some STT engines can detect silence when the sound input from the user ends. If silence detection is enabled, the STT library stops recognition automatically and sends the result. Otherwise, you can manually stop it using the <span style="font-family: Courier New,Courier,monospace;">stt_stop()</span> function.</p>
<p>If you set the silence detection as automatic, STT works as a global STT setting. This option must be set in the <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span> state.</p>
<pre class="prettyprint">
void set_silence_detection(stt_h stt, stt_option_silence_detection_e type)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;// The default type is STT_OPTION_SILENCE_DETECTION_AUTO 
&nbsp;&nbsp;&nbsp;ret = stt_set_silence_detection(stt, type); 
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Set and unset the starting sound.
<p>To play a sound before the STT recognition starts, call the <span style="font-family: Courier New,Courier,monospace;">set_start_sound()</span> function in the <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span> state.</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">The sound file path must be a full path. The sound type supports only the WAV format.</td> 
		</tr> 
	   </tbody> 
	  </table> 

<pre class="prettyprint">
void set_start_sound(stt_h stt, const char* filename)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_start_sound(stt, filename);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}

void unset_start_sound(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unset_start_sound(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Set or unset the stop sound.
<p>To play a sound when the STT stops, use the <span style="font-family: Courier New,Courier,monospace;">stt_set_stop_sound()</span> function in the <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span> state:</p>

	  <table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">The sound file path must be a full path. The sound type supports only the WAV format.</td> 
		</tr> 
	   </tbody> 
	  </table> 
	  
<pre class="prettyprint">
void set_stop_sound(stt_h stt, const char* filename)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_set_stop_sound(stt, filename);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}

void unset_stop_sound(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_unset_stop_sound(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>Start, stop, and cancel recognition:
	<ul>
		<li><p>To start recording, use the <span style="font-family: Courier New,Courier,monospace;">stt_start()</span> function. The connected STT daemon starts recording, and the state is changed to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_RECORDING</span>.</p>
		<table class="note"> 
	   <tbody> 
		<tr> 
		 <th class="note">Note</th> 
		</tr> 
		<tr> 
		 <td class="note">If the <span style="font-family: Courier New,Courier,monospace;">stt_start()</span> function fails, check the error code. You can get the following error codes: 
		 <ul>
		 <li><span style="font-family: Courier New,Courier,monospace;">STT_ERROR_RECORDER_BUSY</span></li>
		 <li><span style="font-family: Courier New,Courier,monospace;">STT_ERROR_OUT_OF_NETWORK</span></li>
		 <li><span style="font-family: Courier New,Courier,monospace;">STT_ERROR_INVALID_STATE</span></li>
		 <li><span style="font-family: Courier New,Courier,monospace;">STT_ERROR_INVALID_LANGUAGE</span></li>
		 </ul></td> 
		</tr> 
	   </tbody> 
	  </table> <p>The language and recognition type must be supported by the current STT engine. If you set <span style="font-family: Courier New,Courier,monospace;">NULL</span> as the language parameter, the STT default language is selected using the <span style="font-family: Courier New,Courier,monospace;">stt_get_default_language()</span> function.</p>

<pre class="prettyprint">
void start(stt_h stt, const char* language, const char* type)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_start(stt, language, type); // The default language is NULL
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li><p>When the STT recording is in process, you can retrieve the current recording volume using the <span style="font-family: Courier New,Courier,monospace;">stt_get_recording_volume()</span> function. The volume value is retrieved periodically with the short-term recorded sound data as dB (decibels). The STT volume normally has a negative value, and 0 is the maximum value.</p>
<pre class="prettyprint">
void get_volume(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;float current_volume;
&nbsp;&nbsp;&nbsp;ret = stt_get_recording_volume(stt, &amp;current_volume);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>To stop recording and get the recognition result, use the <span style="font-family: Courier New,Courier,monospace;">stt_stop()</span> function. The state is changed to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_PROCESSING</span>. The result is sent as a recognition result callback and the state is changed back to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span>.</p>
<pre class="prettyprint">
void stop(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_stop(stt);
&nbsp;&nbsp;&nbsp;if (STT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>To stop recording without getting the result, use the <span style="font-family: Courier New,Courier,monospace;">stt_cancel()</span> function. It changes the state to <span style="font-family: Courier New,Courier,monospace;">STT_STATE_READY</span>.</p>
<pre class="prettyprint">
void cancel(stt_h stt)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = stt_cancel(stt);
&nbsp;&nbsp;&nbsp;if (VC_STATIC_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ul>
</li>
</ul></li></ol>
	
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>


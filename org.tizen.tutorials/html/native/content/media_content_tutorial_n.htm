<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Media Content: Using Album, Bookmark, Playlist, and Other Media Content</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>		
		<ul class="toc">
			<li><a href="#initialize_media_content">Connecting to the Media Database</a></li>
			<li>Media content
				<ul class="toc">
					<li><a href="#folder_list">Getting the Folder List</a></li>
					<li><a href="#item_list">Getting the Item List</a></li>
					<li><a href="#update">Receiving Update Notifications</a></li>
				</ul>
			</li>
			<li>Album
				<ul class="toc">
					<li><a href="#findingall">Finding Albums</a></li>
					<li><a href="#read_album">Reading Album Information</a></li>
					<li><a href="#findinginfo">Retrieving Album Content</a></li>
				</ul>
			</li>
			<li>Bookmark
				<ul class="toc">
					<li><a href="#inserting">Inserting Bookmarks</a></li>
					<li><a href="#finding">Finding Bookmarks</a></li>
					<li><a href="#reading">Reading Bookmark Information</a></li>
					<li><a href="#removing">Removing Bookmarks</a></li>
				</ul>
			</li>
			<li>Filter
				<ul class="toc">
					<li><a href="#filter">Setting up a Filter</a></li>
				</ul>
			</li>
			<li>Folder
				<ul class="toc">
					<li><a href="#find">Finding Folders</a></li>
					<li><a href="#read_folder">Reading Folder Information</a></li>
					<li><a href="#folder_content">Retrieving Folder Content</a></li>
				</ul>
			</li>
			<li>Media information 
				<ul class="toc">
					<li><a href="#info">Retrieving Media Information</a></li>
					<li><a href="#insert">Inserting Media in the Database</a></li>
					<li><a href="#scan">Inserting a Media Folder in the Database</a></li>
				</ul>
			</li>
			<li>Playlist 
				<ul class="toc">
					<li><a href="#create_playlist">Creating Playlists</a></li>
					<li><a href="#find_playlist">Finding Playlists</a></li>
					<li><a href="#read_playlist">Reading Playlist Information</a></li>
					<li><a href="#delete_playlist">Deleting Playlists</a></li>
				</ul>  
			</li>
			<li>Tag
				<ul class="toc">
					<li><a href="#tag_add">Adding Tags</a></li>
					<li><a href="#tag_list">Retrieving Tag Information</a></li>
					<li><a href="#tag_delete">Deleting Tags</a></li>
				</ul>
			</li>
            <li>Storage
                <ul class="toc">
                    <li><a href="#storage_list">Retrieving Storage Information</a></li>
                </ul>
            </li>
			<li>Advanced media content
				<ul class="toc">
					<li><a href="#find_groups">Finding Media Item Groups</a></li>	
					<li><a href="#read_group">Reading Media Item Group Information</a></li>
				</ul>
			</li>
		</ul>       
        <p class="toc-title">Related Info</p>
        <ul class="toc">
             <li><a href="../../../../org.tizen.guides/html/native/content/media_content_n.htm">Media Content Guide</a></li>
			 <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">Media Content API for Mobile Native</a></li>
			 <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">Media Content API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Media Content: Using Album, Bookmark, Playlist, and Other Media Content</h1>

  
  <p>This tutorial demonstrates how you can manage media content.</p>

<h2>Warm-up</h2>
<p>Become familiar with the Media Content API basics by learning about:</p>
	<ul>
		<li><a href="#initialize_media_content">Connecting to the Media Database</a>
		<p>Initialize the media content for use and connect to the media database.</p></li>
		<li>Media content
			<ul>
				<li><a href="#folder_list">Getting the Folder List</a>
				<p>Get a folder list.</p></li>
				<li><a href="#item_list">Getting the Item List</a>
				<p>Get an item list.</p></li>
				<li><a href="#update">Receiving Update Notifications</a>
				<p>Manage an update notification callback.</p></li>
			</ul>
		</li>
		<li>Album
			<ul>
				<li><a href="#findingall">Finding Albums</a>
				<p>Find information about albums available in the system.</p></li>
				<li><a href="#read_album">Reading Album Information</a>
				<p>Get the album ID, artist name, and number of media items in the album.</p></li>
				<li><a href="#findinginfo">Retrieving Album Content</a>
				<p>Get information about the media items in an album.</p></li>
			</ul>
		</li>
		<li>Bookmark
			<ul>
				<li><a href="#inserting">Inserting Bookmarks</a>
				<p>Set a bookmark for a video file.</p></li>
				<li><a href="#finding">Finding Bookmarks</a>
				<p>Find bookmarks using a filter.</p></li>
				<li><a href="#reading">Reading Bookmark Information</a>
				<p>Read the details of a given bookmark.</p></li>
				<li><a href="#removing">Removing Bookmarks</a>
				<p>Remove a bookmark from a video file.</p></li>
			</ul>
		</li>
		<li>Filter
			<ul>
				<li><a href="#filter">Setting up a Filter</a>
				<p>Create a filter and set its properties.</p></li>
			</ul>
		</li>
		<li>Folder
			<ul>
				<li><a href="#find">Finding Folders</a>
				<p>List all available media folders.</p></li>

				<li><a href="#read_folder">Reading Folder Information</a>
				<p>Read information about media folders.</p></li>

				<li><a href="#folder_content">Retrieving Folder Content</a>
				<p>Get folder content and get information about media items in the folders.</p></li>
			</ul>
		</li>
		<li>Media information 
			<ul>
				<li><a href="#info">Retrieving Media Information</a>
				<p>Use media information.</p></li>

				<li><a href="#insert">Inserting Media in the Database</a>
				<p>Add media information in the media database.</p></li>

				<li><a href="#scan">Inserting a Media Folder in the Database</a>
				<p>Add media information in a folder.</p></li>
			</ul>
		</li>
		<li>Playlist 
			<ul>
				<li><a href="#create_playlist">Creating Playlists</a>
				<p>Create a new playlist and add media to it.</p></li>
				<li><a href="#find_playlist">Finding Playlists</a>
				<p>Search for playlists.</p></li>
				<li><a href="#read_playlist">Reading Playlist Information</a>
				<p>Handle the retrieved playlist data.</p></li>
				<li><a href="#delete_playlist">Deleting Playlists</a>
				<p>Delete a playlist that is no longer needed.</p></li>
			</ul>  
		</li>
		<li>Tag
			<ul>
				<li><a href="#tag_add">Adding Tags</a>
				<p>Add media tags to the database.</p></li>
				<li><a href="#tag_list">Retrieving Tag Information</a>
				<p>Get information about media tags.</p></li>
				<li><a href="#tag_delete">Deleting Tags</a>
				<p>Delete media tags from the database.</p></li>

			</ul>
		</li>
        <li>Storage
            <ul>
                <li><a href="#storage_list">Retrieving Storage Information</a>
                <p>Get information about the storage.</p></li>
            </ul>
        </li>
	</ul>
<h2>Follow-up</h2>
<p>Once we have learned the basics of the Media Content API, we can now move on to more advanced tasks, including:</p>
<ul>
		<li>Advanced media content
			<ul>
				<li><a href="#find_groups">Finding Media Item Groups</a> 
				<p>Find all available media items grouped by their MIME type.</p></li>	
				<li><a href="#read_group">Reading Media Item Group Information</a>
				<p>Read information about the item group.</p></li>
			</ul>
		</li>
	</ul>


 <h2 id="initialize_media_content" name="initialize_media_content">Connecting to the Media Database</h2>


<p>To use the media database:</p>
<ol>
<li><p>Media Content functions use a SQLite database to save the metadata of the media files on the user device, along with the tags and bookmarks that the user sets. To use the functions and data types of the Media Content API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
#include &lt;glib.h&gt;
</pre>
<p>The example application used in the other use cases also requires the <span style="font-family: Courier New,Courier,monospace">&lt;glib.h&gt;</span> header file.</p>
</li>
<li>Connect to the database:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;

ret = media_content_connect();
if (ret == MEDIA_CONTENT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;connection is success&quot;);
else
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;connection failed&quot;);

return ret;
</pre></li>
<li>
<p>When you no longer use the database, disconnect from it:</p>
<pre class="prettyprint">
media_content_disconnect();
</pre>
</li>
</ol>

 <h2 id="folder_list" name="folder_list">Getting the Folder List</h2>

<p>To retrieve a list of folders where the media files are stored:</p>

<ol>
<li>Define a callback function for the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function, called for each available media folder. Use the callback to create a list of folders.
<pre class="prettyprint">
bool 
gallery_folder_list_cb(media_folder_h folder, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_folder_h new_folder = NULL;
&nbsp;&nbsp;&nbsp;media_folder_clone(&amp;new_folder, folder);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data; // Include glib.h for this value 

&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_folder);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>To find the folders, call the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function with the defined callback. After the callback has created the folder list, you can access the folder details with various <span style="font-family: Courier New,Courier,monospace">media_folder_get_XXX()</span> functions. 
<pre class="prettyprint">
int i;
int count;
filter_h filter = NULL;
GList *folder_list = NULL; // Include glib.h for this value 
media_folder_h folder_handle = NULL;

ret = media_folder_foreach_folder_from_db(filter, gallery_folder_list_cb, &amp;folder_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_folder_foreach_folder_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_folder_foreach_folder_from_db success!!&quot;);

&nbsp;&nbsp;&nbsp;char *folder_id = NULL;
&nbsp;&nbsp;&nbsp;char *folder_name = NULL;
&nbsp;&nbsp;&nbsp;char *folder_path = NULL;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(folder_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder_handle = (media_folder_h)g_list_nth_data(folder_list, i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_folder_id(folder_handle, &amp;folder_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_name(folder_handle, &amp;folder_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_path(folder_handle, &amp;folder_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_media_count_from_db(folder_id, filter, &amp;count);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Release allocated strings 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_folder_get_media_count_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media count [%d]: %d&quot;, i, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre></li>

<li>When no longer needed, destroy the folder list handle:
<pre class="prettyprint">
// Remove the folder list 
if (folder_list) 
{
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(folder_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder_handle = (media_folder_h)g_list_nth_data(folder_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_folder_destroy(folder_handle);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;g_list_free(folder_list);
}
</pre>
</li>
</ol>

 <h2 id="item_list" name="item_list">Getting the Item List</h2>

<p>To retrieve a list of media items:</p>

<ol>
<li>Define a callback function for the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> function, called for each available media item. Use the callback to create a list of media items. 
<pre class="prettyprint">
bool 
gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data; // Include glib.h for this value 
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>To find the items satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties. For a detailed list of condition fields (such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_TYPE</span>) and their values (such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_TYPE_IMAGE</span> and <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_TYPE_VIDEO</span>), see the <span style="font-family: Courier New,Courier,monospace;">media_content_type.h</span> header file. 
<p>The following example filters media items so that only image and video files are included in the result. The filter is case-insensitive, and the results are sorted in a descending order based on the item display name. For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>. </p>
<pre class="prettyprint">
#define BUFLEN 200 

// Get the item list 
media_info_h media_handle = NULL;
GList *all_item_list = NULL;

media_content_collation_e collate_type = MEDIA_CONTENT_COLLATE_NOCASE;
media_content_order_e order_type = MEDIA_CONTENT_ORDER_DESC;
ret = media_filter_create(&amp;filter);

snprintf(buf, BUFLEN, &quot;%s = %d OR %s = %d&quot;, MEDIA_TYPE, MEDIA_CONTENT_TYPE_IMAGE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MEDIA_TYPE, MEDIA_CONTENT_TYPE_VIDEO);
ret = media_filter_set_condition(filter, buf, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set condition&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}

ret = media_filter_set_order(filter, order_type, MEDIA_DISPLAY_NAME, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set order&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre></li>
<li>To find the media items, use the <span style="font-family: Courier New,Courier,monospace;">media_info_foreach_media_from_db()</span> function with the defined callback. The function is synchronous, and it blocks until the callback has been called for all items or the callback returns <span style="font-family: Courier New,Courier,monospace;">false</span>.
<p>To find only a subset of the items, use a filter. If you want to find all items, set the filter parameter to <span style="font-family: Courier New,Courier,monospace;">NULL</span>.</p>
<pre class="prettyprint">
ret = media_info_foreach_media_from_db(filter, gallery_media_item_cb, &amp;all_item_list);
</pre></li>

<li>When no longer needed, destroy the item list and the filter handle:
<pre class="prettyprint">
// Remove all items list 
if (all_item_list) 
{
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(all_item_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_handle = (media_info_h)g_list_nth_data(all_item_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_destroy(media_handle);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;g_list_free(all_item_list);
}

// Destroy the filter handle
media_filter_destroy(filter);
</pre>
</li>
</ol>

 <h2 id="update" name="update">Receiving Update Notifications</h2>
 
<p>To get notifications of database changes, register a callback. You can only set 1 notification callback at this stage of the process:</p>

<ol>
<li>Define the database update callback function:
<pre class="prettyprint">
void 
_noti_cb(media_content_error_e error, int pid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_db_update_item_type_e update_item,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_db_update_type_e update_type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_type_e media_type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *uuid, char *path, char *mime_type, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (error == MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;noti success! %d\n&quot;, error);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;error occurred! %d\n&quot;, error);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti from PID(%d)\n&quot;, pid);

&nbsp;&nbsp;&nbsp;if (update_item == MEDIA_ITEM_FILE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti item: MEDIA_ITEM_FILE\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_item == MEDIA_ITEM_DIRECTORY) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti item: MEDIA_ITEM_DIRECTORY\n&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (update_type == MEDIA_CONTENT_INSERT) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type: MEDIA_CONTENT_INSERT\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_type == MEDIA_CONTENT_DELETE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type: MEDIA_CONTENT_DELETE\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_type == MEDIA_CONTENT_UPDATE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type: MEDIA_CONTENT_UPDATE\n&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;content type: %d\n&quot;, media_type);

&nbsp;&nbsp;&nbsp;if (path) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;path: %s\n&quot;, path);
&nbsp;&nbsp;&nbsp;if (uuid) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;uuid: %s\n&quot;, uuid);
&nbsp;&nbsp;&nbsp;if (mime_type) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;mime_type: %s\n&quot;, mime_type);
&nbsp;&nbsp;&nbsp;if (user_data) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;String: %s\n&quot;, (char *)user_data);

&nbsp;&nbsp;&nbsp;return;
}
</pre></li>

<li>Register the defined callback:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;

// Subscribe notifications 
char *user_str = strdup(&quot;hi&quot;);
media_content_set_db_updated_cb(_noti_cb, (void*)user_str);
</pre></li>

<li>When you no longer want to receive notifications, deregister the callback:
<pre class="prettyprint">
media_content_unset_db_updated_cb();
</pre></li>
</ol>


 <h2 id="findingall" name="findingall">Finding Albums</h2>

<p>To find albums in the system and filter the results:</p>
<ol>
<li><p>To find the albums satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.</p>
<p>The following example filters media albums so that only albums with the artist named &quot;Tizen&quot; are included in the result. The filter is case-insensitive, and the results are sorted in a descending order based on the album display name. For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>.</p>
<pre class="prettyprint">#define BUFLEN 200

filter_h filter = NULL;
char buf[BUFLEN] = {&#39;\0&#39;};

media_filter_create(&amp;filter);

snprintf(buf, BUFLEN, &quot;%s = &#39;Tizen&#39;&quot;, MEDIA_ARTIST);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);

media_filter_set_order(filter, MEDIA_CONTENT_ORDER_DESC, MEDIA_DISPLAY_NAME, MEDIA_CONTENT_COLLATE_NOCASE);

media_album_foreach_album_from_db(filter, media_album_list_cb, NULL);

media_filter_destroy(filter);</pre>
</li>
<li>To find the albums, use the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> function.
<p>To find only a subset of the albums, use a filter. If you want to find all albums, set the filter parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>
<pre class="prettyprint">
// Find all albums
media_album_foreach_album_from_db(NULL, media_album_list_cb, NULL);

// Find filtered albums
media_album_foreach_album_from_db(filter, media_album_list_cb, NULL);
</pre>

<p>You can also use the <span style="font-family: Courier New,Courier,monospace">media_album_get_album_count_from_db()</span> function to get the number of albums available.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> function requires a callback, which is called for every found album. The function is synchronous, and it blocks until the callback has been called for all albums or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>. For information on how to implement the callback, see <a href="#read_album">Reading Album Information</a>.</p>
</li>
<li>Destroy the filter:
<pre class="prettyprint">
media_filter_destroy(filter);
</pre>
</li>
</ol>


<h2 id="read_album" name="read_album">Reading Album Information</h2>

<p>To read album information, define a callback for the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> function and retrieve the basic album information (album ID, name, artist name, and number of media items in the album) in the callback:</p>
<ol>
<li>Read the album details within the callback:
<pre class="prettyprint">
bool 
media_album_list_cb(media_album_h album, void *user_data)
{
</pre>
<p>A handle to the record is passed as a parameter. The return value determines whether the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace">false</span>).</p>
</li>
<li>Once you have the album handle (<span style="font-family: Courier New,Courier,monospace">media_album_h</span>), you can read the album information:

<ul>
<li>
Use the <span style="font-family: Courier New,Courier,monospace">media_album_get_album_id()</span>, <span style="font-family: Courier New,Courier,monospace">media_album_get_name()</span>, and <span style="font-family: Courier New,Courier,monospace">media_album_get_artist()</span> functions to read the album ID, name, and artist:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;int id = -1; 
&nbsp;&nbsp;&nbsp;char *name = NULL, *artist = NULL;
&nbsp;&nbsp;&nbsp;int count = -1;

&nbsp;&nbsp;&nbsp;// Get the ID of the album
&nbsp;&nbsp;&nbsp;ret = media_album_get_album_id(album, &amp;id);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling	
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Album id: %d\n&quot;, id);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;// Get name of the album
&nbsp;&nbsp;&nbsp;ret = media_album_get_name(album, &amp;name);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Album name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;// Get the artist name
&nbsp;&nbsp;&nbsp;ret = media_album_get_artist(album, &amp;artist);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Artist: %s\n&quot;, artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(artist);
&nbsp;&nbsp;&nbsp;}
</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free the <span style="font-family: Courier New,Courier,monospace">name</span> and <span style="font-family: Courier New,Courier,monospace">artist</span> variables after use.</td>
</tr>
</tbody>
</table>
</li>

<li>
Get the media item count in the album with the <span style="font-family: Courier New,Courier,monospace">media_album_get_media_count_from_db()</span> function.

<p>The second parameter is the filter. If it is set to <span style="font-family: Courier New,Courier,monospace">NULL</span>, all media is counted.</p>

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;// Get media count in the album
&nbsp;&nbsp;&nbsp;// Filter is NULL - all media items are counted
&nbsp;&nbsp;&nbsp;ret = media_album_get_media_count_from_db(id, NULL, &amp;count);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media count in this album: %d\n&quot;, count);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre>

</li>
</ul>
</li>
</ol>

 <h2 id="findinginfo" name="findinginfo">Retrieving Album Content</h2>

<p>To access information about the media items in a given album:</p>

<ol><li>Request album content.

<ol type="a"><li><p>Before you can read the album content information, acquire the album ID. If you have the album handle (<span style="font-family: Courier New,Courier,monospace">media_album_h</span>), you can call the <span style="font-family: Courier New,Courier,monospace">media_album_get_album_id()</span> function:</p>

<pre class="prettyprint">int id = -1;

media_album_get_album_id(album, &amp;id);</pre>

<p>To obtain the handle, call the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> function. The handle is provided in the callback.</p></li>

<li><p>Request the album content and media item count with the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_media_from_db()</span> and <span style="font-family: Courier New,Courier,monospace">media_album_get_media_count_from_db()</span> functions using the album ID as the first parameter.</p>

<p>The following call finds all the media items in the album (<span style="font-family: Courier New,Courier,monospace">NULL</span> filter). The <span style="font-family: Courier New,Courier,monospace">album_contents_info_cb()</span> callback is called for each item.</p>

<pre class="prettyprint">media_album_foreach_media_from_db(id, NULL, album_contents_info_cb, NULL);</pre>

<p>This function is synchronous. The call blocks until the callback has been called for all the albums or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p></li></ol></li>

<li id="receive" name="receive">Receive and handle the album content.
<p>Define the callback which you set in the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_media_from_db()</span> function.</p>
<p>The following example prints the title, MIME type, and size of the media item for which it was called.</p> 
<pre class="prettyprint">
bool 
album_contents_info_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;char *title = NULL, *mime_type = NULL;
&nbsp;&nbsp;&nbsp;unsigned long long size = -1;

&nbsp;&nbsp;&nbsp;// Read the item title
&nbsp;&nbsp;&nbsp;ret = media_info_get_title(media, &amp;title);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Title: %s\n&quot;, title);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Read the item MIME type
&nbsp;&nbsp;&nbsp;ret = media_info_get_mime_type(media, &amp;mime_type);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;MIME type: %s\n&quot;, mime_type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(mime_type);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Read the item size
&nbsp;&nbsp;&nbsp;ret = media_info_get_size(media, &amp;size);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Size: %llu\n&quot;, size);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free the <span style="font-family: Courier New,Courier,monospace">title</span> and <span style="font-family: Courier New,Courier,monospace">mime_type</span> variables after use.</td>
</tr>
</tbody>
</table></li></ol>


 <h2 id="inserting" name="inserting">Inserting Bookmarks</h2>

<p>To set a bookmark for a video file at a given timestamp, use the <span style="font-family: Courier New,Courier,monospace">media_bookmark_insert_to_db()</span> function:</p>

<pre class="prettyprint">char* thumbnail_path = &quot;path/to/image/file&quot;;

media_bookmark_insert_to_db(media_id, 220, thumbnail_path);
media_bookmark_insert_to_db(media_id, 210, thumbnail_path);</pre>

<p>The parameters are the media ID of the video file, the moment (time in seconds from the beginning) in the video to bookmark, and the image used as a thumbnail for the bookmark. You can use the same thumbnail for more than 1 bookmark.</p>

 <h2 id="finding" name="finding">Finding Bookmarks</h2>

<p>To find a media item&#39;s bookmarks and filter the results:</p>

<ol>
<li><p>To find the bookmarks satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.</p>

<p>The following example filters bookmarks so that only the bookmarks set at the 220th second of the file or later are included in the result. The filter is case-insensitive, and the results are sorted in an ascending order based on the time they mark in the file. The file also defines an offset where only the first 3 results are returned. For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>.</p>
<pre class="prettyprint">
filter_h filter = NULL;

media_filter_create(&amp;filter);

#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s &gt;= 220&quot;, BOOKMARK_MARKED_TIME);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_DEFAULT);

media_filter_set_offset(filter,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Offset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Count
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3);

media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, BOOKMARK_MARKED_TIME, MEDIA_CONTENT_COLLATE_NOCASE);</pre></li>

<li><p>To find the bookmarks set for a media item, use the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_bookmark_from_db()</span> function.</p>

<p>To find only a subset of the bookmarks, use a filter. If you want to find all bookmarks set for a media item, set the filter parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>
<pre class="prettyprint">
// Find all items
media_info_foreach_bookmark_from_db(media_id, NULL, get_bookmarks_cb, NULL);

// Find filtered items
media_info_foreach_bookmark_from_db(media_id, filter, get_bookmarks_cb, NULL);
</pre>

<p>Obtain the media ID (first parameter) by calling the <span style="font-family: Courier New,Courier,monospace">*_get_media_id()</span> functions. The handles that these functions require can be obtained from various sources. For example, <span style="font-family: Courier New,Courier,monospace">media_info_h</span> (needed for <span style="font-family: Courier New,Courier,monospace">media_info_get_media_id()</span>) is provided after calling the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> or <span style="font-family: Courier New,Courier,monospace">media_info_insert_to_db()</span> function.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">media_info_foreach_bookmark_from_db()</span> function requires a callback, which is called for every found bookmark. The function is synchronous, and it blocks until the callback has been called for all bookmarks in the media item or the callback returns <span style="font-family: Courier New,Courier,monospace;">false</span>. For information on how to implement the callback, see <a href="#reading">Reading Bookmark Information</a>.</p></li>



<li><p>Destroy the filter:</p>

<pre class="prettyprint">media_filter_destroy(filter);</pre></li>

</ol>

 <h2 id="reading" name="reading">Reading Bookmark Information</h2>

<p>To read bookmark information, define a callback for the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_bookmark_from_db()</span> function and retrieve the basic bookmark information (thumbnail path and marked time) in the callback:</p>
<ol>
<li>Read the bookmark details within the callback:
<pre class="prettyprint">
bool 
get_bookmarks_cb(media_bookmark_h bookmark, void* user_data)
{
</pre>
<p>A handle to the record is passed as a parameter. The return value determines whether the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace;">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace;">false</span>).</p> 
</li>
<li>Once you have the bookmark handle (<span style="font-family: Courier New,Courier,monospace;">media_bookmark_h</span>),  you can read the bookmark information:

<ul>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">media_bookmark_get_thumbnail_path()</span> function to get the thumbnail path of the bookmark:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;char *thumb = NULL;

&nbsp;&nbsp;&nbsp;if (bookmark != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_bookmark_get_thumbnail_path(bookmark, &amp;thumb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Thumbnail path: %s\n&quot;, thumb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(thumb);
</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free the thumbnail path after use.</td>
</tr>
</tbody>
</table>
</li>
<li>Use the <span style="font-family: Courier New,Courier,monospace;">media_bookmark_get_marked_time()</span> function to get the marked time of the bookmark:

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_t time;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_bookmark_get_marked_time(bookmark, &amp;time);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Marked time [s]: %d\n&quot;, (int) time);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li></ul>
</li>
</ol>

 <h2 id="removing" name="removing">Removing Bookmarks</h2>

<p>To remove a bookmark:</p>
<ol><li><p>Acquire the bookmark ID:</p>

<pre class="prettyprint">
media_bookmark_h bookmark = NULL;

// Assuming you have the bookmark handle (media_bookmark_h)
int bookmark_id = -1;
media_bookmark_get_bookmark_id(bookmark, &amp;bookmark_id);</pre></li>

<li><p>Delete the bookmark:</p>

<pre class="prettyprint">media_bookmark_delete_from_db(bookmark_id);</pre></li></ol>


 <h2 id="filter" name="filter">Setting up a Filter</h2>

<p>To use a filter to find media items that satisfy certain criteria or to modify the search results in a specific way:</p>
<ol>
<li><p>Create a filter using the <span style="font-family: Courier New,Courier,monospace">media_filter_create()</span> function:</p>

<pre class="prettyprint">
filter_h filter = NULL;

media_filter_create(&amp;filter);
</pre>
</li>

<li><p>Set a condition using the <span style="font-family: Courier New,Courier,monospace">media_filter_set_condition()</span> function.</p>
<p>The following example sets a condition which finds albums with the artist named &quot;Tizen&quot; with a case-insensitive search:</p>

<pre class="prettyprint">
#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s = &#39;Tizen&#39;&quot;, MEDIA_ARTIST);
ret = media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);
</pre>

<p>The function parameters are:</p>
<ul><li>Filter handle</li>
<li>Condition string used for filtering the search results
<p>Queries made with the Content API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__FRAMEWORK.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__FRAMEWORK.html">wearable</a> applications) are passed to a SQL database. A part of each query is a <span style="font-family: Courier New,Courier,monospace">WHERE</span> clause that determines which properties correspond to certain conditions. The condition string defines the <span style="font-family: Courier New,Courier,monospace">WHERE</span> clause and must match the following pattern:</p>
<pre class="prettyprint">
// Basic pattern
&lt;property&gt; &lt;relation&gt; &lt;value&gt;

// If the relation is =, &gt;, &gt;=, &lt;, or &lt;=, the following is also valid
&lt;value&gt; &lt;relation&gt; &lt;property&gt;
</pre>

<p>The valid relations are:</p>

<pre class="prettyprint">
=, &gt;, &gt;=, &lt;, &lt;=, IN, NOT IN, LIKE
</pre>

<p>Conditions can be joined by <span style="font-family: Courier New,Courier,monospace">OR</span> and <span style="font-family: Courier New,Courier,monospace">AND</span> to form more complex conditions.</p>

<p>Condition properties are defined by a series of <span style="font-family: Courier New,Courier,monospace">#define</span> directives. Each Content API submodule contains definitions for properties used in the submodule API.</p></li>
<li>Collation type determining how the strings are compared
<p>The <span style="font-family: Courier New,Courier,monospace">media_content_collation_e</span> enumerator (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">wearable</a> applications) defines the available collation types.</p></li></ul>

<p>To read the condition of an existing filter, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_condition()</span> function:</p>

<pre class="prettyprint">
char *check_condition = NULL;
media_content_collation_e check_collate_type = MEDIA_CONTENT_COLLATE_DEFAULT;

media_filter_get_condition(filter, &amp;check_condition, &amp;check_collate_type);
</pre>
</li>

<li><p>Set a sorting order using the <span style="font-family: Courier New,Courier,monospace">media_filter_set_order()</span> function.</p>
<p>The following example sorts the results in an ascending order based on the artist name. The sorting is case-sensitive.</p>

<pre class="prettyprint">
media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, MEDIA_ARTIST, MEDIA_CONTENT_COLLATE_DEFAULT);
</pre>

<p>The second and fourth parameters determine the order and collation types, and the available types are defined in the enumerators <span style="font-family: Courier New,Courier,monospace">media_content_order_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gaa4e5eece5a509c7414afb96e7a2c3fa2">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gaa4e5eece5a509c7414afb96e7a2c3fa2">wearable</a> applications) and <span style="font-family: Courier New,Courier,monospace">media_content_collation_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">wearable</a> applications).</p>

<p>To read the order settings of an existing filter, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_order()</span> function:</p>

<pre class="prettyprint">
media_content_order_e check_order_type = MEDIA_CONTENT_ORDER_ASC;
char *check_order_keyword = NULL;
media_content_collation_e check_order_collate_type = MEDIA_CONTENT_COLLATE_DEFAULT;

media_filter_get_order(filter, &amp;check_order_type, &amp;check_order_keyword, &amp;check_order_collate_type);
</pre>
</li>

<li>Set an offset using the <span style="font-family: Courier New,Courier,monospace">media_filter_set_offset()</span> function.
<p>The offset allows you to limit the results to a specific subset. For example, if you sort the items by size in an ascending order and set the offset to 10, the 10 smallest items are not included in the results.</p>

<p>The following example sets an offset that returns results starting from the beginning (offset 0), and returns a maximum of 5 results:</p>

<pre class="prettyprint">media_filter_set_offset(filter, 0, 5);</pre>

<p>To read the offset settings of an existing filter, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_offset()</span> function:</p>

<pre class="prettyprint">
int check_offset = 0;
int check_count = 0;

media_filter_get_offset(filter, &amp;check_offset, &amp;check_count);</pre>
</li>

<li>
<p>When the filter is ready and its properties defined, you can use it in various media foreach functions to find different media items.</p>  
<p>For example, to iterate through all media info in the media database, use the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> function:</p>
<pre class="prettyprint">
media_info_foreach_media_from_db(filter, media_cb, NULL);
</pre>
</li>

<li>
<p>When the filter is no longer needed, destroy it:</p>
<pre class="prettyprint">
media_filter_destroy(filter);
</pre>
</li>
</ol>


 <h2 id="find" name="find">Finding Folders</h2>

<p>To find media folders and filter the results:</p>

<ol>

<li><p>To find only folders satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.</p>
<p>The following example filters media folders so that only folders named &quot;Downloads&quot; found in the internal storage are included in the result. The filter is case-insensitive, and the results are sorted in an ascending order based on the modified time. For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>.</p>
<pre class="prettyprint">
filter_h filter = NULL;

media_filter_create(&amp;filter);

#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};
snprintf(buf, BUFLEN, &quot;%s = &#39;Downloads&#39;&quot;, FOLDER_NAME);
snprintf(buf, BUFLEN, &quot;%s = %d&quot;, FOLDER_STORAGE_TYPE, MEDIA_CONTENT_STORAGE_INTERNAL);

media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);
media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, FOLDER_MODIFIED_TIME, MEDIA_CONTENT_COLLATE_DEFAULT);
media_folder_foreach_folder_from_db(filter, folder_cb, NULL);
</pre>
</li>
<li>
<p>To find the folders, use the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function.</p>
<p>To find only a subset of the folders, use a filter. If you want to find all folders, set the filter parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>

<pre class="prettyprint">
// Find all items
media_folder_foreach_folder_from_db(NULL, folder_cb, NULL);

// Find filtered items 
media_folder_foreach_folder_from_db(filter, folder_cb, NULL);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function requires a callback, which is called for every found folder. The function is synchronous, and it blocks until the callback is called for all available folders or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>. For more information on how to implement the callback, see <a href="#read_folder">Reading Folder Information</a>.</p>
</li>
<li>Destroy the filter:
<pre class="prettyprint">
media_filter_destroy(filter);
</pre>
</li>
</ol>

<h2 id="read_folder" name="read_folder">Reading Folder Information</h2>

<p>To read media folder information, define a callback for the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function and retrieve the basic folder information (folder ID, name, path, storage type, last modified time, and number of media items in the folder) in the callback:</p>

<ol>
<li>
<p>Read the folder details within the callback:</p>
<pre class="prettyprint">
bool 
folder_cb(media_folder_h folder, void *user_data)
{
</pre>

<p>A handle to the record is passed as a parameter. The return value determines whether the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace">false</span>).</p>
</li>
<li>
<p>Once you have the folder handle (<span style="font-family: Courier New,Courier,monospace">media_folder_h</span>), you can read the folder information:</p>

<ul><li><p>Use the <span style="font-family: Courier New,Courier,monospace">media_folder_get_folder_id()</span>, <span style="font-family: Courier New,Courier,monospace">media_folder_get_name()</span>, and <span style="font-family: Courier New,Courier,monospace">media_folder_get_path()</span> functions to read the folder ID, name, and path:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;char *folder_id = NULL;
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;char *path = NULL;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_folder_id(folder, &amp;folder_id);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder id: %s\n&quot;, folder_id);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = media_folder_get_name(folder, &amp;name);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = media_folder_get_path(folder, &amp;path);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder path: %s\n&quot;, path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;}</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free the <span style="font-family: Courier New,Courier,monospace">name</span> and <span style="font-family: Courier New,Courier,monospace">path</span> variables at the end. The <span style="font-family: Courier New,Courier,monospace">folder_id</span> variable is freed later, since it is still needed.</td>
</tr>
</tbody>
</table>
</li>
<li><p>Read the folder storage type using the <span style="font-family: Courier New,Courier,monospace">media_folder_get_storage_type()</span> function:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;media_content_storage_e storage_type = MEDIA_CONTENT_STORAGE_INTERNAL;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_storage_type(folder, &amp;storage_type);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (storage_type) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MEDIA_CONTENT_STORAGE_INTERNAL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: Internal\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MEDIA_CONTENT_STORAGE_EXTERNAL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: External\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: Unknown\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}</pre></li>

<li><p>Get the last modified time:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;time_t time = 0;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_modified_time(folder, &amp;time);
&nbsp;&nbsp;&nbsp;if (MEDIA_CONTENT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Modified time: %s&quot;, ctime(&amp;time));
&nbsp;&nbsp;&nbsp;}</pre></li>

<li>Get the media item count in the folder with the <span style="font-family: Courier New,Courier,monospace">media_folder_get_media_count_from_db()</span> function. <p>The second parameter is the filter. If it is set to <span style="font-family: Courier New,Courier,monospace">NULL</span>, all media is counted.</p>



<pre class="prettyprint">&nbsp;&nbsp;&nbsp;int item_count = -1; 

&nbsp;&nbsp;&nbsp;ret = media_folder_get_media_count_from_db(folder_id, NULL, &amp;item_count);
&nbsp;&nbsp;&nbsp;if (MEDIA_CONTENT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Number of media contents: %d\n&quot;, item_count);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;free(folder_id);

&nbsp;&nbsp;&nbsp;return true;
}</pre>
<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free the <span style="font-family: Courier New,Courier,monospace">folder_id</span> value after it is used for the <span style="font-family: Courier New,Courier,monospace">media_folder_get_media_count_from_db()</span> function.</td>
</tr>
</tbody>
</table></li></ul>
</li>
</ol>


 <h2 id="folder_content" name="folder_content">Retrieving Folder Content</h2>

<p>To access information about the media items in a given folder:</p>

<ol>
<li>Request folder content.
<p>To find all media items from the folder with the given ID, use the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_media_from_db()</span> function.</p>

<pre class="prettyprint">media_folder_foreach_media_from_db(folder_id, NULL, media_cb, NULL);</pre>

<p>This function is synchronous. The call blocks until the callback has been called for all the items or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p>
</li>

<li>Receive and handle folder content.

<p>Define the callback which you set in the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_media_from_db()</span> function.</p>

<p>The following example prints the title of the media item for which it was called.</p>

<pre class="prettyprint">
bool 
media_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *title = NULL;

&nbsp;&nbsp;&nbsp;ret = media_info_get_title(media, &amp;title);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Title: %s\n&quot;, title);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>
</ol>

 <h2 id="info" name="info">Retrieving Media Information</h2>

<p>To access media item information:</p>

<ol>
<li>Define a callback function for the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> function, called for each available media item. Use the callback to create a list of items. 
<pre class="prettyprint">
bool 
gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>To find the items satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.
<p>The following example filters media items so that only image and video items are included in the result. The filter is case-insensitive, and the results are sorted in a descending order based on the item display name. For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>.</p>
<pre class="prettyprint">
#define BUFLEN 200
GList *all_item_list = NULL; // Include glib.h
media_content_type_e media_type;
media_info_h media_handle = NULL;
char *media_id = NULL;
char *media_name = NULL;
char *media_path = NULL;
char buf[BUFLEN] = {&#39;\0&#39;};
int ret = MEDIA_CONTENT_ERROR_NONE;
filter_h filter = NULL;
media_content_collation_e collate_type = MEDIA_CONTENT_COLLATE_NOCASE;
media_content_order_e order_type = MEDIA_CONTENT_ORDER_DESC;

media_filter_create(&amp;filter);

// Set the condition
snprintf(buf, BUFLEN, &quot;%s = %d OR %s = %d&quot;, MEDIA_TYPE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MEDIA_CONTENT_TYPE_IMAGE, MEDIA_TYPE, MEDIA_CONTENT_TYPE_VIDEO);

ret = media_filter_set_condition(filter, buf, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set condition&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}
ret = media_filter_set_order(filter, order_type, MEDIA_DISPLAY_NAME, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set order&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
</li>
<li>
<p>To find the media items, use the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> function with the defined callback. The function is synchronous, and it blocks until the callback has been called for all items or the callback returns false.</p>
<p>To find only a subset of the items, use a filter. If you want to find all items, set the filter parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span>.</p>
<p>After the callback has created the item list, you can access the item details with various <span style="font-family: Courier New,Courier,monospace">media_info_get_XXX()</span> functions. Note that media information is based on the media information handle, and to obtain the information (metadata), you must first retrieve the handle. The available metadata varies depending on the media type, such as image, video, or audio.</p>
<pre class="prettyprint">
ret = media_info_foreach_media_from_db(filter, gallery_media_item_cb, &amp;all_item_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_info_foreach_media_from_db failed: %d&quot;, ret);
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(all_item_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_handle = (media_info_h)g_list_nth_data(all_item_list, i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_id(media_handle, &amp;media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_type(media_handle, &amp;media_type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_display_name(media_handle, &amp;media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_file_path(media_handle, &amp;media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_type == MEDIA_CONTENT_TYPE_IMAGE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_h image_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_orientation_e orientation = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int width = 0, height = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *datetaken = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *burst_id = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_image(media_handle, &amp;image_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_width(image_handle, &amp;width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_height(image_handle, &amp;height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_orientation(image_handle, &amp;orientation);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_date_taken(image_handle, &amp;datetaken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_burst_id(image_handle, &amp;burst_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;This is an image&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Width: %d, Height: %d, Orientation: %d, Date taken: %s&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width, height, orientation, datetaken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (datetaken) free(datetaken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (burst_id) free(burst_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_destroy(image_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (media_type == MEDIA_CONTENT_TYPE_VIDEO) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_h video_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *title = NULL, *artist = NULL, *album = NULL, *album_artist = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int duration = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_t time_played = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_video(media_handle, &amp;video_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_artist(video_handle, &amp;artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_album(video_handle, &amp;album);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_album_artist(video_handle, &amp;album_artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_duration(video_handle, &amp;duration);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_played_time(media_handle, &amp;time_played);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;This is a video&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Title: %s, Album: %s, Artist: %s, Album_artist: %s \n Duration: %d, Played time: %d&quot;, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title, album, artist, album_artist, duration, time_played);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(album);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(album_artist);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_destroy(video_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_id [%d]: %s&quot;, i, media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_name [%d]: %s&quot;, i, media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_path [%d]: %s&quot;, i, media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}
}
</pre></li>


<li>When no longer needed, destroy the list, filter, and query:

<pre class="prettyprint">
media_filter_destroy(filter);
filter = NULL;
</pre></li>
</ol>

 <h2 id="insert" name="insert">Inserting Media in the Database</h2>
 
 <p>To use newly created media files, insert them into the database:</p>

<ol><li><p>Add the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/content.write</span> privilege to the manifest file of the application to use the needed APIs.</p>
<p>In addition, add the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/mediastorage</span> or <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/externalstorage</span> privilege, since when you insert metadata, the Media Content APIs access content in the internal or external storage.</p></li>

<li><p>To add information in the database, use one of the following options:</p>
 
<ul><li><p><span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function:</p>
<pre class="prettyprint">int ret = MEDIA_CONTENT_ERROR_NONE;
char *image_file = &quot;Default.jpg&quot;;
char *directory = NULL;
char *path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;directory);
path = (char*)malloc(strlen(directory) + strlen(image_file) + 1);
memset(path, 0x00, strlen(directory) + strlen(image_file) + 1);
sprintf(path, &quot;%s/%s&quot;, directory, image_file);

media_info_h media_item = NULL;

ret = media_info_insert_to_db(path, &amp;media_item);

if ((ret == MEDIA_CONTENT_ERROR_NONE) &amp;&amp; (media_item != NULL)) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Insertion successful&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Insertion failed&quot;);
&nbsp;&nbsp;&nbsp;if (media_item != NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_destroy(media_item);

&nbsp;&nbsp;&nbsp;return ret;
}

// After using the media handle, destroy it
ret = media_info_destroy(media_item);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>
<p>After using the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function, destroy the received <span style="font-family: Courier New,Courier,monospace;">media_info_h</span> using the <span style="font-family: Courier New,Courier,monospace;">media_info_destroy()</span> function.</p></li>

<li><span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;
char *image_file = &quot;Default.jpg&quot;;
char *directory = NULL;
char *file_path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;directory);
file_path = (char*)malloc(strlen(directory) + strlen(image_file) + 1);
memset(file_path, 0x00, strlen(directory) + strlen(image_file) + 1);
sprintf(file_path, &quot;%s/%s&quot;, directory, image_file);

ret = media_content_scan_file(file_path);
if (ret != MEDIA_CONTENT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre>
</li></ul>

<p>The difference between the 2 options is that the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function automatically gets the <span style="font-family: Courier New,Courier,monospace;">media_info_h</span> handle of the media file after inserting the file in the database, whereas the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function only inserts the file.</p>

<p>Basically, the media database does not allow duplicate paths. If you try to insert the same data, the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function returns an error. However, the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function  returns no error, and allows you to get the <span style="font-family: Courier New,Courier,monospace;">media_info_h</span> handle.</p></li>

</ol>

 <h2 id="scan" name="scan">Inserting a Media Folder in the Database</h2>

<p>To insert a media folder, and optionally any subfolders, in the database:</p>
 
<ol>
<li><p>Add the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/content.write</span> privilege to the manifest file of the application to use these APIs.</p>
<p>In addition, add the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/mediastorage</span> or <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/externalstorage</span> privilege, since when you insert metadata, the Media Content APIs access content in the internal or external storage.</p></li>
<li>Define a callback function that is called after the asynchronous insertion (scanning) process is completed: 
<pre class="prettyprint">
void 
_scan_cb(media_content_error_e err, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder scanned\n&quot;);

&nbsp;&nbsp;&nbsp;return;
}
</pre></li>

<li>Insert (scan) a folder to the database using the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_folder()</span> function.
<p>Since the second parameter is set to <span style="font-family: Courier New,Courier,monospace;">TRUE</span>, the subfolders are scanned and inserted too.</p>
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;
char *dir_path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;dir_path);

ret = media_content_scan_folder(dir_path, TRUE, _scan_cb, NULL);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return ret;
}
</pre></li>
</ol>

 <h2 id="create_playlist" name="create_playlist">Creating Playlists</h2>

<p>To create and insert a playlist to the database:</p>

<ol><li>Insert a playlist record to the database.
<p>To operate on the database, it has to contain records. Add a new playlist to the database using the <span style="font-family: Courier New,Courier,monospace;">media_playlist_insert_to_db()</span> function. It returns a handle to the newly created record.</p>
<pre class="prettyprint">
media_playlist_h playlist = NULL;
GList *media_id_list = NULL; // This requires glib.h inclusion
int media_count;
int start_position = -1;
int count = -1;
int x;
int id;
int ret;

// Create the playlist
media_playlist_insert_to_db(&quot;playlist_for_tutorial&quot;, &amp;playlist);
</pre>
<p>You can modify the playlist name later on using the <span style="font-family: Courier New,Courier,monospace;">media_playlist_set_name()</span> function.</p>
</li>
<li><p>Define a callback function for the <span style="font-family: Courier New,Courier,monospace;">media_info_foreach_media_from_db()</span> function, called for each available media item. Use the callback to cast the user data to a proper type and copy the media ID to a list:</p>

<pre class="prettyprint">
bool 
_media_info_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *data = NULL;
&nbsp;&nbsp;&nbsp;char *id = NULL;

&nbsp;&nbsp;&nbsp;if (media != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_id(media, &amp;id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media found: %s\n&quot;, id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = strdup(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(id);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>

<li><p>To be able to fill a playlist with data, <a href="#insert">insert existing media in the database</a> using the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function. You can also check the media database size using the <span style="font-family: Courier New,Courier,monospace;">media_info_get_media_count_from_db()</span> function and allocate the required amount of space.</p>
<pre class="prettyprint">
// path must be set to an audio file
media_content_scan_file(path); 

media_info_get_media_count_from_db(NULL, &amp;media_count); 
</pre>
</li>
<li><p>To find the media items to be added to the playlist, call the <span style="font-family: Courier New,Courier,monospace;">media_info_foreach_media_from_db()</span> function with the defined callback. After the callback has created the media ID list, you can add the media items to the playlist with the <span style="font-family: Courier New,Courier,monospace;">media_playlist_add_media()</span> function.</p>

<pre class="prettyprint">
media_info_foreach_media_from_db(NULL, _media_info_cb, &amp;media_id_list); 

if (media_count &gt; 0) 
{
&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; media_count; x++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_id = (char*)g_list_nth_data(media_id_list, x);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_playlist_add_media(playlist, media_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_id);
&nbsp;&nbsp;&nbsp;}
}

media_playlist_update_to_db(playlist);
</pre></li>

<li>When no longer needed, destroy the playlist: 
<pre class="prettyprint">
media_playlist_destroy(playlist);
</pre>
</li>
</ol>

<h2 id="find_playlist" name="find_playlist">Finding Playlists</h2>

<p>To find playlists and filter the results:</p>

<ol>
<li>
<p>To find only playlists satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.</p>
<p>For information about creating a filter, see <a href="#filter">Setting up the Filter</a>.</p>
</li>
<li>
<p>To find the playlists, use the <span style="font-family: Courier New,Courier,monospace;">media_playlist_foreach_playlist_from_db()</span> function.</p>

<p>To find only a subset of the playlists, use a filter. If you want to find all playlists, set the filter parameter to <span style="font-family: Courier New,Courier,monospace;">NULL</span>.
</p>
<pre class="prettyprint">
// Find all playlists
media_playlist_foreach_playlist_from_db(NULL, playlist_list_cb,  NULL);

// Find filtered playlists
media_playlist_foreach_playlist_from_db(filter, playlist_list_cb,  NULL);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">media_playlist_foreach_playlist_from_db()</span> function requires a callback, which is called for every found playlist. The function is synchronous, and it blocks until the callback has been called for all playlists or the callback returns  <span style="font-family: Courier New,Courier,monospace;">false</span>. For information on how to implement the callback, see <a href="#read_playlist">Reading Playlist Information</a>.</p>
</li>
<li>Destroy the filter:
<pre class="prettyprint">
media_filter_destroy(filter);
</pre>
</li>
</ol>


<h2 id="read_playlist" name="read_playlist">Reading Playlist Information</h2>

<p>To read playlist information, define a callback for the <span style="font-family: Courier New,Courier,monospace;">media_playlist_foreach_playlist_from_db()</span> function and retrieve the basic playlist information (name, ID, and records included in the playlist) in the callback:</p>

<ol>
<li><p>Read the playlist details within the callback:</p> 
<pre class="prettyprint">
static bool 
playlist_list_cb(media_playlist_h playlist, void* user_data) 
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;int playlist_id = 0;
&nbsp;&nbsp;&nbsp;int count = 0;
</pre>
<p>A handle to the record is passed as a parameter. The return value determines whether the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace;">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace;">false</span>).</p></li>

<li>Once you have the playlist handle (<span style="font-family: Courier New,Courier,monospace;">media_playlist_h</span>), you can read the playlist information:
<ol type="a">
<li><p>Use the <span style="font-family: Courier New,Courier,monospace;">media_playlist_get_name()</span> and <span style="font-family: Courier New,Courier,monospace;">media_playlist_get_playlist_id()</span> functions to read the playlist name and ID:</p>

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;media_playlist_get_name(playlist, &amp;name);
&nbsp;&nbsp;&nbsp;media_playlist_get_playlist_id(playlist, &amp;playlist_id);
</pre></li>

<li><p>Access the records within the playlist using the playlist ID.</p> 
<p>In the following example, 2 searches are executed for the records. The first search operates on all records on the playlist and retrieves the record count. The second search retrieves the first 10 records. Destroy the filters after all operations.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;filter_h temp_filter = NULL;
&nbsp;&nbsp;&nbsp;media_filter_create(&amp;temp_filter);

&nbsp;&nbsp;&nbsp;media_filter_set_offset(temp_filter, -1, -1);

&nbsp;&nbsp;&nbsp;media_playlist_get_media_count_from_db(playlist_id, temp_filter, &amp;count);
&nbsp;&nbsp;&nbsp;filter_h audio_fltr;

&nbsp;&nbsp;&nbsp;media_filter_create(&amp;audio_fltr);

&nbsp;&nbsp;&nbsp;media_filter_set_offset(audio_fltr, 0, 10);

&nbsp;&nbsp;&nbsp;media_playlist_foreach_media_from_db(playlist_id, audio_fltr, audio_list_cb, NULL);

&nbsp;&nbsp;&nbsp;media_filter_destroy(audio_fltr);
&nbsp;&nbsp;&nbsp;media_filter_destroy(temp_filter);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>

<li><p>The search results are returned in a callback that is triggered for each record matching the filter. To get the media info, use the following functions in the callback:</p>
<ul><li><span style="font-family: Courier New,Courier,monospace;">media_info_get_audio()</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">media_info_get_media_id()</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">media_info_get_size()</span></li></ul>

<pre class="prettyprint">
static bool 
audio_list_cb(int playlist_member_id, media_info_h media_hndl, void *user_data) 
{
&nbsp;&nbsp;&nbsp;char * id;
&nbsp;&nbsp;&nbsp;media_info_get_media_id(media_hndl, &amp;id);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media on the playlist: %s\n&quot;, id);
&nbsp;&nbsp;&nbsp;free(id);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
</ol>
</li>
<li>When no longer needed, destroy the playlist: 
<pre class="prettyprint">
media_playlist_destroy(playlist);
</pre>
</li></ol>

<h2 id="delete_playlist" name="delete_playlist">Deleting Playlists</h2>

<p>After all operations, delete the playlist from the database to avoid creating useless records.</p>
<p>In addition, destroy all filters and handles to the records.</p>
<pre class="prettyprint">
media_playlist_get_playlist_id(playlist, &amp;id);
media_playlist_delete_from_db(id);
</pre>



	<h2 id="tag_add" name="tag_add">Adding Tags</h2>
	
<p>To add a tag to the database, and a file to the tag:</p>
<ol>
<li>Add the tag.
<p>Use the <span style="font-family: Courier New,Courier,monospace;">media_tag_insert_to_db()</span> function to add the tag. The result is a handle to the new tag.</p>
<pre class="prettyprint">
media_tag_h tag = NULL;
const char *tag_name = &quot;Tag name&quot;;

media_tag_insert_to_db(tag_name, &amp;tag);
</pre>
</li>

<li>Insert a media item into the tag.
<p>To insert an item into the tag, you need to know the ID of the item. One way of obtaining the ID is to insert a media item into the database. In the following example, a media file is inserted and added to the tag.</p>
<pre class="prettyprint">
media_info_h image_info = NULL;
char *image_id = NULL;

media_info_insert_to_db(&quot;path/to/image_file&quot;, &amp;image_info);

media_info_get_media_id(image_info, &amp;image_id);

media_tag_add_media(tag, image_id);
</pre>
</li>

<li>Update the tag.
<p>After you make any changes to the tag, such as changing its name or adding items, you need to update it.</p>
<pre class="prettyprint">
media_tag_update_to_db(tag);
</pre>
</li>

<li>Destroy the tag handle.
<p>After the tag has been inserted into the database and all updates to it have been made, destroy the handle. Destroying the handle does not <a href="#tag_delete">delete the tag</a> from the database.</p>
<pre class="prettyprint">
media_tag_destroy(tag);
</pre>
</li>
</ol>


 <h2 id="tag_list" name="tag_list">Retrieving Tag Information</h2>

<p>To access information first about the tags and then about the media items related to specific tags:</p>

<ol>
<li>Define callback functions for the <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_tag_from_db()</span> and <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_media_from_db()</span> functions, called for each available tag and each available media item for a specific tag. Use the callbacks to create a list of tags and media items. 
<pre class="prettyprint">
// glib library is used, so include glib.h

bool 
gallery_tag_item_cb(media_tag_h tag, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_tag_h new_tag = NULL;
&nbsp;&nbsp;&nbsp;media_tag_clone(&amp;new_tag, tag);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_tag);

&nbsp;&nbsp;&nbsp;return true;
}

bool 
gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>To find the tags and related media items, use the <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_tag_from_db()</span> and <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_media_from_db()</span> functions with the defined callbacks. The functions are synchronous, and they block until the callbacks have been called for all items or the callbacks return <span style="font-family: Courier New,Courier,monospace;">false</span>.
<p>To find only a subset of the items, use a filter. If you want to find all items, set the filter parameter to <span style="font-family: Courier New,Courier,monospace;">NULL</span>.</p>

<p>After the callbacks have created the lists, you can access the tag details with various <span style="font-family: Courier New,Courier,monospace;">media_tag_get_XXX()</span> functions, and the media item details with various <span style="font-family: Courier New,Courier,monospace;">media_info_get_XXX()</span> functions.</p>
<pre class="prettyprint">
media_tag_h tag_handle = NULL;
GList *tag_list = NULL;
GList *media_list_in_tag = NULL;

ret = media_tag_foreach_tag_from_db(NULL, gallery_tag_item_cb, &amp;tag_list);

if (ret != MEDIA_CONTENT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_tag_foreach_tag_from_db() failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_tag_foreach_tag_from_db() successful&quot;);
&nbsp;&nbsp;&nbsp;char *tag_name = NULL;
&nbsp;&nbsp;&nbsp;int tag_id;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(tag_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag_handle = (media_tag_h)g_list_nth_data(tag_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_get_tag_id(tag_handle, &amp;tag_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_get_name(tag_handle, &amp;tag_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_tag_foreach_media_from_db(tag_id, NULL, gallery_media_item_cb, &amp;media_list_in_tag);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_tag_foreach_media_from_db() failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_tag_foreach_media_from_db() successful&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_h tag_media_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_id = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_name = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_path = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_type_e media_type = MEDIA_CONTENT_TYPE_IMAGE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; g_list_length(media_list_in_tag); j++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag_media_handle = (media_info_h)g_list_nth_data(media_list_in_tag, j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_media_id(tag_media_handle, &amp;media_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_display_name(tag_media_handle, &amp;media_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_file_path(tag_media_handle, &amp;media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_media_type(tag_media_handle, &amp;media_type);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_id [%d]: %s&quot;, tag_name, j, media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_type [%d]: %d&quot;, tag_name, j, media_type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_name [%d]: %s&quot;, tag_name, j, media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_path [%d]: %s&quot;, tag_name, j, media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_destroy(tag_media_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(tag_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_destroy(tag_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_list_free(media_list_in_tag);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_list_in_tag = NULL;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;g_list_free(tag_list);
}
</pre></li>
</ol>

	<h2 id="tag_delete" name="tag_delete">Deleting Tags</h2>
	
<p>To delete a tag:</p>
<ol>
<li>Retrieve the tag ID to delete the tag. 
<p>In this use case, the ID is obtained by calling the <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_tag_from_db()</span> function, gathering a tag list in the function callback, iterating through the tag list to find the needed tag handle, and getting the tag ID with the handle using the <span style="font-family: Courier New,Courier,monospace;">media_tag_get_tag_id()</span> function.</p>
<p>The callback is identical to the one used in the <a href="#tag_list">Retrieving Tag Information</a> use case.</p>
<pre class="prettyprint">
GList *tag_list = NULL;
media_tag_h tag_handle = NULL;
int tag_id;
char *tag_name = NULL;

media_tag_foreach_tag_from_db(NULL, gallery_tag_item_cb, &amp;tag_list);

int len = g_list_length(tag_list);

int i;
for (i = 0; i &lt; len; i++)
{
&nbsp;&nbsp;&nbsp;tag_handle = (media_tag_h) g_list_nth_data(tag_list, i);
&nbsp;&nbsp;&nbsp;ret = media_tag_get_tag_id(tag_handle, &amp;tag_id);
</pre>
</li>
<li>Delete the tag with the <span style="font-family: Courier New,Courier,monospace;">media_tag_delete_from_db()</span> function.
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ret = media_tag_delete_from_db(tag_id);
</pre>
</li>

<li>When no longer needed, destroy the handle:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;ret = media_tag_destroy(tag_handle);
}
</pre>
</li>
<li>Free the tag list.
<p>After all elements have been accessed, free the tag handle list:</p>
<pre class="prettyprint">
g_list_free(tag_list);
tag_list = NULL;
</pre>
</li>
</ol>

<h2 id="storage_list" name="storage_list">Retrieving Storage Information</h2>

<p>To access information about the storages:</p>

<ol>
<li>Define a callback function for the <span style="font-family: Courier New,Courier,monospace;">media_storage_foreach_storage_from_db()</span> function, called for each available storage. Use the callback to create a list of storages.
<pre class="prettyprint">
void 
storage_cb(media_storage_h storage, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_storage_h new_storage = NULL;
&nbsp;&nbsp;&nbsp;media_storage_clone(&amp;new_storage, storage);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);
}
</pre></li>
<li>To find the storages, call the <span style="font-family: Courier New,Courier,monospace;">media_storage_foreach_storage_from_db()</span> function with the defined callback. After the callback has created the storage list, you can access the storage details with various <span style="font-family: Courier New,Courier,monospace;">media_storage_get_XXX()</span> functions. 
<pre class="prettyprint">
char *id = NULL;
char *name = NULL;
char *path = NULL;
GList *storage_list = NULL; // Include glib.h
media_storage_h storage = NULL;

ret = media_storage_foreach_storage_from_db(NULL, storage_cb, &amp;storage_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_storage_foreach_storage_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
}
else
{
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(storage_list); i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage = (media_storage_h)g_list_nth_data(storage_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_id(new_storage, &amp;id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_name(new_storage, &amp;name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_path(new_storage, &amp;path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;id:[%s] name:[%s] path:[%s]&quot;, id, name, path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(storage);
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ol>

 <h2 id="find_groups" name="find_groups">Finding Media Item Groups</h2>

 <p>A group is a collection of media items which have the same value of a given property. For example, if the property is the artist, there are as many groups as there are artists, and each group consists of items by the same artist. The possible groups are determined by the <span style="font-family: Courier New,Courier,monospace;">media_group_e</span> enumerator values (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gae17fa4b89b29bafd9b8a123138039655">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gae17fa4b89b29bafd9b8a123138039655">wearable</a> applications), such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_GROUP_ARTIST</span> and <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_GROUP_MIME_TYPE</span>.</p>
 
<p>To find media item groups and filter the results:</p>

<ol>
<li>
<p>To find the media items satisfying certain criteria, or modify the results in a specific way, create a filter and set its properties.</p>
<p>The following example filters media items so that only items whose display name ends with &quot;.jpg&quot; are included in the result (the &#39;%&#39; characters act as wildcards in the filter query, and they must be escaped using another &#39;%&#39; character to avoid compiler warnings). For more information about the filter properties, see <a href="#filter">Setting up a Filter</a>.</p>
<pre class="prettyprint">
filter_h filter;

media_filter_create(&amp;filter);

#define BUFLEN 200 // This is just an example
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s LIKE &#39;%%.jpg&#39;&quot;, MEDIA_DISPLAY_NAME);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_DEFAULT);
</pre></li>
<li>To group media files based on the MIME type:

<ol type="a"><li>
<p>To find the number of MIME type-related groups, use the <span style="font-family: Courier New,Courier,monospace;">media_group_get_group_count_from_db()</span> function:</p>

<pre class="prettyprint">
media_group_e group = MEDIA_CONTENT_GROUP_MIME_TYPE;
int count = -1; 

media_group_get_group_count_from_db(NULL, group, &amp;count);
dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Group count: %d\n&quot;, count);
</pre>

<p>Since the filter (first parameter) is set to <span style="font-family: Courier New,Courier,monospace;">NULL</span>, no filtering is performed and all groups are counted.</p></li>

<li><p>To find the media item groups, use the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_group_from_db()</span> function.</p>

<p>To find only a subset of the groups, use a filter. If you want to find all groups, set the filter parameter to <span style="font-family: Courier New,Courier,monospace;">NULL</span>.</p>
<pre class="prettyprint">
// Find all media group items
media_group_foreach_group_from_db(NULL, group, group_cb, (void *) group);

// Find filtered media group items
media_group_foreach_group_from_db(filter, group, group_cb, (void *) group);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_group_from_db()</span> function requires a callback, which is called for every found media item group. The function is synchronous, and it blocks until the callback is called for all media item groups or the callback returns <span style="font-family: Courier New,Courier,monospace;">false</span>. For information on how to implement the callback, see <a href="#read_group">Reading Media Item Group Information</a>.</p>
</li>
</ol></li>
<li>Destroy the filter:
<pre class="prettyprint">
media_filter_destroy(filter);
</pre>
</li>
</ol>

<h2 id="read_group" name="read_group">Reading Media Item Group Information</h2>

<p>To read media item group information, define a callback for the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_group_from_db()</span> function and retrieve the basic group information (group items and number of items in the group) in the callback:</p>
<ol>
<li>Read the media item group details within the callback:
<pre class="prettyprint">
bool 
group_cb(const char *name, void *user_data)
{
</pre>
<p>The group name is passed as the <span style="font-family: Courier New,Courier,monospace;">name</span> parameter. In this case, names are set to various found MIME types, such as <span style="font-family: Courier New,Courier,monospace;">image/png</span> and <span style="font-family: Courier New,Courier,monospace;">audio/mpeg</span>.</p>
<p>The callback return value determines whether the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace;">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace;">false</span>).</p>
</li>
<li>Once you have the group name and identifier (passed in <span style="font-family: Courier New,Courier,monospace;">user_data</span>), you can read the group information:
<ul>
<li>
<p>Get the number of items in the group using the <span style="font-family: Courier New,Courier,monospace;">media_group_get_media_count_from_db()</span> function.</p> 
<p>The third parameter is the filter. If it is set to <span style="font-family: Courier New,Courier,monospace;">NULL</span>, all items in the group are counted.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;media_group_e group = (media_group_e) user_data;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;\n&quot;);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Group name: %s\n&quot;, name);

&nbsp;&nbsp;&nbsp;int count = -1; 
&nbsp;&nbsp;&nbsp;media_group_get_media_count_from_db(name, group, NULL, &amp;count);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media count in group: %d\n&quot;, count);
</pre></li>
<li>
<p>Get all items in the group using the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_media_from_db()</span> function. Define a callback (<span style="font-family: Courier New,Courier,monospace;">media_cb()</span>) for the function to be triggered for each found item.</p>

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;media_group_foreach_media_from_db(name, group, NULL, media_cb, NULL);

&nbsp;&nbsp;&nbsp;return true;
}

bool 
media_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;char *name = NULL;

&nbsp;&nbsp;&nbsp;media_info_get_display_name(media, &amp;name);
&nbsp;&nbsp;&nbsp;if (name != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li></ul></li></ol>

	
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

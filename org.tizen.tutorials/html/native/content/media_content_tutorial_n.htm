<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Media Content: Using Album, Bookmark, Playlist, and Other Media Content</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>		
		<ul class="toc">
			<li>Media content
				<ul class="toc">
					<li><a href="#initialize_media_content">Initializing Media Content</a></li>
					<li><a href="#folder_list">Getting the Folder List</a></li>
					<li><a href="#item_list">Getting the Item List</a></li>
					<li><a href="#destroy">Destroying the Handle</a></li>
					<li><a href="#update">Receiving Update Notifications</a></li>
				</ul>
			</li>
			<li>Album
				<ul class="toc">
					<li><a href="#init_album">Initializing the Album Module</a></li>
					<li><a href="#findingall">Finding All Albums</a></li>
					<li><a href="#findingalbums">Finding Albums Using a Filter</a></li>
					<li><a href="#findinginfo">Retrieving Album Content Information</a></li>
				</ul>
			</li>
			<li>Bookmark
				<ul class="toc">
					<li><a href="#init_bookmark">Initializing Bookmarks</a></li>
					<li><a href="#inserting">Inserting a Bookmark</a></li>
					<li><a href="#finding">Finding Bookmarks</a></li>
					<li><a href="#reading">Reading Bookmark Information</a></li>
					<li><a href="#removing">Removing a Bookmark</a></li>
				</ul>
			</li>
			<li>Filter
				<ul class="toc">
					<li><a href="#init_filter">Initializing a Filter</a></li>
					<li><a href="#filter">Setting up a Filter</a></li>
					<li><a href="#media">Using Filters to Find Media Items</a></li>
				</ul>
			</li>
			<li>Folder
				<ul class="toc">
					<li><a href="#init_media_folder">Initializing Media Folders</a></li>
					<li><a href="#find">Finding All Media Folders</a></li>
					<li><a href="#filter_folder">Finding Folders Using a Filter</a></li>
					<li><a href="#folder_content">Finding Folder Content</a></li>
				</ul>
			</li>
			<li>Media information 
				<ul class="toc">
					<li><a href="#initialize_media_info">Initializing Media Information</a></li>
					<li><a href="#info">Using Media Information</a></li>
					<li><a href="#insert">Inserting Media in the Database</a></li>
					<li><a href="#scan">Inserting Media in a Folder</a></li>
				</ul>
			</li>
			<li>Playlist 
				<ul class="toc">
					<li><a href="#init_playlist">Initializing a Playlist</a></li>
					<li><a href="#manage">Managing Playlists</a></li>
				</ul>  
			</li>
			<li>Tag
				<ul class="toc">
					<li><a href="#initialize_tag">Initializing Media Tags</a></li>
					<li><a href="#tag_add">Adding Tags</a></li>
					<li><a href="#tag_list">Getting the Tag List</a></li>
					<li><a href="#tag_delete">Deleting Tags</a></li>
				</ul>
			</li>
            <li>Storage
                <ul class="toc">
                    <li><a href="#initialize_storage">Initializing the Storage</a></li>
                    <li><a href="#storage_list">Getting the Storage List</a></li>
                </ul>
            </li>
			<li>Advanced media content
				<ul class="toc">
					<li><a href="#find_groups">Finding Media Item Groups</a></li>	
					<li><a href="#filter_groups">Finding Media Item Groups Using a Filter</a></li>
				</ul>
			</li>
		</ul>       
        <p class="toc-title">Related Info</p>
        <ul class="toc">
             <li><a href="../../../../org.tizen.guides/html/native/content/media_content_n.htm">Media Content Guide</a></li>
			 <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">Media Content API for Mobile Native</a></li>
			 <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">Media Content API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Media Content: Using Album, Bookmark, Playlist, and Other Media Content</h1>

  
  <p>This tutorial demonstrates how you can manage media content.</p>

<h2>Warm-up</h2>
<p>Become familiar with the Media Content API basics by learning about:</p>
	<ul>
		<li>Media content
			<ul>
				<li><a href="#initialize_media_content">Initializing Media Content</a>
				<p>Initialize the database for use.</p></li>
				<li><a href="#folder_list">Getting the Folder List</a>
				<p>Get a folder list.</p></li>
				<li><a href="#item_list">Getting the Item List</a>
				<p>Get an item list.</p></li>
				<li><a href="#destroy">Destroying the Handle</a>
				<p>Destroy a handle.</p></li>
				<li><a href="#update">Receiving Update Notifications</a>
				<p>Set an update notification callback.</p></li>
			</ul>
		</li>
		<li>Album
			<ul>
				<li><a href="#init_album">Initializing the Album Module</a>
				<p>Initialize media albums for use.</p></li>
				<li><a href="#findingall">Finding All Albums</a>
				<p>Find information about albums available in the system.</p></li>
				<li><a href="#findingalbums">Finding Albums Using a Filter</a>
				<p>Find albums that satisfy a specific condition.</p></li>
				<li><a href="#findinginfo">Retrieving Album Content Information</a>
				<p>Retrieve information about the media items in an album.</p></li>
			</ul>
		</li>
		<li>Bookmark
			<ul>
				<li><a href="#init_bookmark">Initializing Bookmarks</a>
				<p>Initialize bookmarks for use.</p></li>
				<li><a href="#inserting">Inserting a Bookmark</a>
				<p>Set a bookmark for a video file.</p></li>
				<li><a href="#finding">Finding Bookmarks</a>
				<p>Find bookmarks using a filter.</p></li>
				<li><a href="#reading">Reading Bookmark Information</a>
				<p>Read the details of a given bookmark.</p></li>
				<li><a href="#removing">Removing a Bookmark</a>
				<p>Remove a bookmark from a video file.</p></li>
			</ul>
		</li>
		<li>Filter
			<ul>
				<li><a href="#init_filter">Initializing a Filter</a>
				<p>Initialize filter for use.</p></li>

				<li><a href="#filter">Setting up a Filter</a>
				<p>Create a filter and set its properties.</p></li>

				<li><a href="#media">Using Filters to Find Media Items</a>
				<p>Use a filter to find media items.</p></li>
			</ul>
		</li>
		<li>Folder
			<ul>
				<li><a href="#init_media_folder">Initializing Media Folders</a>
				<p>Initialize media folders for use.</p></li>

				<li><a href="#find">Finding All Media Folders</a>
				<p>List all available media folders.</p></li>

				<li><a href="#filter_folder">Finding Folders Using a Filter</a>
				<p>Find folders satisfying a given condition, and sort the results.</p></li>

				<li><a href="#folder_content">Finding Folder Content</a>
				<p>List folder content and get information about media items in the folders.</p></li>
			</ul>
		</li>
		<li>Media information 
			<ul>
				<li><a href="#initialize_media_info">Initializing Media Information</a>
				<p>Initialize media information for use.</p></li>

				<li><a href="#info">Using Media Information</a>
				<p>Use media information.</p></li>

				<li><a href="#insert">Inserting Media in the Database</a>
				<p>Add media information in the media database.</p></li>

				<li><a href="#scan">Inserting Media in a Folder</a>
				<p>Add media information in a folder.</p></li>
			</ul>
		</li>
		<li>Playlist 
			<ul>
				<li><a href="#init_playlist">Initializing a Playlist</a>
				<p>Initialize playlists for use. </p></li>
				<li><a href="#manage">Managing Playlists</a>
				<p>Add playlists to the database, search them, and retrieve information about them.</p></li>
			</ul>  
		</li>
		<li>Tag
			<ul>
				<li><a href="#initialize_tag">Initializing Media Tags</a>
				<p>Initialize media tags for use.</p></li>
				<li><a href="#tag_add">Adding Tags</a>
				<p>Add tags to the database.</p></li>
				<li><a href="#tag_list">Getting the Tag List</a>
				<p>Get information about media tags.</p></li>
				<li><a href="#tag_delete">Deleting Tags</a>
				<p>Delete tags from the database.</p></li>
			</ul>
		</li>
        <li>Storage
            <ul>
                <li><a href="#initialize_storage">Initializing the Storage</a>
                <p>Initialize storage information for use.</p></li>
                <li><a href="#storage_list">Getting the Storage List</a>
                <p>Get information about the storage.</p></li>
            </ul>
        </li>
	</ul>
<h2>Follow-up</h2>
<p>Once we have learned the basics of the Media Content API, we can now move on to more advanced tasks, including:</p>
<ul>
		<li>Advanced media content
			<ul>
				<li><a href="#find_groups">Finding Media Item Groups</a> 
				<p>Find all available media items grouped by their MIME type.</p></li>	
				<li><a href="#filter_groups">Finding Media Item Groups Using a Filter</a>
				<p>Find grouped media items filtered by name.</p>
				</li>
			</ul>
		</li>
	</ul>


 <h2 id="initialize_media_content" name="initialize_media_content">Initializing Media Content</h2>


<p>To use the media database:</p>
<ol>
<li><p>Functions in this module use an SQLite database to save the metadata of the media files on your device, along with the tags and bookmarks that the user sets. To use the functions and data types of the Media Content API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
#include &lt;glib.h&gt;
</pre>
<p>The example application used in the other use cases also requires the <span style="font-family: Courier New,Courier,monospace">&lt;glib.h&gt;</span> header file.</p>
</li>
<li>Connect to the database:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;

ret = media_content_connect();
if (ret == MEDIA_CONTENT_ERROR_NONE)
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;connection is success&quot;);
else
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;connection is failed&quot;);

return ret;
</pre></li>
<li>
<p>When you do not use the database anymore, disconnect from it:</p>
<pre class="prettyprint">
media_content_disconnect();
</pre>
</li>
</ol>

 <h2 id="folder_list" name="folder_list">Getting the Folder List</h2>

<p>To retrieve a list of folders where the media files are stored, register a callback function for each API to manage an individual item in the callback function:</p>

<ol>
<li>Register a callback function to get the folder list:
<pre class="prettyprint">
bool gallery_folder_list_cb(media_folder_h folder, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_folder_h new_folder = NULL;
&nbsp;&nbsp;&nbsp;media_folder_clone(&amp;new_folder, folder);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data; // Include glib.h for this value 

&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_folder);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>Get the folder list:
<pre class="prettyprint">
int i;
int count;
filter_h filter = NULL;
GList *folder_list = NULL; // Include glib.h for this value 
media_folder_h folder_handle = NULL;

ret = media_folder_foreach_folder_from_db(filter, gallery_folder_list_cb, &amp;folder_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_folder_foreach_folder_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_folder_foreach_folder_from_db success!!&quot;);

&nbsp;&nbsp;&nbsp;char *folder_id = NULL;
&nbsp;&nbsp;&nbsp;char *folder_name = NULL;
&nbsp;&nbsp;&nbsp;char *folder_path = NULL;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(folder_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder_handle = (media_folder_h)g_list_nth_data(folder_list, i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_folder_id(folder_handle, &amp;folder_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_name(folder_handle, &amp;folder_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_path(folder_handle, &amp;folder_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_folder_get_media_count_from_db(folder_id, filter, &amp;count);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Release allocated strings 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (folder_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_folder_get_media_count_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media count [%d] : %d&quot;, i, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ol>

 <h2 id="item_list" name="item_list">Getting the Item List</h2>

<p>To retrieve the item list, use a foreach function with a previously defined callback:</p>

<ol>
<li>Create a callback function to retrieve a media item:
<pre class="prettyprint">
bool gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data; // Include glib.h for this value 
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>

<li>To find media items, use the <span style="font-family: Courier New,Courier,monospace;">media_info_foreach_media_from_db()</span> function with a filter to filter and sort the results. For a detailed list of condition fields (such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_TYPE</span>) and their values (such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_TYPE_IMAGE</span> and <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_TYPE_VIDEO</span>), see the <span style="font-family: Courier New,Courier,monospace;">media_content_type.h</span> header file.

<pre class="prettyprint">
#define BUFLEN 200 

// Get the item list 
media_info_h media_handle = NULL;
GList *all_item_list = NULL;

media_content_collation_e collate_type = MEDIA_CONTENT_COLLATE_NOCASE;
media_content_order_e order_type = MEDIA_CONTENT_ORDER_DESC;
ret = media_filter_create(&amp;filter);

snprintf(buf, BUFLEN, &quot;%s = %d OR %s = %d&quot;, MEDIA_TYPE, MEDIA_CONTENT_TYPE_IMAGE, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MEDIA_TYPE, MEDIA_CONTENT_TYPE_VIDEO);
ret = media_filter_set_condition(filter, buf, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set condition&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}

ret = media_filter_set_order(filter, order_type, MEDIA_DISPLAY_NAME, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set order&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}

ret = media_info_foreach_media_from_db(filter, gallery_media_item_cb, &amp;all_item_list);
</pre></li>
</ol>

 <h2 id="destroy" name="destroy">Destroying the Handle</h2>

<p>To destroy the handle received from each function (to release resources):</p>

<pre class="prettyprint">
// Remove the folder list 
if (folder_list) 
{
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(folder_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder_handle = (media_folder_h)g_list_nth_data(folder_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_folder_destroy(folder_handle);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;g_list_free(folder_list);
}

// Remove all items list 
if (all_item_list) 
{
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(all_item_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_handle = (media_info_h)g_list_nth_data(all_item_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_destroy(media_handle);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;g_list_free(all_item_list);
}

// Destroy handle of the filter
media_filter_destroy(filter);
</pre>

 <h2 id="update" name="update">Receiving Update Notifications</h2>
 
<p>To get notifications of database changes, register a callback. You can only set 1 notification callback at this stage of the process:</p>

<ol>
<li>Define the database update callback function:
<pre class="prettyprint">
void _noti_cb(media_content_error_e error, int pid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_db_update_item_type_e update_item,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_db_update_type_e update_type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_type_e media_type,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *uuid, char *path, char *mime_type, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (error == MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;noti success! : %d\n&quot;, error);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;error occurred! : %d\n&quot;, error);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti from PID(%d)\n&quot;, pid);

&nbsp;&nbsp;&nbsp;if (update_item == MEDIA_ITEM_FILE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti item : MEDIA_ITEM_FILE\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_item == MEDIA_ITEM_DIRECTORY) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti item : MEDIA_ITEM_DIRECTORY\n&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;if (update_type == MEDIA_CONTENT_INSERT) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type : MEDIA_CONTENT_INSERT\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_type == MEDIA_CONTENT_DELETE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type : MEDIA_CONTENT_DELETE\n&quot;);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else if (update_type == MEDIA_CONTENT_UPDATE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Noti type : MEDIA_CONTENT_UPDATE\n&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;content type : %d\n&quot;, media_type);

&nbsp;&nbsp;&nbsp;if (path) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;path : %s\n&quot;, path);
&nbsp;&nbsp;&nbsp;if (uuid) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;uuid : %s\n&quot;, uuid);
&nbsp;&nbsp;&nbsp;if (mime_type) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;mime_type : %s\n&quot;, mime_type);
&nbsp;&nbsp;&nbsp;if (user_data) dlog_print(DLOG_DEBUG, LOG_TAG, &quot;String : %s\n&quot;, (char *)user_data);

&nbsp;&nbsp;&nbsp;return;
}
</pre></li>

<li>Register the callback function:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;

// Subscribe notifications 
char *user_str = strdup(&quot;hi&quot;);
media_content_set_db_updated_cb(_noti_cb, (void*)user_str);
</pre></li>

<li>When you no longer want to receive notifications, unregister the database update callback function:
<pre class="prettyprint">
media_content_unset_db_updated_cb();
</pre></li>
</ol>

 <h2 id="init_album" name="init_album">Initializing the Album Module</h2>

<p>To use the functions and data types of the Media Album API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__ALBUM__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__ALBUM__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>			
	
<p>Before using the Album module, open a connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace;">media_content_connect()</span> function:</p>
	
<pre class="prettyprint">media_content_connect();</pre>

<p>When the module is no longer needed, close the connection:</p>

<pre class="prettyprint">media_content_disconnect();</pre>

 <h2 id="findingall" name="findingall">Finding All Albums</h2>

<p>To find all albums in the system and access information about the album content:</p>
<ol><li>Find all albums.
<p>Call the <span style="font-family: Courier New,Courier,monospace">media_album_get_album_count_from_db()</span> and <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> functions to receive information about albums. Set the first parameter to <span style="font-family: Courier New,Courier,monospace">NULL</span> to retrieve all albums and perform no filtering.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">media_album_list_cb()</span>callback is called for each found album. </p>

<pre class="prettyprint">media_album_foreach_album_from_db(NULL, media_album_list_cb, NULL);</pre>

<p>Note that the function is synchronous. The call blocks until the callback is called for all albums or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p></li>

<li>Retrieve album information.

<p>Define the callback and retrieve the basic album information (album id, name, the artist name, and the number of media items in the album) in it.</p>
<p>If the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the iteration continues and the callback is called for the next album, if available. If the value is <span style="font-family: Courier New,Courier,monospace">false</span>, the iteration stops.</p>

<pre class="prettyprint">bool media_album_list_cb(media_album_h album, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;int id = -1; 
&nbsp;&nbsp;&nbsp;char *name = NULL, *artist = NULL;
&nbsp;&nbsp;&nbsp;int count = -1;

&nbsp;&nbsp;&nbsp;// Get the ID of the album
&nbsp;&nbsp;&nbsp;ret = media_album_get_album_id(album, &amp;id);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling	
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Album id: %d\n&quot;, id);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;// Get name of the album
&nbsp;&nbsp;&nbsp;ret = media_album_get_name(album, &amp;name);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Album name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;// Get the artist name
&nbsp;&nbsp;&nbsp;ret = media_album_get_artist(album, &amp;artist);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Artist: %s\n&quot;, artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(artist);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Get media count in the album
&nbsp;&nbsp;&nbsp;// Filter is NULL - all media items are counted
&nbsp;&nbsp;&nbsp;ret = media_album_get_media_count_from_db(id, NULL, &amp;count);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media count in this album: %d\n&quot;, count);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre>


<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free <span style="font-family: Courier New,Courier,monospace">album_name</span> and <span style="font-family: Courier New,Courier,monospace">artist</span> after use.</td>
</tr>
</tbody>
</table> </li></ol>


 <h2 id="findingalbums" name="findingalbums">Finding Albums Using a Filter</h2>

<p>Use a filter to find the albums that meet a certain criteria. If an album does not meet the conditions, it is not in the results.</p>

<p>Before searching for the albums, create the filter, and set its conditions and sort order:</p>

<pre class="prettyprint">#define BUFLEN 200

filter_h filter = NULL;
char buf[BUFLEN] = {&#39;\0&#39;};

media_filter_create(&amp;filter);

snprintf(buf, BUFLEN, &quot;%s = &#39;Tizen&#39;&quot;, MEDIA_ARTIST);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);

media_filter_set_order(filter, MEDIA_CONTENT_ORDER_DESC, MEDIA_DISPLAY_NAME, MEDIA_CONTENT_COLLATE_NOCASE);

media_album_foreach_album_from_db(filter, media_album_list_cb, NULL);

media_filter_destroy(filter);</pre>

 <h2 id="findinginfo" name="findinginfo">Retrieving Album Content Information</h2>

<p>To access information about the media items in a given album:</p>

<ol><li>Request album content.

<ol type="a"><li><p>Before you can read the album content information, acquire the album ID. If you have the album handle (<span style="font-family: Courier New,Courier,monospace">media_album_h</span>), you can call the <span style="font-family: Courier New,Courier,monospace">media_album_get_album_id()</span> function:</p>

<pre class="prettyprint">int id = -1;

media_album_get_album_id(album, &amp;id);</pre>

<p>To obtain the handle, call the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_album_from_db()</span> function. The handle is provided in the callback.</p></li>

<li><p>Request the album content and media item count with the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_media_from_db()</span> and <span style="font-family: Courier New,Courier,monospace">media_album_get_media_count_from_db()</span> functions using the album ID as the first parameter.</p>

<p>The following call finds all the media items in the album (<span style="font-family: Courier New,Courier,monospace">NULL</span> filter). The <span style="font-family: Courier New,Courier,monospace">album_contents_info_cb()</span> callback is called for each item.</p>

<pre class="prettyprint">media_album_foreach_media_from_db(id, NULL, album_contents_info_cb, NULL);</pre>


<p>This function is synchronous. The call blocks until the callback is called for all the albums or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p></li></ol></li>

<li id="receive" name="receive">Receive album content.
<p>Define the callback in which you can receive and handle the album content.</p>
<p>As long as the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, the callback is called for the next item, if available. The iteration stops when the return value is <span style="font-family: Courier New,Courier,monospace">false</span>.</p>
 
<pre class="prettyprint">bool album_contents_info_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;

&nbsp;&nbsp;&nbsp;char *title = NULL, *mime_type = NULL;
&nbsp;&nbsp;&nbsp;unsigned long long size = -1;

&nbsp;&nbsp;&nbsp;// Read the item title
&nbsp;&nbsp;&nbsp;ret = media_info_get_title(media, &amp;title);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Title: %s\n&quot;, title);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Read the item MIME type
&nbsp;&nbsp;&nbsp;ret = media_info_get_mime_type(media, &amp;mime_type);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;MIME type: %s\n&quot;, mime_type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(mime_type);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Read the item size
&nbsp;&nbsp;&nbsp;ret = media_info_get_size(media, &amp;size);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Size: %llu\n&quot;, size);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre>

<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Free <span style="font-family: Courier New,Courier,monospace">title</span> and <span style="font-family: Courier New,Courier,monospace">mime_type</span> after use.</td>
</tr>
</tbody>
</table></li></ol>

 <h2 id="init_bookmark" name="init_bookmark">Initializing Bookmarks</h2>

<p>To initialize the bookmark feature:</p>
<ol><li>			
<p>To use the functions and data types of the Media Bookmark API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__BOOKMARK__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__BOOKMARK__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre></li>
<li><p>Before using bookmarks, open a connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function.</p>
	
<pre class="prettyprint">media_content_connect();</pre>

<p>Close the connection when the service is no longer needed:</p>

<pre class="prettyprint">media_content_disconnect();</pre></li></ol>


 <h2 id="inserting" name="inserting">Inserting a Bookmark</h2>

<p>To set a bookmark for a video file at a given timestamp, use the <span style="font-family: Courier New,Courier,monospace">media_bookmark_insert_to_db()</span> function:</p>

<pre class="prettyprint">char* thumbnail_path = &quot;path/to/image/file&quot;;

media_bookmark_insert_to_db(media_id, 220, thumbnail_path);
media_bookmark_insert_to_db(media_id, 210, thumbnail_path);</pre>

<p>The parameters are the media ID of the video file, the moment (time in seconds from the beginning) in the video to bookmark, and the image used as a thumbnail for the bookmark. You can use the same thumbnail for more than 1 bookmark.</p>

 <h2 id="finding" name="finding">Finding Bookmarks</h2>

<p>To find a media item&#39;s bookmarks and filter the results:</p>

<h3>Finding All Bookmarks</h3>

<p>To find the bookmarks set for a media item, use the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_bookmark_from_db()</span> function:</p>

<pre class="prettyprint">media_info_foreach_bookmark_from_db(media_id, NULL, get_bookmarks_cb, NULL);</pre>

<p>The media ID, required as the first parameter, can be obtained by calling the <span style="font-family: Courier New,Courier,monospace">*_get_media_id()</span> functions. The handles that these functions require can be obtained from various sources. For example, <span style="font-family: Courier New,Courier,monospace">media_info_h</span> (needed for <span style="font-family: Courier New,Courier,monospace">media_info_get_media_id()</span>) is provided after calling the <span style="font-family: Courier New,Courier,monospace">media_info_foreach_media_from_db()</span> or <span style="font-family: Courier New,Courier,monospace">media_info_insert_to_db()</span> function.</p>

<p>Find the bookmarks satisfying certain criteria or otherwise modify the results with a filter. If the filter parameter is <span style="font-family: Courier New,Courier,monospace">NULL</span>, no filtering is performed and all bookmarks are returned.</p>

<p>The callback is called for each bookmark in the media item. If the callback returns <span style="font-family: Courier New,Courier,monospace">true</span>, calling of the callback continues, if there are more bookmarks for which the callback has not been called yet. If the return value is <span style="font-family: Courier New,Courier,monospace">false</span>, the callback iteration stops.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">media_info_foreach_bookmark_from_db()</span> function is synchronous. It blocks until the callback is called for all bookmarks or returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p>

<h3>Finding Bookmarks Using a Filter</h3>

<p>To filter the bookmarks, create a filter and set its properties:</p>

<ol><li>Create a filter.
<pre class="prettyprint">filter_h filter = NULL;

media_filter_create(&amp;filter);</pre></li>

<li>Set a condition.
<p>For example, you can receive a bookmark set after a certain time. In this example, only the bookmarks set at the 220th second of the file or later are returned.</p>

<pre class="prettyprint">#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s &gt;= 220&quot;, BOOKMARK_MARKED_TIME);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_DEFAULT);</pre></li>

<li>Set the offset for the filter.

<pre class="prettyprint">media_filter_set_offset(filter,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, // Offset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 // Count
);</pre>

<p>The count sets the limit on the number of returned bookmarks, and the offset determines which of the found bookmarks counts as the &quot;first&quot;. For example, if you sort the bookmarks in an ascending order and the offset is set to 1, you do not receive the earliest bookmark.</p></li>

<li>Define the sorting order. 
<p>The following code causes the filter to sort the results by time, in an ascending order:</p>

<pre class="prettyprint">media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, BOOKMARK_MARKED_TIME, MEDIA_CONTENT_COLLATE_NOCASE);</pre></li>

<li>Apply the filter.

<pre class="prettyprint">media_info_foreach_bookmark_from_db(media_id, filter, get_bookmarks_cb, NULL);</pre>

<p>For information on how to implement the callback, see the <a href="#reading">Reading Bookmark Information</a>.</p></li>

<li><p>Destroy the filter.</p>

<pre class="prettyprint">media_filter_destroy(filter);</pre></li>

</ol>

 <h2 id="reading" name="reading">Reading Bookmark Information</h2>

<p>To read the bookmark information within a callback after finding the bookmark:</p>

<pre class="prettyprint">bool get_bookmarks_cb(media_bookmark_h bookmark, void* user_data)
{
&nbsp;&nbsp;&nbsp;char *thumb = NULL;

&nbsp;&nbsp;&nbsp;if (bookmark != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_bookmark_get_thumbnail_path(bookmark, &amp;thumb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Thumbnail path: %s\n&quot;, thumb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(thumb);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_t time;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_bookmark_get_marked_time(bookmark, &amp;time);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Marked time [s]: %d\n&quot;, (int) time);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre>
<p>The above callback prints the thumbnail path and marked time for each found bookmark.</p>
<p>Free the thumbnail path after use.</p>

 <h2 id="removing" name="removing">Removing a Bookmark</h2>

<p>To remove a bookmark:</p>
<ol><li><p>Acquire the bookmark ID:</p>

<pre class="prettyprint">
media_bookmark_h bookmark = NULL;

// Assuming you have the bookmark handle (media_bookmark_h)
int bookmark_id = -1;
media_bookmark_get_bookmark_id(bookmark, &amp;bookmark_id);</pre></li>

<li><p>Delete the bookmark:</p>

<pre class="prettyprint">media_bookmark_delete_from_db(bookmark_id);</pre></li></ol>

 <h2 id="init_filter" name="init_filter">Initializing a Filter</h2>

<p>To use the functions and data types of the Media Filter API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__FILTER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__FILTER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>
<p>Open the connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function before using the Media Filter API:</p>
	
<pre class="prettyprint">media_content_connect();</pre>

<p>When the service is no longer needed, close the connection:</p>

<pre class="prettyprint">media_content_disconnect();</pre>

 <h2 id="filter" name="filter">Setting up a Filter</h2>

<p>To create a filter and set its properties: offset, condition, and sorting order.</p>

<ol>
<li>Create a filter.
<p>Create a filter using the <span style="font-family: Courier New,Courier,monospace">media_filter_create()</span> function:</p>

<pre class="prettyprint">filter_h filter = NULL;

media_filter_create(&amp;filter);
</pre>

<p>When the filter is no longer needed, destroy it using the <span style="font-family: Courier New,Courier,monospace">media_filter_destroy()</span> function:</p>

<pre class="prettyprint">media_filter_destroy(filter);</pre>
</li>

<li>Set the condition.

<p>Set the condition using the <span style="font-family: Courier New,Courier,monospace">media_filter_set_condition()</span> function.</p>
<p>The following code sets the condition which finds albums with the artist name &quot;Tizen&quot;, and the condition is case insensitive:</p>

<pre class="prettyprint">#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s = &#39;Tizen&#39;&quot;, MEDIA_ARTIST);
ret = media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);</pre>

<p>The function parameters are:</p>
<ul><li>Filter handle</li>
<li>Condition string used for filtering the search results
<p>Queries made with the Content API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__FRAMEWORK.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__FRAMEWORK.html">wearable</a> applications) are passed to a SQL database. A part of each query is a <span style="font-family: Courier New,Courier,monospace">WHERE</span> clause that determines which properties correspond to certain conditions. The condition string defines the <span style="font-family: Courier New,Courier,monospace">WHERE</span> clause and must match the following pattern:</p>
<pre class="prettyprint">&lt;property&gt; &lt;relation&gt; &lt;value&gt;

// If the relation is =, &gt;, &gt;=, &lt;, or &lt;=, the following is also valid
&lt;value&gt; &lt;relation&gt; &lt;property&gt;</pre>

<p>The valid relations are:</p>

<pre class="prettyprint">=, &gt;, &gt;=, &lt;, &lt;=, IN, NOT IN, LIKE</pre>

<p>Conditions can be joined by <span style="font-family: Courier New,Courier,monospace">OR</span> and <span style="font-family: Courier New,Courier,monospace">AND</span> to form more complex conditions.</p>

<p>Condition properties are defined by a series of <span style="font-family: Courier New,Courier,monospace">#define</span> directives. Each Content submodule contains definitions for properties used in the submodule.</p></li>
<li>Collation type determining how the strings are compared
<p>The <span style="font-family: Courier New,Courier,monospace">media_content_collation_e</span> enumerator (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">wearable</a> applications) defines the available collation types.</p></li></ul>

<p>To read the condition of an existing filter, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_condition()</span> function:</p>

<pre class="prettyprint">char *check_condition = NULL;
media_content_collation_e check_collate_type = MEDIA_CONTENT_COLLATE_DEFAULT;

media_filter_get_condition(filter, &amp;check_condition, &amp;check_collate_type);</pre>
</li>

<li>Set the sorting order.

<p>The sorting order is set using the <span style="font-family: Courier New,Courier,monospace">media_filter_set_order()</span> function. For example, the following code sets the order by the artist name, ascending order, and  case sensitive.</p>

<pre class="prettyprint">media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, MEDIA_ARTIST, MEDIA_CONTENT_COLLATE_DEFAULT);</pre>

<p>The second and fourth parameters determine the order and collation types, and the available types are defined in the enumerators <span style="font-family: Courier New,Courier,monospace">media_content_order_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gaa4e5eece5a509c7414afb96e7a2c3fa2">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#gaa4e5eece5a509c7414afb96e7a2c3fa2">wearable</a> applications) and <span style="font-family: Courier New,Courier,monospace">media_content_collation_e</span> (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__CONTENT__MODULE.html#ga31a20f732fe262e81f112416bfefe13c">wearable</a> applications).</p>

<p>To read the order settings of a filter, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_order()</span> function:</p>

<pre class="prettyprint">media_content_order_e check_order_type = MEDIA_CONTENT_ORDER_ASC;
char *check_order_keyword = NULL;
media_content_collation_e check_order_collate_type = MEDIA_CONTENT_COLLATE_DEFAULT;

media_filter_get_order(filter, &amp;check_order_type, &amp;check_order_keyword, &amp;check_order_collate_type);</pre>
</li>

<li>Set the offset.

<p>To avoid receiving all results returned by the query, use the <span style="font-family: Courier New,Courier,monospace">media_filter_set_offset()</span> function.</p>

<p>For example, set the offset to return results starting from the beginning (offset 0), and get a maximum of 5 results:</p>

<pre class="prettyprint">media_filter_set_offset(filter, 0, 5);</pre>

<p>You can use the offset to get specific results. For example, if you sort the items by size in an ascending order and set the offset to 10, the 10 smallest items are not included in the results.</p>

<p>To read the filter offset settings, use the <span style="font-family: Courier New,Courier,monospace">media_filter_get_offset()</span> function:</p>

<pre class="prettyprint">int check_offset = 0;
int check_count = 0;

media_filter_get_offset(filter, &amp;check_offset, &amp;check_count);</pre>
</li>
</ol>

 <h2 id="media" name="media">Using Filters to Find Media Items</h2>

<p>To use a filter to find media items:</p>

<p>The filter construction depends on what kind of a query it is used for. The condition string contains different properties (columns), depending on the submodule.</p>

<p>The following example finds media items with the following conditions:</p>

<ul><li>The artist is &#39;Tizen&#39;</li>
<li>The search for the artist is case-insensitive</li>
<li>The results are ordered by the artist, ascending, and case-sensitive</li>
<li>At most 5 results are provided, starting from the first result</li></ul>


<pre class="prettyprint">filter_h filter = NULL;
char buf[BUFLEN] = {&#39;\0&#39;};

media_filter_create(&amp;filter);

media_filter_set_offset(filter, 0, 5);
snprintf(buf, BUFLEN, &quot;%s = &#39;Tizen&#39;&quot;, MEDIA_ARTIST);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);
media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, MEDIA_ARTIST, MEDIA_CONTENT_COLLATE_DEFAULT);

media_info_foreach_media_from_db(filter, media_cb, NULL);

media_filter_destroy(filter);</pre>

 <h2 id="init_media_folder" name="init_media_folder">Initializing Media Folders</h2>

<p>To use the functions and data types of the Media Folder API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__FOLDER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__FOLDER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>
<p>Open the connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function before using the Media Folder API:</p>
	
<pre class="prettyprint">media_content_connect();</pre>

<p>When the service is no longer needed, close the connection:</p>

<pre class="prettyprint">media_content_disconnect();</pre>


 <h2 id="find" name="find">Finding All Media Folders</h2>

<p>To list all available media folders and their content:</p>

<ol>
<li>Request all folders.
<p>Find folders using the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function. This function finds all folders meeting the criteria given in a filter (when set to <span style="font-family: Courier New,Courier,monospace">NULL</span>, all folders available on the system are returned) and calls the callback for each such folder.</p>
 
<pre class="prettyprint">media_folder_foreach_folder_from_db(NULL, folder_cb, NULL);</pre>

<p>This function is synchronous; it continues until the callback is called for all available folders or the callback returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p>
</li>

<li>Read folder details within the callback:

<pre class="prettyprint">bool folder_cb(media_folder_h folder, void *user_data)
{</pre>

<p>The return value determines if the iterative calls of the callback continue (<span style="font-family: Courier New,Courier,monospace">true</span>) or are stopped (<span style="font-family: Courier New,Courier,monospace">false</span>).</p>

<p>Once you have the folder handle (<span style="font-family: Courier New,Courier,monospace">media_folder_h</span>), you can read the folder information:</p>

<ul><li><p>Use the <span style="font-family: Courier New,Courier,monospace">media_folder_get_folder_id()</span>, <span style="font-family: Courier New,Courier,monospace">media_folder_get_name()</span>, and <span style="font-family: Courier New,Courier,monospace">media_folder_get_path()</span> functions to read the folder ID, name, and path:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;char *folder_id = NULL;
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;char *path = NULL;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_folder_id(folder, &amp;folder_id);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder id: %s\n&quot;, folder_id);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = media_folder_get_name(folder, &amp;name);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;ret = media_folder_get_path(folder, &amp;path);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder path: %s\n&quot;, path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;}</pre>

<p>Free <span style="font-family: Courier New,Courier,monospace">name</span> and <span style="font-family: Courier New,Courier,monospace">path</span> at the end. The <span style="font-family: Courier New,Courier,monospace">folder_id</span> is freed later, since it is still needed.</p></li>

<li><p>Read the folder storage type using the <span style="font-family: Courier New,Courier,monospace">media_folder_get_storage_type()</span> function:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;media_content_storage_e storage_type = MEDIA_CONTENT_STORAGE_INTERNAL;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_storage_type(folder, &amp;storage_type);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (storage_type) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MEDIA_CONTENT_STORAGE_INTERNAL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: Internal\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MEDIA_CONTENT_STORAGE_EXTERNAL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: External\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder storage type: Unknown\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}</pre></li>

<li><p>Get the last modified time:</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;time_t time = 0;

&nbsp;&nbsp;&nbsp;ret = media_folder_get_modified_time(folder, &amp;time);
&nbsp;&nbsp;&nbsp;if (MEDIA_CONTENT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Modified time: %s&quot;, ctime(&amp;time));
&nbsp;&nbsp;&nbsp;}</pre></li>

<li>Get the media item count in the folder with the <span style="font-family: Courier New,Courier,monospace">media_folder_get_media_count_from_db()</span> function. <p>The second parameter is the filter. If it is set to <span style="font-family: Courier New,Courier,monospace">NULL</span>, all media is counted.</p>

<p>Free the <span style="font-family: Courier New,Courier,monospace">folder_id</span> value after it is used for the <span style="font-family: Courier New,Courier,monospace">media_folder_get_media_count_from_db()</span> function.</p>

<pre class="prettyprint">&nbsp;&nbsp;&nbsp;int item_count = -1; 

&nbsp;&nbsp;&nbsp;ret = media_folder_get_media_count_from_db(folder_id, NULL, &amp;item_count);
&nbsp;&nbsp;&nbsp;if (MEDIA_CONTENT_ERROR_NONE != ret) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Number of media contents: %d\n&quot;, item_count);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;free(folder_id);

&nbsp;&nbsp;&nbsp;return true;
}</pre></li></ul>
</li>
</ol>


 <h2 id="filter_folder" name="filter_folder">Finding Folders Using a Filter</h2>

<p>Use filters to choose which folders are found by the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_folder_from_db()</span> function. For example, find folders which meet certain conditions, such as a name containing a given substring. Other modifications of the results, such as sorting, are also possible.</p>

<ol>
<li>Create a filter.
<p>Create a filter using the <span style="font-family: Courier New,Courier,monospace">media_filter_create()</span> function:</p>

<pre class="prettyprint">filter_h filter = NULL;

media_filter_create(&amp;filter);</pre>

<p>Destroy the filter when it is no longer needed:</p>

<pre class="prettyprint">media_filter_destroy(filter);</pre>
</li>

<li>Set the condition.
<p>Set the condition with the <span style="font-family: Courier New,Courier,monospace">media_filter_set_condition()</span> function.</p>

<p>The condition is the string used as the parameter to the WHERE clause in the SQL query. The general format is &quot;&lt;property&gt; &lt;relation&gt; &lt;value&gt;&quot;, such as &quot;FOLDER_NAME = &#39;Downloads&#39;&quot;.</p>
<ul><li>Condition for the &#39;Downloads&#39; folder name:

<pre class="prettyprint">#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s = &#39;Downloads&#39;&quot;, FOLDER_NAME);</pre></li>

<li><p>Condition for the internal folder storage type:</p>

<pre class="prettyprint">snprintf(buf, BUFLEN, &quot;%s = %d&quot;, FOLDER_STORAGE_TYPE, MEDIA_CONTENT_STORAGE_INTERNAL);</pre></li></ul>

<p>The following code finds the folders in the device internal storage. The results are sorted with respect to the modified time, in an ascending order.</p>

<pre class="prettyprint">#define BUFLEN 200
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s = %d&quot;, FOLDER_STORAGE_TYPE, MEDIA_CONTENT_STORAGE_INTERNAL);

media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_NOCASE);

media_filter_set_order(filter, MEDIA_CONTENT_ORDER_ASC, FOLDER_MODIFIED_TIME, MEDIA_CONTENT_COLLATE_DEFAULT);

media_folder_foreach_folder_from_db(filter, folder_cb, NULL);

media_filter_destroy(filter);</pre>
</li>
</ol>

 <h2 id="folder_content" name="folder_content">Finding Folder Content</h2>

<p>To list folder content and get information about media items in the folders:</p>

<ol>
<li>Request folder content.
<p>To find all media items from the folder with the given ID, use the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_media_from_db()</span> function. The function is synchronous; it blocks until the callback calls are finished.</p>

<pre class="prettyprint">media_folder_foreach_media_from_db(folder_id, NULL, media_cb, NULL);</pre>

<p>The callback is iterated until it has been called for all items or it returns <span style="font-family: Courier New,Courier,monospace">false</span>.</p>
</li>

<li>Receive folder content.

<p>List the content using the <span style="font-family: Courier New,Courier,monospace">media_folder_foreach_media_from_db()</span> function (this is very similar to using the <span style="font-family: Courier New,Courier,monospace">media_album_foreach_media_from_db()</span> function, since both functions call callbacks of the same type). To implement the callback, see the <a href="#receive"><span style="font-family: Courier New,Courier,monospace">media_album_foreach_media_from_db()</span> callback  implementation</a>.</p>

<p>The following example prints the title of the media item for which it was called.</p>

<pre class="prettyprint">bool media_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *title = NULL;

&nbsp;&nbsp;&nbsp;ret = media_info_get_title(media, &amp;title);
&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Title: %s\n&quot;, title);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}   

&nbsp;&nbsp;&nbsp;return true;
}</pre>
</li>
</ol>

 <h2 id="initialize_media_info" name="initialize_media_info">Initializing Media Information</h2>

<p>To use the media database:</p>

<ol>
<li><p>To use the functions and data types of the Media Information API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__INFO__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__INFO__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>
</li>
<li><p>Before retrieving media information, open a connection to the Content Service using the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function:</p>
	
<pre class="prettyprint">media_content_connect();</pre>
</li>

<li><p>Close the connection when the service is no longer needed:</p>

<pre class="prettyprint">media_content_disconnect();</pre>
</li>
</ol>

 <h2 id="info" name="info">Using Media Information</h2>

<p>To retrieve media information:</p>

<ol>
<li>Create a callback function to retrieve a media item:

<pre class="prettyprint">
bool gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>

<li>Create a handle by setting a query and filter.

<p>Media information is based on the media information handle. The metadata varies depending on the media type, such as image, video, or audio. You can obtain common information from the media information.</p>
<p>Based on the media information handle, use a getter function for the metadata after calling a clone function supported by each metadata.</p>

<pre class="prettyprint">
#define BUFLEN 200
GList *all_item_list = NULL; // Include glib.h
media_content_type_e media_type;
media_info_h media_handle = NULL;
char *media_id = NULL;
char *media_name = NULL;
char *media_path = NULL;
char buf[BUFLEN] = {&#39;\0&#39;};
int ret = MEDIA_CONTENT_ERROR_NONE;
filter_h filter = NULL;
media_content_collation_e collate_type = MEDIA_CONTENT_COLLATE_NOCASE;
media_content_order_e order_type = MEDIA_CONTENT_ORDER_DESC;

media_filter_create(&amp;filter);

// Set the condition
snprintf(buf, BUFLEN, &quot;%s = %d OR %s = %d&quot;, MEDIA_TYPE, MEDIA_CONTENT_TYPE_IMAGE, MEDIA_TYPE, MEDIA_CONTENT_TYPE_VIDEO);

ret = media_filter_set_condition(filter, buf, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set condition&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}
ret = media_filter_set_order(filter, order_type, MEDIA_DISPLAY_NAME, collate_type);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Failed to set order&quot;);

&nbsp;&nbsp;&nbsp;return ret;
}

ret = media_info_foreach_media_from_db(filter, gallery_media_item_cb, &amp;all_item_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_info_foreach_media_from_db failed: %d&quot;, ret);
&nbsp;&nbsp;&nbsp;media_filter_destroy(filter);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(all_item_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_handle = (media_info_h)g_list_nth_data(all_item_list, i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_id(media_handle, &amp;media_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_type(media_handle, &amp;media_type);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_display_name(media_handle, &amp;media_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_file_path(media_handle, &amp;media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_type == MEDIA_CONTENT_TYPE_IMAGE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_h image_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_orientation_e orientation = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int width = 0, height = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *datetaken = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *burst_id = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_image(media_handle, &amp;image_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_width(image_handle, &amp;width);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_height(image_handle, &amp;height);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_orientation(image_handle, &amp;orientation);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_date_taken(image_handle, &amp;datetaken);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_get_burst_id(image_handle, &amp;burst_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;This is an image&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Width : %d, Height : %d, Orientation : %d, Date taken : %s&quot;, width, height, orientation, datetaken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (datetaken) free(datetaken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (burst_id) free(burst_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_meta_destroy(image_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (media_type == MEDIA_CONTENT_TYPE_VIDEO) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_h video_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *title = NULL, *artist = NULL, *album = NULL, *album_artist = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int duration = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time_t time_played = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_video(media_handle, &amp;video_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Error handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_artist(video_handle, &amp;artist);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_album(video_handle, &amp;album);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_album_artist(video_handle, &amp;album_artist);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_get_duration(video_handle, &amp;duration);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_played_time(media_handle, &amp;time_played);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;This is a video&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Title: %s, Album: %s, Artist: %s, Album_artist: %s \n Duration: %d, Played time: %d&quot;, title, album, artist, album_artist, duration, time_played);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(artist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(album);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(album_artist);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_meta_destroy(video_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_id [%d] : %s&quot;, i, media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_name [%d] : %s&quot;, i, media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_path [%d] : %s&quot;, i, media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(title);
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
<table class="note">
<tbody>
<tr>
<th class="note">Note</th>
</tr>
<tr>
<td class="note">Note that the video_meta_get_played_time () and a few APIs have been <strong>deprecated since Tizen 2.4</strong>.<br />
To replace video_meta_get_played_time (), use media_info_get_played_time () instead.<br />
Although the deprecated APIs continue to be available, it is strongly recommended to use new APIs.<br />
For more information on the deprecated information, please refer to the media content mobile API reference (<a href="../../../../org.tizen.native.mobile.apireference/group_CAPIMEDIA_CONTENT_MODULE.html">link</a>) and the media content wearable API reference (<a href="../../../../org.tizen.native.mobile.apireference/group_CAPIMEDIA_CONTENT_MODULE.html">link</a>)
</td>
</tr>
</tbody>
</table>
<li>When the filter is no longer used, destroy the list, filter, and query:

<pre class="prettyprint">
media_filter_destroy(filter);
filter = NULL;
</pre></li>
</ol>

 <h2 id="insert" name="insert">Inserting Media in the Database</h2>
 
 <p>To insert media in the database:</p>

<ol><li><p>To use newly created media files, first insert them into the database. You need the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/content.write</span> privilege to use the needed APIs.</p>
<p>You also need the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/mediastorage</span> or <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/externalstorage</span> privilege, since when you insert metadata, the media content APIs access content in the internal or external storage.</p></li>

<li><p>To add information in the database:</p>
 
<ul><li><p>You can use the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function:</p>
<pre class="prettyprint">int ret = MEDIA_CONTENT_ERROR_NONE;
char *image_file = &quot;Default.jpg&quot;;
char *directory = NULL;
char *path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;directory);
path = (char*)malloc(strlen(directory) + strlen(image_file) + 1);
memset(path, 0x00, strlen(directory) + strlen(image_file) + 1);
sprintf(path, &quot;%s/%s&quot;, directory, image_file);

media_info_h media_item = NULL;

ret = media_info_insert_to_db(path, &amp;media_item);

if ((ret == MEDIA_CONTENT_ERROR_NONE) &amp;&amp; (media_item != NULL)) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Insertion successful&quot;);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Insertion failed&quot;);
&nbsp;&nbsp;&nbsp;if (media_item != NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_destroy(media_item);

&nbsp;&nbsp;&nbsp;return ret;
}

// After using the media handle, destroy it
ret = media_info_destroy(media_item);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return ret;
}
</pre></li>

<li>You can use the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;
char *image_file = &quot;Default.jpg&quot;;
char *directory = NULL;
char *file_path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;directory);
file_path = (char*)malloc(strlen(directory) + strlen(image_file) + 1);
memset(file_path, 0x00, strlen(directory) + strlen(image_file) + 1);
sprintf(file_path, &quot;%s/%s&quot;, directory, image_file);

ret = media_content_scan_file(file_path);
if (ret != MEDIA_CONTENT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;// Error handling
}
</pre></li></ul>

<p>The difference between the 2 functions is that the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function is used by getting <span style="font-family: Courier New,Courier,monospace;">media_info_h</span> of the media file after inserting it to the database, whereas the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function supports only inserting a file to the media database, or removing it.</p>

<p>Basically, the media database does not allow duplicate paths. If you try to insert the same data, the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function returns an error. But the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function does not return an error, and allows you to get <span style="font-family: Courier New,Courier,monospace;">media_info_h</span>.</p></li>


<li><p>After using the <span style="font-family: Courier New,Courier,monospace;">media_info_insert_to_db()</span> function, destroy the received <span style="font-family: Courier New,Courier,monospace;">media_info_h</span> with using the <span style="font-family: Courier New,Courier,monospace;">media_info_destroy()</span> function.</p></li></ol>

 <h2 id="scan" name="scan">Inserting Media in a Folder</h2>

<p>To insert media in a folder:</p>
 
<ol>
<li><p>You can scan either a single folder, or include its subdirectories. You need the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/content.write</span> privilege to use these APIs.</p>
<p>You also need the <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/mediastorage</span> or <span style="font-family: Courier New,Courier,monospace;">http://tizen.org/privilege/externalstorage</span> privilege, since when you insert metadata, the media content APIs access content in the internal or external storage.</p></li>
<li>As scanning works asynchronously, you must a callback function:
<pre class="prettyprint">
void _scan_cb(media_content_error_e err, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Folder scanned\n&quot;);

&nbsp;&nbsp;&nbsp;return;
}
</pre></li>

<li>Scan a folder and its subfolders:
<pre class="prettyprint">
int ret = MEDIA_CONTENT_ERROR_NONE;
char *dir_path = NULL;

storage_get_directory(0, STORAGE_DIRECTORY_IMAGES, &amp;dir_path);

ret = media_content_scan_folder(dir_path, TRUE, _scan_cb, NULL);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;// Error handling

&nbsp;&nbsp;&nbsp;return ret;
}
</pre></li>
</ol>

 <h2 id="init_playlist" name="init_playlist">Initializing a Playlist</h2>

<p>To use the playlists:</p>
<ol><li><p>To use the functions and data types of the Media Playlist API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__PLAYLIST__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__PLAYLIST__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>
</li>

<li><p>Establish a connection to the database:</p>
<pre class="prettyprint">
media_content_connect();
</pre>
<p>Close the connection when the service is no longer needed:</p>
<pre class="prettyprint">
media_content_disconnect();
</pre>
</li></ol>

 <h2 id="manage" name="manage">Managing Playlists</h2>

<p>To create and insert a playlist to the database, perform a search on existing records and handle the found items:</p>


<ol><li>Insert a record to the database.
<ol type="a"><li><p>To operate on the database, it has to contain records. Add a new playlist to the database using the <span style="font-family: Courier New,Courier,monospace;">media_playlist_insert_to_db()</span> function. It returns a handle to the newly created record.</p>
<pre class="prettyprint">media_playlist_h playlist = NULL;
filter_h audio_filter = NULL;
GList *media_id_list = NULL; // This requires glib.h inclusion
int media_count;
int start_position = -1;
int count = -1;
int x;
int id;
int ret;

// Create the playlist
media_playlist_insert_to_db(&quot;playlist_for_tutorial&quot;, &amp;playlist);
</pre></li>

<li><p>To fill a playlist with data, register the existing media in the database using the <span style="font-family: Courier New,Courier,monospace;">media_content_scan_file()</span> function. Then you can check the media database size using the <span style="font-family: Courier New,Courier,monospace;">media_info_get_media_count_from_db()</span> function and allocate the required amount of space. The callback function registered using the <span style="font-family: Courier New,Courier,monospace;">media_info_foreach_media_from_db()</span>  function returns a list of media IDs.</p>

<p>The specified media objects are added to the playlist with <span style="font-family: Courier New,Courier,monospace;">media_playlist_add_media()</span>.</p>
<pre class="prettyprint">
// sound_path must be set to an audio file
media_content_scan_file(path); 

media_info_get_media_count_from_db(NULL, &amp;media_count); 

media_info_foreach_media_from_db(NULL, _media_info_cb, &amp;media_id_list); 

if (media_count &gt; 0) 
{
&nbsp;&nbsp;&nbsp;for (x = 0; x &lt; media_count; x++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_id = (char*)g_list_nth_data(media_id_list, x);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_playlist_add_media(playlist, media_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_id);
&nbsp;&nbsp;&nbsp;}
}

media_playlist_update_to_db(playlist);</pre></li>

<li><p>In the callback function, cast the user data to a proper type and copy the media ID:</p>

<pre class="prettyprint">bool _media_info_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *data = NULL;
&nbsp;&nbsp;&nbsp;char *id = NULL;

&nbsp;&nbsp;&nbsp;if (media != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_get_media_id(media, &amp;id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media found: %s\n&quot;, id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = strdup(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(id);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}</pre></li></ol></li>



<li>Perform a search.
<p>To select any records from the database, you must know their ID or perform a search on the records.</p>

<p>To start a search, use the <span style="font-family: Courier New,Courier,monospace;">media_playlist_foreach_playlist_from_db()</span> function. To use this function, provide an existing filter and a callback function to be used each time a record is found.</p>

<pre class="prettyprint">
media_playlist_foreach_playlist_from_db(NULL, playlist_list_cb,  NULL);
</pre>

<p>You can define the playlist name using the <span style="font-family: Courier New,Courier,monospace;">media_playlist_set_name()</span> function.</p></li>

<li>Handle the found records.

<ol type="a"><li><p>When a record is found, a callback function is invoked. A handle to the record is passed as a playlist function parameter.</p> 
<pre class="prettyprint">static bool playlist_list_cb(media_playlist_h playlist, void* user_data) 
{
&nbsp;&nbsp;&nbsp;char *name = NULL;
&nbsp;&nbsp;&nbsp;int playlist_id = 0;
&nbsp;&nbsp;&nbsp;int count = 0;
</pre></li>

<li><p>Access the record details using the <span style="font-family: Courier New,Courier,monospace;">media_playlist_get_name()</span> and <span style="font-family: Courier New,Courier,monospace;">media_playlist_get_playlist_id()</span> functions.</p>

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;media_playlist_get_name(playlist, &amp;name);
&nbsp;&nbsp;&nbsp;media_playlist_get_playlist_id(playlist, &amp;playlist_id);
</pre></li>

<li><p>After reading the playlist ID, execute 2 searches on it. The first search filter operates on all records on the playlist, and the second one works only on the first 10 records. Destroy the filters after all operations. </p>

<p>The <span style="font-family: Courier New,Courier,monospace;">media_playlist_foreach_media_from_db()</span> function invokes a callback for each record matching the filter. The search is performed on a playlist with the specified ID.</p>

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;filter_h temp_filter = NULL;
&nbsp;&nbsp;&nbsp;media_filter_create(&amp;temp_filter);

&nbsp;&nbsp;&nbsp;media_filter_set_offset(temp_filter, -1, -1);

&nbsp;&nbsp;&nbsp;media_playlist_get_media_count_from_db(playlist_id, temp_filter, &amp;count);
&nbsp;&nbsp;&nbsp;filter_h audio_fltr;

&nbsp;&nbsp;&nbsp;media_filter_create(&amp;audio_fltr);

&nbsp;&nbsp;&nbsp;media_filter_set_offset(audio_fltr, 0, 10);

&nbsp;&nbsp;&nbsp;media_playlist_foreach_media_from_db(playlist_id, audio_fltr, audio_list_cb, NULL);

&nbsp;&nbsp;&nbsp;media_filter_destroy(audio_fltr);
&nbsp;&nbsp;&nbsp;media_filter_destroy(temp_filter);

&nbsp;&nbsp;&nbsp;return true;
}</pre></li>

<li><p>The callback function operates on the records the same way as before. To get the media info, use the following functions:</p>
<ul><li><span style="font-family: Courier New,Courier,monospace;">media_info_get_audio()</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">media_info_get_media_id()</span></li>
<li><span style="font-family: Courier New,Courier,monospace;">media_info_get_size()</span></li></ul>

<pre class="prettyprint">static bool audio_list_cb(int playlist_member_id, media_info_h media_hndl, void *user_data) 
{
&nbsp;&nbsp;&nbsp;char * id;
&nbsp;&nbsp;&nbsp;media_info_get_media_id(media_hndl, &amp;id);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media on the playlist: %s\n&quot;, id);
&nbsp;&nbsp;&nbsp;free(id);

&nbsp;&nbsp;&nbsp;return true;
}</pre></li></ol></li>


<li>Clean up.
<p>After all operations, delete the playlist from the database to avoid creating useless records. In addition, destroy all filters and handles to the records. At the end, close the connection to the database.</p>
<pre class="prettyprint">media_playlist_get_playlist_id(playlist, &amp;id);
media_playlist_delete_from_db(id);

media_playlist_destroy(playlist);

media_filter_destroy(audio_filter);
media_content_disconnect();</pre></li></ol>

 <h2 id="initialize_tag" name="initialize_tag">Initializing Media Tags</h2>

<p>To use the functions and data types of the Media Tag API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__TAG__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__TAG__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre>

<p>Before using tag-related functions, open a connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function:</p>
	
<pre class="prettyprint">media_content_connect();</pre>

<p>Close the connection when the service is no longer needed:</p>

<pre class="prettyprint">media_content_disconnect();</pre>

 <h2 id="tag_add" name="tag_add">Adding Tags</h2>
<p>To add a tag to the database, and add a file to the tag:</p>
<ol>
<li>Add the tag.
<p>Use <span style="font-family: Courier New,Courier,monospace;">media_tag_insert_to_db()</span> to add the tag. The result is a handle to the new tag.</p>
<pre>
media_tag_h tag = NULL;
const char *tag_name = "Tag name";

media_tag_insert_to_db(tag_name, &amp;tag);
</pre>
</li>

<li>Insert a media item into the tag.
<p>
To insert an item into the tag, you need to know the id of the item.
One of the ways of obtaining the id is to insert a media item into the database.
In the example below, a media file is inserted and then added to the tag.</p>
<pre>
media_info_h image_info = NULL;
char *image_id = NULL;

media_info_insert_to_db("path/to/image_file", &amp;image_info);

media_info_get_media_id(image_info, &amp;image_id);

media_tag_add_media(tag, image_id);
</pre>
</li>

<li>Update the tag.
<p>After you make any changes to the tag, like change its name or add items, you need to update it.</p>
<pre>
media_tag_update_to_db(tag);
</pre>
</li>

<li>Destroy the tag handle.</li>
<p>After the tag has been inserted into the database and all updates to it have been made, you can destroy the handle. Note that this is not related to deleting the tag from the database.</p>
<pre>
media_tag_destroy(tag);
</pre>
</ol>


 <h2 id="tag_list" name="tag_list">Getting the Tag List</h2>

<p>To get the tag list:</p>

<ol>
<li>Define callback functions:
<pre class="prettyprint">
// glib library is used, so include glib.h

bool gallery_tag_item_cb(media_tag_h tag, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_tag_h new_tag = NULL;
&nbsp;&nbsp;&nbsp;media_tag_clone(&amp;new_tag, tag);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_tag);

&nbsp;&nbsp;&nbsp;return true;
}

bool gallery_media_item_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_info_h new_media = NULL;
&nbsp;&nbsp;&nbsp;media_info_clone(&amp;new_media, media);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>
<li>After getting the tag information which is already set, you can import individual media information.

<p>Get a tag and media list using a tag ID:</p>
<pre class="prettyprint">
media_tag_h tag_handle = NULL;
GList *tag_list = NULL;
GList *media_list_in_tag = NULL;

ret = media_tag_foreach_tag_from_db (NULL, gallery_tag_item_cb, &amp;tag_list);

if (ret != MEDIA_CONTENT_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_tag_foreach_tag_from_db() failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_tag_foreach_tag_from_db() successful&quot;);
&nbsp;&nbsp;&nbsp;char *tag_name = NULL;
&nbsp;&nbsp;&nbsp;int tag_id;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(tag_list); i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag_handle = (media_tag_h)g_list_nth_data(tag_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_get_tag_id(tag_handle, &amp;tag_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_get_name(tag_handle, &amp;tag_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_tag_foreach_media_from_db(tag_id, NULL, gallery_media_item_cb, &amp;media_list_in_tag);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != MEDIA_CONTENT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_tag_foreach_media_from_db() failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;media_tag_foreach_media_from_db() successful&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_h tag_media_handle;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_id = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_name = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *media_path = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_content_type_e media_type = MEDIA_CONTENT_TYPE_IMAGE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; g_list_length(media_list_in_tag); j++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tag_media_handle = (media_info_h)g_list_nth_data(media_list_in_tag, j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_media_id(tag_media_handle, &amp;media_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_display_name(tag_media_handle, &amp;media_name);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_file_path(tag_media_handle, &amp;media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = media_info_get_media_type(tag_media_handle, &amp;media_type);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_id [%d] : %s&quot;, tag_name, j, media_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_type [%d] : %d&quot;, tag_name, j, media_type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_name [%d] : %s&quot;, tag_name, j, media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;[%s] media_path [%d] : %s&quot;, tag_name, j, media_path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(media_path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_info_destroy(tag_media_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(tag_name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_tag_destroy(tag_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_list_free(media_list_in_tag);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_list_in_tag = NULL;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;g_list_free(tag_list);
}
</pre></li>
</ol>

 <h2 id="tag_delete" name="tag_delete">Deleting Tags</h2>
<p>Deleting a tag requires its id. In the example below, the id is obtained by calling <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_tag_from_db()</span>.</p>
<ol>
<li>Define the callback.
<p>Define the callback called for each found tag. The callback will add the handle of each tag to the tag list.</p>
<pre>
bool gallery_tag_item_cb(media_tag_h tag, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_tag_h new_tag = NULL;

&nbsp;&nbsp;&nbsp;int ret = media_tag_clone(&amp;new_tag, tag);
&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_tag);

&nbsp;&nbsp;&nbsp;return true; // Continue with the next iteration
}
</pre>
</li>
<li>Find tags.
<p>Call <span style="font-family: Courier New,Courier,monospace;">media_tag_foreach_tag_from_db()</span> to find tags in the database. The first parameter is a filter; if NULL, all tags are found. The second parameter is the callback, called for each found tag. The third parameter is data passed to the callback in each iteration. In this example it is a list of tag handles.</p>
<pre>
GList *tag_list = NULL;

media_tag_foreach_tag_from_db(NULL, gallery_tag_item_cb, &amp;tag_list);
</pre>

<li>Iterate through the tag list.
<p>After the list is completed, access each element:</p>

<pre>
media_tag_h tag_handle = NULL;
int tag_id;
char *tag_name = NULL;

int len = g_list_length(tag_list);

int i;
for (i = 0; i &lt; len; i++)
{
&nbsp;&nbsp;&nbsp;tag_handle = (media_tag_h) g_list_nth_data(tag_list, i);
</pre>
</li>
<li>Delete the tag.
<p>Provided that you have the tag handle, get the tag id with <span style="font-family: Courier New,Courier,monospace;">media_tag_get_tag_id()</span> and delete the tag with <span style="font-family: Courier New,Courier,monospace;">media_tag_delete_from_db()</span>.</p>
<pre>
&nbsp;&nbsp;&nbsp;ret = media_tag_get_tag_id(tag_handle, &amp;tag_id);

&nbsp;&nbsp;&nbsp;ret = media_tag_delete_from_db(tag_id);
</pre>
</li>

<li>Destroy the tag handle.
<p>Now that the handle is no longer needed, it can be destroyed:</p>
<pre>
&nbsp;&nbsp;&nbsp;ret = media_tag_destroy(tag_handle);
}
</pre>
</li>
<li>Free the tag list.
<p>After all elements have been accessed, free the tag handle list:</p>
<pre>
g_list_free(tag_list);
tag_list = NULL;
</pre>
</li>

</ol>


<h2 id="initialize_storage" name="initialize_storage">Initializing the Storage</h2>

<p>To initialize the storage for use:</p>

<ol><li><p>To use the functions and data types of the Media Storage API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__CONTENT__MEDIA__STORAGE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__CONTENT__MEDIA__STORAGE__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;media_content.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;media_content.h&gt;
</pre></li>

<li><p>Before retrieving storage information, open a connection to the Content Service by calling the <span style="font-family: Courier New,Courier,monospace">media_content_connect()</span> function:</p>
       
<pre class="prettyprint">media_content_connect();</pre>

<p>When the service is no longer needed, close the connection:</p>

<pre class="prettyprint">media_content_disconnect();</pre>
</li></ol>


<h2 id="storage_list" name="storage_list">Getting the Storage List</h2>

<p>To get the storage list:</p>

<ol>
<li>Define callback functions:
<pre class="prettyprint">
void storage_cb(media_storage_h storage, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_storage_h new_storage = NULL;
&nbsp;&nbsp;&nbsp;media_storage_clone(&amp;new_storage, storage);

&nbsp;&nbsp;&nbsp;GList **list = (GList**)user_data;
&nbsp;&nbsp;&nbsp;*list = g_list_append(*list, new_media);
}
</pre></li>
<li>After getting the storage information which is already set, you can use the information for advanced search.
<p>Get the storage information:</p>
<pre class="prettyprint">
char *id = NULL;
char *name = NULL;
char *path = NULL;
GList *storage_list = NULL; // Include glib.h
media_storage_h storage = NULL;

ret = media_storage_foreach_storage_from_db(NULL, storage_cb, &amp;storage_list);
if (ret != MEDIA_CONTENT_ERROR_NONE) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;media_storage_foreach_storage_from_db failed: %d&quot;, ret);

&nbsp;&nbsp;&nbsp;return ret;
}
else
{
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; g_list_length(storage_list); i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storage = (media_storage_h)g_list_nth_data(storage_list, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_id(new_storage, &amp;id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_name(new_storage, &amp;name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_storage_get_path(new_storage, &amp;path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;id:[%s] name:[%s] path:[%s]&quot;, id, name, path);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(storage);
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ol>

 <h2 id="find_groups" name="find_groups">Finding Media Item Groups</h2>

<p>To find groups of media items and items in a given group:</p>

<ol>
<li>Search for groups.
<p>A group is a collection of media items which have the same value of a given property. For example, if the property is the artist, there are as many groups as there are artists, and each group consists of items by the same artist. The possible groups are determined by the <span style="font-family: Courier New,Courier,monospace;">media_group_e</span> values, such as <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_GROUP_ARTIST</span> and <span style="font-family: Courier New,Courier,monospace;">MEDIA_CONTENT_GROUP_MIME_TYPE</span>.</p>
<ol type="a"><li>
<p>Find the number of MIME type-related groups:</p>

<pre class="prettyprint">
media_group_e group = MEDIA_CONTENT_GROUP_MIME_TYPE;
int count = -1; 

media_group_get_group_count_from_db(NULL, group, &amp;count);
dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Group count: %d\n&quot;, count);
</pre>

<p>The first parameter is the <a href="#filter">filter</a>. In this example, the filter is <span style="font-family: Courier New,Courier,monospace;">NULL</span>, which means that no filtering is performed and all items are considered when searching.</p></li>

<li><p>Find groups using the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_group_from_db()</span> function.</p>

<p>The first parameter defines a filter, and the second the group identifier. The third parameter defines the callback called for each group, and the final parameter is the data passed to the callback upon each call.</p>

<p>The following example searches all media items and provides all groups as the result. For each found group, the <span style="font-family: Courier New,Courier,monospace;">group_cb()</span> function is called. The group identifier is given as the data passed to the callback.</p>

<pre class="prettyprint">
media_group_foreach_group_from_db(NULL, group, group_cb, (void *) group);
</pre></li></ol></li>

<li>Receive group data.
<ol type="a"><li>
<p>Define the callback for receiving the group data. If the callback returns <span style="font-family: Courier New,Courier,monospace;">true</span>, the iteration over the found groups continues. If the return value is <span style="font-family: Courier New,Courier,monospace;">false</span>, the iteration is stopped.</p>

<p>Each time the callback is called for a group, the group name is passed as the <span style="font-family: Courier New,Courier,monospace;">name</span> parameter. In this case, names are set to various found MIME types, such as <span style="font-family: Courier New,Courier,monospace;">image/png</span> and <span style="font-family: Courier New,Courier,monospace;">audio/mpeg</span>.</p>

<p>Having the group name and identifier (passed in <span style="font-family: Courier New,Courier,monospace;">user_data</span>), find the number of items in the group using the <span style="font-family: Courier New,Courier,monospace;">media_group_get_media_count_from_db() function</span>. The third parameter is the filter, set to <span style="font-family: Courier New,Courier,monospace;">NULL</span> to count all items in the group.</p>

<p>To find all items in the group, call the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_media_from_db()</span> function. The parameters are similar to those in the <span style="font-family: Courier New,Courier,monospace;">media_group_foreach_media_from_db()</span> function. The <span style="font-family: Courier New,Courier,monospace;">media_cb()</span> callback is called for each found item.</p>

<pre class="prettyprint">
bool group_cb(const char *name, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;media_group_e group = (media_group_e) user_data;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;\n&quot;);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Group name: %s\n&quot;, name);

&nbsp;&nbsp;&nbsp;int count = -1; 
&nbsp;&nbsp;&nbsp;media_group_get_media_count_from_db(name, group, NULL, &amp;count);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Media count in group: %d\n&quot;, count);

&nbsp;&nbsp;&nbsp;media_group_foreach_media_from_db(name, group, NULL, media_cb, NULL);

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li>

<li>Define the <span style="font-family: Courier New,Courier,monospace;">media_cb()</span> callback to handle each found item:

<pre class="prettyprint">
bool media_cb(media_info_h media, void *user_data)
{
&nbsp;&nbsp;&nbsp;media_content_error_e ret = MEDIA_CONTENT_ERROR_NONE;
&nbsp;&nbsp;&nbsp;char *name = NULL;

&nbsp;&nbsp;&nbsp;media_info_get_display_name(media, &amp;name);
&nbsp;&nbsp;&nbsp;if (name != NULL) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Name: %s\n&quot;, name);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(name);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre></li></ol></li></ol>

 <h2 id="filter_groups" name="filter_groups">Finding Media Item Groups Using a Filter</h2>

<p>To find groups containing only items matching the given criteria:</p>	
	
<ol>
<li>Create a filter.
<p>When searching for groups, you can use a filter to limit what media items are considered. For example, search only for items containing a given substring in their name. Items which do not meet this condition are ignored, and groups are formed entirely of items which meet the condition. For example, if you group files by MIME type and only look for files containing &#39;.jpg&#39; in their name, groups which do not contain such files are not listed.</p>

<pre class="prettyprint">
filter_h filter;

media_filter_create(&amp;filter);
</pre></li>

<li><p>Set the filter condition. The condition is a string used in a SQL query. </p>
<p>The following example searches for files containing &#39;.jpg&#39; in their name. The &#39;%&#39; characters in the query act as wildcards. Also, they should be escaped using another &#39;%&#39; character to avoid compiler warnings.</p>

<pre class="prettyprint">
#define BUFLEN 200 // This is just an example
char buf[BUFLEN] = {&#39;\0&#39;};

snprintf(buf, BUFLEN, &quot;%s LIKE &#39;%%.jpg&#39;&quot;, MEDIA_DISPLAY_NAME);
media_filter_set_condition(filter, buf, MEDIA_CONTENT_COLLATE_DEFAULT);
</pre></li>

<li><p>Search for groups as in the &quot;Finding Media Item Groups&quot; use case, but define the created filter as the first parameter. The same callbacks as before are used.</p>

<pre class="prettyprint">
int count = -1; 
media_group_get_group_count_from_db(filter, group, &amp;count);
dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Group count: %d\n&quot;, count);

media_group_foreach_group_from_db(filter, group, group_cb, (void *) group);
</pre></li></ol>
	
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>Message Port: Passing Messages Between Applications</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#init">Initializing Message Port Communication</a></li>
		    <li><a href="#uni">Using Uni-directional Message Port Communication</a></li>
		    <li><a href="#bi">Using Bi-directional Message Port Communication</a></li>
		    <li><a href="#trusted">Using Trusted Message Port Communication</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.guides/html/native/app/message_port_n.htm">Message Port Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MESSAGE__PORT__MODULE.html">Message Port API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MESSAGE__PORT__MODULE.html">Message Port API for Wearable Native</a></li>	
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">

	<h1>Message Port: Passing Messages Between Applications</h1>
	  
<p>This tutorial demonstrates how you can register, unregister, and check the message port, and send messages through the message port.</p>

       
        <h2>Warm-up</h2>
        <p>Become familiar with the Message Port API basics by learning about:</p>
        <ul>
           <li><a href="#init">Initializing Message Port Communication</a>
		   <p>Initialize the message port communication for use.</p></li>
		   <li><a href="#uni">Using Uni-directional Message Port Communication</a>
			<p>Send and receive messages using uni-directional message port communication between Tizen native applications.</p>
		   </li>
		   <li><a href="#bi">Using Bi-directional Message Port Communication</a>
			<p>Send and receive messages using bi-directional message port communication between Tizen native applications.</p>
		   </li>
		   <li><a href="#trusted">Using Trusted Message Port Communication</a>
			<p>Send and receive messages using trusted message port communication between Tizen native applications.</p>
		   </li>
        </ul>


 <h2 id="init" name="init">Initializing Message Port Communication</h2>
			
<p>To initialize message port communication:</p>
<ol>
<li>			
<p>To use the functions and data types of the Message Port API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MESSAGE__PORT__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MESSAGE__PORT__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;message_port.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;message_port.h&gt;
</pre></li>				

<li><p>You need 2 applications to communicate with each other through the message port.</p>
  
  <p>To use trusted message port communication, create an author certificate, register the certificate to the IDE, and grant permissions by the application certificate in the manifest editor.</p></li></ol>
 
 <h2 id="uni" name="uni">Using Uni-directional Message Port Communication</h2>
 
<p>To send a message from Application 1 to Application 2 using the Message Port API:</p>
   
  <p class="figure">Figure: Uni-directional message port communication</p> 
  <p align="center"><img alt="Uni-directional message port communication" src="../../images/message_port_uni-directional_communication.png" /></p> 
     

<ol>

<li>
	<p>Register a local port in Application 2.</p>
	
<p>To register the local port, call the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> function. 
</p>

<pre class="prettyprint">
int message_port_register_local_port(const char* local_port, message_port_message_cb callback, void* user_data)
</pre>

<p>The function requires 2 parameters:</p>
<ul>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">local_port</span>: The name of the local message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">callback</span>: The callback function to be called when a message is received</li>
  <li>Return: A local message port ID on success, otherwise a negative error value</li>
</ul>

<p>Implement the following codes in Application 2. Implement the <span style="font-family: Courier New,Courier,monospace">message_port_cb()</span> callback function for the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> function.</p>

<pre class="prettyprint">
void 
message_port_cb(int local_port_id, const char *remote_app_id, const char *remote_port, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool trusted_remote_port, bundle *message, void *user_data)
{
&nbsp;&nbsp;&nbsp;char *command = NULL;
&nbsp;&nbsp;&nbsp;char *data = NULL;
&nbsp;&nbsp;&nbsp;bundle_get_str(message, &quot;command&quot;, &amp;command);
&nbsp;&nbsp;&nbsp;bundle_get_str(message, &quot;data&quot;, &amp;data);
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Message from %s, command: %s data: %s&quot;, remote_app_id, command, data);
}
</pre>

<p>Call the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> function.</p>

<pre class="prettyprint">
int port_id = message_port_register_local_port(local_port, message_port_cb, NULL);
if (port_id &lt; 0) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;Port register error : %d&quot;, port_id);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, LOG_TAG, &quot;port_id : %d&quot;, port_id);
} 
</pre>
</li>

<li>
<p>Check the remote port in Application 1:</p>

<p>To check the remote port, call the <span style="font-family: Courier New,Courier,monospace">message_port_check_remote_port()</span> function.</p>

<pre class="prettyprint">
int message_port_check_remote_port(const char* remote_app_id, const char* remote_port, bool* exist)
</pre>

<p>The function requires 3 parameters:</p>
<ul>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_app_id</span>: The name of the local message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_port</span>: The name of the remote message port</li>
  <li>[out] <span style="font-family: Courier New,Courier,monospace">exist</span>: <span style="font-family: Courier New,Courier,monospace">true</span> if the message port of the remote application exists, otherwise <span style="font-family: Courier New,Courier,monospace">false</span></li>
  <li>Return: 0 on success, otherwise a negative error value</li>
</ul>

<p>Implement the following codes in Application 1:</p>
<pre class="prettyprint">
bool 
test_check_remote_port() 
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;bool found;

&nbsp;&nbsp;&nbsp;ret = message_port_check_remote_port (remote_app_id, remote_port, &amp;found);
&nbsp;&nbsp;&nbsp;if (ret != MESSAGE_PORT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, TAG, &quot;message_port_check_remote_port error : %d&quot;, ret);	   
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return found;
}
</pre>
</li>


<li>
<p>Send a message in Application 1.</p>

<p>To send a message, call the <span style="font-family: Courier New,Courier,monospace">message_port_send_message()</span> function:</p>

<pre class="prettyprint">int message_port_send_message(const char* remote_app_id, const char* remote_port, bundle* message) </pre>

<p>The function requires 3 parameters:</p>
<ul>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_app_id</span>: The name of the local message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_port</span>: The name of the remote message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">message</span>: The message to be passed to the remote application, the recommended message size is under 4KB</li>
  <li>Return: 0 on success, otherwise a negative error value</li>
</ul>

<pre class="prettyprint">
void 
send_message(void)
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;bundle *b = bundle_create ();
&nbsp;&nbsp;&nbsp;bundle_add_str (b, &quot;command&quot;, &quot;begin&quot;);
&nbsp;&nbsp;&nbsp;bundle_add_str (b, &quot;data&quot;, &quot;dummy&quot;);
&nbsp;&nbsp;&nbsp;ret = message_port_send_message (remote_app_id, remote_port, b);
&nbsp;&nbsp;&nbsp;if (ret != MESSAGE_PORT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, TAG, &quot;message_port_check_remote_port error : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Send message done&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;bundle_free (b);
} 
</pre>
</li></ol>

 <h2 id="bi" name="bi">Using Bi-directional Message Port Communication</h2>
 
<p>To send a message from Application 1 to Application 2, and from Application 2 to Application 1:</p>
  <p class="figure">Figure: Bi-directional message port communication</p> 
  <p align="center"><img alt="Bi-directional message port communication" src="../../images/message_port_bi-directional_communication.png" /></p>

  <ol>
<li>
	<p>Implement the response logic.</p>
  
  
<pre class="prettyprint">
void 
message_port_cb(int local_port_id, const char *remote_app_id, const char *remote_port, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool trusted_remote_port, bundle *message, void *user_data)
{

&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *command = NULL;
&nbsp;&nbsp;&nbsp;char *data = NULL;
&nbsp;&nbsp;&nbsp;bundle_get_str(message, &quot;command&quot;, &amp;command);
&nbsp;&nbsp;&nbsp;bundle_get_str(message, &quot;data&quot;, &amp;data);

&nbsp;&nbsp;&nbsp;// Callback
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Message from %s, command: %s data: %s&quot;, remote_app_id, command, data);


&nbsp;&nbsp;&nbsp;bundle *reply = bundle_create ();
&nbsp;&nbsp;&nbsp;bundle_add_str (reply, &quot;result&quot;, &quot;GOT_IT&quot;);
&nbsp;&nbsp;&nbsp;ret = message_port_send_message (remote_app_id, remote_port, reply);
&nbsp;&nbsp;&nbsp;bundle_free (reply);
&nbsp;&nbsp;&nbsp;if (ret != MESSAGE_PORT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, TAG, &quot;Port send message error : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}
}
</pre>  
</li>

<li>
	<p>Register the local port in Application 1.</p>
	
<pre class="prettyprint">
void 
message_port_cb(int local_port_id, const char *remote_app_id, const char *remote_port, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool trusted_remote_port, bundle *message, void *user_data) 
{
&nbsp;&nbsp;&nbsp;char *result = NULL;
&nbsp;&nbsp;&nbsp;bundle_get_str(message, &quot;result&quot;, &amp;result);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Message from %s, result: %s &quot;, remote_app_id, result);
}	
</pre>	

  <p>Call the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> function.</p>	
<pre class="prettyprint">
int local_port_id = message_port_register_local_port(local_port, message_port_cb);
if (local_port_id &lt; 0) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, TAG, &quot;Port register error : %d&quot;, local_port_id);
} 
else 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;port_id : %d&quot;, port_id);
}
</pre>
</li>

<li>
  <p>Send a message with local port information.</p>
  <p>To get a response from the receiver, local port information has to be sent to the receiver when the message was delivered. To do this, call the <span style="font-family: Courier New,Courier,monospace">message_port_send_message_with_local_port()</span> function.</p>

<p>The function requires 4 parameters:</p>
<ul>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_app_id</span>: The name of the local message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">remote_port</span>: The name of the remote message port</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">message</span>: The message to be passed to the remote application, the recommended message size is under 4KB</li>
  <li>[in] <span style="font-family: Courier New,Courier,monospace">local_port_id</span>: The message port ID returned by the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> or <span style="font-family: Courier New,Courier,monospace">message_port_register_trusted_local_port()</span> function</li>
  <li>Return: 0 on success, otherwise a negative error value</li>
</ul>

  <p>Implement the following codes in Application 1:</p>
<pre class="prettyprint">
void 
send_message_with_local_port(int local_port_id) 
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;bundle *b = bundle_create ();
&nbsp;&nbsp;&nbsp;bundle_add_str (b, &quot;command&quot;, &quot;begin&quot;);
&nbsp;&nbsp;&nbsp;bundle_add_str (b, &quot;data&quot;, &quot;dummy&quot;);

&nbsp;&nbsp;&nbsp;ret = message_port_send_message_with_local_port(remote_app_id, remote_port, b, local_port_id);
&nbsp;&nbsp;&nbsp;if (ret != MESSAGE_PORT_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, TAG, &quot;message_port_send_message_with_local_port error : %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Send message done&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;bundle_free (b);
}
</pre>

<p>Call the <span style="font-family: Courier New,Courier,monospace">send_message_with_local_port()</span> function:</p>
<pre class="prettyprint">
if (test_check_remote_port()) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_INFO, TAG, &quot;Remote port check success.&quot;);
&nbsp;&nbsp;&nbsp;send_message_with_local_port(local_port_id);
}
</pre>
</li>
</ol>

 <h2 id="trusted" name="trusted">Using Trusted Message Port Communication</h2>
 
 <p>To use the trusted message port communication:</p>
  <p class="figure">Figure: Trusted uni-directional message port communication</p> 
  <p align="center"><img alt="Trusted uni-directional message port communication" src="../../images/message_port_trusted_uni-directional_comm.png" /></p>
  
  <p>Create the author certificate, register the created certificate to the IDE, and give permissions by the application certificate in the manifest editor.</p>
  
  <p>During trusted message port communication, only applications signed with the same certificate can communicate with each other.</p>
  
  <p>The usage is similar to the normal Message Port API implementation. However, you must use trusted functions instead of normal functions.</p>
  
<ul>
 <li>Use the <span style="font-family: Courier New,Courier,monospace">message_port_check_trusted_remote_port()</span> function instead of the <span style="font-family: Courier New,Courier,monospace">message_port_check_remote_port()</span> function.</li>
 <li>Use the <span style="font-family: Courier New,Courier,monospace">message_port_send_trusted_message()</span> function instead of the <span style="font-family: Courier New,Courier,monospace">message_port_send_message()</span> function.</li>
 <li>Use the <span style="font-family: Courier New,Courier,monospace">message_port_register_trusted_local_port()</span> function instead of the <span style="font-family: Courier New,Courier,monospace">message_port_register_local_port()</span> function.</li>
</ul>

        
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

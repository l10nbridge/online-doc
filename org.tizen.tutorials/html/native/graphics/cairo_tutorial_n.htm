<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>Cairo: Linking Cairo and Evas</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/><br/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#graph">Drawing a Polygon Using a Cairo Image</a></li>
			<li><a href="#vector">Displaying Animated Geometrical Figures Using Cairo Evas_GL</a></li>

		</ul>		
		<p class="toc-title">Related Info</p>
		<ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/graphics/cairo_n.htm">Cairo Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__OPENSRC__CAIRO__FRAMEWORK.html">Cairo API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__OPENSRC__CAIRO__FRAMEWORK.html">Cairo API for Wearable Native</a></li>
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>Cairo: Linking Cairo and Evas</h1>


<p>This tutorial demonstrates how you can use 2 different backends of <a href="http://cairographics.org" target="_blank">Cairo</a> and link to Evas.</p>
 
<h2>Warm-up</h2>
<p>Become familiar with the Cairo API basics by learning about:</p>
<ul>
<li><a href="#graph">Drawing a Polygon Using a Cairo Image</a>
<p>Draw a polygon and rectangle using the Cairo image backend with the <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> image.</p></li>

<li><a href="#vector">Displaying Animated Geometrical Figures Using Cairo Evas_GL</a>
<p>Draw various figures using the Cairo evas-gl backend with the Evas_GL surface.</p></li>

</ul>

<h2 id="graph" name="graph">Drawing a Polygon Using a Cairo Image</h2>

<p>This use case shows how to link Cairo to Evas and how to draw a polygon and rectangle on the screen using the Cairo API. First create a basic application that provides a basic UI application skeleton and already makes available the window object that can contain the Cairo drawing.</p>

<ol><li>
Build the environment.

<p>Include the <span style="font-family: Courier New,Courier,monospace">&lt;cairo.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;math.h&gt;</span> headers in the sample application:</p>

<pre class="prettyprint">
#include &lt;cairo.h&gt;
#include &lt;math.h&gt;
</pre></li>

<li>Create the <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> image and link to Cairo.

<p>Define the <span style="font-family: Courier New,Courier,monospace">appdata</span> structure that contains the pointers to the objects to be manipulated:</p>

<pre class="prettyprint">
typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;	
&nbsp;&nbsp;&nbsp;Evas_Object *img;

&nbsp;&nbsp;&nbsp;cairo_surface_t *surface;
&nbsp;&nbsp;&nbsp;cairo_t *cairo;
} appdata_s;
</pre></li>
<li>Create the <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> window and image.

<p>To display the Cairo drawing on the screen, create the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> window and <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image:</p>

<pre class="prettyprint">
ad-&gt;win = elm_win_util_standard_add(PACKAGE, PACKAGE);
evas_object_show(ad-&gt;win);
ad-&gt;img = evas_object_image_filled_add(evas_object_evas_get(ad-&gt;win));
evas_object_show(ad-&gt;img);
</pre></li>

<li>Create Cairo.
<p>To create the Cairo surface, you need the window size to set the Cairo surface. You can get the window size using the <span style="font-family: Courier New,Courier,monospace">evas_object_geometry_get()</span> function, after the <span style="font-family: Courier New,Courier,monospace">evas_object_show()</span> function is called:</p>

<pre class="prettyprint">
evas_object_geometry_get(ad-&gt;win, NULL, NULL, &amp;ad-&gt;width, &amp;ad-&gt;height);
ad-&gt;surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, ad-&gt;width, ad-&gt;height);
ad-&gt;cairo = cairo_create(ad-&gt;surface);
</pre></li>

<li>Draw a polygon and rectangle with Cairo.
<p>To draw the vector image itself:</p>

<ol type="a">
<li>To draw Cairo with some specific vector positions, use the window size that you got before. You can compare the window width and height and get the smaller length to set the square side.

<pre class="prettyprint">
void cairo_drawing(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;int d = 0;
&nbsp;&nbsp;&nbsp;if (ad-&gt;width &lt; ad-&gt;height)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = ad-&gt;width;
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = ad-&gt;height;
</pre></li>

<li>To set the background as white color, set the color as white and paint the Cairo:
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;// Clear background as white
&nbsp;&nbsp;&nbsp;cairo_set_source_rgba(ad-&gt;cairo, 1, 1, 1, 1);
&nbsp;&nbsp;&nbsp;cairo_paint(ad-&gt;cairo);
</pre></li>

<li>Draw the polygon and rectangle:

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;cairo_translate(ad-&gt;cairo, 0.1 * d, 0.1 * d);
&nbsp;&nbsp;&nbsp;cairo_set_line_width(ad-&gt;cairo,2);
&nbsp;&nbsp;&nbsp;cairo_set_source_rgba(ad-&gt;cairo, 0.0, 0.0, 1.0, 1.0);

&nbsp;&nbsp;&nbsp;cairo_move_to(ad-&gt;cairo, 0.2 * d , 0.2 * d);
&nbsp;&nbsp;&nbsp;cairo_line_to(ad-&gt;cairo, 0.4 * d, 0.3 * d);
&nbsp;&nbsp;&nbsp;cairo_rel_line_to(ad-&gt;cairo, 0.2 * d, -0.1 * d);
&nbsp;&nbsp;&nbsp;cairo_arc(ad-&gt;cairo, 0.4 * d, 0.4 * d, 0.2* d * sqrt(2), -0.25 * M_PI, 0.25 * M_PI);
&nbsp;&nbsp;&nbsp;cairo_rel_curve_to(ad-&gt;cairo,-0.2* d, -0.1 * d, -0.2* d, 0.1 * d, -0.4 * d, 0);
&nbsp;&nbsp;&nbsp;cairo_close_path(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;cairo_fill(ad-&gt;cairo);

&nbsp;&nbsp;&nbsp;cairo_rectangle(ad-&gt;cairo, 0, 0, 0.8 * d, 0.8 * d);
&nbsp;&nbsp;&nbsp;cairo_stroke(ad-&gt;cairo);
</pre></li>


<li>You need to use the <span style="font-family: Courier New,Courier,monospace">cairo_surface_flush()</span> function to ensure that any pending drawing is performed for the surface:


<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;cairo_surface_flush(ad-&gt;surface);
</pre></li>

<li>Update the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image on the screen:

<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;// Display Cairo drawing on screen
&nbsp;&nbsp;&nbsp;unsigned char * imageData = cairo_image_surface_get_data(cairo_get_target(ad-&gt;cairo));
&nbsp;&nbsp;&nbsp;evas_object_image_data_set(ad-&gt;img, imageData);
&nbsp;&nbsp;&nbsp;evas_object_image_data_update_add(ad-&gt;img, 0, 0, ad-&gt;width, ad-&gt;height);
}
</pre></li>

<li>The delete callback is triggered when the Window is destroyed from the main loop.


<pre class="prettyprint">
static void win_delete_request_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;cairo_surface_destroy(ad-&gt;surface);
&nbsp;&nbsp;&nbsp;cairo_destroy(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;ui_app_exit();
}
</pre></li>
</ol></li></ol>

<p class="figure">Figure: Polygon and rectangle</p> 
<p align="center"><img alt="Polygon and rectangle" src="../../images/cairo_basic.png" /></p>



<h2 id="vector" name="vector">Displaying Animated Geometrical Figures Using Cairo Evas_GL</h2>

<p>The following use case shows how you can draw vector graphics using the Cairo evas-gl backend. The Cairo evas-gl backend is similar to Cairo gl backend, since it can provide an implementation of possibly hardware-accelerated Cairo rendering by targeting the OpenGL&reg; ES API.</p>
<p>First create a basic application that provides a basic UI application skeleton and already makes available the window object that can contain the Cairo drawing.</p>

<p>To display and animate vector graphics with Cairo and the Evas_GL surface:</p>



<ol><li>Build the environment:
<ul>
<li>Include the following header files to use the Cairo evas-gl backend on the Evas_GL surface:
<pre class="prettyprint">
#include &lt;cairo.h&gt;
#include &lt;Evas_GL.h&gt;
#include &lt;cairo-evas-gl.h&gt;
#include &lt;math.h&gt;
</pre></li>
<li>Define the <span style="font-family: Courier New,Courier,monospace">appdata</span> structure that contains the pointers to objects to be manipulated:

<pre class="prettyprint">
typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;	
&nbsp;&nbsp;&nbsp;Evas_Object *img;

&nbsp;&nbsp;&nbsp;cairo_surface_t *surface;
&nbsp;&nbsp;&nbsp;cairo_t *cairo;
&nbsp;&nbsp;&nbsp;cairo_device_t *cairo_device;
	
&nbsp;&nbsp;&nbsp;Evas_GL *evas_gl;
&nbsp;&nbsp;&nbsp;Evas_GL_Config *evas_gl_config;
&nbsp;&nbsp;&nbsp;Evas_GL_Surface *evas_gl_surface;
&nbsp;&nbsp;&nbsp;Evas_GL_Context *evas_gl_context;
} appdata_s;
</pre></li></ul></li>

<li>Initialize Cairo and Evas_GL for Cairo evas-gl drawing.

<p>Initialize the variables related to the Evas_GL within the <span style="font-family: Courier New,Courier,monospace">appdata</span> structure, and create the Evas_GL object using the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image created before.</p>

<ul>
<li>By default, Cairo evas-gl backend uses an Evas_GL context and API set. Before creating the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> window for Cairo evas-gl drawing, the GL Rendering Engine is set because Evas_GL runs with Evas_GL Render Engine:

<pre class="prettyprint">
elm_config_accel_preference_set(&quot;opengl&quot;);
</pre></li>

<li>The <span style="font-family: Courier New,Courier,monospace">cairo_drawing</span> callback function can be registered by the following <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image function:

<pre class="prettyprint">
evas_object_image_pixels_get_callback_set(ad-&gt;img, cairo_drawing, NULL);
</pre></li>
<li>For using hardware-accelerated Cairo rendering, set <span style="font-family: Courier New,Courier,monospace">CAIRO_GL_COMPOSITOR</span> to MSAA compositor:

<pre class="prettyprint">
setenv(&quot;CAIRO_GL_COMPOSITOR&quot;, &quot;msaa&quot;, 1);
</pre></li>

<li>To prevent unnecessary context switching in the Cairo evas-gl backend:
<pre class="prettyprint">
cairo_gl_device_set_thread_aware(ad-&gt;cairo_device, 0);
</pre></li></ul>

<pre class="prettyprint">
static void init_cairo_evasgl_drawing(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;// Create window
&nbsp;&nbsp;&nbsp;elm_config_accel_preference_set(&quot;opengl&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;win = elm_win_util_standard_add(PACKAGE, PACKAGE);
&nbsp;&nbsp;&nbsp;elm_win_autodel_set(ad-&gt;win, EINA_TRUE);
&nbsp;&nbsp;&nbsp;if (elm_win_wm_rotation_supported_get(ad-&gt;win))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rots[4] = {0, 90, 180, 270};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_win_wm_rotation_available_rotations_set(ad-&gt;win, (const int *)(&amp;rots), 4);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(ad-&gt;win, &quot;delete,request&quot;, win_delete_request_cb, NULL);
&nbsp;&nbsp;&nbsp;eext_object_event_callback_add(ad-&gt;win, EEXT_CALLBACK_BACK, win_back_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;win, EVAS_CALLBACK_RESIZE, win_resize_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;win);

&nbsp;&nbsp;&nbsp;// Add image object; a filled one by default
&nbsp;&nbsp;&nbsp;evas_object_geometry_get(ad-&gt;win, NULL, NULL, &amp;ad-&gt;width, &amp;ad-&gt;height);
&nbsp;&nbsp;&nbsp;ad-&gt;img = evas_object_image_filled_add(evas_object_evas_get(ad-&gt;win));
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;img);

&nbsp;&nbsp;&nbsp;// Create evasgl and init
&nbsp;&nbsp;&nbsp;Evas_Native_Surface ns;
&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl = evas_gl_new(evas_object_evas_get(ad-&gt;img));
&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_config = evas_gl_config_new();
&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_config-&gt;color_format = EVAS_GL_RGBA_8888;

&nbsp;&nbsp;&nbsp;// Create a surface and context
&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_surface = evas_gl_surface_create(ad-&gt;evas_gl, ad-&gt;evas_gl_config, ad-&gt;width, ad-&gt;height);
&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_context = evas_gl_context_create(ad-&gt;evas_gl, NULL);
      
&nbsp;&nbsp;&nbsp;evas_gl_native_surface_get(ad-&gt;evas_gl, ad-&gt;evas_gl_surface, &amp;ns);
&nbsp;&nbsp;&nbsp;evas_object_image_native_surface_set(ad-&gt;img, &amp;ns);

&nbsp;&nbsp;&nbsp;// Register Cairo drawing callback
&nbsp;&nbsp;&nbsp;evas_object_image_pixels_get_callback_set(ad-&gt;img, (Evas_Object_Image_Pixels_Get_Cb)cairo_drawing, ad);

&nbsp;&nbsp;&nbsp;// Create cairo and cairo device with evasgl
&nbsp;&nbsp;&nbsp;// Use the MSAA compositor if available
&nbsp;&nbsp;&nbsp;setenv(&quot;CAIRO_GL_COMPOSITOR&quot;, &quot;msaa&quot;, 1);
&nbsp;&nbsp;&nbsp;ad-&gt;cairo_device = (cairo_device_t *)cairo_evas_gl_device_create (ad-&gt;evas_gl, ad-&gt;evas_gl_context);
&nbsp;&nbsp;&nbsp;cairo_gl_device_set_thread_aware(ad-&gt;cairo_device, 0);
&nbsp;&nbsp;&nbsp;ad-&gt;surface = (cairo_surface_t *)cairo_gl_surface_create_for_evas_gl(ad-&gt;cairo_device, ad-&gt;evas_gl_surface, ad-&gt;evas_gl_config, ad-&gt;width, ad-&gt;height);
&nbsp;&nbsp;&nbsp;ad-&gt;cairo = cairo_create(ad-&gt;surface);

&nbsp;&nbsp;&nbsp;// Register animation callback to update the output according to refresh rate
&nbsp;&nbsp;&nbsp;ecore_animator_frametime_set(0.016);
&nbsp;&nbsp;&nbsp;ecore_animator_add(_animate_cb, (void *)ad-&gt;img);
}
</pre>
</li>

<li>Draw geometrical figures in the <span style="font-family: Courier New,Courier,monospace">cairo_drawing()</span> callback function. 
<p>The following code snippet shows how to draw some geometrical figures such as a triangle, rectangle, and circle with various styles and random positions by using the Cairo APIs.</p>
<pre class="prettyprint">
void cairo_drawing(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;int i;
&nbsp;&nbsp;&nbsp;double r, g, b, a;

&nbsp;&nbsp;&nbsp;int Renderloop = 50;

&nbsp;&nbsp;&nbsp;// Clear background as white
&nbsp;&nbsp;&nbsp;cairo_set_source_rgba(ad-&gt;cairo, 1, 1, 1, 1);
&nbsp;&nbsp;&nbsp;cairo_paint(ad-&gt;cairo);

&nbsp;&nbsp;&nbsp;cairo_set_operator(ad-&gt;cairo, CAIRO_OPERATOR_OVER);

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; Renderloop; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Random color
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = drand48();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g = drand48();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = drand48();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = drand48();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_set_source_rgba(ad-&gt;cairo, r, g, b, a);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Random position
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float x = drand48() * ad-&gt;width;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float y = drand48() * ad-&gt;height;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float side = drand48() * 300;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Random style
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int shape = drand48() * 3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float width = drand48() * 50 + 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int line_cap = drand48() * 3;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_line_cap_t line_cap_style = CAIRO_LINE_CAP_BUTT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (line_cap == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cap_style = CAIRO_LINE_CAP_ROUND;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (line_cap == 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_cap_style = CAIRO_LINE_CAP_SQUARE;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int line_join = drand48() * 3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_line_join_t line_join_style = CAIRO_LINE_JOIN_MITER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (line_join == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_join_style = CAIRO_LINE_JOIN_ROUND;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (line_join == 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line_join_style = CAIRO_LINE_JOIN_BEVEL;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double dash[] = {0.0, 0.0};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dash[0] = drand48() * 50;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dash[1] = drand48() * 50;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_set_dash(ad-&gt;cairo, dash, 2, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_set_line_width(ad-&gt;cairo, width);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_set_line_join(ad-&gt;cairo, line_join_style);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_set_line_cap(ad-&gt;cairo, line_cap_style);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (shape == 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw square
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_rectangle(ad-&gt;cairo, x, y, side, side);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_fill(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (shape == 1) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw circle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_arc(ad-&gt;cairo, x, y, side/2, 0.0, 2.0 * M_PI);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_stroke(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw triangle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_move_to(ad-&gt;cairo, x, y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_line_to(ad-&gt;cairo, x + side, y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_line_to(ad-&gt;cairo, x, y + side);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_close_path(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_stroke(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;cairo_surface_flush(ad-&gt;surface);
}
</pre></li>
  
<li>Resize the callback.
<p>In the following code snippet, when resizing occurs, Evas GL surface is recreated and reconnected to the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image.</p>
<pre class="prettyprint">
static void win_resize_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;if (ad-&gt;evas_gl_surface)  
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_surface_destroy(ad-&gt;surface);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_destroy(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_device_destroy(ad-&gt;cairo_device);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_gl_surface_destroy(ad-&gt;evas_gl, ad-&gt;evas_gl_surface);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_surface = NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;evas_object_geometry_get(obj, NULL, NULL, &amp;ad-&gt;width, &amp;ad-&gt;height);
&nbsp;&nbsp;&nbsp;evas_object_image_size_set(ad-&gt;img, &amp;ad-&gt;width, &amp;ad-&gt;height);
&nbsp;&nbsp;&nbsp;evas_object_resize(ad-&gt;img, &amp;ad-&gt;width, &amp;ad-&gt;height);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;img);


&nbsp;&nbsp;&nbsp;if (!ad-&gt;evas_gl_surface) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Native_Surface ns;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;evas_gl_surface = evas_gl_surface_create(ad-&gt;evasgl, ad-&gt;evas_gl_config, &amp;ad-&gt;width, &amp;ad-&gt;height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_gl_native_surface_get(ad-&gt;evasgl, ad-&gt;evas_gl_surface, &amp;ns);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_native_surface_set(ad-&gt;img, &amp;ns);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evas_object_image_pixels_dirty_set(ad-&gt;img, EINA_TRUE);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;cairo_device = (cairo_device_t *)cairo_evas_gl_device_create(ad-&gt;evas_gl, ad-&gt;evas_gl_context);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cairo_gl_device_set_thread_aware(ad-&gt;cairo_device, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;surface = (cairo_surface_t *)cairo_gl_surface_create_for_evas_gl(ad-&gt;cairo_device, ad-&gt;evas_gl_surface, ad-&gt;evas_gl_config, ad-&gt;width, ad-&gt;height);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;cairo = cairo_create (ad-&gt;surface);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>

<li>To use the animator callback for a default update refresh rate, you can add an animator.
<p>To update the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image which is connected to Evas_GL, use the <span style="font-family: Courier New,Courier,monospace">evas_object_image_pixels_dirty_set()</span> function. This updates the <span style="font-family: Courier New,Courier,monospace">Evas_object</span> image whenever Evas renders.</p>

<pre class="prettyprint">
static Eina_Bool _animate_cb(void *data)
{
&nbsp;&nbsp;&nbsp;Evas_Object *obj = (Evas_Object *)data;
&nbsp;&nbsp;&nbsp;evas_object_image_pixels_dirty_set(obj, EINA_TRUE);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}
</pre>
</li>

<li>The delete callback is triggered when the Window is destroyed from the main loop.
<pre class="prettyprint">
static void win_delete_request_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;cairo_surface_destroy(ad-&gt;surface);
&nbsp;&nbsp;&nbsp;cairo_destroy(ad-&gt;cairo);
&nbsp;&nbsp;&nbsp;cairo_device_destroy(ad-&gt;cairo_device);
&nbsp;&nbsp;&nbsp;evas_gl_surface_destroy(ad-&gt;evas_gl, ad-&gt;evas_gl_surface);
&nbsp;&nbsp;&nbsp;evas_gl_context_destroy(ad-&gt;evas_gl, ad-&gt;evas_gl_context);
&nbsp;&nbsp;&nbsp;evas_gl_config_free(ad-&gt;evas_gl_config);
&nbsp;&nbsp;&nbsp;evas_gl_free(ad-&gt;evas_gl);
&nbsp;&nbsp;&nbsp;ui_app_exit();
}
</pre>
</li>
</ol>

<p class="figure">Figure: Random geometrical figures</p> 
<p align="center"><img alt="Random geometrical figures" src="../../images/cairo_evasgl.png" /></p>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

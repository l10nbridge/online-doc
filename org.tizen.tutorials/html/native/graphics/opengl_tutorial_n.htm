<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>OpenGL ES: Using OpenGL ES Graphics</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">	 
		 <li>GLView component
			 <ul class="toc">
				<li><a href="#basic">Creating the Basic Application</a></li>
				<li><a href="#cube">Creating the Cube</a></li>
				<li><a href="#draw">Drawing the Cube with GLView</a></li>
				<li><a href="#render">Rendering the Cube</a></li>
				<li><a href="#animate">Animating the Cube</a></li>
				<li><a href="#component">Implementing UI Component Interaction</a></li>
				<li><a href="#effect">Implementing Effects</a></li>
				<li><a href="#source">Viewing the Entire Cube Source</a></li>
			</ul>
		</li>
		 <li><a href="#multithread">Using OpenGL ES in Multi-threaded Applications</a></li>	
		 <li><a href="#ext">Using OpenGL ES Extensions</a></li>
	     <li><a href="#evas_ext">Using EvasGL Extensions</a></li>
	     <li><a href="#direct">Using Direct Rendering</a></li>
	     <li><a href="#client">Using Client-side Rotation</a></li> 	 
		</ul>		
		<p class="toc-title">Related Info</p>
		<ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/graphics/opengles_n.htm">OpenGL ES Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__OPENSRC__OPENGL__ES__FRAMEWORK.html">OpenGL ES API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__OPENSRC__OPENGL__ES__FRAMEWORK.html">OpenGL ES API for Wearable Native</a></li>
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>OpenGL ES: Using OpenGL ES Graphics</h1>


	<p>This tutorial demonstrates how you can handle OpenGL ES graphics with the GLView component and EvasGL.</p>

<h2>Warm-up</h2>
<p>Become familiar with the OpenGL ES API basics by learning about:</p>
<ul>	 
	  <li>GLView component
	  <ul>
		<li><a href="#basic">Creating the Basic Application</a>
		<p>Create a basic application with a multicolored 3D rotating cube using OpenGL ES 2.0 API provided by the GLView library.</p></li>
		<li><a href="#cube">Creating the Cube</a>
		<p>Create and color a cube.</p></li>
		<li><a href="#draw">Drawing the Cube with GLView</a>
		<p>Draw a cube.</p></li>
		<li><a href="#render">Rendering the Cube</a>
		<p>Render a cube.</p></li>
		<li><a href="#animate">Animating the Cube</a>
		<p>Create an animation.</p></li>
		<li><a href="#component">Implementing UI Component Interaction</a>
		<p>Create UI components that interact with the rendering.</p></li>
		<li><a href="#effect">Implementing Effects</a>
		<p>Create fancy effects for the screen.</p></li>
		<li><a href="#source">Viewing the Entire Cube Source</a>
		<p>View the entire source code of the cube example.</p></li>  
	  </ul>	  </li>
	  <li><a href="#multithread">Using OpenGL ES in Multi-threaded Applications</a>
	  <p>Share OpenGL ES data across threads, synchronize data, and pass messages between threads.</p></li>
	  <li><a href="#ext">Using OpenGL ES Extensions</a>
	  <p>Check whether an extension is available, and call it.</p></li>
	  <li><a href="#evas_ext">Using EvasGL Extensions</a>
	  <p>Check whether an Evas extension is available, and use it.</p></li>
	  <li><a href="#direct">Using Direct Rendering</a>
	  <p>Enhance performance through the Direct Rendering option.</p></li>
	  <li><a href="#client">Using Client-side Rotation</a>
	  <p>Use client-side rotation when the application is using Direct Rendering.</p></li>
</ul>

<h2 id="basic" name="basic">Creating the Basic Application</h2>

<p>This tutorial demonstrates how you can create a multicolored 3D rotating cube using OpenGL ES 2.0 API provided by GLView library. Several concepts are explained, such as the cube geometry, the initialization phase of the model, the adjustment of this very model frame by frame, and the way to design the OpenGL ES rendering loop.</p>
<p>First create a basic application as explained in the Basic application tutorial. This provides a basic UI application skeleton which already makes available the window object that contains the GLView  canvas.</p>
<h3>Building the Environment</h3>
<p>Define the application data structure that holds all the objects pertinent for the GLView application:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">Evas_Object *win</span>: Application window</li>
<li><span style="font-family: Courier New,Courier,monospace">Evas_Object *conform</span>: Conformant object for indicator</li>
<li><span style="font-family: Courier New,Courier,monospace">Evas_Object *glview</span>: GLView object</li>
<li><span style="font-family: Courier New,Courier,monospace">Evas_Object *main_box</span>: Box object which contains glview and inner_box</li>
<li><span style="font-family: Courier New,Courier,monospace">Evas_Object *inner_box</span>: Box object for toolbox</li>
</ul>
<pre class="prettyprint">
typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *conform;
&nbsp;&nbsp;&nbsp;Evas_Object *glview;

&nbsp;&nbsp;&nbsp;Evas_Object *main_box;
&nbsp;&nbsp;&nbsp;Evas_Object *inner_box;
} appdata_s;
</pre>

<h3>OpenGL ES Canvas</h3>

<p>When developing an application with Elementary, you can create a window by using the Elementary utility function as below:</p>

<pre class="prettyprint">
elm_config_accel_preference_set(&quot;opengl&quot;); 
ad-&gt;win = elm_win_util_standard_add(&quot;GLView Example&quot;, &quot;GLView Example&quot;);</pre>

<p>To develop a GL application, you have to call <span style="font-family: Courier New,Courier,monospace">elm_config_accel_preference_set()</span> before creating a window which makes an application to use GPU.</p>

<pre class="prettyprint">
ad-&gt;glview = elm_glview_add(ad-&gt;main_box);</pre>

<p>There are 2 different methods to call GL functions.</p>

<ul><li>First is to use Elementary GL Helper functions. You have to include <span style="font-family: Courier New,Courier,monospace">Elementary_GL_Helpers.h</span> and define a global variable by using <span style="font-family: Courier New,Courier,monospace">ELEMENTARY_GLVIEW_GLOBAL_DEFINE()</span>. Before calling gl functions, write <span style="font-family: Courier New,Courier,monospace">ELEMENTARY_GLVIEW_GLOBAL_USE()</span>. This tutorial uses this method. The usage is as follows.

<pre class="prettyprint">
#include &lt;Elementary_GL_Helpers.h&gt;
ELEMENTARY_GLVIEW_GLOBAL_DEFINE();

static void create_gl_canvas(appdata_s *ad) 
{
&nbsp;&nbsp;&nbsp;ad-&gt;glview = elm_glview_add(ad-&gt;main_box);
&nbsp;&nbsp;&nbsp;ELEMENTARY_GLVIEW_GLOBAL_USE(ad-&gt;glview);
}

static void draw_gl(Evas_Object *obj) 
{ 
&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}</pre></li>

<li><p>Second, you can get the Evas_GL instance from <span style="font-family: Courier New,Courier,monospace">elm_glview_gl_api_get</span> function, then you can call the OpenGL ES functions with the instance.</p>

<pre class="prettyprint">
ad-&gt;glview = elm_glview_add(ad-&gt;main_box);
Evas_GL_API *glapi = elm_glview_gl_api_get(ad-&gt;glview);
glapi-&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</pre></li></ul>

<p>The next thing to do is to set the GLView mode. <span style="font-family: Courier New,Courier,monospace">elm_glview_mode_set(Evas_Object *obj, Elm_GLView_Mode mode)</span> supports alpha, depth, stencil, MSAA, and client_side_rotation.</p>

<pre class="prettyprint">
elm_glview_mode_set(ad-&gt;glview, ELM_GLVIEW_DEPTH);</pre>

<p>To set up callbacks:</p>

<pre class="prettyprint">
elm_glview_init_func_set(ad-&gt;glview, init_gl);
elm_glview_resize_func_set(ad-&gt;glview, resize_gl);
elm_glview_render_func_set(ad-&gt;glview, draw_gl);
elm_glview_del_func_set(ad-&gt;glview, del_gl);
ani = ecore_animator_add(animate_cb, ad-&gt;glview);</pre>

<ul>
	<li>Callback for initialization
	<p>The initialization callback is called when the GLView is first created, after a valid OpenGL ES context and surface have been created. This is called from the main loop, just as the 3 other callbacks.</p>
	</li>
	<li>Callback for resizing
	<p>The resize callback is called whenever the GLView component is resized. A common action to take here is to reset the viewport.</p>
	</li>
	<li>Callback for drawing
	<p>The drawing callback is called whenever a new frame has to be drawn. The exact moment when this function is called depends on the policy set when calling.</p>

	<pre class="prettyprint">
elm_glview_render_policy_set(glview, ELM_GLVIEW_RENDER_POLICY_ON_DEMAND);</pre>

	<p>Another policy is ELM_GLVIEW_POLICY_ALWAYS, which requests render always even when it is not visible. So on demand policy is probably what you are looking for. The application can now draw anything using GL primitives when this callback is triggered. All draw operations are restricted to the surface of the GLView object previously created. Here it covers the whole window.</p>
	</li>
	<li>Callback for deleting
	<p>The delete callback is triggered when the GLView is being destroyed, from the main loop, and no other callback can be called on the same object afterwards.</p>
	</li>
	<li>Add an animator.
	<p>The application above is technically working but the scene does not get updated unless the object is marked as such. Games might want to use an animator to have a regular update of the scene.</p>

	<p>Any other event can be used to refresh the view, for example user input if the view needs to be updated.</p>
	</li>
</ul>


<h2 id="cube" name="cube">Creating the Cube</h2>

<p>Creating and the coloring the cube can be separated into two distinct tasks: define the vertices and then add the colors to the faces.</p>


  <p class="figure">Figure: Cube</p> 
  <p align="center"><img alt="Cube" src="../../images/cube.png" /></p>


<p>Declare an array that stores the vertices of the cube in order to make it look like the drawing above.</p>
 <pre class="prettyprint">static const float vertices[] =
{
&nbsp;&nbsp;&nbsp;// Front
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Right
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;// Back
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;// Left
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Top
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Bottom
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f
};
</pre>

  <p class="figure">Figure: Cube matrix</p> 
  <p align="center"><img alt="Cube matrix" src="../../images/cube_matrix.png" /></p>

<p>Each triangle is defined with three point coordinates, three vertices for each triangle, two triangles per face and six faces, so there are 36 vertices is total.</p>
<p>The next step is to specify a color for each face of the cube. Each color is represented in the RGBA format for the corresponding vertex, where each component is ranged from 0 to 1 where 1 is the maximum value. For example, in 32-byte color space, the RGB color of (16, 147, 237) is translated as (0.0625, 0.57421875, 0.92578125). The A of RGBA stands for the alpha channel, which represents the transparency of the color. All colors defined in this tutorial are opaque to make it simpler, so each alpha value is set to 1.0. In this example, different variants of blue are used for the faces of the cube.</p>
<p>Specify the colors of the cube into an array dedicated to this vertex:</p>
<pre class="prettyprint">static const float colors[] =
{
&nbsp;&nbsp;&nbsp;// Front
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Right
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Back
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Left
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Top
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Bottom
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f
};
</pre>

<h2 id="draw" name="draw">Drawing the Cube with GLView</h2>

<h3>Mathematical Functions for Matrices</h3>
<p>After the model is initialized, create functionality to manipulate the scene. OpenGL ES 2.0 provided by GLView  requires more preliminary work that the previous version of the library, but  gives more power and flexibility, although our example does not take much benefit.</p>
<p>First, declare additional global variables for tasks specific to OpenGL ES 2.0. A program object is needed, an identifier for the vertices buffer and another for the colors. Three variables are also required to ensure the connection with the shader language:</p>
<ul>
<li><span style="font-family: Courier New,Courier,monospace">mvpLoc</span> is an identifier for model-view-projection matrix.</li>
<li><span style="font-family: Courier New,Courier,monospace">positionLoc</span> is an identifier for the vertex position.</li>
<li><span style="font-family: Courier New,Courier,monospace">colorLoc</span> is an identifier for the vertex color.</li>
</ul>
<p>Declare all these variables in the appdata object as static variables so that each function can use variables and that they exist for the whole duration of the program.</p>
<pre class="prettyprint">typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;unsigned int     program;
&nbsp;&nbsp;&nbsp;unsigned int     vtx_shader;
&nbsp;&nbsp;&nbsp;unsigned int     fgmt_shader;
&nbsp;&nbsp;&nbsp;unsigned int     vertexID;
&nbsp;&nbsp;&nbsp;unsigned int     colorID;
&nbsp;&nbsp;&nbsp;unsigned int     mvpLoc;
&nbsp;&nbsp;&nbsp;unsigned int     positionLoc;
&nbsp;&nbsp;&nbsp;unsigned int     colorLoc;
}
</pre>
<p>Since OpenGL ES 2.0, some functions for matrix transformations have been removed. Define three matrices to use: projection matrix, model-view matrix, and a combination of these allows you to perform any transformations on the initial vertices matrix.</p>

<h4>Matrix Multiplication Function (glMultMatrix)</h4>
<p>First, define a function that is able to return the inner  product of two matrices. This function reproduces the behavior of <span style="font-family: Courier New,Courier,monospace">glMultMatrix()</span> available in OpenGL ES 1.1. This function is very useful since almost every matrix transformation can be translated as multiplications of matrices.</p>
<p>The function takes three arguments, one is for the result and the other 2 matrices are operands:</p>
<pre class="prettyprint">static void
customMutlMatrix(float matrix[16], const float matrix0[16], const float matrix1[16])
{
&nbsp;&nbsp;&nbsp;int i, row, column;
&nbsp;&nbsp;&nbsp;float temp[16];
&nbsp;&nbsp;&nbsp;for (column = 0; column &lt; 4; column++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (row = 0; row &lt; 4; row++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[column * 4 + row] = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 4; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[column * 4 + row] += matrix0[i * 4 + row] * matrix1[column * 4 + i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 16; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i] = temp[i];
}
</pre>
<h4>Matrix Identity Function (glLoadIdentity)</h4>

<p>Implement a function equivalent to <span style="font-family: Courier New,Courier,monospace">glLoadIdentity()</span> that replaces the current matrix with the identity matrix:</p>
<pre class="prettyprint">const float unit_matrix[] = 
{
&nbsp;&nbsp;&nbsp;1.0f, 0.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;0.0f, 1.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;0.0f, 0.0f, 1.0f, 0.0f,
&nbsp;&nbsp;&nbsp;0.0f, 0.0f, 0.0f, 1.0f
}

static void
customLoadIdentity(float matrix[16])
{
&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 16; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i] = unit_matrix[i];
}
</pre>

<h4>Matrix Projection Function (glFrustum)</h4>
<p>Since <span style="font-family: Courier New,Courier,monospace">glFrustum</span> has been depreciated, implement a function that produces perspective projection matrices that are used to transform from eye coordinate space to clip coordinate space. This matrix projects a portion of the space (the &quot;fustum&quot;) to your screen. Many caveats apply (normalized device coordinates, perspective divide, etc), but that is the idea:</p>
<pre class="prettyprint">static int
customFrustum(float result[16], 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float left,   const float right, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float bottom, const float top, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const float near,   const float far)
{
&nbsp;&nbsp;&nbsp;if ((right - left) == 0.0f || (top - bottom) == 0.0f || (far - near) == 0.0f) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;

&nbsp;&nbsp;&nbsp;result[0] = 2.0f / (right - left);
&nbsp;&nbsp;&nbsp;result[1] = 0.0f;
&nbsp;&nbsp;&nbsp;result[2] = 0.0f;
&nbsp;&nbsp;&nbsp;result[3] = 0.0f;

&nbsp;&nbsp;&nbsp;result[4] = 0.0f;
&nbsp;&nbsp;&nbsp;result[5] = 2.0f / (top - bottom);
&nbsp;&nbsp;&nbsp;result[6] = 0.0f;
&nbsp;&nbsp;&nbsp;result[7] = 0.0f;

&nbsp;&nbsp;&nbsp;result[8] = 0.0f;
&nbsp;&nbsp;&nbsp;result[9] = 0.0f;
&nbsp;&nbsp;&nbsp;result[10] = -2.0f / (far - near);
&nbsp;&nbsp;&nbsp;result[11] = 0.0f;

&nbsp;&nbsp;&nbsp;result[12] = -(right + left) / (right - left);
&nbsp;&nbsp;&nbsp;result[13] = -(top + bottom) / (top - bottom);
&nbsp;&nbsp;&nbsp;result[14] = -(far + near) / (far - near);
&nbsp;&nbsp;&nbsp;result[15] = 1.0f;

&nbsp;&nbsp;&nbsp;return 1;
}
</pre>

<h4>Matrix Scaling Function (glScale)</h4>
<p>Depreciated <span style="font-family: Courier New,Courier,monospace">glScale()</span> function represents  a non-uniform scaling along the x, y, and z axes. The three parameters indicate the desired scale factor along each of the three axes:</p>
<pre class="prettyprint">const float scale_matrix[] = 
{
&nbsp;&nbsp;&nbsp;x,    0.0f, 0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;0.0f, y,    0.0f, 0.0f,
&nbsp;&nbsp;&nbsp;0.0f, 0.0f, z,    0.0f,
&nbsp;&nbsp;&nbsp;0.0f, 0.0f, 0.0f, 1.0f
}
</pre>
<p>Here is the implementation of the matrix scaling function:</p>
<pre class="prettyprint">static void
customScale(float matrix[16], const float sx, const float sy, const float sz)
{ 
&nbsp;&nbsp;&nbsp;matrix[0]  *= sx; 
&nbsp;&nbsp;&nbsp;matrix[1]  *= sx; 
&nbsp;&nbsp;&nbsp;matrix[2]  *= sx; 
&nbsp;&nbsp;&nbsp;matrix[3]  *= sx; 

&nbsp;&nbsp;&nbsp;matrix[4]  *= sy; 
&nbsp;&nbsp;&nbsp;matrix[5]  *= sy; 
&nbsp;&nbsp;&nbsp;matrix[6]  *= sy; 
&nbsp;&nbsp;&nbsp;matrix[7]  *= sy; 

&nbsp;&nbsp;&nbsp;matrix[8]  *= sz; 
&nbsp;&nbsp;&nbsp;matrix[9]  *= sz; 
&nbsp;&nbsp;&nbsp;matrix[10] *= sz; 
&nbsp;&nbsp;&nbsp;matrix[11] *= sz; 
}
</pre>

<h4>Matrix Rotation Function (glRotate)</h4>
<p>Define a function to represent a rotation by the vector (x y z). The current matrix is multiplied by a rotation matrix:</p>
<pre class="prettyprint">static void
customRotate(float matrix[16], const float anglex, const float angley, const floatanglez)
{
&nbsp;&nbsp;&nbsp;const float pi = 3.141592f;
&nbsp;&nbsp;&nbsp;float temp[16];
&nbsp;&nbsp;&nbsp;float rz = 2.0f * pi * anglez / 360.0f;
&nbsp;&nbsp;&nbsp;float rx = 2.0f * pi * anglex / 360.0f;
&nbsp;&nbsp;&nbsp;float ry = 2.0f * pi * angley / 360.0f;
&nbsp;&nbsp;&nbsp;float sy = sinf(ry);
&nbsp;&nbsp;&nbsp;float cy = cosf(ry);
&nbsp;&nbsp;&nbsp;float sx = sinf(rx);
&nbsp;&nbsp;&nbsp;float cx = cosf(rx);
&nbsp;&nbsp;&nbsp;float sz = sinf(rz);
&nbsp;&nbsp;&nbsp;float cz = cosf(rz);

&nbsp;&nbsp;&nbsp;customLoadIdentity(temp);

&nbsp;&nbsp;&nbsp;temp[0] = cy * cz - sx * sy * sz;
&nbsp;&nbsp;&nbsp;temp[1] = cz * sx * sy + cy * sz;
&nbsp;&nbsp;&nbsp;temp[2] = -cx * sy;

&nbsp;&nbsp;&nbsp;temp[4] = -cx * sz;
&nbsp;&nbsp;&nbsp;temp[5] = cx * cz;
&nbsp;&nbsp;&nbsp;temp[6] = sx;

&nbsp;&nbsp;&nbsp;temp[8] = cz * sy + cy * sx * sz;
&nbsp;&nbsp;&nbsp;temp[9] = -cy * cz * sx + sy * sz;
&nbsp;&nbsp;&nbsp;temp[10] = cx * cy;

&nbsp;&nbsp;&nbsp;customMultMatrix(matrix, matrix, temp);
}
</pre>

<h3>Create the Shader</h3>
<p>Define the source for the shader using a string array. First comes out vertex shader, which is used to a medium precision for float values. Then build a uniform matrix with dimensions 4x4 intended to hold the model-view-projection matrix. Also create two vector attributes which have 4 components for the vertex position and the color. This varying variable <span style="font-family: Courier New,Courier,monospace">v_color</span> can be accessed from the fragment shader. In the main function of the shader, initialize the position of the current vertex, <span style="font-family: Courier New,Courier,monospace">gl_Position</span>, with the product of the vertex position and the model-view-projection matrix, in order to normalize the position for the target screen. The pixel color is calculated by the varying variable from the vertex shader.</p>
<p>In the fragment shader, declare a varying variable, then set the color of the pixel with this interpolated color.</p>
<pre class="prettyprint">static const char vertex_shader[] =
&nbsp;&nbsp;&nbsp;&quot;precision mediump float;&quot;
&nbsp;&nbsp;&nbsp;&quot;uniform mat4 u_mvpMat;&quot;
&nbsp;&nbsp;&nbsp;&quot;attribute vec4 a_position;&quot;
&nbsp;&nbsp;&nbsp;&quot;attribute vec4 a_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;varying vec4 v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;void main()&quot;
&nbsp;&nbsp;&nbsp;&quot;{&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gl_Position = u_mvpMat * a_position;&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;v_color = a_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;}&quot;;

static const char fragment_shader[] =
&nbsp;&nbsp;&nbsp;&quot;varying lowp vec4 v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;void main()&quot;
&nbsp;&nbsp;&nbsp;&quot;{&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gl_FragColor = v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;}&quot;;
</pre>
<p>Create the shaders, attach the source code that is just defined and compile the program object:</p>
<pre class="prettyprint">static void
initShaders(void* data)
{
&nbsp;&nbsp;&nbsp;const char *p;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;p = vertex_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;vtx_shader = glCreateShader(GL_VERTEX_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;vtx_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;vtx_shader);

&nbsp;&nbsp;&nbsp;p = fragment_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;fgmt_shader = glCreateShader(GL_FRAGMENT_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;fgmt_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;fgmt_shader);
</pre>
<p>Once the shaders are ready, instantiate the program object and link the shaders. If the linking succeeds, you can destroy the shaders afterwards (using <span style="font-family: Courier New,Courier,monospace">glDeleteShader</span>). Since they are inside the program object, so it is pointless to keep them in memory.</p>
<pre class="prettyprint">&nbsp;&nbsp;&nbsp;ad-&gt;program = glCreateProgram();

&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;fgmt_shader);

&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;fgmt_shader);

&nbsp;&nbsp;&nbsp;glLinkProgram(ad-&gt;program);
</pre>

<p>For shader process, create identifiers for the attribute variables used in the shader program. First create an identifier for the model-view-projection matrix, another one for the current vertex position, and a last one for the vertex color.</p>
<pre class="prettyprint">&nbsp;&nbsp;&nbsp;ad-&gt;mvpLoc      = glGetUniformLocation(ad-&gt;program, &quot;u_mvpMat&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;positionLoc = glGetAttribLocation(ad-&gt;program, &quot;a_position&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;colorLoc    = glGetAttribLocation(ad-&gt;program, &quot;a_color&quot;);
</pre>

<p>Finally, generate the buffers for the vertex positions and colors.</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;vertexID);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vertexID);
&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;colorID);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;colorID);
&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);
}
</pre>

<p>Allocate memory for the matrix and load a unit matrix into it. Then define the value that is used in order to build the perspective projection matrix. The <span style="font-family: Courier New,Courier,monospace">customFrustum()</span> function is used for it. Multiply this resulting matrix with a resizing matrix, so the model is correctly adjusted to the screen.</p>
<pre class="prettyprint">
float aspect;
customLoadIdentity(view);

if (w &gt; h) 
{
&nbsp;&nbsp;&nbsp;aspect = (float)w/h;
&nbsp;&nbsp;&nbsp;customFrustum(view, -1.0 * aspect, 1.0 * aspect, -1.0, 1.0, -1.0, 1.0);
}
else 
{
&nbsp;&nbsp;&nbsp;aspect = (float)h/w;
&nbsp;&nbsp;&nbsp;customFrustum(view, -1.0, 1.0, -1.0 * aspect, 1.0 * aspect, -1.0, 1.0);
}
</pre>

<h2 id="render" name="render">Rendering the Cube</h2>

<p>We set the viewport at 0,0 corresponding to the bottom left edge of the window, and the height and width of the GL surface. Clear the depth and the color buffers to the values that were selected during initialization. Then call the <span style="font-family: Courier New,Courier,monospace">glUseProgram()</span> function in order to trigger the shader program.</p>
<pre class="prettyprint">glViewport(0, 0, w, h);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

glUseProgram(ad-&gt;program);
</pre>

<p>Also bind the position and color identifiers to the buffers defined above.</p>
<pre class="prettyprint">glEnableVertexAttribArray(ad-&gt;positionLoc);
glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vertexID);
glVertexAttribPointer(ad-&gt;positionLoc, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

glEnableVertexAttribArray(ad-&gt;colorLoc);
glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;colorID);
glVertexAttribPointer(ad-&gt;colorLoc, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);
</pre>

<p>After this, initialize and calculate the transformation matrix of the model-view matrix by calling the <span style="font-family: Courier New,Courier,monospace">customRotate()</span> function. This makes the cube view rotate a little for a better perspective. Once the model-view matrix is ready to display, multiply the projection matrix with the model-view matrix.</p>
<pre class="prettyprint">customLoadIdentity(model);
customRotate(ad-&gt;model, 45.0f, 45.0f, 0.0f);
customMutlMatrix(ad-&gt;mvp, ad-&gt;view, ad-&gt;model);
</pre>

<p>Then load the model-view-projection matrix into the shader and call <span style="font-family: Courier New,Courier,monospace">glDrawArrays()</span> to draw the model.</p>
<pre class="prettyprint">glUniformMatrix4fv(ad-&gt;mvpLoc, 1, GL_FALSE, mvp);
glDrawArrays(GL_TRIANGLES, 0, 36);
glFlush();
</pre>

<p>You now are the proud owner of a nice cube!</p>

  <p class="figure">Figure: Static cube</p> 
  <p align="center"><img alt="Static cube" src="../../images/static_cube.png" /></p>

<h2 id="animate" name="animate">Animating the Cube</h2>

<p><span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span> is used to create an animation.</p>
<pre class="prettyprint">static Eina_Bool
animate_cb(void *data)
{
&nbsp;&nbsp;&nbsp;elm_glview_changed_set(data);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static void
create_gl_canvas(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;ani = ecore_animator_add(animate_cb, ad-&gt;glview);
}
</pre>

<p>Next define the global variables which are used as parameters of the rendering process. Add parameters to the application data object that are used to control the scaling and the rotation of the cube. To make the cube rotate on one axis, take z, and allow the user to interact with the mouse to make the cube rotate on the two other axes x and y. In order to figure out whether the user is holding the mouse down, add a Boolean variable to have this information. Operations such as shader initialization or program compilation are not required at each tick of the animation loop. For better performance, isolate such task from the repetitive rendering loop. For such purpose, add a Boolean variable which tells whether the initialization is already done.</p>
<pre class="prettyprint">typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;float xangle;
&nbsp;&nbsp;&nbsp;float yangle;
&nbsp;&nbsp;&nbsp;float zangle;
&nbsp;&nbsp;&nbsp;Eina_Bool mouse_down : 1;
&nbsp;&nbsp;&nbsp;Eina_Bool initialized : 1;
}  appdata_s;
</pre>

<p>Here are the modifications that must be done to the rendering loop for animation.</p>
<p>First, lighten the recurrent rendering process by adding an initialization step:</p>
<pre class="prettyprint">if (ad-&gt;initialized) 
{
&nbsp;&nbsp;&nbsp;initShaders(ad);
&nbsp;&nbsp;&nbsp;ad-&gt;initialized = EINA_TRUE;
}
</pre>

<p>Before drawing the vertices, the rotation angle for the model-view matrix must be incremented for every tick.</p>
<pre class="prettyprint">customLoadIdentity(ad-&gt;model);
customRotate(ad-&gt;model, ad-&gt;xangle, ad-&gt;yangle, ad-&gt;zangle++);
customMutlMatrix(ad-&gt;mvp, ad-&gt;view, ad-&gt;model);
</pre>

<p>This makes the cube rotate automatically. The next thing is to use the mouse to drag the cube around. To do so, add callbacks for mouse events. The first callback defines whether the user is holding the mouse down while moving the cursor around:</p>
<pre class="prettyprint">static void
mouse_down_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_TRUE;
}

static void
mouse_up_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_FALSE;
}
</pre>

<p>When the mouse is down, calculate the new rotation angle with the mouse movement along the x and y axis:</p>
<pre class="prettyprint">static void
mouse_move_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;Evas_Event_Mouse_Move *ev;
&nbsp;&nbsp;&nbsp;ev = (Evas_Event_Mouse_Move *)event_info;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;float dx = 0, dy = 0;

&nbsp;&nbsp;&nbsp;if (ad-&gt;mouse_down) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx = ev-&gt;cur.canvas.x - ev-&gt;prev.canvas.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy = ev-&gt;cur.canvas.y - ev-&gt;prev.canvas.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;xangle += dy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;yangle += dx;
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>Define the mouse events callbacks when creating the image canvas:</p>
<pre class="prettyprint">evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_DOWN, mouse_down_cb, ad);
evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_UP, mouse_up_cb, ad);
evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_MOVE, mouse_move_cb, ad);
</pre>

<h2 id="component" name="component">Implementing UI Component Interaction</h2>

<p>Consider using UI component to control some aspects of the rendering. For example, use some sliders to control the shape of the cube. Declare 3 sliders to play with the scaling coordinates of the cube.</p>
<pre class="prettyprint">typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *slx;
&nbsp;&nbsp;&nbsp;Evas_Object *sly;
&nbsp;&nbsp;&nbsp;Evas_Object *slz;
}
</pre>

<p>When rendering the GUI, build and show the sliders. Those accept values in a range from 0.0 to 1.5 and control the scaling of each axis of the cube.</p>
<pre class="prettyprint">// Slider for X-axis scale
ad-&gt;slx = elm_slider_add(ad-&gt;inner_box);
evas_object_size_hint_align_set(ad-&gt;slx, EVAS_HINT_FILL, 0);
elm_slider_horizontal_set(ad-&gt;slx, EINA_TRUE);
elm_slider_unit_format_set(ad-&gt;slx, &quot;%1.2f units&quot;);
elm_slider_indicator_format_set(ad-&gt;slx, &quot;%1.2f units&quot;);
elm_slider_indicator_show_set(ad-&gt;slx, EINA_TRUE);
elm_slider_min_max_set(ad-&gt;slx, 0, 1.5);
elm_slider_value_set(ad-&gt;slx, 0.75);
evas_object_color_set(ad-&gt;slx, 0.0, 0.0, 120, 255);
elm_box_pack_end(ad-&gt;inner_box, ad-&gt;slx);
evas_object_show(ad-&gt;slx);

// Slider for Y-axis scale
ad-&gt;sly = elm_slider_add(ad-&gt;inner_box);
evas_object_size_hint_align_set(ad-&gt;sly, EVAS_HINT_FILL, 0);
elm_slider_horizontal_set(ad-&gt;sly, EINA_TRUE);
elm_slider_unit_format_set(ad-&gt;sly, &quot;%1.2f units&quot;);
elm_slider_indicator_format_set(ad-&gt;sly, &quot;%1.2f units&quot;);
elm_slider_indicator_show_set(ad-&gt;sly, EINA_TRUE);
elm_slider_min_max_set(ad-&gt;sly, 0, 1.5);
elm_slider_value_set(ad-&gt;sly, 0.75);
evas_object_color_set(ad-&gt;sly, 0.0, 0.0, 120, 255);
elm_box_pack_end(ad-&gt;inner_box, ad-&gt;sly);
evas_object_show(ad-&gt;sly);

// Slider for Z-axis scale
ad-&gt;slz = elm_slider_add(ad-&gt;inner_box);
evas_object_size_hint_align_set(ad-&gt;slz, EVAS_HINT_FILL, 0);
elm_slider_horizontal_set(ad-&gt;slz, EINA_TRUE);
elm_slider_unit_format_set(ad-&gt;slz, &quot;%1.2f units&quot;);
elm_slider_indicator_format_set(ad-&gt;slz, &quot;%1.2f units&quot;);
elm_slider_indicator_show_set(ad-&gt;slz, EINA_TRUE);
elm_slider_min_max_set(ad-&gt;slz, 0, 1.5);
elm_slider_value_set(ad-&gt;slz, 0.75);
evas_object_color_set(ad-&gt;slz, 0.0, 0.0, 120, 255);
elm_box_pack_end(ad-&gt;inner_box, ad-&gt;slz);
evas_object_show(ad-&gt;slz);
</pre>

<p>Then use the actual sliders&#39;s values and pass them to the scaling function in the rendering loop:</p>
<pre class="prettyprint">double scalex = elm_slider_value_get(ad-&gt;slx);
double scaley = elm_slider_value_get(ad-&gt;sly);
double scalez = elm_slider_value_get(ad-&gt;slz);

customLoadIdentity(ad-&gt;model);
customRotate(ad-&gt;model, ad-&gt;xangle, ad-&gt;yangle, ad-&gt;zangle++);
customScale(ad-&gt;model, scalex, scaley, scalez);
customMutlMatrix(ad-&gt;mvp, ad-&gt;view, ad-&gt;model);
</pre>

<p>Consider also using a colorpicker to change the background. To achieve this, add a colorselector component:</p>
<pre class="prettyprint">typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *cs;
}
</pre>

<p>Build the UI component with a default palette and add it to the GUI:</p>
<pre class="prettyprint">ad-&gt;cs = elm_colorselector_add(ad-&gt;inner_box);
elm_colorselector_mode_set(ad-&gt;cs, ELM_COLORSELECTOR_BOTH);
elm_colorselector_palette_name_set(ad-&gt;cs, &quot;default&quot;);
elm_box_pack_end(ad-&gt;inner_box, ad-&gt;cs);
evas_object_show(ad-&gt;cs);
</pre>

<p>When rendering the cube, retrieve the currently selected color to define the color buffer. The colors from the colorselector vary from 0 to 255, which  needs to be converted to the color format of OpenGL ES.</p>
<p>Build the UI component with a default palette and add it to the GUI:</p>
<pre class="prettyprint">int r, g, b, a;
elm_colorselector_color_get(ad-&gt;cs, &amp;r, &amp;g, &amp;b, &amp;a);
glClearColor(r/255.0, g/255.0, b/255.0, a/255.0);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</pre>

<h2 id="effect" name="effect">Implementing Effects</h2>


<p>Create a button that resets the scene by putting the background color to black and makes the cube bounce back to its original scale. First add the button to the application data object:</p>
<pre class="prettyprint">typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;Evas_Object *button;
}
</pre>

<p>Then add the button to the GUI:</p>
<pre class="prettyprint">elm_object_text_set(ad-&gt;button, &quot;Reset&quot;);
elm_box_pack_start(ad-&gt;reset_vbox, ad-&gt;button);
evas_object_smart_callback_add(ad-&gt;button, &quot;clicked&quot;, btn_reset_cb, ad);
elm_box_pack_end(ad-&gt;inner_box, ad-&gt;button);
evas_object_show(ad-&gt;button);
</pre>

<p>Declare a callback that resets the variables that have influence on the drawing of the cube. In addition, animate the sliders when they get back to their original position using <span style="font-family: Courier New,Courier,monospace">Ecore_Animator</span>.</p>
<pre class="prettyprint">
typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;float slx_value;
&nbsp;&nbsp;&nbsp;float sly_value;
&nbsp;&nbsp;&nbsp;float slz_value;
} appdata_s;

static Eina_Bool
animate_reset_cb(void *data, double pos)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;double frame = pos;
&nbsp;&nbsp;&nbsp;float x, y, z;

&nbsp;&nbsp;&nbsp;frame = ecore_animator_pos_map(pos, ECORE_POS_MAP_BOUNCE, 1.8, 7);
&nbsp;&nbsp;&nbsp;x = ad-&gt;slx_value*(1-frame) + 0.75*frame;
&nbsp;&nbsp;&nbsp;y = ad-&gt;sly_value*(1-frame) + 0.75*frame;
&nbsp;&nbsp;&nbsp;z = ad-&gt;slz_value*(1-frame) + 0.75*frame;

&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slx, x);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;sly, y);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slz, z);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static void
btn_reset_cb(void *data, Evas *e , Evas_Object *obj , void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;slx_value = elm_slider_value_get(ad-&gt;slx);
&nbsp;&nbsp;&nbsp;ad-&gt;sly_value = elm_slider_value_get(ad-&gt;sly);
&nbsp;&nbsp;&nbsp;ad-&gt;slz_value = elm_slider_value_get(ad-&gt;slz);
&nbsp;&nbsp;&nbsp;ecore_animator_timeline_add(1, animate_reset_cb, ad);
}
</pre>

<h2 id="source" name="source">Viewing the Entire Cube Source</h2>

<p>The following code snippet contains the full code of the cube example. The details are explained in the other use cases.</p>
<pre class="prettyprint">// Copyright (c) 2014 Samsung Electronics Co., Ltd All Rights Reserved

#include &lt;app.h&gt;
#include &lt;Elementary.h&gt;
#include &lt;Elementary_GL_Helpers.h&gt;
#include &lt;efl_extension.h&gt;
#include &lt;dlog.h&gt;

#if !defined(PACKAGE)
#define PACKAGE &quot;org.tizen.glviewtutorial&quot;
#endif

ELEMENTARY_GLVIEW_GLOBAL_DEFINE();

typedef struct appdata 
{
&nbsp;&nbsp;&nbsp;// Elm_UI components
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *conform;
&nbsp;&nbsp;&nbsp;Evas_Object *glview;
&nbsp;&nbsp;&nbsp;Evas_Object *main_box;
&nbsp;&nbsp;&nbsp;Evas_Object *inner_box;
&nbsp;&nbsp;&nbsp;Evas_Object *slx;
&nbsp;&nbsp;&nbsp;Evas_Object *sly;
&nbsp;&nbsp;&nbsp;Evas_Object *slz;
&nbsp;&nbsp;&nbsp;Evas_Object *cs;
&nbsp;&nbsp;&nbsp;Evas_Object *button;

&nbsp;&nbsp;&nbsp;unsigned int     program;
&nbsp;&nbsp;&nbsp;unsigned int     vtx_shader;
&nbsp;&nbsp;&nbsp;unsigned int     fgmt_shader;
&nbsp;&nbsp;&nbsp;unsigned int     vertexID;
&nbsp;&nbsp;&nbsp;unsigned int     colorID;
&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp; mvpLoc;
&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp; positionLoc;
&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp; colorLoc;
&nbsp;&nbsp;&nbsp;float 			 model[16], mvp[16];
&nbsp;&nbsp;&nbsp;float 			 view[16];
&nbsp;&nbsp;&nbsp;float            xangle;
&nbsp;&nbsp;&nbsp;float            yangle;
&nbsp;&nbsp;&nbsp;float            zangle;
&nbsp;&nbsp;&nbsp;Eina_Bool        mouse_down : 1;
&nbsp;&nbsp;&nbsp;Eina_Bool        initialized : 1;

&nbsp;&nbsp;&nbsp;float            slx_value;
&nbsp;&nbsp;&nbsp;float            sly_value;
&nbsp;&nbsp;&nbsp;float            slz_value;
} appdata_s;


static const float vertices[] =
{
&nbsp;&nbsp;&nbsp;// Front
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Right
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;// Back
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;// Left
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Top
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, 0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;// Bottom
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, 0.5f,
&nbsp;&nbsp;&nbsp;-0.5f, -0.5f, -0.5f,
&nbsp;&nbsp;&nbsp;0.5f, -0.5f, -0.5f
};

static const float colors[] =
{
&nbsp;&nbsp;&nbsp;// Front
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Right
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Back
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Left
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.0625f, 0.57421875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Top
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.29296875f, 0.66796875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;// Bottom
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f,
&nbsp;&nbsp;&nbsp;0.52734375f, 0.76171875f, 0.92578125f, 1.0f
};

// Vertex Shader Source
static const char vertex_shader[] =
&nbsp;&nbsp;&nbsp;&quot;precision mediump float;&quot;
&nbsp;&nbsp;&nbsp;&quot;uniform mat4 u_mvpMat;&quot;
&nbsp;&nbsp;&nbsp;&quot;attribute vec4 a_position;&quot;
&nbsp;&nbsp;&nbsp;&quot;attribute vec4 a_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;varying vec4 v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;void main()&quot;
&nbsp;&nbsp;&nbsp;&quot;{&quot;
&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;gl_Position = u_mvpMat * a_position;&quot;
&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;v_color = a_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;}&quot;;

// Fragment Shader Source
static const char fragment_shader[] =
&nbsp;&nbsp;&nbsp;&quot;varying lowp vec4 v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;void main()&quot;
&nbsp;&nbsp;&nbsp;&quot;{&quot;
&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;gl_FragColor = v_color;&quot;
&nbsp;&nbsp;&nbsp;&quot;}&quot;;

static void
customLoadIdentity(float matrix[16])
{
&nbsp;&nbsp;&nbsp;matrix[0] = 1.0f;
&nbsp;&nbsp;&nbsp;matrix[1] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[2] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[3] = 0.0f;

&nbsp;&nbsp;&nbsp;matrix[4] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[5] = 1.0f;
&nbsp;&nbsp;&nbsp;matrix[6] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[7] = 0.0f;

&nbsp;&nbsp;&nbsp;matrix[8] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[9] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[10] = 1.0f;
&nbsp;&nbsp;&nbsp;matrix[11] = 0.0f;

&nbsp;&nbsp;&nbsp;matrix[12] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[13] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[14] = 0.0f;
&nbsp;&nbsp;&nbsp;matrix[15] = 1.0f;
}

static void
customMutlMatrix(float matrix[16], const float matrix0[16], const float matrix1[16])
{
&nbsp;&nbsp;&nbsp;int i, row,column;
&nbsp;&nbsp;&nbsp;float temp[16];
&nbsp;&nbsp;&nbsp;for (column = 0; column &lt; 4; column++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (row = 0; row &lt; 4; row++) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[column * 4 + row] = 0.0f;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 4; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[column * 4 + row] += matrix0[i * 4 + row] * matrix1[column * 4 + i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 16; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i] = temp[i];
}

static void
customScale(float matrix[16], const float sx, const float sy, const float sz)
{
&nbsp;&nbsp;&nbsp;matrix[0]  *= sx;
&nbsp;&nbsp;&nbsp;matrix[1]  *= sx;
&nbsp;&nbsp;&nbsp;matrix[2]  *= sx;
&nbsp;&nbsp;&nbsp;matrix[3]  *= sx;

&nbsp;&nbsp;&nbsp;matrix[4]  *= sy;
&nbsp;&nbsp;&nbsp;matrix[5]  *= sy;
&nbsp;&nbsp;&nbsp;matrix[6]  *= sy;
&nbsp;&nbsp;&nbsp;matrix[7]  *= sy;

&nbsp;&nbsp;&nbsp;matrix[8]  *= sz;
&nbsp;&nbsp;&nbsp;matrix[9]  *= sz;
&nbsp;&nbsp;&nbsp;matrix[10] *= sz;
&nbsp;&nbsp;&nbsp;matrix[11] *= sz;
}

static void
customRotate(float matrix[16], const float anglex, const float angley, const float anglez)
{
&nbsp;&nbsp;&nbsp;const float pi = 3.141592f;
&nbsp;&nbsp;&nbsp;float temp[16];
&nbsp;&nbsp;&nbsp;float rz = 2.0f * pi * anglez / 360.0f;
&nbsp;&nbsp;&nbsp;float rx = 2.0f * pi * anglex / 360.0f;
&nbsp;&nbsp;&nbsp;float ry = 2.0f * pi * angley / 360.0f;
&nbsp;&nbsp;&nbsp;float sy = sinf(ry);
&nbsp;&nbsp;&nbsp;float cy = cosf(ry);
&nbsp;&nbsp;&nbsp;float sx = sinf(rx);
&nbsp;&nbsp;&nbsp;float cx = cosf(rx);
&nbsp;&nbsp;&nbsp;float sz = sinf(rz);
&nbsp;&nbsp;&nbsp;float cz = cosf(rz);

&nbsp;&nbsp;&nbsp;customLoadIdentity(temp);

&nbsp;&nbsp;&nbsp;temp[0] = cy * cz - sx * sy * sz;
&nbsp;&nbsp;&nbsp;temp[1] = cz * sx * sy + cy * sz;
&nbsp;&nbsp;&nbsp;temp[2] = -cx * sy;

&nbsp;&nbsp;&nbsp;temp[4] = -cx * sz;
&nbsp;&nbsp;&nbsp;temp[5] = cx * cz;
&nbsp;&nbsp;&nbsp;temp[6] = sx;

&nbsp;&nbsp;&nbsp;temp[8] = cz * sy + cy * sx * sz;
&nbsp;&nbsp;&nbsp;temp[9] = -cy * cz * sx + sy * sz;
&nbsp;&nbsp;&nbsp;temp[10] = cx * cy;

&nbsp;&nbsp;&nbsp;customMutlMatrix(matrix, matrix, temp);
}

static int
customFrustum(float result[16], const float left, const float right, const float bottom, const float top, const float near, const float far)
{
&nbsp;&nbsp;&nbsp;if ((right - left) == 0.0f || (top - bottom) == 0.0f || (far - near) == 0.0f) return 0;

&nbsp;&nbsp;&nbsp;result[0] = 2.0f / (right - left);
&nbsp;&nbsp;&nbsp;result[1] = 0.0f;
&nbsp;&nbsp;&nbsp;result[2] = 0.0f;
&nbsp;&nbsp;&nbsp;result[3] = 0.0f;

&nbsp;&nbsp;&nbsp;result[4] = 0.0f;
&nbsp;&nbsp;&nbsp;result[5] = 2.0f / (top - bottom);
&nbsp;&nbsp;&nbsp;result[6] = 0.0f;
&nbsp;&nbsp;&nbsp;result[7] = 0.0f;

&nbsp;&nbsp;&nbsp;result[8] = 0.0f;
&nbsp;&nbsp;&nbsp;result[9] = 0.0f;
&nbsp;&nbsp;&nbsp;result[10] = -2.0f / (far - near);
&nbsp;&nbsp;&nbsp;result[11] = 0.0f;

&nbsp;&nbsp;&nbsp;result[12] = -(right + left) / (right - left);
&nbsp;&nbsp;&nbsp;result[13] = -(top + bottom) / (top - bottom);
&nbsp;&nbsp;&nbsp;result[14] = -(far + near) / (far - near);
&nbsp;&nbsp;&nbsp;result[15] = 1.0f;

&nbsp;&nbsp;&nbsp;return 1;
}

static void
initShaders(void* data)
{
&nbsp;&nbsp;&nbsp;const char *p;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;p = vertex_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;vtx_shader = glCreateShader(GL_VERTEX_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;vtx_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;vtx_shader);

&nbsp;&nbsp;&nbsp;p = fragment_shader;
&nbsp;&nbsp;&nbsp;ad-&gt;fgmt_shader = glCreateShader(GL_FRAGMENT_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;fgmt_shader, 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;fgmt_shader);

&nbsp;&nbsp;&nbsp;ad-&gt;program = glCreateProgram();

&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program, ad-&gt;fgmt_shader);

&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;fgmt_shader);

&nbsp;&nbsp;&nbsp;glLinkProgram(ad-&gt;program);

&nbsp;&nbsp;&nbsp;ad-&gt;mvpLoc&nbsp;&nbsp;&nbsp;  = glGetUniformLocation(ad-&gt;program, &quot;u_mvpMat&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;positionLoc = glGetAttribLocation(ad-&gt;program, &quot;a_position&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;colorLoc&nbsp;&nbsp;&nbsp;= glGetAttribLocation(ad-&gt;program, &quot;a_color&quot;);
}

static void init_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;int w, h;
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);

&nbsp;&nbsp;&nbsp;if (!ad-&gt;initialized) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initShaders(ad);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;vertexID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vertexID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glGenBuffers(1, &amp;ad-&gt;colorID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;colorID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;initialized = EINA_TRUE;
&nbsp;&nbsp;&nbsp;}
}

void resize_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;int w, h;
&nbsp;&nbsp;&nbsp;float aspect;
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;customLoadIdentity(ad-&gt;view);

&nbsp;&nbsp;&nbsp;if (w &gt; h) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aspect = (float) w / h;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customFrustum(ad-&gt;view, -1.0 * aspect, 1.0 * aspect, -1.0, 1.0, -1.0, 1.0);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aspect = (float) h / w;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customFrustum(ad-&gt;view, -1.0, 1.0, -1.0 * aspect, 1.0 * aspect, -1.0, 1.0);
&nbsp;&nbsp;&nbsp;}
}

static void draw_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;int w, h;
&nbsp;&nbsp;&nbsp;int r, g, b, a;
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;double scalex = elm_slider_value_get(ad-&gt;slx);
&nbsp;&nbsp;&nbsp;double scaley = elm_slider_value_get(ad-&gt;sly);
&nbsp;&nbsp;&nbsp;double scalez = elm_slider_value_get(ad-&gt;slz);

&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;elm_colorselector_color_get(ad-&gt;cs, &amp;r, &amp;g, &amp;b, &amp;a);

&nbsp;&nbsp;&nbsp;glClearDepthf(1.0f);
&nbsp;&nbsp;&nbsp;glClearColor(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
&nbsp;&nbsp;&nbsp;glEnable(GL_CULL_FACE);

&nbsp;&nbsp;&nbsp;glViewport(0, 0, w, h);
&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

&nbsp;&nbsp;&nbsp;glUseProgram(ad-&gt;program);

&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;positionLoc);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vertexID);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;positionLoc, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(ad-&gt;colorLoc);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;colorID);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(ad-&gt;colorLoc, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);

&nbsp;&nbsp;&nbsp;customLoadIdentity(ad-&gt;model);
&nbsp;&nbsp;&nbsp;customRotate(ad-&gt;model, ad-&gt;xangle, ad-&gt;yangle, ad-&gt;zangle++);
&nbsp;&nbsp;&nbsp;customScale(ad-&gt;model, scalex, scaley, scalez);
&nbsp;&nbsp;&nbsp;customMutlMatrix(ad-&gt;mvp, ad-&gt;view, ad-&gt;model);

&nbsp;&nbsp;&nbsp;glUniformMatrix4fv(ad-&gt;mvpLoc, 1, GL_FALSE, ad-&gt;mvp);
&nbsp;&nbsp;&nbsp;glDrawArrays(GL_TRIANGLES, 0, 36);

&nbsp;&nbsp;&nbsp;glFlush();
}

static void del_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = evas_object_data_get(obj, &quot;ad&quot;);

&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;vtx_shader);
&nbsp;&nbsp;&nbsp;glDeleteShader(ad-&gt;fgmt_shader);
&nbsp;&nbsp;&nbsp;glDeleteProgram(ad-&gt;program);

&nbsp;&nbsp;&nbsp;evas_object_data_del((Evas_Object*) obj, &quot;ad&quot;);
}

static Eina_Bool animate_cb(void *data) 
{
&nbsp;&nbsp;&nbsp;elm_glview_changed_set(data);
&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static void del_animate_cb(void *data, Evas *evas, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;Ecore_Animator *ani = evas_object_data_get(obj, &quot;ani&quot;);
&nbsp;&nbsp;&nbsp;ecore_animator_del(ani);
}

static void mouse_down_cb(void *data, Evas *e, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_TRUE;
}

static void mouse_move_cb(void *data, Evas *e, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;Evas_Event_Mouse_Move *ev;
&nbsp;&nbsp;&nbsp;ev = (Evas_Event_Mouse_Move *) event_info;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;float dx = 0, dy = 0;

&nbsp;&nbsp;&nbsp;if (ad-&gt;mouse_down) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx = ev-&gt;cur.canvas.x - ev-&gt;prev.canvas.x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dy = ev-&gt;cur.canvas.y - ev-&gt;prev.canvas.y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;xangle += dy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;yangle += dx;
&nbsp;&nbsp;&nbsp;}
}

static void mouse_up_cb(void *data, Evas *e, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_FALSE;
}

static Eina_Bool animate_reset_cb(void *data, double pos) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;double frame = pos;
&nbsp;&nbsp;&nbsp;float x, y, z;

&nbsp;&nbsp;&nbsp;frame = ecore_animator_pos_map(pos, ECORE_POS_MAP_BOUNCE, 1.8, 7);
&nbsp;&nbsp;&nbsp;x = ad-&gt;slx_value * (1 - frame) + 0.75 * frame;
&nbsp;&nbsp;&nbsp;y = ad-&gt;sly_value * (1 - frame) + 0.75 * frame;
&nbsp;&nbsp;&nbsp;z = ad-&gt;slz_value * (1 - frame) + 0.75 * frame;

&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slx, x);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;sly, y);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slz, z);

&nbsp;&nbsp;&nbsp;return EINA_TRUE;
}

static void btn_reset_cb(void *data, Evas_Object *obj,	void *event_info) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;ad-&gt;slx_value = elm_slider_value_get(ad-&gt;slx);
&nbsp;&nbsp;&nbsp;ad-&gt;sly_value = elm_slider_value_get(ad-&gt;sly);
&nbsp;&nbsp;&nbsp;ad-&gt;slz_value = elm_slider_value_get(ad-&gt;slz);
&nbsp;&nbsp;&nbsp;ecore_animator_timeline_add(1, animate_reset_cb, ad);
}

static void win_resize_cb(void *data, Evas *e, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;Evas_Coord w, h;
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;evas_object_geometry_get(obj, NULL, NULL, &amp;w, &amp;h);

&nbsp;&nbsp;&nbsp;if (w &gt; h) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(ad-&gt;main_box, EINA_TRUE);
&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(ad-&gt;main_box, EINA_FALSE);
&nbsp;&nbsp;&nbsp;}
}

static void win_back_cb(void *data, Evas_Object *obj, void *event_info) 
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;// Let window go to hidden state
&nbsp;&nbsp;&nbsp;elm_win_lower(ad-&gt;win);
}

static void
win_delete_request_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;ui_app_exit();
}

static void create_base_gui(appdata_s *ad) 
{
&nbsp;&nbsp;&nbsp;// Window
&nbsp;&nbsp;&nbsp;elm_config_accel_preference_set(&quot;opengl&quot;);
&nbsp;&nbsp;&nbsp;ad-&gt;win = elm_win_util_standard_add(PACKAGE, PACKAGE);
&nbsp;&nbsp;&nbsp;elm_win_autodel_set(ad-&gt;win, EINA_TRUE);

&nbsp;&nbsp;&nbsp;if (elm_win_wm_rotation_supported_get(ad-&gt;win)) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rots[4] = { 0, 90, 180, 270 };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_win_wm_rotation_available_rotations_set(ad-&gt;win, (const int *) (&amp;rots), 4);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;win, EVAS_CALLBACK_RESIZE, win_resize_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(ad-&gt;win, &quot;delete,request&quot;, win_delete_request_cb, NULL);
&nbsp;&nbsp;&nbsp;eext_object_event_callback_add(ad-&gt;win, EEXT_CALLBACK_BACK, win_back_cb, ad);

&nbsp;&nbsp;&nbsp;elm_win_conformant_set(ad-&gt;win, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_win_indicator_mode_set(ad-&gt;win, ELM_WIN_INDICATOR_SHOW);
&nbsp;&nbsp;&nbsp;elm_win_indicator_opacity_set(ad-&gt;win, ELM_WIN_INDICATOR_TRANSPARENT);

&nbsp;&nbsp;&nbsp;ad-&gt;conform = elm_conformant_add(ad-&gt;win);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(ad-&gt;conform, EVAS_HINT_EXPAND,	EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;elm_win_resize_object_add(ad-&gt;win, ad-&gt;conform);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;conform);

&nbsp;&nbsp;&nbsp;ad-&gt;main_box = elm_box_add(ad-&gt;conform);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(ad-&gt;main_box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;main_box);

&nbsp;&nbsp;&nbsp;elm_object_content_set(ad-&gt;conform, ad-&gt;main_box);

&nbsp;&nbsp;&nbsp;// Show the window after the base GUI is set up
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;win);
}

static void create_gl_canvas(appdata_s *ad) 
{
&nbsp;&nbsp;&nbsp;Ecore_Animator *ani;

&nbsp;&nbsp;&nbsp;// Create and initialize GLView
&nbsp;&nbsp;&nbsp;ad-&gt;glview = elm_glview_add(ad-&gt;main_box);
&nbsp;&nbsp;&nbsp;ELEMENTARY_GLVIEW_GLOBAL_USE(ad-&gt;glview);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(ad-&gt;glview, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(ad-&gt;glview, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);

&nbsp;&nbsp;&nbsp;// Request a surface with alpha and a depth buffer
&nbsp;&nbsp;&nbsp;elm_glview_mode_set(ad-&gt;glview, ELM_GLVIEW_DEPTH);

&nbsp;&nbsp;&nbsp;// The resize policy tells GLView what to do with the surface when it
&nbsp;&nbsp;&nbsp;// resizes. ELM_GLVIEW_RESIZE_POLICY_RECREATE will tell it to
&nbsp;&nbsp;&nbsp;// destroy the current surface and recreate it to the new size
&nbsp;&nbsp;&nbsp;elm_glview_resize_policy_set(ad-&gt;glview, ELM_GLVIEW_RESIZE_POLICY_RECREATE);

&nbsp;&nbsp;&nbsp;// The render policy sets how GLView should render GL code.
&nbsp;&nbsp;&nbsp;// ELM_GLVIEW_RENDER_POLICY_ON_DEMAND will have the GL callback
&nbsp;&nbsp;&nbsp;// called only when the object is visible.
&nbsp;&nbsp;&nbsp;// ELM_GLVIEW_RENDER_POLICY_ALWAYS would cause the callback to be
&nbsp;&nbsp;&nbsp;// called even if the object were hidden.
&nbsp;&nbsp;&nbsp;elm_glview_render_policy_set(ad-&gt;glview, ELM_GLVIEW_RENDER_POLICY_ON_DEMAND);

&nbsp;&nbsp;&nbsp;// The initialize callback function gets registered here
&nbsp;&nbsp;&nbsp;elm_glview_init_func_set(ad-&gt;glview, init_gl);

&nbsp;&nbsp;&nbsp;// The delete callback function gets registered here
&nbsp;&nbsp;&nbsp;elm_glview_del_func_set(ad-&gt;glview, del_gl);

&nbsp;&nbsp;&nbsp;// The resize callback function gets registered here
&nbsp;&nbsp;&nbsp;elm_glview_resize_func_set(ad-&gt;glview, resize_gl);

&nbsp;&nbsp;&nbsp;// The render callback function gets registered here
&nbsp;&nbsp;&nbsp;elm_glview_render_func_set(ad-&gt;glview, draw_gl);

&nbsp;&nbsp;&nbsp;// Add the GLView to the box and show it
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;main_box, ad-&gt;glview);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;glview);

&nbsp;&nbsp;&nbsp;// This adds an animator so that the app will regularly
&nbsp;&nbsp;&nbsp;// trigger updates of the GLView using elm_glview_changed_set()
&nbsp;&nbsp;&nbsp;//
&nbsp;&nbsp;&nbsp;// NOTE: If you delete GL, this animator will keep running trying to access
&nbsp;&nbsp;&nbsp;// GL so this animator needs to be deleted with ecore_animator_del()
&nbsp;&nbsp;&nbsp;ani = ecore_animator_add(animate_cb, ad-&gt;glview);
&nbsp;&nbsp;&nbsp;evas_object_data_set(ad-&gt;glview, &quot;ani&quot;, ani);
&nbsp;&nbsp;&nbsp;evas_object_data_set(ad-&gt;glview, &quot;ad&quot;, ad);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_DEL, del_animate_cb, ad-&gt;glview);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_DOWN, mouse_down_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_UP, mouse_up_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_event_callback_add(ad-&gt;glview, EVAS_CALLBACK_MOUSE_MOVE, mouse_move_cb, ad);

&nbsp;&nbsp;&nbsp;// Set rotation variables
&nbsp;&nbsp;&nbsp;ad-&gt;xangle = 45.0f;
&nbsp;&nbsp;&nbsp;ad-&gt;yangle = 45.0f;
&nbsp;&nbsp;&nbsp;ad-&gt;zangle = 0.0f;
&nbsp;&nbsp;&nbsp;ad-&gt;mouse_down = EINA_FALSE;
&nbsp;&nbsp;&nbsp;ad-&gt;initialized = EINA_FALSE;
}

static void create_toolbox(appdata_s *ad) 
{
&nbsp;&nbsp;&nbsp;ad-&gt;inner_box = elm_box_add(ad-&gt;main_box);
&nbsp;&nbsp;&nbsp;elm_box_horizontal_set(ad-&gt;inner_box, EINA_FALSE);
&nbsp;&nbsp;&nbsp;elm_box_homogeneous_set(ad-&gt;inner_box, EINA_FALSE);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;main_box, ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;inner_box);

&nbsp;&nbsp;&nbsp;// Color selector for the background
&nbsp;&nbsp;&nbsp;ad-&gt;cs = elm_colorselector_add(ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;elm_colorselector_mode_set(ad-&gt;cs, ELM_COLORSELECTOR_BOTH);
&nbsp;&nbsp;&nbsp;elm_colorselector_palette_name_set(ad-&gt;cs, &quot;default&quot;);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;inner_box, ad-&gt;cs);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;cs);

&nbsp;&nbsp;&nbsp;// Slider for X-axis scale
&nbsp;&nbsp;&nbsp;ad-&gt;slx = elm_slider_add(ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(ad-&gt;slx, EVAS_HINT_FILL, 0);
&nbsp;&nbsp;&nbsp;elm_slider_horizontal_set(ad-&gt;slx, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_unit_format_set(ad-&gt;slx, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_format_set(ad-&gt;slx, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_show_set(ad-&gt;slx, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_min_max_set(ad-&gt;slx, 0, 1.5);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slx, 0.75);
&nbsp;&nbsp;&nbsp;evas_object_color_set(ad-&gt;slx, 0.0, 0.0, 120, 255);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;inner_box, ad-&gt;slx);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;slx);

&nbsp;&nbsp;&nbsp;// Slider for Y-axis scale
&nbsp;&nbsp;&nbsp;ad-&gt;sly = elm_slider_add(ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(ad-&gt;sly, EVAS_HINT_FILL, 0);
&nbsp;&nbsp;&nbsp;elm_slider_horizontal_set(ad-&gt;sly, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_unit_format_set(ad-&gt;sly, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_format_set(ad-&gt;sly, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_show_set(ad-&gt;sly, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_min_max_set(ad-&gt;sly, 0, 1.5);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;sly, 0.75);
&nbsp;&nbsp;&nbsp;evas_object_color_set(ad-&gt;sly, 0.0, 0.0, 120, 255);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;inner_box, ad-&gt;sly);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;sly);

&nbsp;&nbsp;&nbsp;// Slider for Z-axis scale
&nbsp;&nbsp;&nbsp;ad-&gt;slz = elm_slider_add(ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(ad-&gt;slz, EVAS_HINT_FILL, 0);
&nbsp;&nbsp;&nbsp;elm_slider_horizontal_set(ad-&gt;slz, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_unit_format_set(ad-&gt;slz, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_format_set(ad-&gt;slz, &quot;%1.2f units&quot;);
&nbsp;&nbsp;&nbsp;elm_slider_indicator_show_set(ad-&gt;slz, EINA_TRUE);
&nbsp;&nbsp;&nbsp;elm_slider_min_max_set(ad-&gt;slz, 0, 1.5);
&nbsp;&nbsp;&nbsp;elm_slider_value_set(ad-&gt;slz, 0.75);
&nbsp;&nbsp;&nbsp;evas_object_color_set(ad-&gt;slz, 0.0, 0.0, 120, 255);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;inner_box, ad-&gt;slz);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;slz);

&nbsp;&nbsp;&nbsp;// Reset button
&nbsp;&nbsp;&nbsp;ad-&gt;button = elm_button_add(ad-&gt;inner_box);
&nbsp;&nbsp;&nbsp;elm_object_text_set(ad-&gt;button, &quot;Reset&quot;);
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(ad-&gt;button, &quot;clicked&quot;, btn_reset_cb, ad);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(ad-&gt;button, EVAS_HINT_FILL, 0);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(ad-&gt;inner_box, ad-&gt;button);
&nbsp;&nbsp;&nbsp;evas_object_show(ad-&gt;button);
}

static bool app_create(void *data) 
{
&nbsp;&nbsp;&nbsp;// Hook to take necessary actions before main event loop starts
&nbsp;&nbsp;&nbsp;// Initialize UI resources and application's data
&nbsp;&nbsp;&nbsp;// If this function returns true, the main loop of application starts
&nbsp;&nbsp;&nbsp;// If this function returns false, the application is terminated
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;

&nbsp;&nbsp;&nbsp;create_base_gui(ad);
&nbsp;&nbsp;&nbsp;create_gl_canvas(ad);
&nbsp;&nbsp;&nbsp;create_toolbox(ad);

&nbsp;&nbsp;&nbsp;return true;
}

static void app_control(app_control_h app_control, void *data) 
{
&nbsp;&nbsp;&nbsp;// Handle the launch request
}

static void app_pause(void *data) 
{
&nbsp;&nbsp;&nbsp;// Take necessary actions when application becomes invisible
}

static void app_resume(void *data) 
{
&nbsp;&nbsp;&nbsp;// Take necessary actions when application becomes visible
}

static void app_terminate(void *data) 
{
&nbsp;&nbsp;&nbsp;// Release all resources
}

int main(int argc, char *argv[]) 
{
&nbsp;&nbsp;&nbsp;appdata_s ad = { 0, };
&nbsp;&nbsp;&nbsp;int ret = 0;
&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback = { 0, };

&nbsp;&nbsp;&nbsp;event_callback.create = app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.pause = app_pause;
&nbsp;&nbsp;&nbsp;event_callback.resume = app_resume;
&nbsp;&nbsp;&nbsp;event_callback.app_control = app_control;

&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &amp;event_callback, &amp;ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, PACKAGE, &quot;The application failed to start, and returned %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>	  

<h2 id="multithread" name="multithread">Using OpenGL ES in Multi-threaded Applications</h2>
	
<p>To use OpenGL ES in multi-threaded applications, set up the rendering view and initialize the application:</p>
 
<ol>
<li>Manage the Elementary GLView:
<ol type="a">

<li>Create a single GLView component covering the whole window using the <span style="font-family: Courier New,Courier,monospace;">app_create()</span> function:
<pre class="prettyprint">
typedef struct 
{
&nbsp;&nbsp;&nbsp;Evas_Object *glview;

&nbsp;&nbsp;&nbsp;Eina_Lock lck;

&nbsp;&nbsp;&nbsp;// RT to main loop
&nbsp;&nbsp;&nbsp;Ecore_Pipe *pipe;

&nbsp;&nbsp;&nbsp;// Main loop to RT: direct pipe file descriptors
&nbsp;&nbsp;&nbsp;int rt_rpipefd, rt_wpipefd;

&nbsp;&nbsp;&nbsp;// General OpenGL ES data: program to draw a texture fullscreen
&nbsp;&nbsp;&nbsp;GLuint vtx_shader[1], fgmt_shader[1], program[1], vbo[2];
&nbsp;&nbsp;&nbsp;Evas_GL_Context *main_ctx;

&nbsp;&nbsp;&nbsp;// Render thread data
&nbsp;&nbsp;&nbsp;struct 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ecore_Thread *thread;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_GL_Context *ctx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_GL_Surface *sfc;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat c1, c2, c3, c4;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool cancelled;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool finished;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eina_Bool ready;
&nbsp;&nbsp;&nbsp;} th;

&nbsp;&nbsp;&nbsp;// Pool of Target_Buffer: empty, ready (locked access)
&nbsp;&nbsp;&nbsp;Eina_Inlist *buffers_empty;
&nbsp;&nbsp;&nbsp;Eina_Inlist *buffers_ready;
&nbsp;&nbsp;&nbsp;Target_Buffer *last_buffer;
} App_Data;

static bool app_create(void *data)
{
&nbsp;&nbsp;&nbsp;Evas_Object *win, *glview;
&nbsp;&nbsp;&nbsp;App_Data *ad = data;

&nbsp;&nbsp;&nbsp;// Request OpenGL hardware acceleration
 
&nbsp;&nbsp;&nbsp;elm_config_accel_preference_set(&quot;gl&quot;);
&nbsp;&nbsp;&nbsp;elm_config_accel_preference_override_set(EINA_TRUE);
&nbsp;&nbsp;&nbsp;// Create a basic window  
&nbsp;&nbsp;&nbsp;win = elm_win_util_standard_add(&quot;win&quot;, &quot;Multi-thread OpenGL ES demo&quot;);
&nbsp;&nbsp;&nbsp;evas_object_show(win);
&nbsp;&nbsp;&nbsp;// On window deletion, exit the render thread  
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(win, &quot;delete,request&quot;, delete_cb, &amp;ad);
&nbsp;&nbsp;&nbsp;// Create a basic OpenGL ES surface with GLView  
&nbsp;&nbsp;&nbsp;glview = elm_glview_version_add(win, EVAS_GL_GLES_2_X);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_min_set(glview, 240, 240);
&nbsp;&nbsp;&nbsp;elm_win_resize_object_add(win, glview);
&nbsp;&nbsp;&nbsp;ELEMENTARY_GLVIEW_GLOBAL_USE(glview);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(glview, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(glview, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;evas_object_show(glview);

&nbsp;&nbsp;&nbsp;elm_glview_mode_set(glview, ELM_GLVIEW_ALPHA);
&nbsp;&nbsp;&nbsp;elm_glview_render_policy_set(glview, ELM_GLVIEW_RENDER_POLICY_ON_DEMAND);
&nbsp;&nbsp;&nbsp;elm_glview_resize_policy_set(glview, ELM_GLVIEW_RESIZE_POLICY_RECREATE);
&nbsp;&nbsp;&nbsp;elm_glview_init_func_set(glview, init);
&nbsp;&nbsp;&nbsp;elm_glview_render_func_set(glview, render);

&nbsp;&nbsp;&nbsp;evas_object_data_set(glview, &quot;ad&quot;, &amp;ad);
&nbsp;&nbsp;&nbsp;ad-&gt;glview = glview;
}
</pre>
</li>

<li>Initialize the gl status. The main thread render function acts as a compositor thread.
<pre class="prettyprint">
static void
init(Evas_Object *obj)
{
&nbsp;&nbsp;&nbsp;App_Data *ad = evas_object_data_get(obj, &quot;ad&quot;);
&nbsp;&nbsp;&nbsp;const char *p;
&nbsp;&nbsp;&nbsp;static const char vertex_texture[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attribute vec4 vPosition;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attribute vec2 vTexCoord;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;varying vec2 texcoord;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;void main()\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;   gl_Position = vPosition;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;   texcoord = vTexCoord;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;}\n&quot;;
&nbsp;&nbsp;&nbsp;static const char fragment_texture[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#ifdef GL_ES\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;precision mediump float;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#endif\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;uniform sampler2D tex;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;varying vec2 texcoord;\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;void main()\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;   gl_FragColor = texture2D(tex, texcoord);\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;}\n&quot;;
&nbsp;&nbsp;&nbsp;const float rectangle_fullscreen_vertices[] =
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,  1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0, -1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, -1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,  1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0,  1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0, -1.0,  0.0
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;const float texture_vertices[] =
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,  1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,  0.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,  1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,  1.0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,  0.0,
&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;// Init main data
&nbsp;&nbsp;&nbsp;ad-&gt;main_ctx = evas_gl_current_context_get(elm_glview_evas_gl_get(obj));
&nbsp;&nbsp;&nbsp;// Create vertex data
&nbsp;&nbsp;&nbsp;glGenBuffers(2, ad-&gt;vbo);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vbo[0]);
&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, 3 * 6 * 4, rectangle_fullscreen_vertices, GL_STATIC_DRAW);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vbo[1]);
&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER, 2 * 6 * 4, texture_vertices, GL_STATIC_DRAW);
&nbsp;&nbsp;&nbsp;// Texture draw
&nbsp;&nbsp;&nbsp;p = vertex_texture;
&nbsp;&nbsp;&nbsp;ad-&gt;vtx_shader[0] = glCreateShader(GL_VERTEX_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;vtx_shader[0], 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;vtx_shader[0]);
&nbsp;&nbsp;&nbsp;p = fragment_texture;
&nbsp;&nbsp;&nbsp;ad-&gt;fgmt_shader[0] = glCreateShader(GL_FRAGMENT_SHADER);
&nbsp;&nbsp;&nbsp;glShaderSource(ad-&gt;fgmt_shader[0], 1, &amp;p, NULL);
&nbsp;&nbsp;&nbsp;glCompileShader(ad-&gt;fgmt_shader[0]);
&nbsp;&nbsp;&nbsp;ad-&gt;program[0] = glCreateProgram();
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program[0], ad-&gt;vtx_shader[0]);
&nbsp;&nbsp;&nbsp;glAttachShader(ad-&gt;program[0], ad-&gt;fgmt_shader[0]);
</pre>
</li>
</ol>
</li>

<li>Create Ecore threads:
<p>To easily create threads with EFL, use the <span style="font-family: Courier New,Courier,monospace;">ecore_thread()</span> infrastructure, which provides a high level abstraction over system threads, along with callbacks in the main loop to signal that a thread has finished running or has been canceled.</p>
<p>When the main OpenGL ES context is properly set up, spawn the render thread and start setting up its OpenGL ES context:</p>
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;glBindAttribLocation(ad-&gt;program[0], 0, &quot;vPosition&quot;);
&nbsp;&nbsp;&nbsp;glBindAttribLocation(ad-&gt;program[0], 1, &quot;vTexCoord&quot;);
&nbsp;&nbsp;&nbsp;glLinkProgram(ad-&gt;program[0]);

&nbsp;&nbsp;&nbsp;ad-&gt;th.thread = ecore_thread_run(thread_run, thread_end, thread_cancel, ad);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">thread_run()</span>, <span style="font-family: Courier New,Courier,monospace;">thread_end()</span>, and <span style="font-family: Courier New,Courier,monospace;">thread_cancel()</span> callback functions are called when the thread runs, returns successfully, or is canceled prematurely. In this application, the thread always returns and must never be forcefully canceled because it never returns from the <span style="font-family: Courier New,Courier,monospace;">thread_run()</span> function. To run again, trigger a cancel callback if the thread is calling the <span style="font-family: Courier New,Courier,monospace;">ecore_thread_reschedule()</span> function.</p>
</li>
</ol>

	<h3>Managing Inter-thread Communication Channels</h3>
			
<p>To establish safe communication channels between threads:</p>
<ol>
<li>Since most of EFL is not thread-safe, certain operations cannot be executed from another thread and you must use the main loop instead. 
<p>Establish a communication channel from the render thread to the main loop:</p>
<ol type="a">
<li>Create an <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span> channel.
<p>EFL provides a simple tool to send messages to the main thread using pipes. Ecore Pipe is the abstraction layer around pipe objects, and is the easiest way to send a message from any thread back to the main thread.</p>
<pre class="prettyprint">
// In the app_create() function, create pipe for messaging  
ad.pipe = ecore_pipe_add(pipe_handler, &amp;ad);
eina_lock_new(&amp;ad.lck);
</pre>

<p><span style="font-family: Courier New,Courier,monospace;">eina_lock_new()</span> creates a new <span style="font-family: Courier New,Courier,monospace;">Eina_Lock</span>. It protects access to shared variables.</p>
</li>
<li>Send messages with <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span>.
<p>The following code passes <span style="font-family: Courier New,Courier,monospace;">Message_Data</span> structures, which are copied by <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span> and sent over to the <span style="font-family: Courier New,Courier,monospace;">pipe_handler</span> callback. <span style="font-family: Courier New,Courier,monospace;">Message_Data</span> structures have to be defined by the application.</p>
<pre class="prettyprint">
// Render thread to main loop  
static void
message_send(App_Data *ad, Message_Type type, ...)
{
&nbsp;&nbsp;&nbsp;Message_Data msg = {0};
&nbsp;&nbsp;&nbsp;msg.type = type;
&nbsp;&nbsp;&nbsp;if (type == MSG_NEWFRAME)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_list args;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_start(args, type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.newframe.target = va_arg(args, Target_Buffer *);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// The pipe copies the passed data
&nbsp;&nbsp;&nbsp;ecore_pipe_write(ad-&gt;pipe, &amp;msg, sizeof(msg));
}
</pre>
</li>

<li>Receive messages through the <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span>.
<p>The <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span> has a callback running in the main thread, and receives data sent over by any thread.</p>
<pre class="prettyprint">
static void
pipe_handler(void *data, void *buf, unsigned int len EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;Message_Data *msg = buf;
&nbsp;&nbsp;&nbsp;App_Data *ad = data;
&nbsp;&nbsp;&nbsp;switch (msg-&gt;type)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MSG_HELLO:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Render thread has started  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;The render thread is saying hello.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case MSG_GOODBYE:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It is now safe to request exit from the main loop  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Thread has cleanly terminated.\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_exit();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}
</pre>
<p>You need not use the <span style="font-family: Courier New,Courier,monospace;">free()</span> function to free data since the data belongs to the <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span>.</p>
</li>
</ol>
</li>

<li><p>Sending messages to the render thread from the main thread covers input event passing handling. The following example passes input event messages and regular ticks to the render thread.</p>

<p>Establish a communication channel from the main thread to the render thread:</p>

<ol type="a">
<li>Create a pipe.
<p>The easiest way to send a simple message in EFL in Tizen is to rely on a POSIX pipe file handle:</p>
<pre class="prettyprint">
// Create a pipe for messaging  
int fds[2];
pipe(fds);
ad.rt_rpipefd = fds[0];
ad.rt_wpipefd = fds[1];
</pre>
</li>

<li>Send messages to a thread. Write data to the pipe created above, from the main loop:
<pre class="prettyprint">
// Main loop to render thread  
static void
event_send(App_Data *ad, Event_Type type, ...)
{
&nbsp;&nbsp;&nbsp;// Event Data is defined by application
&nbsp;&nbsp;&nbsp;Event_Data *ed = calloc(1, sizeof(Event_Data));
&nbsp;&nbsp;&nbsp;ed-&gt;type = type;
&nbsp;&nbsp;&nbsp;if (type == EVENT_MOUSE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_list args;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_start(args, type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ed-&gt;mouse.down = (va_arg(args, int) != 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_end(args);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// Manually send this over the pipe fd (only the pointer)  
&nbsp;&nbsp;&nbsp;write(ad-&gt;rt_wpipefd, &amp;ed, sizeof(ed));
}
</pre>
</li>

<li>Receive messages in a thread:
<p>In the render thread, use the event handling code:</p>
<pre class="prettyprint">
while (!ecore_thread_check(ad-&gt;th.thread))
{
&nbsp;&nbsp;&nbsp;Event_Data *ev = NULL;
&nbsp;&nbsp;&nbsp;int r;

&nbsp;&nbsp;&nbsp;// Render

&nbsp;&nbsp;&nbsp;r = read(ad-&gt;rt_rpipefd, &amp;ev, sizeof(ev));
&nbsp;&nbsp;&nbsp;if ((r == sizeof(ev)) &amp;&amp; ev)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle message
&nbsp;&nbsp;&nbsp;}
}
</pre></li>

<li>Use a simple pipe file descriptor to use the <span style="font-family: Courier New,Courier,monospace;">poll()</span> or <span style="font-family: Courier New,Courier,monospace;">select()</span> function, in order to wait for events for a pre-determined period of time, or to wait for events on more than a single file descriptor. In this example, the main loop is responsible for the render thread life-cycle:
<pre class="prettyprint">
thread_run(void *data, Ecore_Thread *th EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;evas_gl_make_current(evgl, ad-&gt;th.sfc, ad-&gt;th.ctx);
&nbsp;&nbsp;&nbsp;while (!ecore_thread_check(ad-&gt;th.thread))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Prepare new frame
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glViewport(0, 0, BUFFER_WIDTH, BUFFER_HEIGHT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindFramebuffer(GL_FRAMEBUFFER, target-&gt;fbo);
	  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((r = read(ad-&gt;rt_rpipefd, &amp;ev, sizeof(ev))) == sizeof(ev)) &amp;&amp; ev)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ev-&gt;type == EVENT_QUIT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(ev);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">ecore_thread_check()</span> function returns true when the thread is canceled using the <span style="font-family: Courier New,Courier,monospace;">ecore_thread_cancel()</span> function.</p>
</li>
</ol>
</li>

<li>Handle input events:
<p>With the above setup environment, pass input events from the main thread to any thread.</p>
<ol type="a">
<li>Add the following code to the <span style="font-family: Courier New,Courier,monospace;">app_create()</span> function to catch mouse up or down events on the GLView object:
<pre class="prettyprint">
evas_object_event_callback_add(glview, EVAS_CALLBACK_MOUSE_DOWN, mouse_down_cb, &amp;ad);
evas_object_event_callback_add(glview, EVAS_CALLBACK_MOUSE_UP, mouse_up_cb, &amp;ad);
</pre>
</li>

<li>
<p>Add a handle to the callbacks:</p>
<p>The mouse down callback sends a mouse down event to render thread.</p>
<pre class="prettyprint">
static void
mouse_down_cb(void *data, Evas *e EINA_UNUSED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *obj EINA_UNUSED, void *event_info)
{
&nbsp;&nbsp;&nbsp;Evas_Event_Mouse_Down *event = event_info;
&nbsp;&nbsp;&nbsp;App_Data *ad = data;
&nbsp;&nbsp;&nbsp;if (event-&gt;button != 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;event_send(ad, EVENT_MOUSE, EINA_TRUE);
}
</pre>
</li>
<li>
<p>The mouse up callback sends a mouse up event to render thread.</p>
<pre class="prettyprint">
static void
mouse_up_cb(void *data, Evas *e EINA_UNUSED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *obj EINA_UNUSED, void *event_info)
{
&nbsp;&nbsp;&nbsp;Evas_Event_Mouse_Up *event = event_info;
&nbsp;&nbsp;&nbsp;App_Data *ad = data;

&nbsp;&nbsp;&nbsp;if (event-&gt;button != 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;

&nbsp;&nbsp;&nbsp;event_send(ad, EVENT_MOUSE, EINA_FALSE);
}
</pre>

<p>The render thread receives these events calling the <span style="font-family: Courier New,Courier,monospace;">read()</span> function:</p>
<pre class="prettyprint">
thread_run(void *data, Ecore_Thread *th EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;// Prepare new frame
&nbsp;&nbsp;&nbsp;glViewport(0, 0, BUFFER_WIDTH, BUFFER_HEIGHT);
&nbsp;&nbsp;&nbsp;glBindFramebuffer(GL_FRAMEBUFFER, target-&gt;fbo);
&nbsp;&nbsp;&nbsp;evas_gl_make_current(evgl, ad-&gt;th.sfc, ad-&gt;th.ctx);
&nbsp;&nbsp;&nbsp;while (!ecore_thread_check(ad-&gt;th.thread))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check for events from the main thread (one event at a time)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((r = read(ad-&gt;rt_rpipefd, &amp;ev, sizeof(ev))) == sizeof(ev)) &amp;&amp; ev)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ev-&gt;type == EVENT_MOUSE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ev-&gt;mouse.down)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do something
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ol>
</li>
</ol>

<h3>Managing Multi-thread OpenGL ES</h3>
			
<p>To deliver the result of OpenGL ES rendering to the main thread for compositing, render the thread:</p>
<ol>
<li>
<p>The easiest way to share data between threads in OpenGL ES is to use shared contexts. However, all objects ID&#39;s, such as texture IDs and FBOs, are shared between contexts. In addition, it is not always allowed to bind the same object from different contexts at the same time.</p>

<p>The example shows that the render thread uses EvasGL directly to create a dummy PBuffer surface and its render context. The PBuffer surface is necessary for the <span style="font-family: Courier New,Courier,monospace;">evas_gl_make_current()</span> function:</p>
<pre class="prettyprint">
Evas_GL *evgl = elm_glview_evas_gl_get(ad-&gt;glview);

cfg = evas_gl_config_new();
cfg-&gt;color_format = EVAS_GL_NO_FBO;
cfg-&gt;depth_bits = EVAS_GL_DEPTH_NONE;
cfg-&gt;stencil_bits = EVAS_GL_STENCIL_NONE;
cfg-&gt;options_bits = EVAS_GL_OPTIONS_NONE;
ad-&gt;th.sfc = evas_gl_pbuffer_surface_create(evgl, cfg, 1, 1, NULL);
evas_gl_config_free(cfg);
ad-&gt;th.ctx = evas_gl_context_create(evgl, ad-&gt;main_ctx);
evas_gl_make_current(evgl, ad-&gt;th.sfc, ad-&gt;th.ctx);
</pre>
</li>

<li>
<p>Deliver images from one context to another using a shared FBO. The following example uses a pool of at least 2 buffers: texture and FBO. This works as double or triple buffering. At all times, one buffer is used for drawing (rendering in the render thread) and the other for compositing (reading in the main thread).</p>
<pre class="prettyprint">
// Create targets (needs at least 2)  
eina_lock_take(&amp;ad-&gt;lck);
for (i = 0; i &lt; BUFFER_COUNT; i++)
{
&nbsp;&nbsp;&nbsp;target = target_create(ad);
&nbsp;&nbsp;&nbsp;if (!target) break;
&nbsp;&nbsp;&nbsp;target-&gt;id = i;
&nbsp;&nbsp;&nbsp;ad-&gt;buffers_empty = eina_inlist_append(ad-&gt;buffers_empty,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EINA_INLIST_GET(target));
}
eina_lock_release(&amp;ad-&gt;lck);
message_send(ad, MSG_READY);
</pre>
</li>
<li>
<p>Use the <span style="font-family: Courier New,Courier,monospace;">target_create()</span> function to create a texture and an attached FBO, and package them together:</p>
<pre class="prettyprint">
typedef struct 
{
&nbsp;&nbsp;&nbsp;EINA_INLIST;
&nbsp;&nbsp;&nbsp;GLuint fbo, tex;
&nbsp;&nbsp;&nbsp;EvasGLSync sync;
&nbsp;&nbsp;&nbsp;int id;
} 
Target_Buffer;

static Target_Buffer *
target_create(App_Data *ad EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;Target_Buffer *target = calloc(1, sizeof(Target_Buffer));
&nbsp;&nbsp;&nbsp;GLenum err;
&nbsp;&nbsp;&nbsp;if (!target)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;glGenFramebuffers(1, &amp;target-&gt;fbo);
&nbsp;&nbsp;&nbsp;glBindFramebuffer(GL_FRAMEBUFFER, target-&gt;fbo);
&nbsp;&nbsp;&nbsp;glGenTextures(1, &amp;target-&gt;tex);
&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D, target-&gt;tex);
&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
&nbsp;&nbsp;&nbsp;glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, BUFFER_WIDTH, BUFFER_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
&nbsp;&nbsp;&nbsp;glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, target-&gt;tex, 0);
&nbsp;&nbsp;&nbsp;err = glCheckFramebufferStatus(GL_FRAMEBUFFER);
&nbsp;&nbsp;&nbsp;if (err != GL_FRAMEBUFFER_COMPLETE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;FBO could not be set: 0x%x\n&quot;, (int) err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glDeleteTextures(1, &amp;target-&gt;tex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glDeleteFramebuffers(1, &amp;target-&gt;fbo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(target);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return target;
}
</pre>
</li>

<li>
<p>Use the shared buffers in the render thread as target surfaces:</p>
<pre class="prettyprint">
thread_run(void *data, Ecore_Thread *th EINA_UNUSED)
{
&nbsp;&nbsp;&nbsp;evas_gl_make_current(evgl, ad-&gt;th.sfc, ad-&gt;th.ctx);
&nbsp;&nbsp;&nbsp;while (!ecore_thread_check(ad-&gt;th.thread))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get an empty buffer  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_lock_take(&amp;ad-&gt;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!ad-&gt;buffers_empty)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wait
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_lock_release(&amp;ad-&gt;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(1000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = EINA_INLIST_CONTAINER_GET(ad-&gt;buffers_empty, Target_Buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ad-&gt;buffers_empty = eina_inlist_remove(ad-&gt;buffers_empty, ad-&gt;buffers_empty);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eina_lock_release(&amp;ad-&gt;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Prepare new frame  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glViewport(0, 0, BUFFER_WIDTH, BUFFER_HEIGHT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindFramebuffer(GL_FRAMEBUFFER, target-&gt;fbo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw a new frame  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_draw(ad);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Release FBO; some drivers complain if it is bound by a different thread
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindFramebuffer(GL_FRAMEBUFFER, 0);
&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
<li>
<p>To render in a thread, use the <span style="font-family: Courier New,Courier,monospace;">thread_draw()</span> function. The following example draws with a color:</p>
<pre class="prettyprint">
static void
thread_draw(App_Data *ad, Evas_GL_API *gl)
{
&nbsp;&nbsp;&nbsp;// Draw function  
&nbsp;&nbsp;&nbsp;glClearColor(ad-&gt;th.c1, ad-&gt;th.c2, ad-&gt;th.c3, ad-&gt;th.c4);
&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT);
}
</pre>
</li>

<li>Render the FBO to the screen. The following example uses the <span style="font-family: Courier New,Courier,monospace;">ecore_pipe</span>:
<pre class="prettyprint">
// Signal the main thread that a new frame is now available  
message_send(ad, MSG_NEWFRAME, target);
</pre>
</li>
<li>
<p>The pipe handler receives this message in <span style="font-family: Courier New,Courier,monospace;">pipe_handler</span>. The following example adds the target buffer to a queue:</p>
<pre class="prettyprint">
case MSG_NEWFRAME:
&nbsp;&nbsp;&nbsp;// Queue a new frame description  
&nbsp;&nbsp;&nbsp;printf(&quot;Got a new frame with buffer %d\n&quot;, msg-&gt;newframe.target-&gt;id);
&nbsp;&nbsp;&nbsp;eina_lock_take(&amp;ad-&gt;lck);
&nbsp;&nbsp;&nbsp;ad-&gt;buffers_ready = eina_inlist_append(ad-&gt;buffers_ready, EINA_INLIST_GET(msg-&gt;newframe.target));
&nbsp;&nbsp;&nbsp;eina_lock_release(&amp;ad-&gt;lck);
&nbsp;&nbsp;&nbsp;elm_glview_changed_set(ad-&gt;glview);
&nbsp;&nbsp;&nbsp;break;
</pre>
</li>
<li>
<p>The GLView <span style="font-family: Courier New,Courier,monospace;">render()</span> function is called from the main loop, and draws the texture to the screen:</p>
<pre class="prettyprint">
// Draw the texture on the screen  
evas_object_geometry_get(ad-&gt;glview, 0, 0, &amp;w, &amp;h);
draw_rectangle(ad, w, h, target-&gt;tex);
</pre>

<p>Draw the texture:</p>
<pre class="prettyprint">
void
draw_rectangle(App_Data *ad, int w, int h, int tex)
{
&nbsp;&nbsp;&nbsp;GLuint u;
&nbsp;&nbsp;&nbsp;glViewport(0, 0, w, h);
&nbsp;&nbsp;&nbsp;glClearColor(0.2, 0.2, 0.2, 1.0);
&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT);
&nbsp;&nbsp;&nbsp;glEnable(GL_BLEND);
&nbsp;&nbsp;&nbsp;glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
&nbsp;&nbsp;&nbsp;glUseProgram(ad-&gt;program[0]);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vbo[0]);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(0);
&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER, ad-&gt;vbo[1]);
&nbsp;&nbsp;&nbsp;glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, 0);
&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(1);
&nbsp;&nbsp;&nbsp;u = glGetUniformLocation(ad-&gt;program[0], &quot;tex&quot;);
&nbsp;&nbsp;&nbsp;glUniform1i(u, 0);
&nbsp;&nbsp;&nbsp;glActiveTexture(GL_TEXTURE0);
&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D, tex);
&nbsp;&nbsp;&nbsp;glDrawArrays(GL_TRIANGLES, 0, 6);
}
</pre>
</li>

<li>
<p>The above code works in some cases but depending on the GPU and driver, there can be synchronization issues between the 2 threads, as one is drawing and the other is reading from the same object. Remember that most GL commands are asynchronous.</p>

<p>You can synchronize data between threads:</p>
<ul>
<li>Using fence sync objects
<p>Use the <span style="font-family: Courier New,Courier,monospace;">fence_sync</span> extension:</p>
<pre class="prettyprint">
// Create fence sync  
if (evasglCreateSync)
&nbsp;&nbsp;&nbsp;target-&gt;sync = evasglCreateSync(evgl, EVAS_GL_SYNC_FENCE, NULL);
else
{
&nbsp;&nbsp;&nbsp;target-&gt;sync = EVAS_GL_NO_SYNC;
&nbsp;&nbsp;&nbsp;glFinish();
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace;">evasglCreateSync</span> function pointer is <span style="font-family: Courier New,Courier,monospace;">NULL</span> if the extension is not supported. In that case, call the <span style="font-family: Courier New,Courier,monospace;">glFinish()</span> function, because the lock is not used.</p>
</li>

<li>Waiting on a fence
<p>The main thread now waits on this sync before drawing the texture on the screen. This yields a better performance than the <span style="font-family: Courier New,Courier,monospace;">glFinish()</span> function:</p>
<pre class="prettyprint">
// Wait for the render thread to complete rendering, if fence_sync is available  
if (target-&gt;sync)
{
&nbsp;&nbsp;&nbsp;evasglClientWaitSync(evgl, target-&gt;sync,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVAS_GL_SYNC_FLUSH_COMMANDS_BIT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVAS_GL_FOREVER);
&nbsp;&nbsp;&nbsp;evasglDestroySync(evgl, target-&gt;sync);
&nbsp;&nbsp;&nbsp;target-&gt;sync = EVAS_GL_NO_SYNC;
}

// Draw the texture on the screen  
</pre>


<p>Instead of passing <span style="font-family: Courier New,Courier,monospace;">EVAS_GL_FOREVER</span>, it is also possible to pass a timeout, so that the wait function never dead locks.</p>
</li>
</ul>
</li>
</ol>

<h3>Using EvasGL Images</h3>
		
<p>You can deliver the result of rendering from one OpenGL ES thread to another to use EvasGLImage objects. This requires an underlying EGL image extension (or equivalent if the backend is not EGL), and might not be fully supported on all platforms.</p>
<ol>
<li>
<p>To check for the presence of this extension, check the function pointers in Evas_GL_API:</p>
<pre class="prettyprint">
if (evasglCreateImageForContext)
{
&nbsp;&nbsp;&nbsp;// Create an image
}
</pre>
</li>

<li>
<p>Create the image with a texture ID or a renderbuffer ID. Since EFL abstracts the underlying display system, such as X or Wayland, a portable application limits itself to the most portable options, such as pure OpenGL ES objects:</p>
<pre class="prettyprint">
if (evasglCreateImageForContext)
{
&nbsp;&nbsp;&nbsp;// Create an image
&nbsp;&nbsp;&nbsp;evasglCreateImageForContext(evgl, ctx, EVAS_GL_TEXTURE_2D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)(intptr_t)texid, NULL);
}
</pre>
<p>Tizen also provides specific buffers created with TBM that can be passed to this function. Unfortunately the image extension is more device-dependent, and may not even work in the Tizen emulator.</p>
</li>
</ol>			
			

<h2 id="ext" name="ext">Using OpenGL ES Extensions</h2>

<p>EvasGL, offering an abstraction layer above OpenGL ES, provides an easy mechanism to check for support and use OpenGL ES extensions:</p>

<ol>
	<li>Detect support for an extension.
	<p>In OpenGL ES, you must always call the <span style="font-family: Courier New,Courier,monospace;">glGetString(GL_EXTENSIONS)</span> function. Make sure that the extension name is present in the list and then dynamically find the function pointer using the <span style="font-family: Courier New,Courier,monospace;">dlsym()</span>, <span style="font-family: Courier New,Courier,monospace;">eglGetProcAddress()</span>, or <span style="font-family: Courier New,Courier,monospace;">glXGetProcAddress()</span> function.</p>

	<p>Since EvasGL exposes only a structure with the function pointers set to internal wrappers or the proper OpenGL ES implementation library, it can also expose all the detected extensions simply by setting their function pointers.</p>

	<p>To detect support for the <span style="font-family: Courier New,Courier,monospace;">GL_OES_get_program_binary</span> extension or equivalent, and to get the function pointer associated:</p>

	<pre class="prettyprint">
Evas_GL_API *gl = elm_glview_api_get(glview);

// Check for support for the Program Binary OES extension
if (gl-&gt;glGetProgramBinaryOES)
{
&nbsp;&nbsp;&nbsp;printf(&quot;Program binary extension is supported.\n&quot;);
}
</pre>
	</li>
	<li>Call an extension.
	<p>Calling an extension is similar to calling a function:</p>

	<pre class="prettyprint">
if (gl-&gt;glGetProgramBinaryOES)
{
&nbsp;&nbsp;&nbsp;char buf[4096];
&nbsp;&nbsp;&nbsp;size_t len;
&nbsp;&nbsp;&nbsp;Glenum fmt;
&nbsp;&nbsp;&nbsp;gl-&gt;glGetProgramBinaryOES(prgid, sizeof(buf), &amp;len, &amp;fmt, buf);
}
</pre>
	</li>
</ol>

<h2 id="evas_ext" name="evas_ext">Using EvasGL Extensions</h2>

<p>EvasGL is not only an abstraction layer on top of OpenGL ES, but also on top of EGL and GLX. As such, EvasGL tries to imitate EGL in a platform-independent manner, and exposes the underlying platform extensions when it can.</p>

<p>Image and sync support are the most commonly used EvasGL extensions. Both can be used for multi-thread rendering, but EvasGL images can also be used to share images between contexts.</p>

<h3>EvasGLImage</h3>

<p>There are 2 versions of the <span style="font-family: Courier New,Courier,monospace;">evasglCreateImage</span> function, out of which extra <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Context</span> is taken as an argument. It is recommended to call <span style="font-family: Courier New,Courier,monospace;">evasglCreateImageForContext</span> if you are dealing with multiple contexts, otherwise calling the <span style="font-family: Courier New,Courier,monospace;">evasglCreateImage</span> function is sufficient.</p>

<p>The code below is just an example.</p>

<ol>
	<li>Check for support.
	<p>Before using this extension, check whether it is supported:</p>

	<pre class="prettyprint">
if (gl-&gt;evasglCreateImageForContext &amp;&amp; gl-&gt;evasglDestroyImage)
{
&nbsp;&nbsp;&nbsp;// Good...
}
</pre>
	</li>
	<li>Create an image.
	<p>Create a render buffer and bind it to an EvasGL image:</p>

	<pre class="prettyprint">
const int width = 64, height = 64;
GLuint fbo, color_rb;
EvasGLImage *image;
Evas_GL *evgl;
Evas_GL_Context *ctx;

gl-&gt;GenFramebuffers(1, &amp;fbo);
gl-&gt;glBindFramebuffer(GL_FRAMEBUFFER_EXT, fbo);
gl-&gt;glGenRenderbuffers(1, &amp;color_rb);
gl-&gt;glBindRenderbuffer(GL_RENDERBUFFER_EXT, color_rb);
gl-&gt;glRenderbufferStorage(GL_RENDERBUFFER_EXT, GL_RGBA, width, height);
gl-&gt;glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_COLOR_ATTACHMENT0_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_RENDERBUFFER_EXT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color_rb);

evgl = elm_glview_evas_gl_get(glview);
ctx = evas_gl_current_context_get(evgl);
image = gl-&gt;evasglCreateImageForContext(evgl, ctx, EVAS_GL_TEXTURE_2D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)(intptr_t) color_rb, NULL);
</pre>

	<p>The EvasGL image is now created and available for use from another context.</p>
	</li>
	<li>Use an image.
	<p>To draw something in the texture and render that texture to the screen. To skip the draw function:</p>

	<pre class="prettyprint">
gl-&gt;glBindFramebuffer(GL_FRAMEBUFFER_EXT, fbo);
draw_scene(glview);</pre>

	<p>You can also bind the image to a texture for display on the back buffer:</p>

	<pre class="prettyprint">
GLuint tex;

gl-&gt;glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
gl-&gt;glGenTextures(1, &amp;tex);
gl-&gt;glBindTexture(GL_TEXTURE_2D, tex);
gl-&gt;glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);
And do the actual draw operation (draw the contents of the texture on screen):
static const GLint verts[12] = { -5, -6, -10,  5, -6, -10,  -5, 4, 10,  5, 4, 10 };
static const GLint tex_coords[8] = { 0, 0,  1, 0,  0, 1,  1, 1 };

gl-&gt;glClearColor(0, 0, 0, 0);
gl-&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
gl-&gt;glEnable(GL_TEXTURE_2D);
gl-&gt;glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
gl-&gt;glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_REPEAT);
gl-&gt;glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
gl-&gt;glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

gl-&gt;glEnableClientState(GL_VERTEX_ARRAY);
gl-&gt;glEnableClientState(GL_TEXTURE_COORD_ARRAY);
gl-&gt;glVertexPointer(3, GL_INT, 0, verts);
gl-&gt;glTexCoordPointer(2, GL_INT, 0, tex_coords);

gl-&gt;glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

gl-&gt;glDisableClientState(GL_VERTEX_ARRAY);
gl-&gt;glDisableClientState(GL_COLOR_ARRAY);
gl-&gt;glDisable(GL_TEXTURE_2D);
</pre>

	<p>The image content can be shared between different contexts.</p>
	</li>
	<li>Destroy an image.
	<p>After releasing all the associated resources, such as FBO and textures, release the image object itself:</p>

	<pre class="prettyprint">
gl-&gt;evasglDestroyImage(image);</pre>
	</li>
</ol>

<h3>Sync</h3>

<p>Another commonly used extension is the fence sync extension along with the reusable sync and wait sync. This allows creating a semaphore-style object that is released as soon as all the previous render operations have been completed.</p>

<p>This guide does not explain the details of these extensions, as they should behave in a similar way to their EGL implementations.</p>

<p>As usual with extensions, check the support:</p>

<pre class="prettyprint">
if (gl-&gt;evasglCreateSync)
  // fence_sync must be supported
</pre>

<h2 id="direct" name="direct">Using Direct Rendering</h2>

<p>To enhance rendering performance, the Direct Rendering option is supported.</p>

<h3>GLView</h3>

<pre class="prettyprint">
elm_config_accel_preference_set(&quot;opengl:depth24:stencil8:msaa_high&quot;);
Evas_Object *win = elm_win_util_standard_add(&quot;sample&quot;, &quot;sample&quot;);

Evas_Object *glview = elm_glview_add(win);
elm_glview_mode_set(glview, ELM_GLVIEW_DEPTH_24 | ELM_GLVIEW_STENCIL_8 | ELM_GLVIEW_MULTISAMPLE_HIGH);
</pre>

<p>In GLView, the <span style="font-family: Courier New,Courier,monospace;">ELM_GLVIEW_DIRECT</span> option is one of GLView mode&#39;s enums and the option can be enabled using the <span style="font-family: Courier New,Courier,monospace;">elm_glview_mode_set()</span> function.</p>

<p>To use the Direct Rendering mode, set the same option values (depth, stencil, and MSAA) to a rendering engine and a GLView object. You can set the option values to a rendering engine using the <span style="font-family: Courier New,Courier,monospace">elm_config_accel_preference_set()</span> function and to a GLView object using the <span style="font-family: Courier New,Courier,monospace">elm_glview_mode_set()</span> function. If the GLView object option values are bigger or higher than the rendering engine&#39;s, the Direct Rendering mode is disabled.</p>

<h3>EvasGL</h3>

<pre class="prettyprint">
elm_config_accel_preference_set(&quot;opengl:depth24:stencil8:msaa_high&quot;);
Evas_Object *win = elm_win_util_standard_add(&quot;sample&quot;, &quot;sample&quot;);

Evas_GL_Config *cfg = evas_gl_config_new();
cfg = evas_gl_config_new();
 
cfg-&gt;color_format = EVAS_GL_RGB_888;
cfg-&gt;depth_bits = EVAS_GL_DEPTH_BIT_24;
cfg-&gt;stencil_bits = EVAS_GL_STENCIL_BIT_8;
cfg-&gt;options_bits = EVAS_GL_OPTIONS_DIRECT;
cfg-&gt;multisample_bits = EVAS_GL_MULTISAMPLE_HIGH;
</pre>

<p>In EvasGL, the <span style="font-family: Courier New,Courier,monospace;">EVAS_GL_OPTIONS_DIRECT</span> is one of EvasGL&#39;s config options and the option can be enabled by setting the <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Config</span> option. To use the Direct Rendering mode, set the same option values (depth, stencil, and MSAA) to a rendering engine and an <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Config</span> object. You can set the option values to a rendering engine using the <span style="font-family: Courier New,Courier,monospace">elm_config_accel_preference_set()</span> function. If the <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Config</span> object option values are bigger or higher than the rendering engine&#39;s, the Direct Rendering mode is disabled.</p>

  <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">If direct rendering is enabled, EvasGL will render directly to the back buffer of the window. Otherwise, EvasGL will render to the off screen buffer, then composited to the back buffer of the window.

<p>Although direct rendering is enabled, EvasGL will not always render directly to the back buffer. Here are some conditions that will disable direct rendering and force a fallback to indirect rendering in a frame buffer.</p>

<ol>
	<li>If the object&#39;s color is not 255,255,255,255.</li>
	<li>If the object has an Evas map.</li>
	<li>If the object size is different from the viewport, (<span style="font-family: Courier New,Courier,monospace;">RESIZE_POLICY_SCALE</span>).</li>
	<li>If the window is rotated and <span style="font-family: Courier New,Courier,monospace;">CLIENT_SIDE_ROTATION</span> is not set.</li>
	<li>If the GLView policy is set to <span style="font-family: Courier New,Courier,monospace;">ALWAYS</span> render or the EvasGL does not use pixel getter callback.</li>
</ol></td> 
    </tr> 
   </tbody> 
  </table> 

    <table class="note"> 
   <tbody> 
    <tr> 
     <th class="note">Caution</th> 
    </tr> 
    <tr> 
     <td class="note">In the render callback function, call only GL functions.
<p>In case the GL functions are called outside the render callback function, you must call the <span style="font-family: Courier New,Courier,monospace;">evas_gl_make_current()</span> function before the GL function calls. However, this results in a performance degradation due to context switching, and only works if the target surface is not an <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Surface</span> with Direct Rendering enabled.</p>	 

<p>If the target buffer is an <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Surface</span> with Direct Rendering enabled, all GL functions must be called from the render callback function only. All other operations can break the rendering order and the unexpected rendering will occur.</p></td> 
    </tr> 
   </tbody> 
  </table> 

  <h2 id="client" name="client">Using Client-side Rotation</h2>


<p>The Client Side Rotation is a special value that indicates to EFL that the application will handle the view rotation when the device is rotated. This is needed only when the application requests Direct Rendering.</p>

<p>If the window is rotated and the Direct Rendering flag is set, Client Side Rotation can be used to avoid falling back to a frame buffer.</p>

<h3>GLView</h3>

<pre class="prettyprint">
Evas_Object *gl;
gl = elm_glview_add(win);
 
elm_glview_mode_set(gl, ELM_GLVIEW_DEPTH | ELM_GLVIEW_DIRECT | ELM_GLVIEW_CLIENT_SIDE_ROTATION);</pre>

<p>In GLView, the <span style="font-family: Courier New,Courier,monospace;">ELM_GLVIEW_CLIENT_SIDE_ROTATION</span> option is one of GLView mode&#39;s enums and the option can be enabled by using the <span style="font-family: Courier New,Courier,monospace;">elm_glview_mode_set()</span> function. This option is needed only when Direct Rendering is enabled.</p>

<h3>EvasGL</h3>

<pre class="prettyprint">
Evas_GL_Config *cfg;
cfg = evas_gl_config_new();
 
cfg-&gt;options_bits = EVAS_GL_OPTIONS_DIRECT | EVAS_GL_OPTIONS_CLIENT_SIDE_ROTATION;</pre>

<p>In EvasGL, the <span style="font-family: Courier New,Courier,monospace;">EVAS_GL_OPTIONS_CLIENT_SIDE_ROTATION</span> is one of EvasGL&#39;s config options and this option can be enabled by setting the <span style="font-family: Courier New,Courier,monospace;">Evas_GL_Config</span> option.</p>

<p>Get the current rotation value:</p>

<pre class="prettyprint">
static void _draw_gl(Evas_Object *obj) 
{
&nbsp;&nbsp;&nbsp;int w, h, rotation;
&nbsp;&nbsp;&nbsp;elm_glview_size_get(obj, &amp;w, &amp;h);
&nbsp;&nbsp;&nbsp;rotation = evas_gl_rotation_get(ad-&gt;evasgl);

&nbsp;&nbsp;&nbsp;if (rotation % 180)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Adjust gl size
&nbsp;&nbsp;&nbsp;} 
}</pre>

<p>To get the current rotation of the view, in degrees, call the <span style="font-family: Courier New,Courier,monospace;">evas_gl_rotation_get()</span> in order to properly handle the current rotation of the view. It will always return 0 unless the option <span style="font-family: Courier New,Courier,monospace;">EVAS_GL_OPTIONS_CLIENT_SIDE_ROTATION</span> has been set. Indeed, in case of Direct Rendering to the back buffer, the client application is responsible for properly rotating its view. This can generally be done by applying a rotation to a view matrix.</p>			
		

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>Media Demuxer: Parsing Multiplexed Media Streams</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
	</div>
	
	<div id="toc_border"><div id="toc">
	<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#prerequisites">Prerequisites</a></li>
			<li><a href="#prepare">Preparing the Media Demuxer</a></li>
			<li><a href="#manage">Managing the Media Demuxer</a></li>
			</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.guides/html/native/multimedia/media_demuxer_n.htm">Media Demuxer Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">Media Demuxer API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">Media Demuxer API for Wearable Native</a></li>
			</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>Media Demuxer: Parsing Multiplexed Media Streams</h1> 

<p>This tutorial demonstrates how you can demux multiplexed media files.</p>

<h2>Warm-up</h2>

<p>Become familiar with the Media Demuxer API basics by learning about:</p>
<ul>
	<li><a href="#prerequisites">Prerequisites</a>
	<p>Prepare your application to use the media demuxer functionality.</p></li>
	<li><a href="#prepare">Preparing the Media Demuxer</a>
	<p>Initialize and configure the media demuxer for use.</p></li>
	<li><a href="#manage">Managing the Media Demuxer</a>
	<p>Create threads to use the media demuxer.</p></li>
</ul> 


<h2 id="prerequisites">Prerequisites</h2>

<p>To use the functions and data types of the Media Demuxer API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIADEMUXER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;mediademuxer.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;mediademuxer.h&gt;

#include &lt;media_format.h&gt;
#include &lt;media_packet.h&gt;
</pre>
<p>You also need the <span style="font-family: Courier New,Courier,monospace">&lt;media_format.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;media_packet.h&gt;</span> header files to identify and manage individual tracks within the media file.</p>

<h2 id="prepare">Preparing the Media Demuxer</h2>

<p>To prepare the media demuxer:</p>
<ol>
<li>Define a handle for the media demuxer and pass it to the <span style="font-family: Courier New,Courier,monospace">mediademuxer_create()</span> function. The same handle must be passed to the rest of the media demuxer functions.
<pre class="prettyprint">
mediademuxer_h *demuxer;
ret = mediademuxer_create(&amp;demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>

<li>If the handle is created normally, set the input data source by passing the path to the <span style="font-family: Courier New,Courier,monospace">mediademuxer_set_data_source()</span> function:
<pre class="prettyprint">
if (mediademuxer_set_data_source(demuxer, path)!= MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_set_data_source API failed\n&quot;);
</pre>
</li>

<li>Call the <span style="font-family: Courier New,Courier,monospace">mediademuxer_prepare()</span> function to move the media demuxer into the ready state:
<pre class="prettyprint">
if (mediademuxer_prepare(demuxer) != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_prepare API failed\n&quot;);
</pre>
</li>

<li>Once the media demuxer is in the ready state, get the total number of individual elementary streams present: 
<pre class="prettyprint">
if (mediademuxer_get_track_count(demuxer, &amp;num_tracks) != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;mediademuxer_get_track_count API failed\n&quot;);
</pre>
</li>

<li>Select all the tracks to be extracted:
<pre class="prettyprint">
for (track = 0; track &lt; num_tracks; track++) {
&nbsp;&nbsp;&nbsp;&nbsp;if (mediademuxer_select_track(demuxer, track))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;mediademuxer_select track %d failed\n&quot;, track);
}
</pre>
</li>

<li>Start the media demuxer:
<pre class="prettyprint">
if (mediademuxer_start(demuxer))
&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;mediademuxer_start failed\n&quot;);
</pre>
</li>

<li>Once the total track counts are known, the media format for each track must be identified. Before calling the <span style="font-family: Courier New,Courier,monospace">media_format_create()</span> function, you must define and create a valid <span style="font-family: Courier New,Courier,monospace">media_format_h</span> handle (the <span style="font-family: Courier New,Courier,monospace">format</span> parameter in the given function).
<p>The following example retrieves the media format for each track:</p>
<pre class="prettyprint">
media_format_h *g_media_format = NULL;
int track;
g_media_format = (media_format_h *)g_malloc(sizeof(media_format_h) * num_tracks);
for (track = 0; track &lt; num_tracks; track++) {
&nbsp;&nbsp;&nbsp;&nbsp;ret = media_format_create(&amp;g_media_format[track]);
&nbsp;&nbsp;&nbsp;&nbsp;if (ret == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;g_media_format[%d] is created successfully! \n&quot;, track);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = mediademuxer_get_track_info(demuxer, track, g_media_format[track]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_get_video_info(g_media_format[track], &amp;mime, &amp;w, &amp;h, NULL, NULL) == MEDIA_FORMAT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_get_video_info is success!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vid_track = track;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (media_format_get_audio_info(g_media_format[track], &amp;mime, &amp;channel, &amp;samplerate, NULL, NULL) == MEDIA_FORMAT_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_get_audio_info is success!\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aud_track = track;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Not supported yet&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Error while getting mediademuxer_get_track_info\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Error while creating media_format_create\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre>
</li>
</ol>



<h2 id="manage" name="manage">Managing the Media Demuxer</h2> 

<p>To manage the media demuxer process:</p>
<ol>
<li>You can create individual threads to manage each track simultaneously, but it is not mandatory. The following sample code explains how to extract the video track in a new thread:
<pre class="prettyprint">
int
test_mediademuxer_read_sample()
{
&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread[1];
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_t attr;
&nbsp;&nbsp;&nbsp;&nbsp;/* Initialize and set thread detached attribute */
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_init(&amp;attr);
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
&nbsp;&nbsp;&nbsp;&nbsp;if (vid_track != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;In main: creating thread for video\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;thread[0], &amp;attr, _fetch_video_data, NULL);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_destroy(&amp;attr);

&nbsp;&nbsp;&nbsp;&nbsp;return 0;
}

void*
_fetch_video_data(void *ptr)
{
&nbsp;&nbsp;&nbsp;&nbsp;int *status = (int *)g_malloc(sizeof(int) * 1);
&nbsp;&nbsp;&nbsp;&nbsp;*status = -1;
&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Video Data function\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;int count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;media_packet_h vidbuf;
&nbsp;&nbsp;&nbsp;&nbsp;media_format_h vidfmt;
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_create(&amp;vidfmt)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_create failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_mime(vidfmt, MEDIA_FORMAT_H264_SP)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_mime failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_width(vidfmt, 760)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_width failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_format_set_video_height(vidfmt, 480)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_format_set_video_height failed\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (media_packet_create_alloc(vidfmt, NULL, NULL, &amp;vidbuf)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_packet_create_alloc failed\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while (1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int EOS = mediademuxer_read_sample(demuxer, vid_track, &amp;vidbuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (EOS == MD_EOS || EOS != MD_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_exit(NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;Read::[%d] video sample\n&quot;, count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the media packet and release the packet here */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;media_packet_destroy(vidbuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Create a new packet for getting next frame of data */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (media_packet_create_alloc(vidfmt, NULL, NULL, &amp;vidbuf)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g_print(&quot;media_packet_create_alloc failed\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;*status = 0;

&nbsp;&nbsp;&nbsp;&nbsp;return (void *)status;
}
</pre>
</li>

<li>After you have finished work with the media demuxer, reset the media demuxer and destroy the handle by using the <span style="font-family: Courier New,Courier,monospace">mediademuxer_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">mediademuxer_destroy()</span> functions. 
<p>The media demuxer state changes to <span style="font-family: Courier New,Courier,monospace">MEDIADEMUXER_STATE_NONE</span>.</p>
<pre class="prettyprint">
ret = mediademuxer_unprepare(demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
ret = mediademuxer_destroy(demuxer);
if (ret != MEDIADEMUXER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;return false;
</pre>
</li>
</ol>
    
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>


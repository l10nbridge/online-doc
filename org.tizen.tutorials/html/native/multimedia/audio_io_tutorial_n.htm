<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
    <title>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
        <p class="toc-title">Content</p>
        <ul class="toc">
            <li><a href="#prerequisites">Prerequisites</a></li>
            <li><a href="#simple">Managing Synchronous Recording and Playback</a></li>
            <li><a href="#async">Managing Asynchronous Recording and Playback</a></li>
        </ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/multimedia/audio_io_n.htm">Audio I/O Guide</a></li>
            <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Mobile Native</a></li>
            <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Mobile Native</a></li>
            <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Wearable Native</a></li>
            <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">

<h1>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</h1>

<p>This tutorial demonstrates how you can control audio input and output to record and play audio.</p>

<h2>Warm-up</h2>

<p>Become familiar with the Audio I/O and Sound Manager API basics by learning about:</p>

<ul>
    <li><a href="#prerequisites">Prerequisites</a>
		<p>Prepare your application to use the audio input and output functionalities.</p></li>
    <li><a href="#simple">Managing Synchronous Recording and Playback</a>
        <p>Using a synchronous API, record an audio sample from the audio input device, play the recorded audio sample through the audio output device, and modify the volume in the recorded audio sample.</p>
    </li>
    <li><a href="#async">Managing Asynchronous Recording and Playback</a>
        <p>Using an asynchronous API, record an audio sample from the audio input device, and play the recorded audio sample through the audio output device.</p>
    </li>
</ul>

<h2 id="prerequisites">Prerequisites</h2>

<p>To enable your application to use the audio input and output functionalities:</p>
<ol><li>
<p>To use the functions and data types of the Audio I/O (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">wearable</a> applications) and Sound Manager (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications) APIs, include the <span style="font-family: Courier New,Courier,monospace">&lt;audio_io.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files in your application:</p>
<pre class="prettyprint">
#include &lt;audio_io.h&gt;
#include &lt;sound_manager.h&gt;
</pre>
</li>

<li><p>To initialize the audio input and output devices, use the <span style="font-family: Courier New,Courier,monospace">audio_in_create()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> functions:</p>

<pre class="prettyprint">
/* Define the sample rate for recording audio */
#define SAMPLE_RATE 44100

/* Declare the variable used for checking function results */
audio_io_error_e error_code;

/* Initialize the audio input device */
audio_in_h input;

error_code = audio_in_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, &amp;input);

/* Initialize the audio output device */
audio_out_h output;

error_code = audio_out_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, SOUND_TYPE_SYSTEM, &amp;output);
</pre>
<p>The audio input and output devices support the channel types defined in the <span style="font-family: Courier New,Courier,monospace">audio_channel_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">wearable</a> applications), and the sample types defined in the <span style="font-family: Courier New,Courier,monospace">audio_sample_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">wearable</a> applications). For playing the recorded audio, use the same channel and sample type in both audio devices.</p>

<p>The sound types are defined in the <span style="font-family: Courier New,Courier,monospace">sound_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__VOLUME__MODULE.html#gab0b52eeab59765b94c7a751097738a0b">wearable</a> applications). You can select the sound type according to the audio sample type.</p></li></ol>

<h2 id="simple" name="simple">Managing Synchronous Recording and Playback</h2>

<p>Recording and playing audio synchronously involves:</p>

<ol>
    <li><p><a href="#set">Creating a local buffer for storing the audio data</a></p></li>
    <li><p><a href="#record">Recording and playing an audio sample</a></p></li>
</ol>

<p>You can also <a href="#modify">modify the volume of the audio sample</a>.</p>

<h3 id="set" name="set">Creating a Buffer for Audio Data</h3>

<p>Before starting the synchronous recording process, you need to create a local buffer for storing the audio data. To create the buffer, you need to know its required size based on the expected duration of the recording, since the recording process ends when the buffer is full.</p>

<p>To determine the required buffer size, use one of the following options:</p>

<ul>

<li><p>To determine the required buffer size based on what is recommended by the Audio I/O API:</p>

<ol><li>
<p>Retrieve the recommended buffer size using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function. The function retrieves the buffer size recommended by the sound server (such as PulseAudio).</p>

<pre class="prettyprint">
int buffer_size;

error_code = audio_in_get_buffer_size(input, &amp;buffer_size);
</pre>

<p>If no error occurs, the <span style="font-family: Courier New,Courier,monospace">buffer_size</span> parameter returns the preferred size of the buffer that must be allocated (in bytes), based on the specified audio parameters.</p>
 
<p>The recommended buffer size depends on the device. The size can be different for TV, mobile, and wearable devices.</p>
</li>

<li>

<p>Set the buffer size to correspond to the desired duration of the recording.</p>

<p>For example, for the device used in creating this tutorial, the <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function returns the recommended buffer size for 100 milliseconds of recording time. To determine the actual, required buffer size in seconds, multiply the recommended buffer size by 10 (to increase the duration from 100 milliseconds to 1 second) and by the number of seconds the recording lasts (here, 5 seconds):</p>

<pre class="prettyprint">
#define RECORDING_SEC 5

buffer_size *= 10 * RECORDING_SEC;
</pre>

</li>

</ol></li>
<li>
<p>To explicitly calculate the required buffer size:</p>

<ol>

<li>
<p>Retrieve the audio channel type using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_channel()</span> function:</p>

<pre class="prettyprint">
audio_channel_e channel;

error_code = audio_in_get_channel(input, &amp;channel);
</pre>
</li>

<li>
<p>Retrieve the audio sample type using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_sample_type()</span> function:</p>

<pre class="prettyprint">
audio_sample_type_e sample_type;

error_code = audio_in_get_sample_type(input, &amp;sample_type);
</pre>
</li>

<li>
<p>Calculate the buffer size based on the retrieved information:</p>

<pre class="prettyprint">
int buffer_size = SAMPLE_RATE * (channel == AUDIO_CHANNEL_STEREO ? 2 : 1) * (sample_type == AUDIO_SAMPLE_TYPE_S16_LE ? 2 : 1);
</pre>
</li>

<li>
<p>Multiply the buffer size by the number of seconds the recording lasts:</p>

<pre class="prettyprint">
buffer_size *= RECORDING_SEC;
</pre>
</li>
</ol></li></ul>

<p>After determining the required buffer size, allocate the memory to the buffer using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function:</p>

<pre class="prettyprint">
void *buffer = malloc(buffer_size);
</pre>

<p>You have created the local buffer for storing the audio data. You can now start the synchronous recording process.</p>

<h3 id="record" name="record">Recording and Playing an Audio Sample</h3>

<p>The synchronous recording and playback processes block other processes running in the same thread. Launching a recording or playback process from the main thread of the application can make the application unresponsive. To prevent this, launch the recording and playback processes from their own thread. For example, in this use case, the recording and playback processes are run inside the <span style="font-family: Courier New,Courier,monospace">synchronous_playback()</span> function, which is executed in a separate thread using the <span style="font-family: Courier New,Courier,monospace">ecore_thread_run()</span> function:</p>

<pre class="prettyprint">
ecore_thread_run(synchronous_playback, NULL, NULL, NULL);
</pre>

<p>To record and play audio:</p>

<ol><li>
<p>Prepare the audio input device and start the recording process using the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio input device (starts the hardware recording process) */
error_code = audio_in_prepare(input);
</pre></li>

<p>The hardware device starts buffering the audio recorded by the audio input device. The audio data is buffered to the internal input buffer.</p>

<li><p>Copy the audio data from the internal input buffer to the local buffer using the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function:</p>

<pre class="prettyprint">
/* Copy the audio data from the internal input buffer to the local buffer */
int bytes_number = audio_in_read(input, buffer, buffer_size);
</pre>

<p>The returned value represents the number of bytes read from the internal input buffer. A negative value represents an error code.</p>

<p>The <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function can behave in the following ways:</p>
<ul>
<li>If the function is called immediately after preparing the audio input device, the function blocks the thread it is launched from until the local buffer is full.</li>
<li>If the function is called with a delay long enough to allow the internal input buffer to store more audio data than the local buffer can hold, the function executes immediately without blocking its thread.</li></ul>

<p>The <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function fills the local buffer by copying audio data from the internal input buffer. If the internal input buffer does not contain enough data to fill up the local buffer, the function waits until enough data is recorded. If you want to start recording audio immediately after clicking a button, call the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function just before the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function inside the same button callback function. If you prepare the audio input device earlier in a separate function and only run the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function inside the button callback function, the local buffer is filled with audio data recorded before the button is clicked.</p>
</li>

<li><p>Stop the recording process using the <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware recording process */
error_code = audio_in_unprepare(input);
</pre></li>

<li><p>After you have finished working with the audio input device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_in_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio input device */
error_code = audio_in_destroy(input);
</pre></li>

<li><p>Prepare the audio output device and start the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio output device (starts the hardware playback process) */
error_code = audio_out_prepare(output);
</pre>

<p>The hardware device prepares its internal output buffer for playback. Playback begins when the internal output buffer starts receiving audio data.</p>

</li>
<li><p>To start playing the recorded audio, copy the audio data from the local buffer to the internal output buffer using the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function:</p>

<pre class="prettyprint">
/* Copy the audio data from the local buffer to the internal output buffer */
int bytes_number = audio_out_write(output, buffer, buffer_size);
</pre>
<p>The returned value represents the number of bytes written to the internal output buffer. A negative value represents an error code.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function behaves in a similar manner to the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function.</p>
</li>

<li><p>After all data has been copied to the internal output buffer, release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function:</p>
<pre class="prettyprint">
/* Release the memory allocated to the local buffer */
free(buffer);
</pre></li>

<li><p>Stop the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware playback process */
error_code = audio_out_unprepare(output);
</pre></li>

<li><p>After you have finished working with the audio output device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio output device */
error_code = audio_out_destroy(output);
</pre></li>
</ol>

<h3 id="modify" name="modify">Modifying the Audio Sample Volume</h3>

<table class="note">
 <tbody>
  <tr>
  <th class="note">Note</th>
  </tr>
  <tr>
   <td class="note">Modifying the volume only works if you have not emptied the local buffer or deinitialized the input audio device.</td>
  </tr>
 </tbody>
</table>

<p>To modify the volume of the audio sample stored in the local buffer:</p>

<pre class="prettyprint">
#define MIN_2BYTES_SIGNED (−32768)
#define MAX_2BYTES_SIGNED 32767

void
modify_sound()
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Retrieve the sample type of the input */
&nbsp;&nbsp;&nbsp;&nbsp;audio_sample_type_e sample_type;

&nbsp;&nbsp;&nbsp;&nbsp;int error_code = audio_in_get_sample_type(input, &amp;sample_type);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_get_sample_type() failed! Error code = %d&quot;, error_code);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *index = (uint8_t*)buffer;
&nbsp;&nbsp;&nbsp;&nbsp;while (index &lt; (((uint8_t*)buffer)+buffer_size)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AUDIO_SAMPLE_TYPE_S16_LE == sample_type) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the int16_t type, because it is 2 bytes long */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int16_t *value = (int16_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make the sample louder */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t tmp = (*value) * 8; /* Why not 8 times louder? (on dB scale even much louder) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; MAX_2BYTES_SIGNED)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = MAX_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &lt; MIN_2BYTES_SIGNED)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = MIN_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use the uint8_t type, because it is 1 byte long */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *value = (uint8_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Make the sample louder */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t tmp = (*value) * 8; /* Why not 8 times louder? (on dB scale even much louder) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; 255)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Go to the next sample */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index += sample_type == AUDIO_SAMPLE_TYPE_S16_LE ? 2 : 1;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Volume of the synchronous recording increased.&quot;);
}
</pre>

<p>In this example, the volume is significantly increased. You can also make other modifications to the audio sample playback.</p>

<h2 id="async" name="async">Managing Asynchronous Recording and Playback</h2>

<p>Recording and playing audio asynchronously involves:</p>

<ol>
    <li><p><a href="#async_rec">Starting asynchronous recording</a></p></li>
    <li><p><a href="#stop">Stopping asynchronous recording</a></p></li>
    <li><p><a href="#start">Starting asynchronous playback</a></p></li>
    <li><p><a href="#stop_async">Stopping asynchronous playback</a></p></li>
</ol>

<h3 id="async_rec" name="async_rec">Starting Asynchronous Recording</h3>

<p>The asynchronous recording process uses a callback function for storing the audio recorded by the audio input device. The callback function is invoked asynchronously for each chunk of recorded audio. In this use case, the audio data is stored in a file rather than a local buffer.</p>

<p>To start recording audio:</p>

<ol><li><p>Set the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_in_set_stream_cb()</span> function. Use this function before calling the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, because otherwise the callback function is never invoked.</p>

<pre class="prettyprint">
/* Set a callback function that is invoked asynchronously for each chunk of recorded audio */
error_code = audio_in_set_stream_cb(input, _audio_io_stream_read_cb, NULL);
</pre>
</li>

<li>
<p>Create and open the file for storing the audio data:</p>

<pre class="prettyprint">
#include &lt;storage.h&gt;

/* Prepare the file where the recorded audio data is stored */
char io_stream_w_path[200];
char *storage_path;
/* You can find the storage ID using the storage_foreach_device_supported() function */
int error = storage_get_directory(storage_id, STORAGE_DIRECTORY_SOUNDS, &amp;storage_path);
snprintf(io_stream_w_path, 200, &quot;%s/%s&quot;, storage_path, &quot;pcm_w.raw&quot;);
free(storage_path);

FILE* fp_w = fopen(io_stream_w_path, &quot;w&quot;);
if (!fp_w)
&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;fopen() function failed while opening %s file!&quot;, io_stream_w_path);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">storage_get_directory()</span> function of the Storage API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__SYSTEM__STORAGE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__SYSTEM__STORAGE__MODULE.html">wearable</a> applications) retrieves the storage path based on the storage ID. To retrieve the storage ID, use the <span style="font-family: Courier New,Courier,monospace">storage_foreach_device_supported()</span> function of the Storage API.</p>
</li>

<li>
<p>Prepare the audio input device and start the recording process using the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio input device (starts the hardware recording process) */
error_code = audio_in_prepare(input);
</pre>

<p>The hardware device starts buffering the audio recorded by the audio input device. The audio data is buffered to the internal input buffer. The callback function is invoked separately for each chunk of audio data.</p>
</li>

<li>
<p>To store the recorded audio data in the file (inside the callback function):</p>
<ol type="a">
<li>Retrieve a pointer to the internal input buffer and the number of recorded audio data bytes using the <span style="font-family: Courier New,Courier,monospace">audio_in_peek()</span> function.</li>
<li>Retrieve the recorded audio data from the internal input buffer and store it in the file using the <span style="font-family: Courier New,Courier,monospace">fwrite()</span> function.</li>
<li>Remove the recorded audio data, since it is no longer needed, from the internal input buffer using the <span style="font-family: Courier New,Courier,monospace">audio_in_drop()</span> function.</li>
</ol>

<pre class="prettyprint">
/* Callback invoked for each chunk of recorded audio */
void
_audio_io_stream_read_cb(audio_in_h handle, size_t nbytes, void *userdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;const void * buffer = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;if (nbytes &gt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Retrieve a pointer to the internal input buffer and the number of recorded audio data bytes */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int error_code = audio_in_peek(handle, &amp;buffer, &amp;nbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_peek() failed! Error code = %d&quot;, error_code);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Store the recorded audio data in the file */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite(buffer, sizeof(char), nbytes, fp_w);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Remove the recorded audio data from the internal input buffer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_code = audio_in_drop(handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_drop() failed! Error code = %d&quot;, error_code);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ol>

<h3 id="stop" name="stop">Stopping Asynchronous Recording</h3>

<p>To stop recording audio:</p>

<ol><li><p>Stop the recording process using the <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware recording process */
error_code = audio_in_unprepare(input);
</pre>
<p>The device no longer invokes the callback function.</p>
</li>
<li>
<p>If you no longer need asynchronous recording, or if you want to set the callback function separately for each asynchronous recording session, unset the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_in_unset_stream_cb()</span> function:</p>
<pre class="prettyprint">
/* Unset the callback function used for asynchronous recording */
error_code = audio_in_unset_stream_cb(input);
</pre>
</li>

<li><p>After you have finished working with the audio input device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_in_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio input device */
error_code = audio_in_destroy(input);
</pre></li>

<li><p>Close the file where the recorded audio is stored using the <span style="font-family: Courier New,Courier,monospace">fclose()</span> function:</p>

<pre class="prettyprint">
/* Close the file used for asynchronous recording */
error_code = fclose(fp_w);
fp_w = NULL;
</pre>
</li>

</ol>

<h3 id="start" name="start">Starting Asynchronous Playback</h3>

<p>The asynchronous playback process uses a callback function for playing the recorded audio. The callback function is invoked asynchronously for each chunk of recorded audio. In this use case, the audio data is read from a file rather than a local buffer.</p>

<p>To start playing the recorded audio:</p>

<ol><li>
<p>Set the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function:</p>

<pre class="prettyprint">
/* Set a callback function that is invoked asynchronously for each chunk of stored (recorded) audio */
error_code = audio_out_set_stream_cb(output, _audio_io_stream_write_cb, NULL);
</pre>
</li>
<li>
<p>Open the file where the audio data is stored:</p>

<pre class="prettyprint">
#include &lt;storage.h&gt;

/* Prepare the file where the recorded audio data is stored */
char io_stream_r_path[200];
char *storage_path;
/* You can find the storage ID using the storage_foreach_device_supported() function */
int error = storage_get_directory(storage_id, STORAGE_DIRECTORY_SOUNDS, &amp;storage_path);
snprintf(io_stream_r_path, 200, &quot;%s/%s&quot;, storage_path, &quot;pcm_w.raw&quot;);
free(storage_path);

FILE* fp_r = fopen(io_stream_r_path, &quot;r&quot;);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace">storage_get_directory()</span> function of the Storage API retrieves the storage path based on the storage ID. To retrieve the storage ID, use the <span style="font-family: Courier New,Courier,monospace">storage_foreach_device_supported()</span> function of the Storage API.</p>
</li>

<li>
<p>Prepare the audio output device and start the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function:</p>

<pre class="prettyprint">
/* Prepare the audio output device (starts the hardware playback process) */
error_code = audio_out_prepare(output);
</pre>
<p>The hardware device prepares its internal output buffer for playback.</p>
</li>
<li>

<p>To play the audio from the file (inside the callback function):</p>
<ol type="a">

<li><p>Allocate a local buffer for the audio data using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function. The function returns a pointer to the buffer. Reset the buffer by filling it with zeros using the <span style="font-family: Courier New,Courier,monospace">memset()</span> function.</p></li>

<li><p>Read audio data from the file and store the data in the local buffer using the <span style="font-family: Courier New,Courier,monospace">fread()</span> function.</p></li>

<li><p>Copy the audio data from the local buffer to the internal output buffer using the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function. Playback begins when the internal output buffer starts receiving the audio data.</p></li>

<li><p>Release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function.</p></li>

</ol>

<pre class="prettyprint">
/* Callback invoked for each chunk of stored (recorded) audio */
void
_audio_io_stream_write_cb(audio_out_h handle, size_t nbytes, void *userdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;char * buffer = NULL;

&nbsp;&nbsp;&nbsp;&nbsp;if (nbytes &gt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Allocate and reset a local buffer for reading the audio data from the file */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = malloc(nbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(buffer, 0, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Read audio data from the file and store it in the local buffer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fread(buffer, sizeof(char), nbytes, fp_r);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Copy the audio data from the local buffer to the internal output buffer (starts playback) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int data_size = audio_out_write(handle, buffer, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data_size &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_out_write() failed! Error code = %d&quot;, data_size);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Release the memory allocated to the local buffer */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre></li></ol>

<h3 id="stop_async" name="stop_async">Stopping Asynchronous Playback</h3>

<p>To stop playing the recorded audio:</p>

<ol><li><p>Stop the playback process using the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>

<pre class="prettyprint">
/* Stop the hardware playback process */
error_code = audio_out_unprepare(output);
</pre>
<p>The device no longer invokes the callback function.</p>
</li>
<li>
<p>If you no longer need asynchronous playback, or if you want to set the callback function separately for each asynchronous playback session, unset the callback function using the <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> function:</p>

<pre class="prettyprint">
/* Unset the callback function used for asynchronous playback */
error_code = audio_out_unset_stream_cb(output);
</pre>
</li>

<li><p>After you have finished working with the audio output device, deinitialize it using the <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> function:</p>
<pre class="prettyprint">
/* Deinitialize the audio output device */
error_code = audio_out_destroy(output);
</pre></li>

<li>
<p>Close the file where the recorded audio is stored using the <span style="font-family: Courier New,Courier,monospace">fclose()</span> function:</p>
<pre class="prettyprint">
/* Close the file used for asynchronous playback */
error_code = fclose(fp_r);
fp_r = NULL;
</pre>
</li>
</ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
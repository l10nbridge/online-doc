<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#init">Initializing the Audio Devices</a></li>
			<li><a href="#simple">Managing Simple Recording and Playback</a></li>
			<li><a href="#async">Managing Asynchronous Recording and Playback</a></li>
			<li><a href="#release">Releasing Resources</a></li>
		</ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/multimedia/audio_io_n.htm">Audio I/O Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</h1>

  
<p>This tutorial demonstrates how you can control audio input and output to record, and play an audio sample.</p>

<h2>Warm-up</h2>

<p>Become familiar with the Audio I/O and Sound Manager API basics by learning about:</p>

<ul>
 <li><a href="#init">Initializing the Audio Devices</a>
 <p>Initialize the audio input and output devices for use.</p></li>
 <li><a href="#simple">Managing Simple Recording and Playback</a>
  <p>Record an audio sample from the audio input device, play the recorded audio sample through the audio output device, and modify the volume in the recorded audio sample using a simple API.</p>
 </li>
 <li><a href="#async">Managing Asynchronous Recording and Playback</a>
  <p>Record an audio sample from the audio input device, play the recorded audio sample through the audio output device, and modify the volume in the recorded audio sample using a low-latency API.</p>
 </li>
 <li><a href="#release">Releasing Resources</a>
  <p>Finish all audio device operations.</p>
 </li>
</ul>


 <h2 id="init" name="init">Initializing the Audio Devices</h2>

<p>To initialize the audio devices for use:</p>
<ol><li>
<p>To use the functions and data types of the Audio I/O (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">wearable</a> applications) and Sound Manager (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications) APIs, include the <span style="font-family: Courier New,Courier,monospace">&lt;audio_io.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files in your application:</p>
<pre class="prettyprint">
#include &lt;audio_io.h&gt;
#include &lt;sound_manager.h&gt;
</pre></li>

<li><p>To initialize the audio input and output devices, use the <span style="font-family: Courier New,Courier,monospace">audio_in_create()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> functions:</p>

<pre class="prettyprint">
// Define the sample rate for the recording
#define SAMPLE_RATE 44100

// Declare the variable used for checking function result
audio_io_error_e error_code;

// Initialize the audio input device
audio_in_h input;

error_code = audio_in_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, &amp;input);

// Initialize the audio output device
audio_out_h output;

error_code = audio_out_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, SOUND_TYPE_SYSTEM, &amp;output);
</pre>
<p>The audio input and output devices support the channel types defined in the <span style="font-family: Courier New,Courier,monospace">audio_channel_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">wearable</a> applications), and the sample types defined in the <span style="font-family: Courier New,Courier,monospace">audio_sample_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">wearable</a> applications). For playing the recorded audio, set the same channel and sample type for both devices.</p>

<p>The sound types are defined in the <span style="font-family: Courier New,Courier,monospace">audio_channel_e</span> enumeration. You can select the sound type according to the audio sample type.</p></li></ol>

 <h2 id="simple" name="simple">Managing Simple Recording and Playback</h2>
 
<h3 id="set" name="set">Creating an Audio Buffer</h3>

<p>Before starting the synchronous recording/playback process, you need to allocate the buffer that is used for storing the captured audio data. The buffer is allocated with the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function, so the desired buffer size must be known first. You can get that size by using one of the following options:</p>

<ul>

<li><p>Get the buffer size recommended by the Audio I/O API:</p>

<ol><li>
<p>Use the <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function to get the buffer size recommended by the sound server (such as PulseAudio):</p>

<pre class="prettyprint">
int buffer_size;

error_code = audio_in_get_buffer_size(input, &amp;buffer_size);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">buffer_size</span> parameter returns the recommended size of the buffer based on the specified audio parameters.</p>

</li>

<li>
<p>The size returned by the <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function depends on the device (it can be different for TV, mobile, and wearable). The synchronous recording process ends when the buffer is full. To determine the duration of the recording, set the buffer size corresponding to the desired duration.</p>
<p>For example, this function returns the size for around 100 milliseconds for the device used for creation of this tutorial. In such case, multiply the obtained buffer size by 10 (to change the units to seconds) and by the number of seconds that the recording lasts:</p>


<pre class="prettyprint">
#define RECORDING_SEC 5

buffer_size *= 10 * RECORDING_SEC;
</pre>

</li>

</ol></li>
<li>
<p>Explicitly calculate the buffer size:</p>

<ol>

<li>
<p>Retrieve the audio channel type information using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_channel()</span> function:</p>

<pre class="prettyprint">
audio_channel_e channel;

error_code = audio_in_get_channel(input, &amp;channel);
</pre>
</li>

<li>
<p>Retrieve the audio sample type information using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_sample_type()</span> function:</p>

<pre class="prettyprint">
error_code = audio_in_get_sample_type(input, &amp;sample_type);
</pre>
</li>

<li>
<p>Calculate the buffer size based on the retrieved information:</p>

<pre class="prettyprint">int buffer_size = SAMPLE_RATE * (channel == AUDIO_CHANNEL_STEREO ? 2 : 1) * (sample_type == AUDIO_SAMPLE_TYPE_S16_LE ? 2 : 1);</pre>
</li>
<li>
<p>Multiply the buffer size by the number of seconds that the recording takes:</p>

<pre class="prettyprint">
buffer_size *= RECORDING_SEC;
</pre>
</li>
</ol></li></ul>

<p>After determining the buffer size, allocate the memory for the buffer using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function:</p>

<pre class="prettyprint">void *buffer = malloc(buffer_size);</pre>

<p>Now, when the local buffer for recording/playback is created, you can start the recording/playback process.</p>


<h3 id="record" name="record">Recording and Playing an Audio Sample</h3>

<p>The synchronous recording/playback process is blocking. It means that launching a recording or playback process from the main thread of the application can make it unresponsive. To prevent this, launch the recording/playback in a different thread. This use case uses the <span style="font-family: Courier New,Courier,monospace">ecore_thread_run()</span> function for that purpose.</p>

<pre class="prettyprint">
ecore_thread_run(synchronous_playback, NULL, NULL, NULL);
</pre>

<p>Now, inside the <span style="font-family: Courier New,Courier,monospace">synchronous_playback()</span> function, you can safely run the recording/playback process:</p>


<ol><li>
<p>To start capturing the audio from the H/W device, prepare the audio input device. After using the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, the device starts buffering (storing in an internal buffer) the captured audio.</p>

<pre class="prettyprint">error_code = audio_in_prepare(input);
</pre></li>

<li><p>To obtain the captured audio data from the internal buffer, use the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function:</p>

<pre class="prettyprint">
// Copy recorded data from the input buffer to the local buffer
int bytes_number = audio_in_read(input, buffer, buffer_size);
</pre>

<p>The returned value must be the number of bytes read from the input buffer. However, if the value is negative, it represents an error code.</p>

<p>This function can behaves in 2 different ways:</p>
<ul>
<li>When it is called immediately after calling the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, it blocks the thread it is launched from until the buffer is fulfilled with the captured audio data.</li>
<li>When it is called with a delay long enough to let the internal buffer store more data than the buffer size indicates, the function executes immediately, without blocking its thread.</li></ul>

<p>The <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function fulfills the local buffer by copying the data from the internal buffer. If not enough audio data was captured yet (not enough data is stored in the internal buffer), the function waits until enough data is captured to fulfill the whole local buffer. It is <strong>important</strong> to understand this mechanism. If you want to start recording audio after clicking a button, call the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function just before the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function (in the same button callback). Otherwise, if you prepare the device earlier and run only the reading function inside the button callback, your recording buffer is fulfilled with the audio data recorded earlier (before the button was clicked).</p>
</li>

<li><p>To stop the hardware recording process (buffering) after reading the data, use the <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function:</p>

<pre class="prettyprint">
error_code = audio_in_unprepare(input);
</pre></li>

<li><p>Playing the recorded audio sample follows the same rules as the recording process.</p>
<p>To play the recorded audio sample from the buffer, prepare the audio output device. After using the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function, the device prepares its internal output buffer for the playback.</p>

<pre class="prettyprint">
error_code = audio_out_prepare(output);
</pre>
</li>
<li><p>The audio sample playback process is launched by using the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function:</p>

<pre class="prettyprint">
// Copy the recorded data from the local buffer to the output buffer
int bytes_number = audio_out_write(output, buffer, buffer_size);
</pre>

<p>The returned value must be the number of bytes read from the input buffer. However, if the value is negative, it represents an error code.</p>
</li>

<li><p>To stop the hardware playback process (buffering) after writing the data to the output buffer, use the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>

<pre class="prettyprint">
error_code = audio_out_unprepare(output);
</pre></li></ol>

<h3 id="modify" name="modify">Modifying the Audio Sample Volume</h3>

<p>To modify the volume of the audio sample stored in the local buffer:</p>

<pre class="prettyprint">
#define MIN_2BYTES_SIGNED (−32768)
#define MAX_2BYTES_SIGNED 32767

void modify_sound()
{
&nbsp;&nbsp;&nbsp;// Get the sample type of the input
&nbsp;&nbsp;&nbsp;audio_sample_type_e sample_type;

&nbsp;&nbsp;&nbsp;int error_code = audio_in_get_sample_type(input, &amp;sample_type);
&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_get_sample_type() failed! Error code = %d&quot;, error_code);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;uint8_t *index = (uint8_t*)buffer;
&nbsp;&nbsp;&nbsp;while (index &lt; (((uint8_t*)buffer)+buffer_size))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AUDIO_SAMPLE_TYPE_S16_LE == sample_type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Use int16_t type, because it is 2 bytes long
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int16_t *value = (int16_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make the sample louder
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t tmp = (*value) * 8; // Why not 8 times louder? (on dB scale even much louder)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; MAX_2BYTES_SIGNED) tmp = MAX_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &lt; MIN_2BYTES_SIGNED) tmp = MIN_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Use uint8_t type, because it is 1 byte long
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *value = (uint8_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make the sample louder
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t tmp = (*value) * 8; // Why not 8 times louder? (on dB scale even much louder)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp &gt; 255) tmp = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go to the next sample
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index += sample_type == AUDIO_SAMPLE_TYPE_S16_LE? 2 : 1;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, LOG_TAG, &quot;Volume of the synchronous recording increased.&quot;);
}
</pre>

<p>In this example, the volume is significantly increased. You can also make other modifications to the audio sample playback.</p>

 <h2 id="async" name="async">Managing Asynchronous Recording and Playback</h2>

<h3 id="async_rec" name="async_rec">Starting the Asynchronous Recording</h3>

<p>The asynchronous recording process uses callback functions for capturing audio samples.</p>

<ol><li>After initialization of the audio input device, proper callback function must be set using the <span style="font-family: Courier New,Courier,monospace">audio_in_set_stream_cb()</span> function. Use this function before calling the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, because otherwise the callback function is not be called.

<pre class="prettyprint">
// Set a callback function that is called asynchronously for every single part of the captured voice data
error_code = audio_in_set_stream_cb(input, _audio_io_stream_read_cb, NULL);
</pre>

<p>After this step, call the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function and start capturing the audio. However, in this case, to store the recording in a file instead of using local buffer, you must prepare (create and open) a file the recording is stored in:</p>

<pre class="prettyprint">
#include &lt;storage.h&gt;

// Prepare a file, where the recorded data is stored
char io_stream_w_path[200];
char *storage_path;
// storage_id can be found using the storage_foreach_device_supported() function
int error = storage_get_directory(storage_id, STORAGE_DIRECTORY_SOUNDS, &amp;storage_path);  
snprintf(io_stream_w_path, 200, &quot;%s/%s&quot;, storage_path, &quot;pcm_w.raw&quot;);
free(storage_path);

FILE* fp_w = fopen(io_stream_w_path, &quot;w&quot;);
if (!fp_w) 
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;fopen() function failed while opening %s file!&quot;, io_stream_w_path);
}
</pre>
<p>To obtain the storage path, use the Storage API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__SYSTEM__STORAGE__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__SYSTEM__STORAGE__MODULE.html">wearable</a> applications) instead of direct access.</p>
</li>

<li>
<p>The file is ready and the callback function is set. Proceed with the asynchronous recording by calling the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function to initiate the hardware recording process:</p>

<pre class="prettyprint">
error_code = audio_in_prepare(input);
</pre>

<p>From now on, the callback function is invoked respectively for every captured audio sample pack.</p>

<p>Inside the callback function, you retrieve a handle to the input device and the number of captured audio sample bytes using the <span style="font-family: Courier New,Courier,monospace">audio_in_peek()</span> function. This information can be used to extract the data from the input internal buffer and store it in the file. The audio data stored in the obtained buffer is written to the recording file (the one that was prepared earlier) with the <span style="font-family: Courier New,Courier,monospace">fwrite()</span> function, and after storing the received audio sample pack in the file, it can be removed from the internal buffer using the <span style="font-family: Courier New,Courier,monospace">audio_in_drop()</span> function.</p>

<pre class="prettyprint">
void _audio_io_stream_read_cb(audio_in_h handle, size_t nbytes, void *userdata)
{
&nbsp;&nbsp;&nbsp;const void * buffer = NULL;

&nbsp;&nbsp;&nbsp;if (nbytes &gt; 0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Retrieve buffer pointer from audio input buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int error_code = audio_in_peek(handle, &amp;buffer, &amp;nbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_peek() failed! Error code = %d&quot;, error_code);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store the recorded part in the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite(buffer, sizeof(char), nbytes, fp_w);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Remove the obtained audio input data from the actual stream buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_code = audio_in_drop(handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_in_drop() failed! Error code = %d&quot;, error_code);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
}
</pre></li>
</ol>

<h3 id="stop" name="stop">Stopping the Asynchronous Recording</h3>

<p>It is possible to stop the asynchronous recording process manually:</p>

<ol><li>The <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function stops the hardware recording process, so the callback for asynchronous recording is no longer called:

<pre class="prettyprint">
error_code = audio_in_unprepare(input);
</pre>
</li>
<li><p>If the asynchronous recording is no longer used, or if the <span style="font-family: Courier New,Courier,monospace">audio_in_set_stream_cb()</span> function is called each time before starting the asynchronous recording, you can unset the callback function with the <span style="font-family: Courier New,Courier,monospace">audio_in_unset_stream_cb()</span> function:</p>
<pre class="prettyprint">
error_code = audio_in_unset_stream_cb(input);
</pre>
</li>
<li><p>The file used for recording is still opened, so if the recording was stopped, the file can be closed:</p>

<pre class="prettyprint">
error_code = fclose(fp_w);
</pre>
</li></ol>

<h3 id="start" name="start">Starting the Asynchronous Playback</h3>

<p>Playing the audio sample asynchronously is similar to the recording:</p>

<ol><li>The callback function used for asynchronous playback is set with the <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function:

<pre class="prettyprint">
// Set a callback function that is called asynchronously for every single part of the stored audio data
error_code = audio_out_set_stream_cb(output, _audio_io_stream_write_cb, NULL);
</pre>
<p>After this step, you can call the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function and start playing the audio. However, in this case, to play the recording from a file instead of using local buffer, you must prepare (open for reading) a file the recording is stored in:</p>

<pre class="prettyprint">
#include &lt;storage.h&gt;

char io_stream_r_path[200];
char *storage_path;
// storage_id can be found using the storage_foreach_device_supported() function
int error = storage_get_directory(storage_id, STORAGE_DIRECTORY_SOUNDS, &amp;storage_path);  
snprintf(io_stream_r_path, 200, &quot;%s/%s&quot;, storage_path, &quot;pcm_w.raw&quot;);
free(storage_path);

FILE* fp_r = fopen(io_stream_r_path, &quot;r&quot;);
</pre>
</li>

<li>
<p>The file is ready and the callback function is set. Proceed with the asynchronous playback by calling the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function to initiate the hardware playback process:</p>

<pre class="prettyprint">
error_code = audio_out_prepare(output);
</pre>

</li>
<li>
<p>From now on, the callback function is invoked respectively for every audio sample pack retrieved from the file.</p>

<p>Inside the callback, you retrieve a handle to the output internal buffer and the number of audio sample bytes that can be written to the output buffer using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> and <span style="font-family: Courier New,Courier,monospace">memset()</span> functions. Read the pack of the audio sample from the file and store it in the local buffer using the <span style="font-family: Courier New,Courier,monospace">fread()</span> function, and copy the audio sample data from the local buffer to the output internal buffer to start the playback with the <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function.</p>

<pre class="prettyprint">
void _audio_io_stream_write_cb(audio_out_h handle, size_t nbytes, void *userdata)
{
&nbsp;&nbsp;&nbsp;char * buffer = NULL;

&nbsp;&nbsp;&nbsp;if (nbytes &gt; 0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = malloc(nbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(buffer, 0, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Play the following part of the recording
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fread(buffer, sizeof(char), nbytes, fp_r);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the recorded data from the buffer to the output buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int data_size = audio_out_write(handle, buffer, nbytes);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data_size &lt; 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;audio_out_write() failed! Error code = %d&quot;, data_size);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free (buffer);
&nbsp;&nbsp;&nbsp;}
}
</pre></li></ol>

<h3 id="stop_async" name="stop_async">Stopping the Asynchronous Playback</h3>
<p>you can stop the asynchronous playback process manually:</p>

<ol><li>The <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function stops the hardware playback process, so the callback for asynchronous playback is no longer called:

<pre class="prettyprint">
error_code = audio_out_unprepare(output);
</pre>
</li>
<li>
<p>If the asynchronous playback is no longer used, or if the <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function is called each time before starting the asynchronous playback, you can unset the callback function with the <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> function when the playback is stopped:</p>

<pre class="prettyprint">
error_code = audio_out_unset_stream_cb(output);
</pre>
</li>
<li>
<p>The file used for playback is still opened, so if the playback was stopped, the file can be closed:</p>

<pre class="prettyprint">
error_code = fclose(fp_r);
</pre>
</li></ol>


 <h2 id="release" name="release">Releasing Resources</h2>

<p>To destroy the audio handles and release the allocated resources after you have finished working with the audio input and output devices:</p>

<ol><li><p>Release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function:</p>

<pre class="prettyprint">free(buffer);</pre></li>

<li><p>Unprepare the audio input and output devices using the <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> functions:</p>

<pre class="prettyprint">
// Stop the hardware recording process
error_code = audio_in_unprepare(input);

// Stop the hardware playback process
error_code = audio_out_unprepare(output);
</pre></li>

<li><p>Unset the callback functions used for asynchronous recording/playback, if they were not unset yet, using the <span style="font-family: Courier New,Courier,monospace">audio_in_unset_stream_cb()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> functions:</p>

<pre class="prettyprint">
// Unset the callback function used for asynchronous recording process
audio_in_unset_stream_cb(input);

// Unset the callback function used for asynchronous playback process
audio_out_unset_stream_cb(output);
</pre></li>

<li><p>Destroy the audio input and output handles using the <span style="font-family: Courier New,Courier,monospace">audio_in_destroy()</span> and <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> functions:</p>

<pre class="prettyprint">
// Deinitialize audio input device
error_code = audio_in_destroy(input);

// Deinitialize audio output device
error_code = audio_out_destroy(output);
</pre></li>


<li><p>Close opened files, if they were not closed yet, using the <span style="font-family: Courier New,Courier,monospace">fclose()</span> function:</p>

<pre class="prettyprint">
fclose(fp_w);
fp_w = NULL;

fclose(fp_r);
fp_r = NULL;</pre></li></ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

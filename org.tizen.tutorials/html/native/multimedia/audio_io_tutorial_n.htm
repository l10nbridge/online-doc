<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li><a href="#init">Initializing the Audio Devices</a></li>
			<li><a href="#simple">Managing Simple Recording and Playback</a></li>
			<li><a href="#async">Managing Asynchronous Recording and Playback</a></li>
			<li><a href="#release">Releasing Resources</a></li>
		</ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/multimedia/audio_io_n.htm">Audio I/O Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Mobile Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">Audio I/O API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">Sound Manager API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Audio I/O: Recording from the Audio Device and Playing Raw Audio Data</h1>

  
<p>This tutorial demonstrates how you can control audio input and output to record, and play an audio sample.</p>

<h2>Warm-up</h2>

<p>Become familiar with the Audio I/O and Sound Manager API basics by learning about:</p>

<ul>
 <li><a href="#init">Initializing the Audio Devices</a>
 <p>Initialize the audio input and output devices for use.</p></li>
 <li><a href="#simple">Managing Simple Recording and Playback</a>
  <p>Record an audio sample from the audio input device, play the recorded audio sample through the audio output device, and modify the volume in the recorded audio sample using a simple API.</p>
 </li>
 <li><a href="#async">Managing Asynchronous Recording and Playback</a>
  <p>Record an audio sample from the audio input device, play the recorded audio sample through the audio output device, and modify the volume in the recorded audio sample using a low-latency API.</p>
 </li>
 <li><a href="#release">Releasing Resources</a>
  <p>Finish all audio device operations.</p>
 </li>
</ul>


 <h2 id="init" name="init">Initializing the Audio Devices</h2>

<p>To initialize the audio devices for use:</p>
<ol><li>
<p>To use the functions and data types of the Audio I/O (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html">wearable</a> applications) and Sound Manager (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__SOUND__MANAGER__MODULE.html">wearable</a> applications) APIs, include the <span style="font-family: Courier New,Courier,monospace">&lt;audio_io.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;sound_manager.h&gt;</span> header files in your application:</p>
<pre class="prettyprint">
#include &lt;audio_io.h&gt;
#include &lt;sound_manager.h&gt;
</pre></li>
<li><p>To initialize the audio input and output devices, use the <span style="font-family: Courier New,Courier,monospace">audio_in_create()</span>
       and <span style="font-family: Courier New,Courier,monospace">audio_out_create()</span> functions:</p>
<pre class="prettyprint">
// Define the sample rate for the recording.
#define SAMPLE_RATE 44100

// Declare variable used for checking function result.
audio_io_error_e error_code;

// Initialize the audio input device.
audio_in_h input;

error_code = audio_in_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, &amp;input);

// Initialize the audio output device.
audio_out_h output;

error_code = audio_out_create(SAMPLE_RATE, AUDIO_CHANNEL_MONO, AUDIO_SAMPLE_TYPE_S16_LE, SOUND_TYPE_SYSTEM, &amp;output);
</pre>
<p>The audio input and output devices support the channel types defined in the <span style="font-family: Courier New,Courier,monospace">audio_channel_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga4e07ead99d581a0a049e8ee632b858b4">wearable</a> applications)
   and the sample types defined in the <span style="font-family: Courier New,Courier,monospace">audio_sample_type_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__AUDIO__IO__MODULE.html#ga1e66f976b2890f5fc2e9e6ec71af7536">wearable</a> applications).
   For playing the recorded audio, set the same channel and sample type for both devices.</p>

<p>The sound types are defined in the <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__SOUND__MANAGER__SESSION__MODULE.html#ga125699870d48881ea153a4fce7140958">audio_channel_e</a> enumeration.
   You can select the sound type according to the audio sample type.</p></li></ol>

 <h2 id="simple" name="simple">Managing Simple Recording and Playback</h2>

<h3 id="set" name="set">Creating an Audio Buffer</h3>

<p>Before starting the synchronous recording/playback process, you need to allocate the buffer that will be used for storing the captured audio data.
   The buffer will be allocated with the usage of the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function,
   so the desired buffer size need to be known first. You can get that size by using one of the following options:</p>
 
<ol>

<li>

<p>Get the buffer size recommended by the Audio I/O API.</p>

<ol>

<li>

<p>Use the <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function to get the buffer size recommended by the sound server (e.g. PulseAudio):</p>

<pre class="prettyprint">
int buffer_size;

error_code = audio_in_get_buffer_size(input, &amp;buffer_size);
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace">buffer_size</span> parameter returns the recommended size of the buffer based on the specified audio parameters.</p>

</li>

<li>

<p>Normally, <span style="font-family: Courier New,Courier,monospace">audio_in_get_buffer_size()</span> function returns the size for around 100 milliseconds.
   The synchronous recording process ends when the buffer is full, so to determine the duration of the recording, multiply the obtained buffer size by 10 (to change the units to seconds)
   and by the number of seconds, that the recording should take:</p>

<pre class="prettyprint">
#define RECORDING_SEC 5

buffer_size *= 10 * RECORDING_SEC;
</pre>

</li>

</ol>

</li>

<li>

<p>Alternatively, explicitly calculate the buffer size:</p>
<ol>

<li>
<p>Retrieve the audio channel type information using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_channel()</span> function:</p>
<pre class="prettyprint">
audio_channel_e channel;

error_code = audio_in_get_channel(input, &amp;channel);
</pre>
</li>

<li>
<p>Retrieve the audio sample type information using the <span style="font-family: Courier New,Courier,monospace">audio_in_get_sample_type()</span> function:</p>
<pre class="prettyprint">
audio_sample_type_e sample_type;

error_code = audio_in_get_sample_type(input, &amp;sample_type);
</pre>
</li>

<li>
<p>Calculate the buffer size based on the retrieved information:</p>
<pre class="prettyprint">
int buffer_size = SAMPLE_RATE * (channel == AUDIO_CHANNEL_STEREO ? 2 : 1) * (sample_type == AUDIO_SAMPLE_TYPE_S16_LE ? 2 : 1);
</pre>
</li>

<li>
<p>Multiply the buffer size by the number of seconds, that the recording should take:</p>
<pre class="prettyprint">
buffer_size *= RECORDING_SEC;
</pre>
</li>

</ol>

</li>

<li>
<p>Allocate the memory for the buffer using the <span style="font-family: Courier New,Courier,monospace">malloc()</span> function:</p>
<pre class="prettyprint">void *buffer = malloc(buffer_size);</pre>
<p>Now, when the local buffer for recording/playback is created, it is possible to start the recording/playback process.</p>
</li>

</ol>

<h3 id="record" name="record">Recording and Playing an Audio Sample</h3>

<p>Please note that the synchronous recording/playback process is blocking. It means that launching recording/playback from the main thread of the application can make it unresponsive.
   To prevent from such situation, you can launch the recording/playback in a different thread.
   The tutorial application uses <span style="font-family: Courier New,Courier,monospace">ecore_thread_run()</span> function for that purpose.</p>
<pre class="prettyprint">
ecore_thread_run(synchronous_playback, NULL, NULL, NULL);
</pre>
<p>Now, inside the <span style="font-family: Courier New,Courier,monospace">synchronous_playback()</span> function, you can safely run the recording/playback process:</p>

<ol>
<li>
<p>To start capturing the audio from the H/W device, you need to prepare the audio input device.
   After using <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, the device starts buffering (storing in an internal buffer) the captured audio.</p>

<pre class="prettyprint">
// Audio input prepare (starts the hardware recording process).
error_code = audio_in_prepare(input);
</pre>
</li>

<li>
<p>To obtain the captured audio data from the internal buffer, use the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function.</p>
<pre class="prettyprint">
// Copy recorded data from the input buffer to the local buffer.
int bytes_number = audio_in_read(input, buffer, buffer_size);
</pre>
<p>The returned value should be the number of bytes read from the input buffer. However, if the value is negative, it represents an error code.</p>
<p>Please note that this function can behave in two different ways:</p>
<ol>
<li>When it is called immediately after calling <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function,
    then it blocks the thread it is launched from until the buffer is fulfilled with the captured audio data.</li>
<li>However, if the function is called with a delay long enough to let the internal buffer store
    more data than the buffer size indicate, then the function will execute immediately, without blocking its thread.</li></ol>
<p>The explanation is connected with the functionality of the <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span> function.
   It fulfills the local buffer by copying the data from the internal buffer. If not enough audio data was captured yet (not enough data is stored in the internal buffer),
   the function waits until enough data is captured to fulfill the whole local buffer. It is <strong>important</strong> to understand this mechanism. If you want to start recording audio after clicking a button,
   call <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function just before <span style="font-family: Courier New,Courier,monospace">audio_in_read()</span>
   (in the same button's callback). Otherwise, if you prepare the device earlier and run only reading function inside the button's callback, your recording buffer will be fulfilled with the audio data
   recorded earlier (before the button was clicked).</p>
</li>

<li><p>To stop the hardware recording process (buffering), after reading the data, use <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function:</p>
<pre class="prettyprint">
// Stop the hardware recording process.
error_code = audio_in_unprepare(input);
</pre></li>
</ol>

<ol>
<li><p>Playing the recorded audio sample follows the same rules as the recording process.</p>
<p>To play the recorded audio sample from the buffer, you need to prepare the audio output device.
   After using <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function, the device prepares its internal output buffer for the playback.</p>
<pre class="prettyprint">
// Audio output prepare (starts the hardware playback process).
error_code = audio_out_prepare(output);
</pre>
</li>

<li><p>Then, the audio sample playback process is launched by using <span style="font-family: Courier New,Courier,monospace">audio_out_write()</span> function:</p>
<pre class="prettyprint">
// Copy the recorded data from the local buffer to the output buffer.
int bytes_number = audio_out_write(output, buffer, buffer_size);
</pre>
<p>The returned value should be the number of bytes read from the input buffer. However, if the value is negative, it represents an error code.</p>
</li>

<li><p>To stop the hardware playback process (buffering), after writing the data to the output buffer, use the <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function:</p>
<pre class="prettyprint">
// Stop the hardware playback process.
error_code = audio_out_unprepare(output);
</pre></li></ol>

<h3 id="record" name="record">Modifying the Audio Sample Volume</h3>

<p>To modify the volume of the audio sample stored in the local buffer, proceed with the following function:</p>
<pre class="prettyprint">
#define MIN_2BYTES_SIGNED (âˆ’32768)
#define MAX_2BYTES_SIGNED 32767

void modify_sound()
{
&nbsp;&nbsp;&nbsp;&nbsp;// Get the sample type of the input.
&nbsp;&nbsp;&nbsp;&nbsp;audio_sample_type_e sample_type;

&nbsp;&nbsp;&nbsp;&nbsp;int error_code = audio_in_get_sample_type(input, &sample_type);
&nbsp;&nbsp;&nbsp;&nbsp;if (error_code != AUDIO_IO_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, "audio_in_get_sample_type() failed! Error code = %d", error_code);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *index = (uint8_t*)buffer;
&nbsp;&nbsp;&nbsp;&nbsp;while (index < (((uint8_t*)buffer)+buffer_size))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AUDIO_SAMPLE_TYPE_S16_LE == sample_type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We are using int16_t type, because it's 2 bytes long.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int16_t *value = (int16_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make the sample louder.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int32_t tmp = (*value) * 8; // Why not 8 times louder? (on dB scale even much louder)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp > MAX_2BYTES_SIGNED) tmp = MAX_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp < MIN_2BYTES_SIGNED) tmp = MIN_2BYTES_SIGNED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We are using uint8_t type, because it's 1 byte long.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8_t *value = (uint8_t*)index;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make the sample louder.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint16_t tmp = (*value) * 8; // Why not 8 times louder? (on dB scale even much louder)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp > 255) tmp = 255;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*value) = tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go to the next sample.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index += sample_type == AUDIO_SAMPLE_TYPE_S16_LE? 2 : 1;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;PRINT_MSG("Volume of the synchronous recording increased.")
}
</pre>

<p>In this example, the volume is significantly increased. You can also make other modifications to the audio sample playback.</p>

 <h2 id="async" name="async">Managing Asynchronous Recording and Playback</h2>

<h3 id="set" name="set">Start Asynchronous Recording</h3>
<p>The asynchronous recording process uses callback functions for capturing audio samples. After initialization of the audio input device, proper callback function must be set using
   <span style="font-family: Courier New,Courier,monospace">audio_in_set_stream_cb()</span> function. It is <strong>important</strong> to use this function before calling
   <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function, because otherwise, the callback function won't be called.</p>
<pre class="prettyprint">
// Set a callback function that will be called asynchronously for every single part of the captured voice data.
error_code = audio_in_set_stream_cb(input, _audio_io_stream_read_cb, NULL);
</pre>
<p>After this step we can call the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function and start capturing the audio. However, in this case we want to store
   the recording in a file instead of using local buffer. For this purpose we have to prepare (create and open) a file the recording will be stored in.</p>
<pre class="prettyprint">
FILE* fp_w = NULL;

// Prepare a file, where the recorded data will be stored.
char io_stream_w_path[200];
snprintf(io_stream_w_path, 200, "%s%s", "/opt/usr/media/Sounds/", "pcm_w.raw");
fp_w = fopen(io_stream_w_path, "w");
if (!fp_w) {
    dlog_print(DLOG_ERROR, LOG_TAG, "fopen() function failed while opening %s file!", io_stream_w_path);
}
</pre>

<p>The file is ready and the callback function is set. Now you can proceed with the asynchronous recording. Call the <span style="font-family: Courier New,Courier,monospace">audio_in_prepare()</span> function
   to initiate the hardware recording process.</p>
<pre class="prettyprint">
// Audio input prepare (starts the hardware recording process).
error_code = audio_in_prepare(input);
</pre>

<p>From now on our callback function will be invoked respectively for every captured audio sample pack.</p>
<pre class="prettyprint">
// Callback invoked for every captured part of the recording.
void _audio_io_stream_read_cb(audio_in_h handle, size_t nbytes, void *userdata)
{
    const void * buffer = NULL;

    if (nbytes > 0)
    {
        // Retrieve buffer pointer from audio input buffer
        int error_code = audio_in_peek(handle, &buffer, &nbytes);
        if (error_code != AUDIO_IO_ERROR_NONE)
        {
            dlog_print(DLOG_ERROR, LOG_TAG, "audio_in_peek() failed! Error code = %d", error_code);
            return;
        }

        // Store the recorded part in the file.
        fwrite(buffer, sizeof(char), nbytes, fp_w);

        // Remove the obtained audio input data from the actual stream buffer.
        error_code = audio_in_drop(handle);
        if (error_code != AUDIO_IO_ERROR_NONE)
        {
            dlog_print(DLOG_ERROR, LOG_TAG, "audio_in_drop() failed! Error code = %d", error_code);
        }
    }
}
</pre>
<p>As can be seen above, inside the callback function we retrieve a handle to the input device and the number of captured audio sample bytes.
   This information can be used to extract the data from the input internal buffer and store it in the file. First of all, the pointer to the internal audio buffer is obtained
   using <span style="font-family: Courier New,Courier,monospace">audio_in_peek()</span> function.</p>
<pre class="prettyprint">
// Retrieve a pointer to the audio input internal buffer.
int error_code = audio_in_peek(handle, &buffer, &nbytes);
</pre>

<p>Then the audio data stored in the obtained buffer is written to the recording file (the one that was prepared earlier) with <span style="font-family: Courier New,Courier,monospace">fwrite()</span> function.</p>
<pre class="prettyprint">
// Store the recorded part in the file.
fwrite(buffer, sizeof(char), nbytes, fp_w);
</pre>

<p>After storing the received audio sample pack in the file, it can be removed from internal buffer.</p>
<pre class="prettyprint">
// Remove the obtained audio input data from the actual stream buffer.
error_code = audio_in_drop(handle);
</pre>

<h3 id="set" name="set">Stop Asynchronous Recording</h3>

<p>It is possible to stop the asynchronous recording process manually. The <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span> function stops the hardware recording process,
   so the callback for asynchronous recording won't be called anymore.</p>
<pre class="prettyprint">
// Stop the hardware recording process.
error_code = audio_in_unprepare(input);
</pre>

<p>If the asynchronous recording won't be used anymore, or if the <span style="font-family: Courier New,Courier,monospace">audio_in_set_stream_cb()</span> function is called each time before starting
   the asynchronous recording, then you can unset the callback function with <span style="font-family: Courier New,Courier,monospace">audio_in_unset_stream_cb()</span> function.</p>
<pre class="prettyprint">
// Unset the callback function used for asynchronous recording process.
error_code = audio_in_unset_stream_cb(input);
</pre>

<p>Please note that the file used for recording is still opened, so if the recording was stopped, the file can be closed.</p>
<pre class="prettyprint">
// Close the file used for recording.
error_code = fclose(fp_w);
</pre>

<h3 id="set" name="set">Start Asynchronous Playback</h3>

<p>Playing the audio sample asynchronously is similar to the recording. First of all, the callback function used for asynchronous playback is set with
   <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function. </p>
<pre class="prettyprint">
// Set a callback function that will be called asynchronously for every single part of the stored audio data.
error_code = audio_out_set_stream_cb(output, _audio_io_stream_write_cb, NULL);
</pre>

<p>After this step we can call the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function and start playing the audio. However, in this case we want to play
   the recording from a file instead of using local buffer. For this purpose we have to prepare (open for reading) a file the recording is stored in.</p>
<pre class="prettyprint">
// Prepare a file, that will be used for playback.
char io_stream_r_path[200];
snprintf(io_stream_r_path, 200, "%s%s", "/opt/usr/media/Sounds/", "pcm_w.raw");
fp_r = fopen(io_stream_r_path, "r");
</pre>

<p>The file is ready and the callback function is set. Now you can proceed with the asynchronous playback. Call the <span style="font-family: Courier New,Courier,monospace">audio_out_prepare()</span> function
   to initiate the hardware playback process.</p>
<pre class="prettyprint">
// Audio output prepare (starts the hardware playback process)
error_code = audio_out_prepare(output);
</pre>

<p>From now on our callback function will be invoked respectively for every audio sample pack retrieved from the file.</p>
<pre class="prettyprint">
// Callback invoked for every stored part of the audio.
void _audio_io_stream_write_cb(audio_out_h handle, size_t nbytes, void *userdata)
{
    char * buffer = NULL;

    if (nbytes > 0)
    {
        buffer = malloc(nbytes);
        memset(buffer, 0, nbytes);

        // Play the following part of the recording.
        fread(buffer, sizeof(char), nbytes, fp_r);

        // Copy the recorded data from the buffer to the output buffer.
        int data_size = audio_out_write(handle, buffer, nbytes);
        if (data_size < 0)
        {
            dlog_print(DLOG_ERROR, LOG_TAG, "audio_out_write() failed! Error code = %d", data_size);
        }

        free(buffer);
    }
}
</pre>

<p>As can be seen above, inside the callback function we retrieve a handle to the output internal buffer and the number of audio sample bytes that can be written to the output buffer.
   First of all, read the audio sample pack from the file and store it in a local buffer.</p>
<pre class="prettyprint">
char * buffer = malloc(nbytes);
memset(buffer, 0, nbytes);

// Read the pack of the audio sample from the file and store it in the local buffer.
fread(buffer, sizeof(char), nbytes, fp_r);
</pre>

<p>Copy the audio sample data from the local buffer to the output internal buffer to start the playback.</p>
<pre class="prettyprint">
// Copy the recorded data from the local buffer to the output buffer.
int data_size = audio_out_write(handle, buffer, nbytes);
</pre>

<h3 id="set" name="set">Stop Asynchronous Playback</h3>

<p>It is possible to stop the asynchronous playback process manually. The <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> function stops the hardware playback process,
   so the callback for asynchronous playback won't be called anymore.</p>
<pre class="prettyprint">
// Stop the hardware playback process.
error_code = audio_out_unprepare(output);
</pre>

<p>If the asynchronous playback won't be used anymore, or if the <span style="font-family: Courier New,Courier,monospace">audio_out_set_stream_cb()</span> function is called each time before starting
   the asynchronous playback, then you can unset the callback function with <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> function, when the playback is stopped.</p>
<pre class="prettyprint">
// Unset the callback function used for asynchronous playback process.
error_code = audio_out_unset_stream_cb(output);
</pre>

<p>Please note that the file used for playback is still opened, so if the playback was stopped, the file can be closed.</p>
<pre class="prettyprint">
// Close the file used for playback.
error_code = fclose(fp_r);
</pre>

 <h2 id="release" name="release">Releasing Resources</h2>

<p>To destroy the audio handles and release the allocated resources after you have finished working with the audio input and output devices do the following steps:</p>

<ol><li><p>Release the memory allocated to the local buffer using the <span style="font-family: Courier New,Courier,monospace">free()</span> function:</p>

<pre class="prettyprint">
// Release the memory allocated for the local buffer used for recording/playing.
free(buffer);
</pre></li>

<li><p>Unprepare the audio input and output devices using the <span style="font-family: Courier New,Courier,monospace">audio_in_unprepare()</span>
       and <span style="font-family: Courier New,Courier,monospace">audio_out_unprepare()</span> functions.</p>
<pre class="prettyprint">
// Stop the hardware recording process.
error_code = audio_in_unprepare(input);

// Stop the hardware playback process
error_code = audio_out_unprepare(output);
</pre></li>

<li><p>Unset callback function used for asynchronous recording/playback, if they weren't unset yet, using the <span style="font-family: Courier New,Courier,monospace">audio_in_unset_stream_cb()</span>
       and <span style="font-family: Courier New,Courier,monospace">audio_out_unset_stream_cb()</span> functions.</p>
<pre class="prettyprint">
// Unset the callback function used for asynchronous recording process.
audio_in_unset_stream_cb(input);

// Unset the callback function used for asynchronous playback process.
audio_out_unset_stream_cb(output);
</pre></li>

<li><p>Destroy the audio input and output handles using the <span style="font-family: Courier New,Courier,monospace">audio_in_destroy()</span>
       and <span style="font-family: Courier New,Courier,monospace">audio_out_destroy()</span> functions.</p>
<pre class="prettyprint">
// Deinitialize audio input device.
error_code = audio_in_destroy(input);

// Deinitialize audio output device.
error_code = audio_out_destroy(output);
</pre></li>

<li><p>Close opened files, if they weren't closed yet, using the <span style="font-family: Courier New,Courier,monospace">fclose()</span> function:</p>

<pre class="prettyprint">
fclose(fp_w);
fp_w = NULL;

fclose(fp_r);
fp_r = NULL;</pre></li></ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

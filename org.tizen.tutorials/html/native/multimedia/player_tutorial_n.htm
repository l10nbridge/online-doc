<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>
    <title>Player: Playing Multimedia Content from a File, Network, and Memory</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mobile_s_n.png"/> <img alt="Wearable native" src="../../images/wearable_s_n.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
        <p class="toc-title">Content</p>
        <ul class="toc">
            <li>Player
                <ul class="toc">
                    <li><a href="#init">Initializing the Player</a></li>
                    <li><a href="#play_audio">Playing an Audio File</a></li>
                    <li><a href="#play_video">Playing a Video File</a></li>
                    <li><a href="#release">Stopping the Player and Releasing Resources</a></li>
                </ul>
            </li>
            <li>Multi-player
                <ul class="toc">
                    <li><a href="#init_multiplayer">Initializing Multiple Players</a></li>
                    <li><a href="#play">Playing Multiple Files Simultaneously</a></li>
                </ul>
            </li>
            <li>Advanced player
                <ul class="toc">
                    <li><a href="#set_parameters">Configuring the Video Playback Display</a></li>
                    <li><a href="#get_stream">Retrieving Stream Information</a></li>
                    <li><a href="#insert">Inserting Subtitles</a></li>
                </ul>
            </li>
        </ul>
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/multimedia/player_n.htm">Player Guide</a></li>
            <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">Player API for Mobile Native</a></li>
            <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">Player API for Wearable Native</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">

<h1>Player: Playing Multimedia Content from a File, Network, and Memory</h1>

<p>This tutorial demonstrates how you can play audio and video files, and play multiple audio files simultaneously.</p>

<h2>Warm-up</h2>

<p>Become familiar with the Player API basics by learning about:</p>

<ul>
    <li>Player
        <ul>
            <li><a href="#init">Initialing the Player</a>
                <p>Initialize the player for use.</p></li>
            <li><a href="#play_audio">Playing an Audio File</a>
                <p>Play an audio file.</p></li>
            <li><a href="#play_video">Playing a Video File</a>
                <p>Play a video file.</p></li>
            <li><a href="#release">Stopping the Player and Releasing Resources</a>
                <p>Stop the player, and release the resources allocated to the player.</p></li>
        </ul>
    </li>
    <li>Multi-player
        <ul>
            <li><a href="#init_multiplayer">Initializing Multiple Players</a>
                <p>Initialize multiple players for use.</p></li>
            <li><a href="#play">Playing Multiple Files Simultaneously</a>
                <p>Play multiple files simultaneously.</p></li>
        </ul>
    </li>
</ul>

<h2>Follow-up</h2>

<p>Once we have learned the basics of the Player API, we can now move on to more advanced tasks, including:</p>

<ul>
    <li>Advanced player
        <ul>
            <li><a href="#set_parameters">Configuring the Video Playback Display</a>
                <p>Set the display parameters for playing a video file.</p></li>
            <li><a href="#get_stream">Retrieving Stream Information</a>
                <p>Retrieve information about the audio and video streams.</p></li>
            <li><a href="#insert">Inserting Subtitles</a>
                <p>Insert subtitles to a video file.</p></li>
        </ul>
    </li>
</ul>

<h2 id="init" name="init">Initializing the Player</h2>

<p>To initialize the player for use:</p>

<ol>

<li>
<p>To use the functions and data types of the Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;player.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;player.h&gt;
#include &lt;Elementary.h&gt;
#include &lt;glib.h&gt;
</pre>
<p>In this tutorial, you also need the <span style="font-family: Courier New,Courier,monospace">&lt;Elementary.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;glib.h&gt;</span> header files to set the display and use the Glib library functions.</p>
</li>

<li>
<p>Retrieve the default internal storage paths for audio and video files, and define the specific paths for the audio and video files to play. To access and use internal storage, include the <span style="font-family: Courier New,Courier,monospace;">storage.h</span> header file in your application.</p>
<pre class="prettyprint">
#define MP3_SAMPLE &quot;SampleAudio.mp3&quot;;
#define MP4_SAMPLE &quot;SampleVideo.mp4&quot;;

int internal_storage_id;
char *audio_storage_path = NULL;
char *video_storage_path = NULL;
char *audio_path = NULL;
char *video_path = NULL;

static bool
storage_cb(int storage_id, storage_type_e type, storage_state_e state,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *path, void *user_data)
{
&nbsp;&nbsp;&nbsp;if (type == STORAGE_TYPE_INTERNAL)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal_storage_id = storage_id;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}

void
_get_storage_path()
{
&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;char *path = NULL;

&nbsp;&nbsp;&nbsp;error_code = storage_foreach_device_supported(storage_cb, NULL);
&nbsp;&nbsp;&nbsp;error_code = storage_get_directory(internal_storage_id, STORAGE_DIRECTORY_MUSIC, &amp;path);
&nbsp;&nbsp;&nbsp;if (error_code != STORAGE_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_storage_path = strdup(path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;error_code = storage_get_directory(internal_storage_id, STORAGE_DIRECTORY_VIDEOS, &amp;path);
&nbsp;&nbsp;&nbsp;if (error_code != STORAGE_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video_storage_path = strdup(path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(path);
&nbsp;&nbsp;&nbsp;}
}

void
_set_test_path()
{
&nbsp;&nbsp;&nbsp;int path_len = 0;

&nbsp;&nbsp;&nbsp;path_len = strlen(audio_storage_path) + strlen(MP3_SAMPLE) + 1;
&nbsp;&nbsp;&nbsp;audio_path = malloc(path_len);
&nbsp;&nbsp;&nbsp;memset(audio_path, 0x0, path_len);

&nbsp;&nbsp;&nbsp;strncat(audio_path, audio_storage_path, strlen(audio_storage_path));
&nbsp;&nbsp;&nbsp;strncat(audio_path, MP3_SAMPLE, strlen(MP3_SAMPLE));

&nbsp;&nbsp;&nbsp;path_len = strlen(video_storage_path) + strlen(MP4_SAMPLE) + 1;
&nbsp;&nbsp;&nbsp;video_path = malloc(path_len);
&nbsp;&nbsp;&nbsp;memset(video_path, 0x0, path_len);

&nbsp;&nbsp;&nbsp;strncat(video_path, video_storage_path, strlen(video_storage_path));
&nbsp;&nbsp;&nbsp;strncat(video_path, MP4_SAMPLE, strlen(MP4_SAMPLE));
}
</pre>
</li>

<li id="init_handle" name="init_handle">
<p>Define a variable for the player handle, and create the handle by passing the variable to the <span style="font-family: Courier New,Courier,monospace;">player_create()</span> function. You need the handle for defining which file to play and with what playback settings. The following example code also creates buttons for the UI to control the playback.</p>
<pre class="prettyprint">
typedef struct
appdata
{
&nbsp;&nbsp;&nbsp;player_h player;
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;error_code = player_create(&amp;ad-&gt;player);
&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to create&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// Perform more playback configuration, such as setting callbacks,
&nbsp;&nbsp;&nbsp;// setting the source file URI, and preparing the player
}

static void
create_base_gui(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;// Create a window
&nbsp;&nbsp;&nbsp;// Create a button
&nbsp;&nbsp;&nbsp;// Add a callback to the button
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(button_init, &quot;clicked&quot;, init_base_player, ad);
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(button_end, &quot;clicked&quot;, release_base_player, ad);
&nbsp;&nbsp;&nbsp;// Create an Evas image object for the video surface
}

static void
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;create_base_gui(ad);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>
</li>

<li>

<p>To receive notifications, register the appropriate callbacks:</p>

<ul>

<li>
<p>To receive notifications about playback interruptions, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_interrupted_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_interrupted_cb(player_interrupted_coded_e code, void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;player_state_e state;

&nbsp;&nbsp;&nbsp;player_get_state(ad-&gt;player, &amp;state);
&nbsp;&nbsp; log_print(DLOG_INFO, LOG_TAG, &quot;current player state = %d&quot;, state);
&nbsp;&nbsp;&nbsp;// If the state is PLAYER_STATE_PAUSED, update UI (for example, button)
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;// Set an interruption callback if the application wants to know the reason
&nbsp;&nbsp;&nbsp;error_code = player_set_interrupted_cb(g_player, _player_interrupted_cb, ad);
&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to create&quot;);
}
</pre>
<p>The playback is interrupted and the callback triggered when, for example, another multimedia application is run. The player state automatically changes to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span> or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> according to the session policy. To get the current state, use the <span style="font-family: Courier New,Courier,monospace;">player_get_state()</span> function.</p>
</li>

<li>
<p>To receive a notification when the playback ends, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_completed_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_completed_cb(void *data)
{
&nbsp;&nbsp; dlog_print(DLOG_INFO, &quot;Player&quot;, &quot;Playback End&quot;);
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;// Set a completed callback if the application wants to know when the playback ends
&nbsp;&nbsp;&nbsp;error_code = player_set_completed_cb(g_player, _player_completed_cb, ad);

&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to set completed cb&quot;);
}
</pre>
</li>

<li>
<p>To receive notifications about player errors during playback, register a callback function using the <span style="font-family: Courier New,Courier,monospace;">player_set_error_cb()</span> function:</p>
<pre class="prettyprint">
static void
_player_error_cb(int error_code, void *user_data)
{
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, LOG_TAG, &quot;playback failed, error = %x&quot;, error_code);
}

static void
init_base_player(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;error_code = player_set_error_cb(g_player, _player_error_cb, NULL);
&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dlog_print(DLOG_ERROR, LOG_TAG, &quot;failed to set error cb&quot;);
}
</pre>
<p>The player error callback is triggered when the player stops working due to an error. You can use the callback to try to recover from the error. For example, try to change the player state to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> by calling the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> function. Then remove all other callbacks and reset the player by calling the <span style="font-family: Courier New,Courier,monospace;">player_unprepare()</span> function. At the end, the player is in the <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> state, so you can release the resources allocated to the player.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">Do not call the <span style="font-family: Courier New,Courier,monospace;">player_destroy()</span> function from the called context, as this can cause the <span style="font-family: Courier New,Courier,monospace;">PLAYER_ERROR_INVALID_OPERATION</span> error.</td>
        </tr>
    </tbody>
</table>
</li>

</ul>

</li>

</ol>

<h2 id="play_audio" name="play_audio">Playing an Audio File</h2>

<p>To play an audio file:</p>

<ol>

<li>
<p>After creating the player handle, specify the audio file to play using the <span style="font-family: Courier New,Courier,monospace;">player_set_uri()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_uri(ad-&gt;player, audio_path);
</pre>
</li>

<li>
<p>Prepare the player for playback using the <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare(ad-&gt;player);
</pre>
<p>The function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li>
<p>Start playing the audio file using the <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function:</p>
<pre class="prettyprint">
error_code = player_start(ad-&gt;player);
</pre>
<p>The function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>. The audio file plays until you call the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> or <span style="font-family: Courier New,Courier,monospace;">player_pause()</span> function.</p>
</li>

</ol>

<h2 id="play_video" name="play_video">Playing a Video File</h2>

<p>To play a video file:</p>

<ol>

<li>
<p>After creating the player handle, specify the video file to play using the <span style="font-family: Courier New,Courier,monospace;">player_set_uri()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_uri(ad-&gt;player, video_path);
</pre>
</li>

<li id="play_video_display" name="play_video_display">
<p>Set the display on which the video is played.</p>
<p>To retrieve the correct display handle, use the <span style="font-family: Courier New,Courier,monospace;">GET_DISPLAY()</span> function. To set the display, use the <span style="font-family: Courier New,Courier,monospace;">player_set_display()</span> function with the player handle, display type (a <span style="font-family: Courier New,Courier,monospace;">player_display_type_e</span> enumerator in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html#ga6b83386e10a8febc7e5dfbff85b342ab">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html#ga6b83386e10a8febc7e5dfbff85b342ab">wearable</a> applications), and display handle:</p>
<pre class="prettyprint">
error_code = player_set_display(g_player, PLAYER_DISPLAY_TYPE_OVERLAY, GET_DISPLAY(evas_obj));
</pre>
<p>After the <span style="font-family: Courier New,Courier,monospace;">player_set_display()</span> function has been successfully executed, the player is connected to the display.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">In case of an overlay surface, when the device orientation changes, the displayed video does not rotate automatically. If you want to change the video orientation according to the device orientation, use the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function within the <span style="font-family: Courier New,Courier,monospace;">app_device_orientation_cb()</span> callback function used by the application. In case of an Evas surface, the Evas object for the video is rotated by the window manager used by the application, not by the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function.</td>
        </tr>
    </tbody>
</table>
</li>

<li id="play_video_prepare" name="play_video_prepare">
<p>Prepare the player for playback using the <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare(ad-&gt;player);
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace;">player_prepare()</span> function works synchronously, so it can block the application execution. To prepare the player asynchronously instead, use the <span style="font-family: Courier New,Courier,monospace;">player_prepare_async()</span> function:</p>
<pre class="prettyprint">
error_code = player_prepare_async(ad-&gt;player, _prepared_cb, ad);
</pre>
<p>Both functions change the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li id="play_video_play" name="play_video_play">
<p>Play the video file:</p>
<ol type="a">
<li>
<p>Ensure that the player state has changed to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>. To check the state, use the <span style="font-family: Courier New,Courier,monospace;">player_get_state()</span> function in a waiting loop:</p>
<pre class="prettyprint">
player_state_e state;
do
{
&nbsp;&nbsp;&nbsp;error_code = player_get_state(ad-&gt;player, &amp;state);
&nbsp;&nbsp;&nbsp;if (error_code != PLAYER_ERROR_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;usleep(1000);
} while (state != PLAYER_STATE_READY);
</pre>
</li>
<li>
<p>Start playing the video file using the <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function:</p>
<pre class="prettyprint">
if (error_code == PLAYER_ERROR_NONE)
{
&nbsp;&nbsp;&nbsp;error_code = player_start(g_player);
}
</pre>
<p>If you used the <span style="font-family: Courier New,Courier,monospace;">player_prepare_async()</span> function to prepare the player, use the following callback function to handle the playback:</p>
<pre class="prettyprint">
static void
_prepared_cb(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;int error_code = 0;
&nbsp;&nbsp;&nbsp;error_code = player_start(ad-&gt;player);
}
</pre>
<p>The <span style="font-family: Courier New,Courier,monospace;">player_start()</span> function changes the player state from <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span> to <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>. The video file plays until you call the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> or <span style="font-family: Courier New,Courier,monospace;">player_pause()</span> function.</p>
</li>
</ol>
</li>

</ol>

<h2 id="release" name="release">Stopping the Player and Releasing Resources</h2>

<p>To stop the player and release the resources allocated to the player:</p>

<ol>

<li>
<p>Stop the player using the <span style="font-family: Courier New,Courier,monospace;">player_stop()</span> function:</p>
<pre class="prettyprint">
error_code = player_stop(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_stop() = %d&quot;, error_code);
</pre>
</li>

<li>
<p>Reset the player using the <span style="font-family: Courier New,Courier,monospace;">player_unprepare()</span> function:</p>
<pre class="prettyprint">
error_code = player_unprepare(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_unprepare() = %d&quot;, error_code);
</pre>
<p>After the player is reset, it is in the <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span> state.</p>
</li>

<li>
<p>Destroy the player handle using the <span style="font-family: Courier New,Courier,monospace;">player_destroy()</span> function:</p>
<pre class="prettyprint">
error_code = player_destroy(player);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_destroy = %d&quot;, error_code);
</pre>
</li>

</ol>

<h2 id="init_multiplayer" name="init_multiplayer">Initializing Multiple Players</h2>

<p>To initialize multiple players for use:</p>

<ol>

<li>
<p>To use the functions and data types of the Player API (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__MODULE.html">wearable</a> applications), include the <span style="font-family: Courier New,Courier,monospace">&lt;player.h&gt;</span> header file in your application:</p>
<pre class="prettyprint">
#include &lt;player.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</pre>
<p>In this tutorial, you also need the <span style="font-family: Courier New,Courier,monospace">&lt;stdio.h&gt;</span> and <span style="font-family: Courier New,Courier,monospace">&lt;unistd.h&gt;</span> header files to use standard file input and output functions and system calls.</p>
<p>To ensure that a Player function has been executed properly, make sure that the return value is equal to <span style="font-family: Courier New,Courier,monospace">PLAYER_ERROR_NONE</span>.</p>
</li>

<li>
<p>Define the variables for player handlers, player states, file paths, playback time, and return value:</p>
<pre class="prettyprint">
static player_h player_1, player_2, player_3;
static player_state_e state_1, state_2, state_3;
static int ret =0;
static char *path_1 = NULL;
static char *path_2 = NULL;
static char *path_3 = NULL;
char *resource_path = NULL;

resource_path = app_get_resource_path();
snprintf(path_1, sizeof(path_1)-1, &quot;%s/sample.3gp&quot;, resource_path);
snprintf(path_2, sizeof(path_2)-1, &quot;%s/test.wav&quot;, resource_path);
snprintf(path_3, sizeof(path_3)-1, &quot;%s/test2.wav&quot;, resource_path);
free(resource_path);

static const int PLAYBACK_TIME = 6;
</pre>
</li>

</ol>

<h2 id="play" name="play">Playing Multiple Files Simultaneously</h2>

<p>To play multiple files simultaneously:</p>

<ol>

<li>
<p>Create a player handle for each file using the <span style="font-family: Courier New,Courier,monospace">player_create()</span> function:</p>
<pre class="prettyprint">
ret = player_create(&amp;player_1);

ret = player_create(&amp;player_2);

ret = player_create(&amp;player_3);
</pre>
</li>

<li>
<p>Specify the files to play using the <span style="font-family: Courier New,Courier,monospace">player_set_uri()</span> function:</p>
<pre class="prettyprint">
ret = player_set_uri(player_1, path_1);

ret = player_set_uri(player_2, path_2);

ret = player_set_uri(player_3, path_3);
</pre>
</li>

<li>
<p>Prepare the players for playback using the <span style="font-family: Courier New,Courier,monospace">player_prepare()</span> function:</p>
<pre class="prettyprint">
ret = player_prepare(player_1);

ret = player_prepare(player_2);

ret = player_prepare(player_3);
</pre>
<p>The function changes the player states from <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_IDLE</span> to <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_READY</span>, which is required to start playback.</p>
</li>

<li>
<p>Play the files:</p>
<ol type="a">
<li>
<p>Ensure that the player states have changed to <span style="font-family: Courier New,Courier,monospace">PLAYER_STATE_READY</span>. To check the states, use the <span style="font-family: Courier New,Courier,monospace">player_get_state()</span> function in a waiting loop:</p>
<pre class="prettyprint">
// Wait to prepare player_1
ret = player_get_state(player_1, &amp;state_1);

while (state_1 != PLAYER_STATE_READY)
{
&nbsp;&nbsp;&nbsp;ret = player_get_state(player_1, &amp;state_1);

&nbsp;&nbsp;&nbsp;usleep(1000);
}

// Wait to prepare player_2
ret = player_get_state(player_2, &amp;state_2);

while (state_2 != PLAYER_STATE_READY)
{
&nbsp;&nbsp;&nbsp;ret = player_get_state(player_2, &amp;state_2);

&nbsp;&nbsp;&nbsp;usleep(1000);
}

// Wait to prepare player_3
ret = player_get_state(player_3, &amp;state_3);

while (state_3 != PLAYER_STATE_READY)
{
&nbsp;&nbsp;&nbsp;ret = player_get_state(player_3, &amp;state_3);

&nbsp;&nbsp;&nbsp;usleep(1000);
}
</pre>
</li>
<li>
<p>Start playing the files using the <span style="font-family: Courier New,Courier,monospace">player_start()</span> function:</p>
<pre class="prettyprint">
ret = player_start(player_1);

ret = player_start(player_2);

ret = player_start(player_3);
</pre>
</li>
</ol>
</li>

<li>
<p>After the playback has ended or been stopped, reset the players and destroy the player handles using the <span style="font-family: Courier New,Courier,monospace">player_unprepare()</span> and <span style="font-family: Courier New,Courier,monospace">player_destroy()</span> functions:</p>
<pre class="prettyprint">
ret = player_unprepare(player_1);
ret = player_destroy(player_1);

ret = player_unprepare(player_2);
ret = player_destroy(player_2);

ret = player_unprepare(player_3);
ret = player_destroy(player_3);
</pre>
</li>

</ol>

<h2 id="set_parameters" name="set_parameters">Configuring the Video Playback Display</h2>

<p>To set the display parameters for playing a video file:</p>

<ol>

<li><p>Make sure that the <a href="#init_handle">player handle has been created</a>, the <a href="#play_video_display">display set</a>, and the <a href="#play_video_prepare">player prepared</a> and <a href="#play_video_play">started</a>.</p></li>

<li>

<p>During playback, you can manage the display settings as needed:</p>

<ul>

<li>
<p>Make the display visible:</p>
<ol type="a">
<li>
<p>Check whether the display is already visible using the <span style="font-family: Courier New,Courier,monospace;">player_is_display_visible()</span> function:</p>
<pre class="prettyprint">
bool is_visible;

error_code = player_is_display_visible(player, &amp;is_visible);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_is_display_visible = %d&quot;, error_code);
</pre>
</li>
<li>
<p>If the display is not visible, make it visible using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_visible()</span> function with the second parameter set to <span style="font-family: Courier New,Courier,monospace;">true</span>:</p>
<pre class="prettyprint">
if (!is_visible)
{
&nbsp;&nbsp;&nbsp;error_code = player_set_display_visible(player, true);
&nbsp;&nbsp; dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_visible = %d&quot;, error_code);
}
</pre>
</li>
</ol>
</li>

<li>
<p>Set the display mode using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_mode()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_display_mode(player, PLAYER_DISPLAY_MODE_FULL_SCREEN);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
<p>The available display modes are defined in the <span style="font-family: Courier New,Courier,monospace;">player_display_mode_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gaafcf6f7487d8cb376e1851a6e1253f3a">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gaafcf6f7487d8cb376e1851a6e1253f3a">wearable</a> applications).</p>
</li>

<li>
<p>Set the display rotation using the <span style="font-family: Courier New,Courier,monospace;">player_set_display_rotation()</span> function:</p>
<pre class="prettyprint">
error_code = player_set_display_rotation(player, PLAYER_DISPLAY_ROTATION_90);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
<p>The available display rotations are defined in the <span style="font-family: Courier New,Courier,monospace;">player_display_rotation_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gab8c4c170d4b2628a09831edc8d652302">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__DISPLAY__MODULE.html#gab8c4c170d4b2628a09831edc8d652302">wearable</a> applications).</p>
</li>

</ul>

</li>

</ol>

<h2 id="get_stream" name="get_stream">Retrieving Stream Information</h2>

<p>To retrieve information about the audio and video streams:</p>

<ol>

<li>
<p><a href="#init_handle">Create the player handle</a>, <a href="#play_video">prepare and start the player</a>, and <a href="#set_parameters">set the display parameters</a>.</p>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">To retrieve the stream information, the player state must be either <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span> or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span>.</td>
        </tr>
    </tbody>
</table>
</li>

<li>
<p>Retrieve the stream information:</p>
<ul>
<li>
<p>Video display size</p>
<p>Retrieve the width and height of the video display using the <span style="font-family: Courier New,Courier,monospace;">player_get_video_size()</span> function:</p>
<pre class="prettyprint">
int width, height;

error_code = player_get_video_size(player, &amp;width, &amp;height);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_is_display_visible = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Duration</p>
<p>Retrieve the total media running time (in milliseconds) using the <span style="font-family: Courier New,Courier,monospace;">player_get_duration()</span> function:</p>
<pre class="prettyprint">
int duration;

error_code = player_get_duration(player, &amp;duration);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_duration = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Audio stream details</p>
<p>Retrieve the audio stream details using the <span style="font-family: Courier New,Courier,monospace;">player_get_audio_stream_info()</span> function. The function returns the audio sample rate (in Hz), number of audio channels (1 for mono or 2 for stereo), and audio bit rate (in Hz).</p>
<pre class="prettyprint">
int sample_rate, channels, bit_rate;

error_code = player_get_audio_stream_info(player, &amp;sample_rate, &amp;channels, &amp;bit_rate);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_audio_stream_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Video stream details</p>
<p>Retrieve the video stream details using the <span style="font-family: Courier New,Courier,monospace;">player_get_video_stream_info()</span> function. The function returns the number of frames per second and the video bit rate (in Hz).</p>
<pre class="prettyprint">
int fps, bit_rate;

error_code = player_get_video_stream_info(player, &amp;fps, &amp;bit_rate);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_video_stream_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Audio and video codec names</p>
<p>Retrieve the audio and video codec names using the <span style="font-family: Courier New,Courier,monospace;">player_get_codec_info()</span> function:</p>
<pre class="prettyprint">
char *audio_codec;
char *video_codec;

error_code = player_get_codec_info(player, &amp;audio_codec, &amp;video_codec);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_codec_info = %d&quot;, error_code);
</pre>
</li>
<li>
<p>Content metadata</p>
<p>Retrieve information about the album, artist, author, genre, title, and year using the <span style="font-family: Courier New,Courier,monospace;">player_get_content_info()</span> function. The available metadata attributes are defined in the <span style="font-family: Courier New,Courier,monospace;">player_content_info_e</span> enumeration (in <a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MEDIA__PLAYER__STREAM__INFO__MODULE.html#ga2d25f300270965c3ea302b7a7e845f12">mobile</a> and <a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__MEDIA__PLAYER__STREAM__INFO__MODULE.html#ga2d25f300270965c3ea302b7a7e845f12">wearable</a> applications).</p>

<pre class="prettyprint">
char *album, *artist, *author, *genre, *title, *year;

error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_ALBUM, &amp;album);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info album = %d&quot;, album);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_ARTIST, &amp;artist);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info artist = %d&quot;, artist);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_AUTHOR, &amp;author);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info author = %d&quot;, author);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_GENRE, &amp;genre);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info genre = %d&quot;, genre);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_TITLE, &amp;title);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info title = %d&quot;, title);
error_code = player_get_content_info(player, PLAYER_CONTENT_INFO_YEAR, &amp;year);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_get_content_info year = %d&quot;, year);
</pre>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">The values must be released using the <span style="font-family: Courier New,Courier,monospace;">free()</span> function.</td>
        </tr>
    </tbody>
</table>
</li>
<li>
<p>Album artwork</p>
<p>Retrieve the album artwork using the <span style="font-family: Courier New,Courier,monospace;">player_get_album_art()</span> function. The function returns the encoded artwork image and size.</p>
<pre class="prettyprint">
void *album_art;
int size;

error_code = player_get_album_art(player, &amp;album_art, &amp;size);
dlog_print(DLOG_INFO, LOG_TAG, &quot;player_set_display_mode = %d&quot;, error_code);
</pre>
</li>
</ul>
</li>

</ol>

<h2 id="insert" name="insert">Inserting Subtitles</h2>

<p>To insert subtitles to a video file:</p>

<ol>

<li><p><a href="#init_handle">Create the player handle.</a></p></li>

<li>
<p>Set the subtitle path using the <span style="font-family: Courier New,Courier,monospace;">player_set_subtitle_path()</span> function:</p>
<pre class="prettyprint">
#define SUBTITLE &quot;subtitles_test_file.srt&quot;

char *data_path = app_get_data_path();
int path_len = strlen(data_path) + 10;
char *path = malloc(path_len);
strncat(path, data_path, path_len);
strncat(path, SUBTITLE, path_len);

error_code = player_set_subtitle_path(player, path);
dlog_print(DLOG_ERROR, LOG_TAG, &quot;player_set_subtitle_path() = %d&quot;, error_code);
free(path);
</pre>
<table class="note">
    <tbody>
        <tr>
            <th class="note">Note</th>
        </tr>
        <tr>
            <td class="note">You can set the subtitle path when the player state is <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_IDLE</span>, <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_READY</span>, <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PLAYING</span>, or <span style="font-family: Courier New,Courier,monospace;">PLAYER_STATE_PAUSED</span>.</td>
        </tr>
    </tbody>
</table>
</li>

</ol>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
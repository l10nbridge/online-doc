<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>Genlist: Managing Large Element Sets</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">
	
<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Wearable native" src="../../images/wn_icon.png"/></p>
	</div>
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
			<li>Set-up
				<ul class="toc">
					<li><a href="#genlist_application_init">Initializing the Application</a></li>
					<li><a href="#genlist_creation">Creating a Genlist</a></li>
					<li><a href="#entries_creation">Adding New Entries</a></li>
				</ul>
			</li>
			<li>Modifications
				<ul class="toc">
					<li><a href="#item_style">Choosing Another Item Style to Add or Remove Parts</a></li>
					<li><a href="#item_modes">Using Item Modes</a></li>
					<li><a href="#other_apis">Using Other APIs</a></li>
				</ul>
			</li>
		</ul>		
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			<li><a href="../../../../org.tizen.guides/html/native/ui/components_wn.htm#genlist">Genlist Guide for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Elementary.html">Elementary API for Wearable Native</a></li>
			<li><a href="../../../../org.tizen.native.wearable.apireference/group__Evas.html">Evas API for Wearable Native</a></li>			
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">
<h1>Genlist: Managing Large Element Sets</h1>

<p>This tutorial deals with genlists, a list component for large sets of elements. It uses callbacks to populate entries. The same UI component handles both flat lists and trees.</p>

 <table class="note"> 
<tbody> 
    <tr> 
     <th class="note">Note</th> 
    </tr> 
    <tr> 
     <td class="note">This feature is supported in wearable applications only.</td> 
    </tr> 
   </tbody> 
  </table>

<h2>Warm-up</h2>
<p>Become familiar with the Elementary and Evas API basics by learning about:</p>
	<ul>
		<li>Set-up
			<ul>
				<li><a href="#genlist_application_init">Initializing the Application</a>
				<p>Initialize the application for use.</p></li>
				<li><a href="#genlist_creation">Creating a Genlist</a>
				<p>Create a genlist.</p></li>
				<li><a href="#entries_creation">Adding New Entries</a>
				<p>Add new entries to the list.</p></li>
			</ul>
		</li>
		<li>Modifications
			<ul>
				<li><a href="#item_style">Choosing Another Item Style to Add or Remove Parts</a>
				<p>Customize your list.</p></li>
				<li><a href="#item_modes">Using Item Modes</a>
				<p>Use different list modes in your application.</p></li>
				<li><a href="#other_apis">Using Other APIs</a>
				<p>Change the item class and size of the genlist.</p></li>
			</ul>
		</li>
	</ul>

 <h2 id="genlist_application_init" name="genlist_application_init">Initializing the Application</h2>

   <p class="figure">Figure: Example of a genlist</p> 
   <p align="center"><img alt="Example of a genlist" src="../../images/genlist_wn.png" /></p>
  <p>The code below shows a typical elementary application that creates a window entitled &quot;Genlist Basic Tutorial&quot;. It is consisted of a conformant component that contains a naviframe component. The genlist goes inside the naviframe.</p>
<pre class="prettyprint">static bool
_app_create(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *app = data;

&nbsp;&nbsp;&nbsp;app-&gt;win = elm_win_util_standard_add(&quot;main&quot;, &quot;Genlist Basic Tutorial&quot;);
&nbsp;&nbsp;&nbsp;elm_win_conformant_set(app-&gt;win, EINA_TRUE);
&nbsp;&nbsp;&nbsp;evas_object_show(app-&gt;win);
&nbsp;&nbsp;&nbsp;evas_object_resize(app-&gt;win, 480, 800);
&nbsp;&nbsp;&nbsp;elm_win_autodel_set(app-&gt;win, EINA_TRUE);

&nbsp;&nbsp;&nbsp;app-&gt;conformant = elm_conformant_add(app-&gt;win);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(app-&gt;conformant, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;elm_win_resize_object_add(app-&gt;win, app-&gt;conformant);
&nbsp;&nbsp;&nbsp;evas_object_show(app-&gt;conformant);

&nbsp;&nbsp;&nbsp;app-&gt;naviframe = elm_naviframe_add(app-&gt;win);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(app-&gt;naviframe, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;elm_win_resize_object_add(app-&gt;win, app-&gt;naviframe);
&nbsp;&nbsp;&nbsp;evas_object_show(app-&gt;naviframe);
&nbsp;&nbsp;&nbsp;elm_object_content_set(app-&gt;conformant, app-&gt;naviframe);

&nbsp;&nbsp;&nbsp;_create_list(app);
&nbsp;&nbsp;&nbsp;elm_naviframe_item_push(app-&gt;naviframe, NULL, NULL, NULL, app-&gt;list, NULL);

&nbsp;&nbsp;&nbsp;return true;
}

int
main(int argc, char **argv)
{
&nbsp;&nbsp;&nbsp;// Declare a few structures and zero-initialize (C99 feature)
&nbsp;&nbsp;&nbsp;struct app_data app = { 0 };
&nbsp;&nbsp;&nbsp;ui_app_lifecycle_callback_s event_callback = { 0 };

&nbsp;&nbsp;&nbsp;event_callback.create = _app_create;

&nbsp;&nbsp;&nbsp;// Run the mainloop
&nbsp;&nbsp;&nbsp;return ui_app_main(&amp;argc, &amp;argv, &amp;event_callback, &amp;ad);
}
</pre>
<p> The declaration of the <span style="font-family: Courier New,Courier,monospace">struct app_data</span> is shown below:</p>
<pre class="prettyprint">struct app_data
{
&nbsp;&nbsp;&nbsp;Evas_Object *win;
&nbsp;&nbsp;&nbsp;Evas_Object *naviframe;
&nbsp;&nbsp;&nbsp;Evas_Object *conformant;
&nbsp;&nbsp;&nbsp;Evas_Object *list;
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *itc;
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *itc2;
};
</pre>

 <h2 id="genlist_creation" name="genlist_creation">Creating a Genlist</h2>

<p>Call <span style="font-family: Courier New,Courier,monospace">elm_genlist_add()</span> to create a genlist. Then new entries can be added. In this example, first the basic windows is created, then a genlist is added to it, and then 10000 elements with text and a colored block on each side of it.</p>
<pre class="prettyprint">Evas_Object *list = elm_genlist_add(parent);
</pre>

 <h2 id="entries_creation" name="entries_creation">Adding New Entries</h2>

<p>Use <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> to add new elements. Its second parameter is a structure which describes how to populate entries. Typically this structure is built once and re-used across calls to <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span>.</p>
<h3 id="elm_genlist_item_class_new" name="elm_genlist_item_class_new">
Building a Basic Item Class</h3>
<p>The code for the minimal genlist item class is below: </p>

<pre class="prettyprint">Elm_Genlist_Item_Class *itc = elm_genlist_item_class_new();
itc-&gt;item_style = &quot;default&quot;;
itc-&gt;func.text_get = NULL;
itc-&gt;func.content_get = NULL;
itc-&gt;func.state_get = NULL;
itc-&gt;func.del = NULL;
</pre>

<p>It creates a simple item class, sets the <span style="font-family: Courier New,Courier,monospace">item_style</span> to &quot;default&quot; and every other field to NULL. However, this leaves out the <span style="font-family: Courier New,Courier,monospace">text_get</span> and <span style="font-family: Courier New,Courier,monospace">content_get</span> fields which are used to add text and an icon to the list entry. This is explained in another section.</p>
<h3 id="elm_genlist_item_append" name="elm_genlist_item_append">Adding the Element</h3>
<p>Once the genlist item class object is created, a new element is added to the list by calling <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span>. </p>
<pre class="prettyprint">elm_genlist_item_append(list,
&nbsp;&nbsp;&nbsp;itc,
&nbsp;&nbsp;&nbsp;NULL,                    // Item data
&nbsp;&nbsp;&nbsp;NULL,                    // Parent item for trees, NULL if none
&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,   // Item type; this is the common one
&nbsp;&nbsp;&nbsp;NULL,                    // Callback on selection of the item
&nbsp;&nbsp;&nbsp;NULL                     // Data for that callback function
);
</pre>
<p>With most parameters as NULL and <span style="font-family: Courier New,Courier,monospace">itc</span> having most of its members NULL, too, the elements of that list are blank and will not trigger anything when selected. This shows the APIs that are used.</p>
<h3 id="text_get" name="text_get">Text in the List Elements</h3>
<p> Use <span style="font-family: Courier New,Courier,monospace">text_get</span> callback to add text in the elements in the <span style="font-family: Courier New,Courier,monospace">Elm_Genlist_Item_Class</span> structure. These callbacks must have a prototype matching to the following: </p>

<pre class="prettyprint">char * text_get(void *data, Evas_Object *obj, const char *part);
</pre>
<p>This callbacks returns a C string that is displayed in the part named after the <span style="font-family: Courier New,Courier,monospace">part</span> parameter. This callback is called for each user-settable text part according to the current theme.</p>
<p>If you are not familiar with the concept of parts in the EFLs,  read the <a href="../../../../org.tizen.guides/html/native/ui/edje_n.htm#simple_edc_file">Write a Simple EDC File</a> section.</p>


  <table class="note"> 
   <tbody> 
  <tr> 
   <th class="note">Note</th> 
  </tr> 
  <tr> 
   <td class="note">The value returned is freed by the EFLs: the value must be freshly-allocated, do not free it yourself and do not re-use it across list elements.</td> 
  </tr> 
   </tbody> 
  </table> 

<p>For the default theme there is one part named <span style="font-family: Courier New,Courier,monospace">elm.text</span>. A possible implementation of the <span style="font-family: Courier New,Courier,monospace">text_get</span> callback is therefore: </p>
<pre class="prettyprint">static char *
_genlist_text_get(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;// Check this is text for the part we&#39;re expecting
&nbsp;&nbsp;&nbsp;if (strcmp(part, &quot;elm.text&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(&quot;Some text&quot;);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;}
}
</pre>

  <table class="note"> 
   <tbody> 
  <tr> 
   <th class="note">Note</th> 
  </tr> 
  <tr> 
   <td class="note">The names and positions of parts depends on the <span style="font-family: Courier New,Courier,monospace">item_style</span> chosen when adding new items to the genlist. Setting a custom theme makes it possible to completely change genlists by adding and moving parts. The <a href="../../../../org.tizen.guides/html/native/ui/edje_n.htm">Edje</a> guide explains how to do that.</td> 
  </tr> 
   </tbody> 
  </table> 

<p>The <span style="font-family: Courier New,Courier,monospace">data</span> parameter makes it possible to behave differently according to data that is given to the EFLs during the call to <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> in the <span style="font-family: Courier New,Courier,monospace">data</span> parameter. For example, given an integer in that field through casting with <span style="font-family: Courier New,Courier,monospace">(void *)(uintptr_t) i</span>, it is possible to get its value back using <span style="font-family: Courier New,Courier,monospace">(int)(uintptr_t)data</span>:</p>
<pre class="prettyprint">static char *
_genlist_text_get(void *data, Evas_Object *obj__UNUSED__, const char *part)
{
&nbsp;&nbsp;&nbsp;if (strcmp(part, &quot;elm.text&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char *buf = malloc(16);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf, 16, &quot;Entry %d.&quot;, (int)(uintptr_t)data);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return buf;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;}
}
</pre> 

<h3 id="content_get" name="content_get">Evas_Objects in the List Elements</h3>
<p>Icons are added in a similar fashion: there is a callback named <span style="font-family: Courier New,Courier,monospace">content_get</span> which returns a pointer to an <span style="font-family: Courier New,Courier,monospace">Evas_Object</span> and is called for each part which contents can be set.</p>
<p>The prototype of the callback must match this one: </p>
<pre class="prettyprint">Evas_Object * content_get(void *data, Evas_Object *obj, const char *part);
</pre>

<p>The only difference with the <span style="font-family: Courier New,Courier,monospace">text_get</span> callback is that it returns an <span style="font-family: Courier New,Courier,monospace">Evas_Object*</span> rather than a <span style="font-family: Courier New,Courier,monospace">char *</span>.</p>
<p>This leads to a fairly simple dummy implementation with colored rectangles in the parts that are to be set:</p>
<pre class="prettyprint">
static Evas_Object *
_genlist_content_get(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;int i = (int) (uintptr_t) data;

&nbsp;&nbsp;&nbsp;if (strcmp(part, &quot;elm.swallow.icon&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *bg = elm_bg_add(obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_bg_color_set(bg, 255 * cos(i / (double) 10), 0, i % 255);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bg;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else if (strcmp(part, &quot;elm.swallow.end&quot;) == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evas_Object *bg = elm_bg_add(obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_bg_color_set(bg, 0, 255 * sin(i / (double) 10), i % 255);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bg;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
&nbsp;&nbsp;&nbsp;}
}
</pre>
<p> For the default theme, this displays a red rectangle on the left of each list item and a green one on their right.</p>
<h3 id="state_get" name="state_get">Events on Genlist Items</h3>

  <table class="note"> 
   <tbody> 
  <tr> 
   <th class="note">Note</th> 
  </tr> 
  <tr> 
   <td class="note">The swallow parts have no minimum size. This means that if you do not fix the minimum size, the part cannot be seen.</td> 
  </tr> 
   </tbody> 
  </table> 

<p>Genlist items triggers a callback when clicked. This callback is chosen when adding the new item (for example, when calling <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span>):</p>
<pre class="prettyprint">elm_genlist_item_append(list,
&nbsp;&nbsp;&nbsp;itc,
&nbsp;&nbsp;&nbsp;NULL,                    // item data
&nbsp;&nbsp;&nbsp;NULL,                    // parent item for trees, NULL if none
&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,   // item type, other values are used for trees
&nbsp;&nbsp;&nbsp;_genlist_selected_cb,      // callback on selection of the item
&nbsp;&nbsp;&nbsp;NULL                     // data for that callback function
);
</pre>

<p>This callback adheres to the following prototype: </p>
<pre class="prettyprint">void _contact_selected_cb(void *data, Evas_Object *obj, void *event_info)
</pre>

<p>The implementation below changes the item style of items when they are selected:</p>
<pre class="prettyprint">static void
_genlist_selected_cb(void *data, Evas_Object *obj, void *event_info)
{
&nbsp;&nbsp;&nbsp;appdata_s *app = data;

&nbsp;&nbsp;&nbsp;Elm_Object_Item *it = (Elm_Object_Item*) event_info;

&nbsp;&nbsp;&nbsp;elm_genlist_item_item_class_update(it, app-&gt;itc2);
}
</pre>

	<h2 id="item_style" name="item_style">Choosing Another Item Style to Add or Remove Parts</h2>
 
<p>As mentioned above, the number of parts to fill depends on the item style that is chosen when adding a new item. This is simply a matter of setting the right value when filling the <span style="font-family: Courier New,Courier,monospace">Elm_Genlist_Item_Class</span> struct: </p>
<pre class="prettyprint">app-&gt;itc-&gt;item_style = &quot;default&quot;;
</pre>
<p>The <a href="../../../../org.tizen.guides/html/native/ui/components_wn.htm#genlist">Genlist</a> component lists all available item styles.</p>
<p>Further customization is achieved by modifying the theme as explained in the <a href="../../../../org.tizen.guides/html/native/ui/edje_n.htm">Edje</a> guide.</p>
<p>In case the customization is only visual, it is good practice to keep the same item style names for new themes. This makes it possible to change theme and keep the code the same while also retaining the same overall item placement.</p>

 <h2 id="item_modes" name="item_modes">Using Item Modes</h2>

<p>So far the genlist examples have all featured bare lists while the genlist component is able to display trees or even a &quot;group&quot; mode where scrolling keeps the item at the top of the UI component until another group comes and replaces it.</p>
<h3 id="item_group" name="item_group">Group Mode</h3>
<p>The group mode makes it possible to keep an element visible as long as one of its children is visible. This is most useful for &quot;title&quot; items.</p>
<p>Mark some elements as <span style="font-family: Courier New,Courier,monospace">ELM_GENLIST_ITEM_GROUP</span> and use the returned <span style="font-family: Courier New,Courier,monospace">Elm_Object_Item</span> to establish the parent-children relationship when adding the children items.</p>
<p>Since there are two kind of items, create two item classes. Give them different styles and callback functions. The callback functions are visible in the example, they have no functionalities:</p>
<pre class="prettyprint">
app-&gt;itc = elm_genlist_item_class_new();
app-&gt;itc-&gt;item_style = &quot;default&quot;;
app-&gt;itc-&gt;func.text_get = _genlist_text_get_size;
app-&gt;itc-&gt;func.content_get = _genlist_content_get_bg;
app-&gt;itc-&gt;func.state_get = NULL;
app-&gt;itc-&gt;func.del = NULL; 

app-&gt;itc2 = elm_genlist_item_class_new();
app-&gt;itc2-&gt;item_style = &quot;1text.1icon&quot;;
app-&gt;itc2-&gt;func.text_get = _genlist_text_get_nosize;
app-&gt;itc2-&gt;func.content_get = _genlist_content_get_icon;
app-&gt;itc2-&gt;func.state_get = NULL;
app-&gt;itc2-&gt;func.del = NULL; 
</pre>

<p> Then add a group header and follow it with 10 children. This is repeated 1000 times.</p>
<p>The parent has type <span style="font-family: Courier New,Courier,monospace">ELM_GENLIST_ITEM_GROUP</span> while the children have type <span style="font-family: Courier New,Courier,monospace">ELM_GENLIST_ITEM_NONE</span>.</p>
<p>The other important point is that the value returned by <span style="font-family: Courier New,Courier,monospace">lm_genlist_item_append()</span> is stored in it and then sent to the <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> call that adds the children. This creates the parent-children relationship.</p>
<pre class="prettyprint">
for (i = 0; i &lt; 1000; i++) 
{
&nbsp;&nbsp;&nbsp;it = elm_genlist_item_append(app-&gt;list, app-&gt;itc2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)(uintptr_t) (10 * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_GROUP,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL
&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; 10; j++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_genlist_item_append(app-&gt;list, app-&gt;itc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)(uintptr_t) (10 * i + j),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<h3 id="item_tree" name="item_tree">Tree Mode</h3>
<p>Like group mode, tree mode uses the parenting relationship with other items. Unlike group mode, the child elements are created on-demand when their parent is expanded and deleted when it is contracted. This is done by using smart callbacks: <span style="font-family: Courier New,Courier,monospace">expand,request</span>, <span style="font-family: Courier New,Courier,monospace">expanded</span>, <span style="font-family: Courier New,Courier,monospace">contract,request</span>, and <span style="font-family: Courier New,Courier,monospace">contracted</span>. Like any smart callback, they are registered through <span style="font-family: Courier New,Courier,monospace">evas_object_smart_callback_add</span> on the genlist object:</p>
<pre class="prettyprint">evas_object_smart_callback_add(app-&gt;list, &quot;expand,request&quot;,
&nbsp;&nbsp;&nbsp;_tree_item_expand_request, NULL);
evas_object_smart_callback_add(app-&gt;list, &quot;expanded&quot;,
&nbsp;&nbsp;&nbsp;_tree_item_expanded, NULL);

evas_object_smart_callback_add(app-&gt;list, &quot;contract,request&quot;,
&nbsp;&nbsp;&nbsp;_tree_item_contract_request, NULL);
evas_object_smart_callback_add(app-&gt;list, &quot;contracted&quot;,
&nbsp;&nbsp;&nbsp;_tree_item_contracted, NULL);
</pre>

<p> The callbacks <span style="font-family: Courier New,Courier,monospace">expand,request</span> and <span style="font-family: Courier New,Courier,monospace">contract,request</span> do only one thing: decide whether the element is expanded or contracted. This is done by using <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_expanded_set()</span> function; if it changes the expansion status of the item, the next callback is called (either <span style="font-family: Courier New,Courier,monospace">expanded</span> or <span style="font-family: Courier New,Courier,monospace">contracted</span>, depending on whether it was an <span style="font-family: Courier New,Courier,monospace">expand,request</span> or <span style="font-family: Courier New,Courier,monospace">contract,request</span> event). A minimal implementation of these callbacks is therefore:</p>
<pre class="prettyprint">
static void
_tree_item_expand_request(void *data, Evas_Object *o, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it = (Elm_Object_Item*) event_info;

&nbsp;&nbsp;&nbsp;elm_genlist_item_item_class_update(it, app-&gt;itc2);

&nbsp;&nbsp;&nbsp;elm_genlist_item_expanded_set(it, EINA_TRUE);
}
</pre>

  <table class="note"> 
   <tbody> 
  <tr> 
   <th class="note">Note</th> 
  </tr> 
  <tr> 
   <td class="note">The example above has an extra line: the call to <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_item_class_update()</span>. It changes the item style and is explained in the <a href="#item_class_update">Changing the item class of an item after its creation</a> section.</td> 
  </tr> 
   </tbody> 
  </table> 

<pre class="prettyprint">
static void
_tree_item_contract_request(void *data, Evas_Object *o, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it = (Elm_Object_Item*) event_info;

&nbsp;&nbsp;&nbsp;elm_genlist_item_item_class_update(it, app-&gt;itc);

&nbsp;&nbsp;&nbsp;elm_genlist_item_expanded_set(it, EINA_FALSE);
}
</pre>

<p> As said above, once the genlist item status is set to expanded, the <span style="font-family: Courier New,Courier,monospace">expanded</span> event is triggered and it is the duty of a callback for that event to populate the list with the item&#39;s children. This relies on the <span style="font-family: Courier New,Courier,monospace">parent</span> parameter of functions like <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span>, like for the group mode.</p>
<p>The function below is a callback implementation for the <span style="font-family: Courier New,Courier,monospace">expanded</span> event. It adds items that are built similarly to previous items, the only change is the parent parameter which is not NULL. Conveniently, the parent <span style="font-family: Courier New,Courier,monospace">Elm_Object_Item</span> pointer that is passes to the <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> function is given in the <span style="font-family: Courier New,Courier,monospace">event_info</span> callback and needs to be cast.</p>
<pre class="prettyprint">static void
_tree_item_expanded(void *data, Evas_Object *o, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it_parent = (Elm_Object_Item*) event_info;
&nbsp;&nbsp;&nbsp;int i_parent = (int)(uintptr_t) data;
&nbsp;&nbsp;&nbsp;int i;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; 10; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elm_genlist_item_append(app-&gt;list, app-&gt;itc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void *)(uintptr_t) (i + i_parent),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it_parent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>The following code has the callback function for the <span style="font-family: Courier New,Courier,monospace">contracted</span> event. It imply calls <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_subitems_clear()</span> to clear all children (including their own children if they have any) of the given item. Again, the item that is being contracted is available through the <span style="font-family: Courier New,Courier,monospace">event_info</span> parameter to the callback.</p>
<pre class="prettyprint">static void
_tree_item_contracted(void *data, Evas_Object *o, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it_parent = (Elm_Object_Item*) event_info;

&nbsp;&nbsp;&nbsp;elm_genlist_item_subitems_clear(it_parent);
}
</pre>

<h3 id="item_group_tree" name="item_group_tree">Mixing Group and Tree Modes</h3>
<p>A common UI design is to mix group and tree modes. It allows for a tree behavior while also keeping the group header item. The EFLs do not do any magic here and the way to get such a behavior is to create an item of type group, an item of type tree which parent is the group item. Then add the callbacks to populate the children of the tree item in the regular way.</p>

 <h2 id="other_apis" name="other_apis">Using Other APIs</h2>

<h3 id="homogeneous_set" name="homogeneous_set">Homogeneous Item Size</h3>
<p>Because of the scroller, the actual height and/or width of the genlist must be computed. This means summing the sizes of all the items, the sizes must be computed. This obviously has a cost and slows down adding items to the genlist.</p>
<p>The <span style="font-family: Courier New,Courier,monospace">elm_genlist_homogeneous_set()</span> function alleviates this issue by assuming all the items are the same size as the first one of the list. It speeds up large insertions. However, it may lead to serious graphical issues if the items are not actually the same size. Use with care.</p>

<h3 id="item_class_update" name="item_class_update">Changing the Item Class of an Item After Its Creation</h3>
<p>Changing the item class of a UI component is an easy way to change its appearance upon selection or other actions of the user. This is done by calling <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_class_update()</span>:</p>
<pre class="prettyprint">static void
_tree_item_expand_request(void *data, Evas_Object *o, void *event_info)
{
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it = (Elm_Object_Item*) event_info;

&nbsp;&nbsp;&nbsp;// Change the appearance and possibly content of the item being expanded.
&nbsp;&nbsp;&nbsp;elm_genlist_item_item_class_update(it, app-&gt;itc2);

&nbsp;&nbsp;&nbsp;elm_genlist_item_expanded_set(it, EINA_TRUE);
}
</pre>

<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>	

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>

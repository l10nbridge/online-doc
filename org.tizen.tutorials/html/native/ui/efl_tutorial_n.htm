<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=9" />
	<link rel="stylesheet" type="text/css" href="../../css/styles.css" />
	<link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
	<script type="text/javascript" src="../../scripts/snippet.js"></script>	
	<script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
	<script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

	<title>EFL: Using EFL Features for Designing the UI</title>  
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="toc-navigation">
	<div id="profile">
		<p><img alt="Mobile native" src="../../images/mn_icon.png"/> <img alt="Wearable native" src="../../images/wn_icon.png"/></p>
	</div>
	
	<div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
		  <li><a href="#basic">Learning EFL Basics</a></li>	
		  <li><a href="#native">Using EFL in Tizen Native Applications</a></li>
		  <li><a href="#layout">Using the Base Application Layout</a></li>
		  <li><a href="#ClockSimple">Creating a Simple Clock View</a></li>
		  <li><a href="#ClockComplex">Creating a Complex Clock View</a></li>
		</ul>
		<p class="toc-title">Related Info</p>
		<ul class="toc">
			  <li><a href="../../../../org.tizen.guides/html/native/ui/efl_n.htm">EFL Guide</a></li>	
			  <li><a href="../../../../org.tizen.native.mobile.apireference/group__EFL__Group.html">EFL API for Mobile Native</a></li>
			  <li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__EFL__EXTENSION__MODULE.html">Efl Extension API for Mobile Native</a></li>	
			  <li><a href="../../../../org.tizen.native.mobile.apireference/group__Elementary.html">Elementary API for Mobile Native</a></li>
			  <li><a href="../../../../org.tizen.native.wearable.apireference/group__EFL__Group.html">EFL API for Wearable Native</a></li>
			  <li><a href="../../../../org.tizen.native.wearable.apireference/group__CAPI__EFL__EXTENSION__MODULE.html">Efl Extension API for Wearable Native</a></li>	
			  <li><a href="../../../../org.tizen.native.wearable.apireference/group__Elementary.html">Elementary API for Wearable Native</a></li>			  
		</ul>
	</div></div>
</div>	

<div id="container"><div id="contents"><div class="content">

<h1>EFL: Using EFL Features for Designing the UI</h1>


<p>This tutorial demonstrates how you can use EFL to create your application UI. EFL is an open-source toolkit that provides a set of libraries that offer useful features to applications. EFL covers a number of areas from data structures to UI component sets. EFL is one of the Tizen native UI modules and is available in various Tizen profiles. In Tizen, EFL is commonly used for UI applications, although you can also use it for non-UI applications.</p>
  
 

<h2>Warm-up</h2>
<p>Become familiar with the Efl Extension and Elementary API basics by learning about:</p>

<ul>
  <li><a href="#basic">Learning EFL Basics</a> 
  	  <p>Learn the basic EFL characteristics and the EFL libraries supported in Tizen.</p></li>	
  <li><a href="#native">Using EFL in Tizen Native Applications</a> 
  	  <p>Start the Ecore main loop.</p> </li>
  <li><a href="#layout">Using the Base Application Layout</a> 
  	  <p>Use the base layout with EFL for your application.</p> </li>
  <li><a href="#ClockSimple">Creating a Simple Clock View</a> 
  	  <p>Create a simple clock view using a box, container UI component, and label to create a basic layout.</p> </li>
  <li><a href="#ClockComplex">Creating a Complex Clock View</a> 
  	  <p>Create a complex clock view by organizing a basic layout using boxes.</p> </li>

</ul>

 <h2 id="basic" name="basic">Learning EFL Basics</h2>

<p>EFL stands for Enlightenment Foundation Libraries. Enlightenment is a project consisting of the Enlightenment window manager, EFL libraries, and various utilities and applications. The Enlightenment team needed powerful libraries to handle, among others, rendering, main loops, and events, so EFL was introduced during the development of the Enlightenment window manager to fill these gaps. EFL is now widely used outside of the Enlightenment window manager.</p>

<p>Currently, five EFL libraries are publicly available to Tizen native applications. These libraries provide the following features, among others:</p>

<ul>
 <li>Data structures</li>
 <li>Optimized rendering</li>
 <li>Thread pool</li>
 <li>Events and callbacks</li>
 <li>Fd handlers</li>
 <li>Timers and animators</li>
 <li>UI components</li>
 <li>Layout scripts</li>
</ul>

<h3>EFL Characteristics</h3>

<p>EFL is aimed at not only desktop computers but also touch-screen and embedded devices, making EFL applications portable to many different types of devices. Applications do not need to care about the types of devices and profiles they run on. Instead of changing the code, it is typically enough to simply configure the applications for different devices.</p>

<p>The key characteristics of EFL include:</p>

<ul>
 <li><strong>Performance</strong>
  <p>The main reason Tizen adopted EFL as its native toolkit is its speed. EFL is highly optimized by using a scene graph and retained-mode rendering. EFL is fast even in software rendering.</p></li>
 <li><strong>Small memory footprint</strong>
  <p>Despite its fast performance, EFL's memory footprint is smaller than that of other toolkits with similar features. A small memory footprint is useful in the embedded world, since embedded devices do not normally have much memory.</p></li>
 <li><strong>Back-end engine support</strong>
  <p>EFL supports several back-end engines, such as X11 (OpenGL, Xlib, Xcb), Wayland (OpenGL, SHM), Direct Framebuffer, DRM, memory buffers, PS3 native, Windows, and Mac OS. Applications do not need to deal with each back-end engine separately.</p></li>
 <li><strong>GUI and logic separation</strong>
  <p>EFL supports GUI layout and logic separation by having the layout description in a plain text file and the logic code in the C or C++ source files.</p></li>
 <li><strong>Themeable</strong>
  <p>An EFL theme can be changed at runtime without restarting the application. UI components are customizable so that each application can create its own customized theme to overlay above the default theme, adding customized versions of UI components to achieve a specific look and feel.</p></li>
 <li><strong>Scalable</strong>
  <p>EFL supports a scale factor that affects the size of objects in the application at runtime. By configuring the scale factor, applications can scale up and down as needed. The scale factor also supports a default setting that allows applications to scale nicely out-of-the-box.</p></li>
 <li><strong>Animations</strong>
  <p>EFL supports different types of animations. Evas supports Evas maps with low-level APIs for performing 2D, 2.5D, and 3D object transformations. Edje supports pre-defined transitions and wrapping of Evas maps. Elementary supports transit APIs for various types of animations, which can be combined.</p></li>
 <li><strong>Hardware acceleration</strong>
  <p>EFL supports OpenGL&reg; and OpenGL-ES acceleration.</p></li>
</ul>
	
	
	<h3 name="libraries" id="libraries">EFL Libraries</h3>

<p class="figure">Figure: EFL libraries</p>
<p align="center"><img alt="EFL libraries" src="../../images/efl_libraries.png"/></p>

<p>Tizen supports the following EFL libraries:</p>

<ul>
 <li><strong>Ecore</strong>
  <p>A clean and tiny event loop library with many convenience modules supporting operating system abstraction and integration. Ecore runs a main loop that is a key feature for event-driven applications and the rest of EFL. The Ecore main loop runs infinitely (or until requested to quit) and handles all registered events, such as touch, mouse, key, timers, animators, idlers, and fd handlers. Ecore also provides modules for handling network connections, files, input methods, and so on. EFL assumes that you run an Ecore main loop at all times (except at application startup and shutdown) and use the main loop to handle all callbacks (unless otherwise documented). ELF also assumes that threads use the Ecore infrastructure to return the results of their work back to the main loop for implementation.</p></li>
 <li><strong>Edje</strong>
  <p>A complex graphical design and layout library. Edje supports a separation between layout and logic. Edje was designed as a theme layer for moving the look, feel, and animation of objects into separate data files loaded at runtime, as opposed to being defined in-code. Using a plain text <span style="font-family: Courier New,Courier,monospace">edc</span> file, you can describe your application's layout without writing a line of code.</p></li>
 <li><strong>Eina</strong>
  <p>A library for data types and other useful tools. Eina provides data types such as lists, in-line lists, arrays, in-line arrays, hash tables, compact lists, iterator functions, sparse matrices, red-black trees, string buffers, shared string tokens, rectangle regions, generic value storage, and data models. Eina also supports tools such as benchmarking infrastructure, converters, counters, error handlers, basic file handlers, lazy allocators, loggers, magic number handlers, memory pools, modules, rectangles, safety checks, and string handlers.</p></li>
 <li><strong>Elementary</strong>
  <p>A UI component set library. Elementary is composed of several common UI components, such as buttons, check boxes, entries, lists, pop-ups, and windows. Some infrastructure is shipped with Elementary, such as scale configuration handling, finger-size configuration for touch UIs, theme handling, focus handling, accessibility, UI mirroring, and profile handling.</p></li>
 <li><strong>Evas</strong>
  <p>A highly optimized scene graph and rendering library. Evas is a stateful canvas scene graph in which you can place objects such as rectangles, lines, polygons, text, text blocks, images, and smart objects. Evas uses a scene graph to keep track of the state of all objects. You do not need to worry about objects repainting or keeping their states. You only need to modify them for the new state and let Evas take care of the rest. Evas supports anti-aliased text, smooth super and sub-sampled scaled images, alpha-blended objects, and more.</p></li>
</ul>

 <h2 id="native" name="native">Using EFL in Tizen Native Applications</h2>

<p>To start the Ecore main loop and move your application into the running state, call the <span style="font-family: Courier New,Courier,monospace">ui_app_main()</span> function. The Ecore main loop handles all general events, such as touch, mouse, key, and network events.</p>

<pre class="prettyprint">
int
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;ret = ui_app_main(argc, argv, &amp;event_callback, &amp;ad);

&nbsp;&nbsp;&nbsp;return ret;
}
</pre>

After your application is running:

<ol>
 <li>Create a window, and organize your UI components inside the window.</li>
 <li>Create the application logic code to be called when callbacks or timed events occurs (for example, animators for animations, timers for timeouts).</li>
</ol>

 <h2 id="layout" name="layout">Using the Base Application Layout</h2>

<p>This section provides how to use base layout with EFL for your application. Also, you can get some idea of sample layouts for applications.</p>

<h3>Using the Base Layout</h3>

<p>When developing a Tizen native application, it is recommended that you base your application layout on the base layout. The base layout supports the indicator and view management. The following figure shows the wireframe and UI component hierarchy of the base layout:</p>

<p class="figure">Figure: Base layout wireframe and UI component hierarchy</p>
<p align="center"><img alt="Base layout wireframe and UI component hierarchy" src="../../images/base_layout.png"/></p>

<p>The UI components have the following roles:</p>

<ul>
 <li>Window (Elm_win): Every UI component from Elementary is rendered in a Window.</li>
 <li>Conformant (Elm_Conformant): The Conformant supports the indicator area and resizing the application due to rotation or the ISF (keypad).</li>
 <li>Naviframe (Elm_Naviframe): The Naviframe acts as a view manager and optionally provides the application title. The main layout of the application is added to the Naviframe's view area.</li>
</ul>


<h3>Sample Applications with the Base Layout</h3>

<h4>Setting</h4>

<p>The Setting application consists of a list to show as a menu. For organizing the application, create the application layout with a screen-size-list and place the layout into the Naviframe's view area.</p>

<p class="figure">Figure: Setting UI and layout</p>
<p align="center"><img alt="Settings UI and layout" src="../../images/setting_sd.png"/></p>

<p>For more information, see the Setting sample application.</p>

<h4>Application Store</h4>

<p>For organizing the Application Store application, you need to add a scroller to the base layout, since the total height of the layout will be greater than the screen size, and you will therefore need to scroll the screen contents up and down. If the layout is larger than the screen, the scroller makes the view itself scrollable.</p>

<p>You can use a list or grid if the same objects are shown repeatedly. In this sample application, however, the various items are shown in a layout.</p>

<p class="figure">Figure: Application Store UI and layout</p>
<p align="center"><img alt="Application Store UI and layout" src="../../images/application_store_sd.png"/></p>

<p>For more information, see the Application Store sample application.</p>

<h3>Sample Applications with a Custom Layout</h3>

<h4>Calculator - No Naviframe</h4>

<p>The Calculator is a good example of an exception to the base layout. The application has no view changes and no application title. As these are the two reasons why you should use a Naviframe, you do not need to add a Naviframe to the Calculator.</p>

<p>You can organize the application layout with container components. Container components are used for arranging UI components, both basic UI components and other container components.</p>

<p class="figure">Figure: Calculator UI and layout</p>
<p align="center"><img alt="Calculator UI and layout" src="../../images/calculator_sd.png"/></p>

<p>For more information, see the Calculator sample application.</p>

<h4>Email - Drawer</h4>

<p>The Email application shows information using a list. The main view is the same as in the Setting application, consisting of a screen-size-list for displaying emails. However, the Email application has an additional feature: the Drawer, which is used for displaying the menu with a hierarchy.</p>

<p>To develop the application as a Tizen native application, add a layout on the Conformant, and add a Naviframe to the layout. This layout has a content area for the Drawer and Naviframe, and its style name is "layout/drawer/panel". To use this layout, use the following code:</p>

<pre class="prettyprint">
layout = elm_layout_add(parent);
elm_layout_theme_set(layout, &quot;layout&quot;, &quot;drawer&quot;, &quot;panel&quot;);
</pre>

<p>The style includes parts for locating the Drawer and the main view. In the Drawer area, you can add a list to indicate the menu. In the main view, you can add a Naviframe to organize the view of the layout.</p>

<p class="figure">Figure: Email UI and layout</p>
<p align="center"><img alt="Email UI and layout" src="../../images/email_sample.png"/></p>

<p>For more information, see the Email sample application.</p>

 <h2 id="ClockSimple" name="ClockSimple">Creating a Simple Clock View</h2>

<p>This sample creates a basic clock view that shows the time, current city, and date. This sample demonstrates how to use a box, container component, and label to create a basic layout. The application includes the following UI components:</p>

<ul>
<li><span style="font-family: Courier New,Courier,monospace">Elm_window</span>: Basic canvas for rendering the screen</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_conformant</span>: Support indicator area</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_naviframe</span>: View manager component</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_box</span>: Container component for layouting other UI components</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_label</span>: Basic UI component for showing text with a tag</li>
</ul> 

<p>The following figure illustrates the main view of the simple clock sample application and its wireframe structure.</p>
  
<p class="figure">Figure: Simple clock screen</p>
<p align="center"><img alt="Simple clock screen" src="../../images/efl_simple_clock.png" /></p>

<p>The basic clock is implemented in the <span style="font-family: Courier New,Courier,monospace">world_clock.c</span> file. In this application, the data structure for application is following:</p>

<pre class="prettyprint">typedef struct appdata
{
&nbsp;&nbsp;&nbsp;// Save the window
&nbsp;&nbsp;&nbsp;Evas_Object *win;
} 
appdata_s;
</pre>

<p>The information in <span style="font-family: Courier New,Courier,monospace">appdata</span> is used for the entire system. In this sample application, the information is related to handling the HW back key.</p> 

<p>The  single callback function for application handling is <span style="font-family: Courier New,Courier,monospace">app_create</span>, and it only creates the basic GUI:</p>

<pre class="prettyprint">int
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = {0,};
&nbsp;&nbsp;&nbsp;app_event_callback_s event_callback = {0,};
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;event_callback.create = app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.pause = app_pause;
&nbsp;&nbsp;&nbsp;event_callback.resume = app_resume;
&nbsp;&nbsp;&nbsp;event_callback.app_control = app_control;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, ui_app_low_battery, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, ui_app_low_memory, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, ui_app_orient_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, ui_app_lang_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, ui_app_region_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_remove_event_handler(handlers[APP_EVENT_LOW_MEMORY]);

&nbsp;&nbsp;&nbsp;ret = app_main(argc, argv, &amp;event_callback, &amp;ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(&quot;app_main() is failed. err = %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return ret;
}

static bool
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;create_base_gui(ad);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>Use the <span style="font-family: Courier New,Courier,monospace">create_base_gui()</span> function to create a basic layout with a window, conformant and naviframe. This is the basic layout in the Tizen mobile environment.</p>
  
<pre class="prettyprint">ad-&gt;win = elm_win_util_standard_add(PACKAGE, PACKAGE);
elm_win_autodel_set(ad-&gt;win, EINA_TRUE);

// Conformant
conform = elm_conformant_add(ad-&gt;win);
elm_win_conformant_set(ad-&gt;win, EINA_TRUE);
evas_object_size_hint_weight_set(conform, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
elm_win_resize_object_add(ad-&gt;win, conform);
evas_object_show(conform);

// Naviframe
nf = elm_naviframe_add(conform);
elm_object_content_set(conform, nf);
evas_object_show(nf);
</pre>

<p>After creating a basic layout, create the main layout for the application. In this sample, it contains a box with 3 labels. The labels show the time, city and date. To add the labels to the box, use the <span style="font-family: Courier New,Courier,monospace">elm_box_pack_end()</span> function.</p>
  
<p>After adding the labels, you must set their text. You can set or decorate the text in the labels using the <span style="font-family: Courier New,Courier,monospace">elm_object_text_set()</span> function. You can modify the text size (<span style="font-family: Courier New,Courier,monospace">font_size</span>), color (<span style="font-family: Courier New,Courier,monospace">color</span>), and thickness (<span style="font-family: Courier New,Courier,monospace">b</span>).</p>
  
  <pre class="prettyprint">
// Add the box
box = elm_box_add(nf);
// Create a label
label1 = elm_label_add(box);
// Set text to the label with a tag
elm_object_text_set(label1, &quot;&lt;font_size=110&gt;&lt;color=#000000&gt;07:26&lt;/color&gt;&lt;/font_size&gt;&quot;);
// Add the label to the box
elm_box_pack_end(box, label1);
// Change label visibility
evas_object_show(label1);

// Repeat with other labels

evas_object_show(box);
</pre>

<p>After creating the box with labels, set the box as a new view. You can also set the title of the application. These operations are handled by the naviframe using the <span style="font-family: Courier New,Courier,monospace">elm_naviframe_item_push()</span> function:</p>
  
  <pre class="prettyprint">elm_naviframe_item_push(nf, _(&quot;World Clock&quot;), NULL, NULL, box, &quot;basic&quot;);</pre>
  
<p>The parameters include the title, the name of the UI component added as a new view, and the naviframe style. The basic style is used for a simple view with normal title.</p>
  
  <p>The following figure illustrates the UI component hierarchy of the application.</p>

<p class="figure">Figure: Simple clock components</p>
<p align="center"><img alt="Simple clock components" src="../../images/efl_simple_clock_tree.png" /></p>
  
<p>Set the HW key handler. The Tizen mobile environment supports the <strong>More</strong> and back keys, but only the back key is handled in this sample. </p> 
<pre class="prettyprint">eext_object_event_callback_add(ad-&gt;win, EEXT_CALLBACK_BACK, win_back_cb, ad);
</pre> 

<p>After setting the callback function, the <span style="font-family: Courier New,Courier,monospace">win_back_cb</span> callback is invokes when a back key is pressed. The <span style="font-family: Courier New,Courier,monospace">win_back_cb</span> callback will hide the window:</p> 
<pre class="prettyprint">static void
win_back_cb(void *data , int type , void *event)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;elm_win_lower(ad-&gt;win);
}
</pre>

 <h2 id="ClockComplex" name="ClockComplex">Creating a Complex Clock View</h2>
 
<p>This sample creates a complex clock view. The sample demonstrates how to organize a basic layout using boxes. The application includes the following UI components:</p>


<ul>
<li><span style="font-family: Courier New,Courier,monospace">Elm_window</span>: Basic canvas for rendering the screen</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_conformant</span>: Support indicator area</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_naviframe</span>: View manager component</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_box</span>: Container component for layouting other UI components</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_label</span>: Basic UI component for showing text with a tag</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_genlist</span>: List component</li>
<li><span style="font-family: Courier New,Courier,monospace">Elm_button</span>: Simple push button</li>
</ul> 
  
<p>The following figure illustrates the main view of the complex clock sample application and its wireframe structure.</p>
  
<p class="figure">Figure: Complex clock screen</p>
<p align="center"><img alt="Complex clock screen" src="../../images/efl_complex_clock.png" /></p>

<h3>Basic GUI</h3> 

<p>The basic clock is implemented in the <span style="font-family: Courier New,Courier,monospace">world_clock.c</span> file. In this application, the data structure for application is following:</p>

<pre class="prettyprint">typedef struct appdata
{
&nbsp;&nbsp;&nbsp;// Save the window
&nbsp;&nbsp;&nbsp;Evas_Object *win;
} 
appdata_s;
</pre>

<p>The information in <span style="font-family: Courier New,Courier,monospace">appdata</span> is used for the entire system. In this sample application, the information is related to handling the HW back key.</p> 

<p>The  single callback function for application handling is <span style="font-family: Courier New,Courier,monospace">app_create</span>, and it only creates the basic GUI:</p>

<pre class="prettyprint">int
main(int argc, char *argv[])
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = {0,};
&nbsp;&nbsp;&nbsp;app_event_callback_s event_callback = {0,};
&nbsp;&nbsp;&nbsp;int ret = 0;

&nbsp;&nbsp;&nbsp;event_callback.create = app_create;
&nbsp;&nbsp;&nbsp;event_callback.terminate = app_terminate;
&nbsp;&nbsp;&nbsp;event_callback.pause = app_pause;
&nbsp;&nbsp;&nbsp;event_callback.resume = app_resume;
&nbsp;&nbsp;&nbsp;event_callback.app_control = app_control;

&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_BATTERY], APP_EVENT_LOW_BATTERY, ui_app_low_battery, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LOW_MEMORY], APP_EVENT_LOW_MEMORY, ui_app_low_memory, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_DEVICE_ORIENTATION_CHANGED], APP_EVENT_DEVICE_ORIENTATION_CHANGED, ui_app_orient_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_LANGUAGE_CHANGED], APP_EVENT_LANGUAGE_CHANGED, ui_app_lang_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_add_event_handler(&amp;handlers[APP_EVENT_REGION_FORMAT_CHANGED], APP_EVENT_REGION_FORMAT_CHANGED, ui_app_region_changed, &amp;ad);
&nbsp;&nbsp;&nbsp;ui_app_remove_event_handler(handlers[APP_EVENT_LOW_MEMORY]);

&nbsp;&nbsp;&nbsp;ret = app_main(argc, argv, &amp;event_callback, &amp;ad);
&nbsp;&nbsp;&nbsp;if (ret != APP_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(&quot;app_main() is failed. err = %d&quot;, ret);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return ret;
}

static bool
app_create(void *data)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;create_base_gui(ad);

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>The base GUI of the application contains the following elements:</p>

<ul>
<li>Clock</li>
<li>List</li>
<li>Main layout with buttons</li>
</ul>

<h3>Clock</h3> 

 <p>The clock element contains 3 labels. The labels are packed as a single box component, which is part of the main layout.</p> 
<pre class="prettyprint">static Evas_Object *
create_clock(Evas_Object *nf)
{
&nbsp;&nbsp;&nbsp;Evas_Object *box, *label1, *label2, *label3;

&nbsp;&nbsp;&nbsp;// Box
&nbsp;&nbsp;&nbsp;box = elm_box_add(nf);

&nbsp;&nbsp;&nbsp;label1 = elm_label_add(box);
&nbsp;&nbsp;&nbsp;elm_object_text_set(label1, &quot;&lt;font_size=110&gt;&lt;color=#000000&gt;07:26&lt;/color&gt;&lt;/font_size&gt;&quot;);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(box, label1);
&nbsp;&nbsp;&nbsp;evas_object_show(label1);

&nbsp;&nbsp;&nbsp;evas_object_show(box);

&nbsp;&nbsp;&nbsp;return box;
}
</pre>

<h3>List</h3> 

<p>This element contains a list of cities. The UI component used is <span style="font-family: Courier New,Courier,monospace">genlist</span>, which is a complex list able to show information with various styles.</p> 
<pre class="prettyprint">static Evas_Object *
create_list(Evas_Object *nf)
{
&nbsp;&nbsp;&nbsp;Evas_Object* list;
&nbsp;&nbsp;&nbsp;Elm_Genlist_Item_Class *itc = NULL;
&nbsp;&nbsp;&nbsp;int i, num_of_item;
&nbsp;&nbsp;&nbsp;Elm_Object_Item *it;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;list = elm_genlist_add(nf);
</pre> 
  
<p>To add items to the list, use the <span style="font-family: Courier New,Courier,monospace">Elm_Genlist_Item_Class</span> class. After adding a new class, set callback function to detect, when the item is rendered. </p> 
<pre class="prettyprint">itc = elm_genlist_item_class_new();
&nbsp;&nbsp;&nbsp;itc-&gt;item_style = &quot;2line.top.4&quot;;
&nbsp;&nbsp;&nbsp;itc-&gt;func.text_get = gl_text_get_cb;
&nbsp;&nbsp;&nbsp;itc-&gt;func.content_get = NULL;
&nbsp;&nbsp;&nbsp;itc-&gt;func.del = NULL;
</pre> 

<p>In this application, all the list items are similar and use the same callback function (<span style="font-family: Courier New,Courier,monospace">gl_text_get_cb()</span>) for setting text, so only 1 item class is created:</p> 
<pre class="prettyprint">static char*
gl_text_get_cb(void *data, Evas_Object *obj, const char *part)
{
&nbsp;&nbsp;&nbsp;item_data_s *id = data;
&nbsp;&nbsp;&nbsp;char buf[1024];

&nbsp;&nbsp;&nbsp;if (id-&gt;index == 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!strcmp(part, &quot;elm.text.main.left.top&quot;)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf, 1023, &quot;%s&quot;, &quot;07:26&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (!strcmp(part, &quot;elm.text.sub.right.top&quot;)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf, 1023, &quot;%s&quot;, &quot;Cardiff&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (!strcmp(part, &quot;elm.text.sub.left.bottom&quot;)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf, 1023, &quot;%s&quot;, &quot;Wen, Jan 1&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (!strcmp(part, &quot;elm.text.sub.right.bottom&quot;)) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snprintf(buf, 1023, &quot;%s&quot;, &quot;wales&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strdup(buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return NULL;
}
</pre> 

<p>Append items using the <span style="font-family: Courier New,Courier,monospace">elm_genlist_item_append()</span> function. In this application, 3 items are added:</p> 
<pre class="prettyprint">num_of_item = 3;

&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; num_of_item; i++) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item_data_s *id = calloc(sizeof(item_data_s), 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id-&gt;index = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it = elm_genlist_item_append(list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELM_GENLIST_ITEM_NONE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id-&gt;item = it;
&nbsp;&nbsp;&nbsp;}
</pre>
 
 <h3>Main Layout with a Button</h3> 
 
<p>In the main layout, the other layout elements are merged together and a button added. The following example describes handling the main layout:</p>

<pre class="prettyprint">static void
create_base_gui(appdata_s *ad)
{
&nbsp;&nbsp;&nbsp;Evas_Object *conform, *nf, *box, *clock, *layout, *rect, *button;
&nbsp;&nbsp;&nbsp;// Window
&nbsp;&nbsp;&nbsp;ad-&gt;win = elm_win_util_standard_add(PACKAGE, PACKAGE);
&nbsp;&nbsp;&nbsp;elm_win_autodel_set(ad-&gt;win, EINA_TRUE);

&nbsp;&nbsp;&nbsp;// Conformant
&nbsp;&nbsp;&nbsp;conform = elm_conformant_add(ad-&gt;win);
&nbsp;&nbsp;&nbsp;elm_win_conformant_set(ad-&gt;win, EINA_TRUE);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(conform, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;elm_win_resize_object_add(ad-&gt;win, conform);
&nbsp;&nbsp;&nbsp;evas_object_show(conform);

&nbsp;&nbsp;&nbsp;// Naviframe
&nbsp;&nbsp;&nbsp;nf = elm_naviframe_add(conform);
&nbsp;&nbsp;&nbsp;elm_object_content_set(conform, nf);
&nbsp;&nbsp;&nbsp;evas_object_show(nf);
}
</pre> 

<p>The box component is used to organize the main layout. The box is expanded as much as possible to fill the entire view.</p> 
<pre class="prettyprint">&nbsp;&nbsp;&nbsp;// Box
&nbsp;&nbsp;&nbsp;box = elm_box_add(nf);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(box, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(box, EVAS_HINT_FILL, EVAS_HINT_FILL);
</pre> 

<p>The box contains the following elements:</p> 

<ul>

<li><p>The clock element contains 3 labels. The parameter for the <span style="font-family: Courier New,Courier,monospace">evas_object_size_hint_weight_set()</span> function is 0.1 meaning that the height of the clock box occupies 30% of the available area. </p> 
<pre class="prettyprint">&nbsp;&nbsp;&nbsp;clock = create_clock(nf);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(clock, EVAS_HINT_EXPAND, 0.3);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(clock, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(box, clock);
</pre> 
</li>

<li><p>The list element is packed into the box. As the <span style="font-family: Courier New,Courier,monospace">genlist</span> elements does not have a determined size, its size depends on the <span style="font-family: Courier New,Courier,monospace">layout</span> parameter.</p> 
<pre class="prettyprint">
&nbsp;&nbsp;&nbsp;layout = elm_layout_add(box);
&nbsp;&nbsp;&nbsp;elm_layout_theme_set(layout, &quot;layout&quot;, &quot;application&quot;, &quot;default&quot;);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(layout, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(layout, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;rect = create_list(nf);
&nbsp;&nbsp;&nbsp;elm_layout_content_set(layout, &quot;elm.swallow.content&quot;, rect);
&nbsp;&nbsp;&nbsp;evas_object_show(rect);
&nbsp;&nbsp;&nbsp;evas_object_show(layout);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(box, layout);
</pre> 
</li>

<li><p>The button element has a callback function to detect, when the button is clicked.</p> 
<pre class="prettyprint">button = elm_button_add(box);
&nbsp;&nbsp;&nbsp;evas_object_smart_callback_add(button, &quot;clicked&quot;, btn_clicked_cb, NULL);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_weight_set(button, EVAS_HINT_EXPAND, 0.1);
&nbsp;&nbsp;&nbsp;evas_object_size_hint_align_set(button, EVAS_HINT_FILL, EVAS_HINT_FILL);
&nbsp;&nbsp;&nbsp;elm_object_text_set(button, &quot;Terminate&quot;);
&nbsp;&nbsp;&nbsp;evas_object_show(button);
&nbsp;&nbsp;&nbsp;elm_box_pack_end(box, button);
</pre> 
</li>
</ul>

<p>The following figure illustrates the UI component hierarchy of the application.</p>

<p class="figure">Figure: Complex clock components</p>
<p align="center"><img alt="Complex clock components" src="../../images/efl_complex_clock_tree.png" /></p>

<p>Add the main layout to the naviframe, and set the HW key handler:</p> 
<pre class="prettyprint">eext_object_event_callback_add(ad-&gt;win, EEXT_CALLBACK_BACK, win_back_cb, ad);
</pre> 

<p>After setting the callback function, the <span style="font-family: Courier New,Courier,monospace">win_back_cb</span> callback is invokes when a back key is pressed. The <span style="font-family: Courier New,Courier,monospace">win_back_cb</span> callback will hide the window:</p> 
<pre class="prettyprint">static void
win_back_cb(void *data , int type , void *event)
{
&nbsp;&nbsp;&nbsp;appdata_s *ad = data;
&nbsp;&nbsp;&nbsp;elm_win_lower(ad-&gt;win);
}
</pre> 
	
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>
</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>


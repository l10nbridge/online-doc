<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <link rel="stylesheet" type="text/css" href="../../css/styles.css" />
    <link rel="stylesheet" type="text/css" href="../../css/snippet.css" />
    <script type="text/javascript" src="../../scripts/snippet.js"></script>
    <script type="text/javascript" src="../../scripts/jquery.util.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/common.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/core.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../scripts/search.js" charset="utf-8"></script>

    <title>Push: Using the Push Service</title>
</head>

<body onload="prettyPrint()" style="overflow: auto;">

<div id="navigation">
    <div id="profile">
        <p><img alt="Mobile native" src="../../images/mn_icon.png"/></p>
    </div>
    <div id="toc_border"><div id="toc">
		<p class="toc-title">Content</p>
		<ul class="toc">
				<li><a class="opensection" href="#start">Initializing the Push Service</a></li>
				<li><a class="opensection" href="#connect">Connecting to the Push Service</a></li>
				<li><a class="opensection" href="#registration">Registering with the Push Server</a></li>
				<li>Notification management
				<ul class="toc">
				<li><a class="opensection" href="#send">Sending Push Notifications</a></li>	
				<li><a class="opensection" href="#dealing">Handling Push Notifications</a></li>
				</ul></li>
				<li><a class="opensection" href="#security">Managing Security</a></li>	
		</ul>     
        <p class="toc-title">Related Info</p>
        <ul class="toc">
            <li><a href="../../../../org.tizen.guides/html/native/messaging/push_n.htm">Push Guide</a></li>
			<li><a href="../../../../org.tizen.native.mobile.apireference/group__CAPI__MESSAGING__PUSH__PUBLIC__MODULE.html">Push API</a></li>
        </ul>
    </div></div>
</div>

<div id="container"><div id="contents"><div class="content">
<h1>Push: Using the Push Service</h1>
  <div class="cont"><div class="static-cont">
  
<p>This tutorial demonstrates how you can use the Tizen Push Service to allow applications in a mobile device to receive notifications through the Internet even when the applications are not running.</p>

<h2>Warm-up</h2>
<p>Become familiar with the Push API basics by learning about:</p>
	<ul>
		<li><a class="opensection" href="#start">Initializing the Push Service</a>
		<p>Initialize the push service for use.</p></li>
		<li><a class="opensection" href="#connect">Connecting to the Push Service</a>
		<p>Establish a socket connection to the push service.</p></li>
		<li><a class="opensection" href="#registration">Registering with the Push Server</a>
		<p>Register and unregister with the push server.</p></li>
		<li>Notification management
		<ul>
		<li><a class="opensection" href="#send">Sending Push Notifications</a>
		<p>Send push notifications from the application server to an application.</p></li>	
		<li><a class="opensection" href="#dealing">Handling Push Notifications</a>
		<p>Receive notifications at different states.</p></li>
		</ul></li>
		<li><a class="opensection" href="#security">Managing Security</a>
		<p>Ensure the security of notifications containing sensitive information.</p></li>
	</ul>
          
<div class="devicespecs-util mt5 clfix">
		<ul class="dutil">
			<li><a href="#" class="showA">Show All</a></li>
			<li class="none"><a href="#" class="hideA">Hide All</a></li>
		</ul>
	</div>

		<ul class="devicespecifications">
		<li>
			<div class="devicespec-tit">
 <h2 id="start" name="start" class="items-tit-h2">Initializing the Push Service</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>The following figure illustrates the architecture of the Tizen push service.</p>
<p style="text-align:center;"><img alt="Overview" src="../../images/push_overview.png" /></p>
<p>The following steps illustrate a typical scenario for using the push messaging service on a Tizen device:</p>
<ol>
<li>When an application is installed and launched, it sends a registration request to Tizen push server through the push service.</li>
<li>If the registration request is approved, the server replies the registration ID to the application through the push service.</li>
<li>The application sends the registration ID to the application server. This registration ID is used to identify the application installed in that particular device.</li>
<li>When the application server needs to send a push notification to the application in that particular device, it sends the notification together with the registration ID to the push server.</li>
<li>When the push server receives the notification and the registration ID, it checks which device has the application of the registration ID and then sends the notification to that device.</li>
<li>When the push service receives the notification and the registration ID, it sends the notification to the destination application.</li>
</ol>

<p>Make sure the following requirements are fulfilled:</p>
<ol>
<li>Internet access 
<p>To connect to the Tizen push server and receive notifications from it, your target device or emulator must be able to contact any IP address with the port 5223. If you are in an enterprise network, ensure that the proxy setting in your local network allows outgoing traffic destined for this port number.</p></li>
<li>Package ID
<p>When you create your project in the Tizen SDK, you are given the package ID (randomly generated by the SDK or entered by yourself). The Tizen push server identifies your applications using the package ID.</p></li>
<li>Permission to Tizen push servers
<p>To use the push messaging service, the application needs the permission to access the Tizen push server. Request the permission from the Tizen push service team by <a href="mailto:push.tizen@samsung.com">email</a>, including the following information. When the team approves your request, you receive a push app ID corresponding to your package ID.</p></li>
</ol>

<table>
<caption>Table: Request form details</caption>
   <colgroup> 
    <col width="25%" /> 
    <col width="75%" /> 
   </colgroup> 
<tbody>
    <tr> 
     <th colspan="2">Developer information</th> 
    </tr> 
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Email address</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your email address to receive the approval response.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Last name</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your last name.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>First name</p></td> 
     <td rowspan="1" colspan="1"> <p>Your first name.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Country</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your country of residence.</p> </td> 
	</tr>
    <tr> 
     <th colspan="2">Application information</th> 
    </tr> 
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Package ID </p> </td> 
     <td rowspan="1" colspan="1"> <p> The ID of the application package that uses the push messaging service. The package ID can be obtained from the <span style="font-family: Courier New,Courier,monospace">.xml</span> file in the Tizen SDK.  </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Application name</p> </td> 
     <td rowspan="1" colspan="1"> <p>Name of the application that uses the push service.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Testing purpose</p> </td> 
     <td rowspan="1" colspan="1"> <p> Yes or no. If you request the service for testing purposes only, the duration of the push service is limited to 3 weeks.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Purpose of the push notification usage </p> </td> 
     <td rowspan="1" colspan="1"> <p> Description of how you plan to use the push service, including the situations in which you want to use it. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> App launch date </p> </td> 
     <td rowspan="1" colspan="1"> <p> Application launch date in the YYYY/MM/DD format.<br />For example: 2014/08/01. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Service area/country </p> </td> 
     <td rowspan="1" colspan="1"> <p> Service area, such as Asia, Africa, America, Europe, or the country where the application is used. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Daily push requests </p> </td> 
     <td rowspan="1" colspan="1"> <p> Estimated number of daily notifications. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Transactions per second </p> </td> 
     <td rowspan="1" colspan="1"> <p> Estimated peak number of transactions per second (the recommendation is below 100). </p> </td> 
	</tr>
</tbody>
</table>


<p>To set up the required library and privilege for your application:</p>
<ol>
<li><p>To use APIs for the Tizen push service, include the  <span style="font-family: Courier New,Courier,monospace;">&lt;push-service.h&gt;</span> header file to your application:</p>

<pre class="prettyprint">
#include &lt;push-service.h&gt;
</pre>
</li>

<li id="privilege" name="privilege"><p>To access the Tizen push service on the device, add the following privilege to the manifest file:
</p>

<pre class="prettyprint">
http://tizen.org/privilege/push
</pre>
</li>
</ol>
	</div>
		</li>		
		<li>
			<div class="devicespec-tit">
 <h2 id="connect" name="connect" class="items-tit-h2">Connecting to the Push Service</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To request or receive push notifications, establish a socket connection to the push service. All the information regarding this connection must be controlled by a connection handle which can be defined as a global variable:</p>

<pre class="prettyprint">
push_service_connection_h push_conn;
</pre>

<p>To manage push service connections:</p>
<ol>
<li>Connect to the push service.
<p>Once the connection handle is defined, use the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function to connect the push service:</p>

<pre class="prettyprint">
#define PUSH_APP_ID &quot;YOUR_PUSH_ID_HERE&quot;

static bool app_create(void *data)
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;// Connect to the push service when the application is launched
&nbsp;&nbsp;&nbsp;ret = push_service_connect(PUSH_APP_ID, _state_cb, _noti_cb, NULL, &amp;push_conn);

&nbsp;&nbsp;&nbsp;if (ret != PUSH_SERVICE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;push_service_connect() Failed&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>In the above example, the application establishes a socket connection to the push service using the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The <span style="font-family: Courier New,Courier,monospace;">YOUR_PUSH_ID_HERE</span> argument is the push app ID received from the Tizen push server team when the access to the server was requested. Keep this push app ID confidential, otherwise your push notifications can be hijacked by malicious applications.</p>
<p>The <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> and <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> parameters are callback functions called when the <a href="#state">state changes</a> or <a href="#dealing">a notification arrives from the server</a> through the push service.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">push_conn</span> parameter is the output of the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. If the connection between your application and the service is successful, the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function returns <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> and the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> connection handle is returned through the last parameter. If the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function returns other values, the connection to the service failed. This happens most likely when the <a href="#privilege">push privilege</a> is not added in the SDK.</p>

<p>This sample application establishes a connection to the service when it is launched and disconnects from the service when it terminates. Due to this, the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function is located in the <span style="font-family: Courier New,Courier,monospace;">app_create()</span> function, which is called when the application is launched.
</p>
</li>

<li>Disconnect from the push service.
<p>When the application terminates or no longer uses the push service, close the connection using the <span style="font-family: Courier New,Courier,monospace;">push_service_disconnect()</span> function.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">push_service_disconnect()</span> function closes the existing connection associated with the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> handle and returns all the resources allocated for the connection.</p>

<pre class="prettyprint">
push_service_disconnect(push_conn);
push_conn = NULL;
</pre>

<p>The connection is automatically closed when the application terminates. Hence, if your application uses the push service while being launched, your application does not need this function. However, your application can disconnect the service in the middle of the application operation. If you add a toggle switch to your application for switching the push service on and off, call this function when the service is switched off.</p>
</li>

<li id="state" name="state">Handle state transitions.
<p>After the connection to the service is made, your application is notified whenever the connection state changes. This notification is conducted through the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> callback, which is defined in the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The following figure illustrates the possible states.</p>

<p style="text-align:center;"><img alt="State transitions" src="../../images/push_state_transitions.png" /></p>

<p>Once launched, your application is in the <span style="font-family: Courier New,Courier,monospace;">INITIAL</span> state. When the application establishes a connection to the service using the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function, the state becomes either <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span> or <span style="font-family: Courier New,Courier,monospace;">REGISTERED</span>:</p>
<ul class="ul"><li>If your application is currently registered to the push server, the service forces your application to transit from the <span style="font-family: Courier New,Courier,monospace;">INITIAL</span> state to the <span style="font-family: Courier New,Courier,monospace;">REGISTERED</span> state. In this case, your application can request deregistration to the push server through the push service using the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function. If this request is approved by the push server, the state transits to <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span>.</li>
<li>If your application is not currently registered to the push server, the state transits from the <span style="font-family: Courier New,Courier,monospace;">INITIAL</span> state to the <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span> state. In this case, your application can request registration to the push server through the push service using the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function. If this request is approved by the push server, the state transits to <span style="font-family: Courier New,Courier,monospace;">REGISTERED</span>.</li>
<li>When an error occurs, the state transits to <span style="font-family: Courier New,Courier,monospace;">ERROR</span>.</li></ul>

<p>When the current state transits, the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> function is called and the new state is obtained from the first argument. The application then needs to determine its actions based on the new state:</p>

<pre class="prettyprint">
static void _state_cb(push_service_state_e state, const char *err, void *user_data)	
{
&nbsp;&nbsp;&nbsp;switch (state)	
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_UNREGISTERED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;Arrived at STATE_UNREGISTERED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_unregistered(user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_REGISTERED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;Arrived at STATE_REGISTERED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_registered(user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;Arrived at STATE_ERROR&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_error(err, user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;Unknown State&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>In the above example, the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span>, <span style="font-family: Courier New,Courier,monospace;">_on_state_unregistered()</span>, and <span style="font-family: Courier New,Courier,monospace;">_on_state_error()</span> functions contain the actions for the <span style="font-family: Courier New,Courier,monospace;">REGISTERED</span>, <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span>, and <span style="font-family: Courier New,Courier,monospace;">ERROR</span> states, respectively. Your application does not need to handle the <span style="font-family: Courier New,Courier,monospace;">INITIAL</span> state because it is maintained internally, and this callback function is never invoked in this state. The second argument, <span style="font-family: Courier New,Courier,monospace;">err</span>, is the error message from the push service when the state becomes ERROR. Consequently, only the <span style="font-family: Courier New,Courier,monospace;">_on_state_error()</span> function takes this argument while others ignore it.</p>
</li>
</ol>
	</div>
		</li>		
		<li>
			<div class="devicespec-tit">
 <h2 id="registration" name="registration" class="items-tit-h2">Registering with the Push Server</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>To receive push notifications, your application must send a registration request to the Tizen push server. When the server receives this request, it assigns a registration ID that is unique to your application on the particular device. When sending a notification from your application server, this registration ID is used as a destination address of your application. If your application no longer needs to receive push notifications, it needs to send a deregistration request to the server.</p>

<ol>
<li>Request registration.
<p>After connecting to the push service, request registration using the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function.</p>
<p>The function takes 3 arguments. The first argument is the connection handle that was returned from the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The second argument is the callback function that returns the result of this registration request. The last argument is the user data to be handed over to the result callback function. </p>

<pre class="prettyprint">
static void _on_state_unregistered(void *user_data) 
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;// Send a registration request to the push service
&nbsp;&nbsp;&nbsp;ret = push_service_register(push_conn, _result_cb, NULL);
}
</pre>

<p>The <span style="font-family: Courier New,Courier,monospace;">_on_state_unregistered()</span> function containing the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function is called when the state transits to <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span>. This sample application is designed to send the registration request as soon as it is connected to the push service. If your application requires users to login to your service, this registration request must be sent after the login process is complete.</p>

<p>Note that the registration request is non-blocking. If <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> returns from the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function, your request is successfully delivered to the push service. However, it does not necessarily mean that your request is approved by the server. If the push service successfully sends your request to the server and receives an approval, the <span style="font-family: Courier New,Courier,monospace;">_result_cb()</span> callback is called with <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_RESULT_SUCCESS</span> from the first parameter:</p>

<pre class="prettyprint">
static void _result_cb(push_service_result_e result, const char *msg, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result == PUSH_SERVICE_RESULT_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGI(&quot;Registration request is approved.&quot;);
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(&quot;Registration ERROR [%s]&quot;, msg);

&nbsp;&nbsp;&nbsp;return;
}
</pre>

<p>When an error occurs in the middle of the registration process, the reason is returned from the first parameter of the callback. For example, if the push server is not responding, the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function returns <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> (because delivery to the service is successful), but the <span style="font-family: Courier New,Courier,monospace;">_result_cb()</span> function is called later with <span style="font-family: Courier New,Courier,monospace;">PUSH_RESULT_TIMEOUT</span>. In this case, your application does not need to request registration again because the push service keeps the previous request and sends it when the network becomes online. The <span style="font-family: Courier New,Courier,monospace;">msg</span> argument is the error message from the push service if the request fails.</p>
</li>

<li id="upon" name="upon">
<p>Your application transits to the <span style="font-family: Courier New,Courier,monospace;">REGISTERED</span> state in one of the following cases:</p>
<ul class="ul">
<li>Your registration request that your application sent at the <span style="font-family: Courier New,Courier,monospace;">UNREGISTERED</span> state is approved.</li>
<li>Your already-registered application at the <span style="font-family: Courier New,Courier,monospace;">INITIAL</span> state is successfully connected to the push service.</li>
</ul>

<p>In both cases, the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> callback function is called with <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_STATE_REGISTERED</span>. The application calls the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span> function immediately, <a href="#state">as shown in the state transitions</a>. Although you determine the actions inside the function, the following example shows the following actions that you need to bear in mind:</p>
<ul class="ul">
<li>If the application has already been registered, request unread notifications to the service that has arrived before the application is launched.</li>
<li>If the application is newly registered, send the registration ID issued by the push server to your application server.</li>
</ul>

<pre class="prettyprint">
static void _on_state_registered(void *user_data) 
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *reg_id = NULL;
&nbsp;&nbsp;&nbsp;char *app_id = NULL;

&nbsp;&nbsp;&nbsp;// Request unread notifications to the push service 
&nbsp;&nbsp;&nbsp;// _noti_cb() is called if there are unread notifications
&nbsp;&nbsp;&nbsp;ret = push_service_request_unread_notification(push_conn);

&nbsp;&nbsp;&nbsp;// Get the registration ID
&nbsp;&nbsp;&nbsp;ret = push_service_get_registration_id(push_conn, &amp;reg_id);
&nbsp;&nbsp;&nbsp;if (ret != PUSH_SERVICE_ERROR_NONE)	
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGE(&quot;ERROR [%d]: push_service_get_registration_id()&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Send reg_id to your application server if necessary
&nbsp;&nbsp;&nbsp;_send_reg_id_if_necessary(reg_id);

&nbsp;&nbsp;&nbsp;if (reg_id)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(reg_id);
}
</pre>

<p>First, you asynchronously request notifications that have arrived before the application is launched. If there is such a notification, it can be received through the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function after the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span> function returns. Once your request for unread notifications is successfully delivered, <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> is returned.</p>
<p>Secondly, retrieve the registration ID from the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> connection handle. If the ID is new or updated, you need to send it to your application server. This ID is used as a destination address to your application in a particular device. If your application has already sent the ID, you can skip this step. This logic is implemented in the <span style="font-family: Courier New,Courier,monospace;">_send_reg_id_if_necessary()</span> function.</p>

<p>Compute the hash value of the ID and compare it with the existing hash value.</p>
<ul class="ul"><li>If they are different, your current ID is different from the previous one. In that case, send the registration ID to your application server and then store the new hash value. For security, it is not safe to keep your ID as a string because it can be easily exposed.</li>
<li>If they are the same, your application server already has this registration ID. In this case, the application exits this function.</li></ul>


<pre class="prettyprint">
#include &lt;openssl/sha.h&gt;
#define PUSH_HASH_KEY &quot;existing_push_reg_id&quot;

static void _send_reg_id_if_necessary(const char *reg_id)
{
&nbsp;&nbsp;&nbsp;unsigned char md[SHA_DIGEST_LENGTH];
&nbsp;&nbsp;&nbsp;char hash_string[2*SHA_DIGEST_LENGTH+1];
&nbsp;&nbsp;&nbsp;char *buf_ptr = hash_string;
&nbsp;&nbsp;&nbsp;char *stored_hash_value = NULL;
&nbsp;&nbsp;&nbsp;int ret, i;

&nbsp;&nbsp;&nbsp;// Generate a hash string from reg_id
&nbsp;&nbsp;&nbsp;SHA1((unsigned char *)reg_id, sizeof(reg_id), md);

&nbsp;&nbsp;&nbsp;// Convert byte array to hex string
&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; SHA_DIGEST_LENGTH; i++)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf_ptr += sprintf(buf_ptr, &quot;%02X&quot;, md[i]);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;hash_string[2*SHA_DIGEST_LENGTH] = &#39;\0&#39;;

&nbsp;&nbsp;&nbsp;// Get the saved hash string
&nbsp;&nbsp;&nbsp;ret = preference_get_string(PUSH_HASH_KEY, &amp;stored_hash_value);

&nbsp;&nbsp;&nbsp;// If there is no hash string stored before or
&nbsp;&nbsp;&nbsp;// if the stored hash string is different from the new one,
&nbsp;&nbsp;&nbsp;// send reg_id to the server
&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE || strncmp(stored_hash_value, hash_string, 2*SHA_DIGEST_LENGTH) !=0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation here to send reg_id to your application server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = _send_reg_id(reg_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If reg_id is successfully sent, store the new hash value.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!ret) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = preference_set_string(PUSH_HASH_KEY, hash_string);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (stored_hash_value) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(stored_hash_value);

&nbsp;&nbsp;&nbsp;return;
}
</pre>
</li>

<li>Request deregistration.
<p>When your application no longer wants to receive push notifications, use the following function to request deregistration:</p>

<pre class="prettyprint">
push_service_deregister(push_conn, _dereg_result_cb, NULL);
</pre>

<p>This function is non-blocking. If <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> returns from this function, the request is successfully received by the push service. The result of this request is returned in the <span style="font-family: Courier New,Courier,monospace;">_dereg_result_cb()</span> callback function. The third argument is the pointer to the user data which is handed over to the result function.</p>

<p>Note that the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function is not used, if the application is intended to receive push notifications while being installed. If the application is uninstalled, the push service detects the event and deregisters the application automatically. In contrast, if the application wants to receive push notifications only when a user logs in, the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function must be called whenever a user logs out.</p>
</li>
</ol>

	</div>
		</li>		
		<li>
			<div class="devicespec-tit">
 <h2 id="send" name="send" class="items-tit-h2">Sending Push Notifications</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>Once your application successfully sends its registration ID to your application server, you are ready to send push notifications from your application server to the application on that particular device. In this tutorial, a simple instruction for sending a push notification to 1 device is provided. For advanced features, refer to the detailed guide from the push server team.</p>

<p>To send push notifications:</p>

<ul class="ul">
<li>Determine the RQM server.
 <p>The request manager (RQM) servers collect your push notifications before sending them to your applications. The RQM server must be chosen based on the first 2 digits of the registration ID.</p>
 
<table>
<caption>Table: RQM servers</caption>
<tbody>
<tr>
 <th>Prefix of the <span style="font-family: Courier New,Courier,monospace;">regId</span></th>
 <th>Region</th>
 <th>URL</th>
</tr>
<tr>
 <td>00</td>
 <td>US East</td>
 <td>https://useast.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>01</td>
 <td>US West</td>
 <td>https://uswest.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>02</td>
 <td>Asia Pacific Southeast</td>
 <td>https://apsoutheast.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>03</td>
 <td>EU West</td>
 <td>https://euwest.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>04</td>
 <td>Asia Pacific Northeast</td>
 <td>https://apnortheast.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>05</td>
 <td>Korea</td>
 <td>https://apkorea.push.samsungosp.com:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>06</td>
 <td>China</td>
 <td>https://apchina.push.samsungosp.com.cn:8088/spp/pns/api/push</td>
</tr>
<tr>
 <td>7C</td>
 <td>Staging (AP Northeast)</td>
 <td>https://175.41.248.50:8088/spp/pns/api/push</td>
</tr>
</tbody>
</table>

<p>For instance, if the registration ID of the application that you want to send a notification to begins with 04, the URL of the RQM server must be <span style="font-family: Courier New,Courier,monospace;">https://apnortheast.push.samsungosp.com:8088/spp/pns/api/push</span>.</p>
</li>

<li>Create the notification message.
<p>A message is one of the fields that constitute a notification. This message field contains not only the message to show in the quick panel on the device, but also the behaviors that the device should take when receiving the notification. This message field is a string that consists of key-value pairs. The available options are given in the following table.</p>

<table>
<caption>Table: Message key-value pairs</caption>
<tbody>
<tr>
 <th>Key</th>
 <th>Value</th>
 <th>Description</th>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">action</span></td>
 <td>ALERT: Store the message and alert the user.
	<p>SILENT: Store the message without alerting the user.</p>
	<p>DISCARD: Discard the message.</p>
	<p>LAUNCH: Forcibly launch the app and deliver the notification.</p></td>
 <td>Action to be performed if the application is not running. If action is not included, the default behavior is SILENT.</td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">alertMessage</span></td>
 <td>Up to 127 bytes</td>
 <td>Alert message shown to the user in the quick panel. If the action is not set as ALERT, this value is meaningless.</td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">badgeOption</span></td>
 <td>INCREASE: Increase the badge number by the given value.
	<p>DECREASE: Decrease the badge number by the given value.</p>
	<p>SET: Set badge number to the given value.</p></td>
 <td>Option for updating the icon badge number. If the action is set as DISCARD, the <span style="font-family: Courier New,Courier,monospace;">badgeOption</span> is ignored. If it is not included, the icon badge number remains unchanged.</td>
</tr>
<tr>
 <td>badgeNumber</td>
 <td>0-999</td>
  <td>-</td>
</tr>
</tbody>
</table>

<p>For example, to show a &quot;Hi&quot; message in the quick panel and increase the badge count by 1 when the notification arrives at the device, the message field of the notification must be as follows:</p>

<pre class="prettyprint">&quot;badgeOption=INCREASE&amp;badgeNumber=1&amp;action=ALERT&amp;alertMessage=Hi&quot;</pre>

<p>Note that this message field takes effect only when your application is not running (more precisely, when your application is not connected to the push service.) If a notification with the above message field arrives at the device where the application is running, the push service delivers the notification directly to the application, neither showing the &quot;Hi&quot; message in the quick panel nor increasing the badge count.</p>
</li>

<li>Send notifications.
<p>With the message field that you just created, you can construct a notification using a JSON query and send it to the RQM server using the POST method. The following list contains the details:</p>
<ul class="ul">
<li>URI: URI of the RQM server chosen based on the first 2 digits of the registration ID</li>
<li>Method: POST</li>
<li>Data: JSON </li>
<li>Description: Request a notification push to a push client</li>
<li>Note: Total request message body must be less than the system default value, 200 kb. If not, &quot;3034 – error of too long chuned message data&quot; is returned. System default value can be changed as needed.</li>
<li>Header

<p>There are 2 required fields: <span style="font-family: Courier New,Courier,monospace;">appID</span> and <span style="font-family: Courier New,Courier,monospace;">appSecret</span>.</p>

<p>The fields are given when you register your application, and they are used for application authentication. If either is missing, the push server rejects the request and returns &quot;3046 – error of application authentication&quot; error. Put these 2 parameters on the request header.</p>

</li>
<li>Arguments
<table>
<caption>Table: Arguments</caption>
<tbody>
<tr>
 <th>Key</th>
 <th>Description</th>
 <th>Additional information</th>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">regID</span></td>
 <td>Distinguish a recipient from other recipients by assigning a unique registration ID to each recipient. The registration ID is assigned when a third party application is installed in a device and marked to use an application service. The preloaded push client connects to the push server and registers the third party application. Then the push server returns the registration ID to the push client. The push client passes this ID to the third party application. The push server passes this registration ID to a third party server. For the rest of the applications, the third party application passes this registration ID to the third party server. This passing registration ID policy can change.</td>
 <td>required
 <p>type: String</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">requestID</span></td>
 <td>A third party server needs to assign a request ID to each request. It enables distinguishing a request from others.</td>
 <td>required
 <p>type: String</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">sender</span></td>
 <td>Information of the user who sends the notification.</td>
 <td>optional
 <p>type: String</p>
 <p>default: null</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">message</span></td>
 <td>The message the sender wants to deliver. It can be a multibyte character. It goes through the push server and push client from a third party server. The push client just passes it to the third party application so that it is needed to handle the message. 
 <p>Maximum message length must be less than 2 kb. Make sure that if there is no message and <span style="font-family: Courier New,Courier,monospace;">appData</span>, the push server rejects the message and returns an error.</p></td>
 <td>conditionally mandatory
(if <span style="font-family: Courier New,Courier,monospace;">appData</span> is null, this field is required)
<p>type: String</p>
<p>default: null</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">appData</span></td>
 <td>Third party applications can use this field to carry their own data. It is dependent on the type described below. 
 <p>Make sure that if there is no message and no <span style="font-family: Courier New,Courier,monospace;">appData</span>, the push server rejects the message and returns an error.</p></td>
 <td>conditionally mandatory
(if message is null, this field is required)
 <p>type: String</p>
 <p>default: null</p></td>
</tr>

<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">type</span></td>
 <td>This field lets the push client know how to deal with push notification messages. If this field is set to 0, it is a normal push notification to pass to an application. Number 1 is assigned for system message and 2 is assigned for errors. Between 10 and 100, they are embedded cases, such as 10: m.fluent. After a hundred, they are user-defined.</td>
 <td>optional
 <p>type: int</p>
 <p>default: 0</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">delayDate</span></td>
 <td>The time how long the server holds the request before sending the request to the push client. This is an optional field, so if this field does not exist, the server applies its default values as 0 (minute). If <span style="font-family: Courier New,Courier,monospace;">delayTime</span> is 0, the push server delivers as soon as the push server receives the notification request.</td>
 <td>optional
 <p>type: int</p>
 <p>unit: minute</p>
 <p>default: 0</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">reliableOption</span></td>
 <td>The push server guarantees reliable message delivery if the <span style="font-family: Courier New,Courier,monospace;">reliableOption</span> is set. Possible options are the following:
 <ul class="ul">
  <li><span style="font-family: Courier New,Courier,monospace;">NoReliable</span>: Do not send any acknowledgment back to a third party server and do not store the notification in the push server if the push client did not receive the notification.</li>
  <li><span style="font-family: Courier New,Courier,monospace;">Transport</span>: Send an acknowledgment back to the third party server when the push client receives the notification.</li>
  <li><span style="font-family: Courier New,Courier,monospace;">Application</span>: Send an acknowledgment back to the third party server when a third party application checks the notification.</li>
 </ul>
 <p>This is an optional field, so if this field does not exist, the server applies its default value as <span style="font-family: Courier New,Courier,monospace;">Transport</span>. An acknowledgment at this point does not mean a response to the notification request, but an acknowledgment that the push client has received the notification. This acknowledgment as a form of JSON is sent to the app server by the push server through http when the push client receives the notification.</p>
 </td>
 <td>optional
 <p>type: String</p>
 <p>default: Transport</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">sessionInfo</span></td>
 <td>Connection information of an application. 3<sup>rd</sup> party applications can define this field by themselves.</td>
 <td>optional
 <p>type: String</p>
 <p>default: null</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">timeStamp</span></td>
 <td>Server time in milliseconds when a notification request has been made.</td>
 <td>optional
 <p>type: long</p>
 <p>default: null</p></td>
</tr>
<tr>
 <td><span style="font-family: Courier New,Courier,monospace;">connectionTerm</span></td>
 <td>The option determines whether it stays registered with the push client. If the value is 0, it stays registered. If the value is 1, it does not stay registered.</td>
 <td>optional
 <p>type: int</p>
 <p>default: null</p></td>
</tr>
</tbody>
</table>
</li>

<li>Example header
<pre class="prettyprint">
appID: 1234567890987654
appSecret: dYo/o/m11gmWmjs7+5f+2zLNVOc=
</pre></li>

<li>Example request	
<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;&quot;encoding&quot; : &quot;base64&quot; // Optional
&nbsp;&nbsp;&nbsp;&quot;regID&quot; : &quot;ab123456&quot;,
&nbsp;&nbsp;&nbsp;&quot;requestID&quot; : &quot;0000001&quot;,
&nbsp;&nbsp;&nbsp;&quot;sender&quot; : &quot;oscal&quot;, // Optional
&nbsp;&nbsp;&nbsp;&quot;type&quot; : 0 // Optional
&nbsp;&nbsp;&nbsp;&quot;message&quot; : &quot;badgeOption=INCREASE&amp;badgeNumber=1&amp;action=ALERT&amp;alertMessage=Hi&quot;, // Optional
&nbsp;&nbsp;&nbsp;&quot;appData&quot; : &quot;{id:asdf&amp;passwd:1234}&quot;, // Optional, (Opaque)
&nbsp;&nbsp;&nbsp;&quot;delayDate&quot; : 60, // Optional
&nbsp;&nbsp;&nbsp;&quot;reliableOption&quot; : &quot;Transport&quot;, // Optional 
&nbsp;&nbsp;&nbsp;&quot;sessionInfo&quot; : &quot;002002&quot;, // Optional
&nbsp;&nbsp;&nbsp;&quot;timeStamp&quot; : 1234567890, // Optional
}
</pre>
</li>

<li>Example response
<p>If the push server receives a notification request, the server returns a JSON string that contains the <span style="font-family: Courier New,Courier,monospace;">regID</span>, <span style="font-family: Courier New,Courier,monospace;">requestID</span>, status code, and status message. If the request contains a malformed JSON format, requests are not processed and are returned without the <span style="font-family: Courier New,Courier,monospace;">regID</span> and <span style="font-family: Courier New,Courier,monospace;">requestID</span> values. If the request is of the JSON format but has invalid data, no requests are processed and are considered as an error. This return message only shows whether receiving notification request was successful. This return message does not deal with whether the push client receives the notification. The order of the return message is the same as the request message order.</p>

<p>The following example is shown if the request is successful:</p>
<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;&quot;results&quot;:
&nbsp;&nbsp;&nbsp;[{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;regID&quot;:&quot;ab123456&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;requestID&quot;:&quot;0000001&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusCode&quot;:1000,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusMsg&quot;:&quot;Success&quot;
&nbsp;&nbsp;&nbsp;}]
}
</pre>
<p>The following example is shown if the request fails due to malformation:</p>
<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;&quot;results&quot;:
&nbsp;&nbsp;&nbsp;[{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;regID&quot;:&quot;&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;requestID&quot;:&quot;&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusCode&quot;:3023,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusMsg&quot;:&quot;error of json mapping exception&quot;
&nbsp;&nbsp;&nbsp;}]
}
</pre><p>The following example is shown if the request fails due to abnormal data:</p>
<pre class="prettyprint">
{
&nbsp;&nbsp;&nbsp;&quot;results&quot;:
&nbsp;&nbsp;&nbsp;[{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;regID&quot;:&quot;ab123456&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;requestID&quot;:&quot;0000001&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusCode&quot;:3008,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;statusMsg&quot;:&quot;error of not registered regID&quot;
&nbsp;&nbsp;&nbsp;}]
}
</pre>
</li>
</ul>
</li>
</ul>
	</div>
		</li>		
		<li>
			<div class="devicespec-tit">
 <h2 id="dealing" name="dealing" class="items-tit-h2">Handling Push Notifications</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>When a notification arrives at the device, it is delivered to the destination application in a manner that depends on whether the application is running.</p>

<p>To handle incoming push notifications:</p>

<ul class="ul">
<li id="receive" name="receive">Receive notifications when the application is running.
<p>When a notification arrives to your application while it is running (precisely, your application is connected to the service), the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function is called as defined in the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. In this callback function, you can handle the received notification. The following example shows how your application can retrieve the app data (payload), message, and timestamp from the received notification:</p>

<pre class="prettyprint">
static void _noti_cb(push_service_notification_h noti, void *user_data)
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;char *data=NULL; // App data loaded on the notification
&nbsp;&nbsp;&nbsp;char *msg=NULL; // Noti message
&nbsp;&nbsp;&nbsp;long long int time_stamp; // Time when the noti is generated
&nbsp;&nbsp;&nbsp;char *sender=NULL; // Optional sender information
&nbsp;&nbsp;&nbsp;char *session_info=NULL; // Optional session information
&nbsp;&nbsp;&nbsp;char *request_id=NULL; // Optional request ID
&nbsp;&nbsp;&nbsp;int type=0; // Optional type information

&nbsp;&nbsp;&nbsp;// Retrieve app data from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_data(noti, &amp;data);
&nbsp;&nbsp;&nbsp;// Your logic here to decrypt app data if it is encrypted

&nbsp;&nbsp;&nbsp;// Retrieve notification message from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_message(noti, &amp;msg);

&nbsp;&nbsp;&nbsp;// Retrieve the time when notification is created from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_time(noti, &amp;time_stamp);

&nbsp;&nbsp;&nbsp;// Retrieve the optional information
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_sender(noti, &amp;sender);
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_session_info(noti, &amp;session_info);
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_request_id(noti, &amp;request_id);
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_type(noti, &amp;type);

&nbsp;&nbsp;&nbsp;// Your implementation here to use data, msg, time_stamp, sender,
&nbsp;&nbsp;&nbsp;// session_info, request_id, and type

&nbsp;&nbsp;&nbsp;// Free all resources
&nbsp;&nbsp;&nbsp;// Do not free noti in the callback function
&nbsp;&nbsp;&nbsp;if (data)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(data);
&nbsp;&nbsp;&nbsp;if (msg)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(msg);
&nbsp;&nbsp;&nbsp;if (sender)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(sender);
&nbsp;&nbsp;&nbsp;if (session_info)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(session_info);
&nbsp;&nbsp;&nbsp;if (request_id)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(request_id);
}
</pre>

<p>When the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function is called, obtain the notification through the first parameter. The second parameter is the pointer to the user data. You can retrieve the app data, message, and time stamp from the handle using the <span style="font-family: Courier New,Courier,monospace;">push_get_notification_data()</span>, <span style="font-family: Courier New,Courier,monospace;">push_get_notification_message()</span>, and <span style="font-family: Courier New,Courier,monospace;">push_get_notification_time()</span> functions respectively. Before exiting the function, free the data. However, do not free <span style="font-family: Courier New,Courier,monospace;">noti</span> in the notification callback function. It is freed automatically right after this callback function.</p>
</li>

<li>Receive notifications when the application is not running.
<p>If the notification arrives when your application is not running, there are 3 ways to handle the notification:</p>
<ul class="ul">
<li>Forcibly launch the application and deliver the notification to it.</li>
<li>Store the notification at the push service database and request it later when the application is launched.</li>
<li>Discard it.</li>
</ul>

<p>For the first option, you need to set the action to LAUNCH in the message field when sending the notification from the application server.</p>

<p>When such notification action arrives at the device, the push service forcibly launches your application and delivers the notification as a bundle. To retrieve the notification when launched, call the <span style="font-family: Courier New,Courier,monospace;">push_service_app_control_to_notification()</span> function in the <span style="font-family: Courier New,Courier,monospace;">app_control()</span> function, which is a callback function that is triggered when your application is launched by another application or process.
</p>

<pre class="prettyprint">
static void app_control(app_control_h app_control, void *data)
{
&nbsp;&nbsp;&nbsp;char *op = NULL;
&nbsp;&nbsp;&nbsp;push_service_notification_h noti = NULL;
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;if (app_control_get_operation(app_control, &amp;op) &lt; 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
	
&nbsp;&nbsp;&nbsp;// Retrieve noti from the bundle
&nbsp;&nbsp;&nbsp;ret = push_service_app_control_to_notification(app_control, op, &amp;noti);

&nbsp;&nbsp;&nbsp;if (noti)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation for handling noti

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Free the noti
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push_service_free_notification(noti);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation for the case when 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this app is not launched by the push service
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (op)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(op);
}
</pre>

<p>When you create your project in the SDK, the <span style="font-family: Courier New,Courier,monospace;">app_control()</span> function is created automatically. When your application is launched by the push service, all related information regarding this launch request is delivered through the <span style="font-family: Courier New,Courier,monospace;">app_control</span> argument. From this handle, retrieve the <span style="font-family: Courier New,Courier,monospace;">op</span> operation using the <span style="font-family: Courier New,Courier,monospace;">app_control_get_operation()</span> function. With <span style="font-family: Courier New,Courier,monospace;">app_control</span> and <span style="font-family: Courier New,Courier,monospace;">op</span>, retrieve the notification data using the <span style="font-family: Courier New,Courier,monospace;">push_service_app_control_to_noti_data()</span> function. If your application is not launched by the push service, this function returns as <span style="font-family: Courier New,Courier,monospace;">NULL</span>.</p>

<p>For the second option, you need to set the action to <span style="font-family: Courier New,Courier,monospace;">ALERT</span> or <span style="font-family: Courier New,Courier,monospace;">SILENT</span> in the message field when sending the notification from the application server. When such a notification arrives at the device, the push service keeps the notification in the database and waits for the request from the application. The difference of the 2 options is that the former shows the alert message in the quick panel and changes the badge count while the latter does not. If the user clicks the message in the quick panel, the push service forcibly launches the application and delivers the notification through the app control callback function as in the first option. </p>

<p>For the last option, you need to set the action to <span style="font-family: Courier New,Courier,monospace;">DISCARD</span> in the message field when sending the notification from the application server. When such a notification arrives at the device, the push service discards the notification unless the application is running.</p>
</li>

<li>Request unread notifications.

<p>If the user does not launch the application from the quick panel, the application requests the unread notifications after start-up using the <span style="font-family: Courier New,Courier,monospace;">push_service_request_unread_notification()</span> function as <a href="#upon">already introduced</a>. The synchronous request using the <span style="font-family: Courier New,Courier,monospace;">push_service_get_unread_notification()</span> function is shown below:
</p>

<pre class="prettyprint">
push_service_notification_h noti;
int ret;
do 
{
&nbsp;&nbsp;&nbsp;ret = push_service_get_unread_notification(push_conn, &amp;noti);

&nbsp;&nbsp;&nbsp;// Your implementation to process unread message noti

&nbsp;&nbsp;&nbsp;push_server_free_notification(&amp;noti);
} while (1);
</pre>

<p>Call this function repeatedly until no notification is returned. If there are multiple unread notifications, the notifications are retrieved in their arrival order. Note that the <span style="font-family: Courier New,Courier,monospace;">push_server_free_notification()</span> function blocks the code while it receives a notification from the service. Unless you need a synchronous behavior, the asynchronous function is recommended.</p>


</li>
</ul>
	</div>
		</li>		
		<li>
			<div class="devicespec-tit">
 <h2 id="security" name="security" class="items-tit-h2">Managing Security</h2>
<span class="fr"><a href="#" class="bt-arr"><em>Hide</em></a></span>
  </div>
			<div class="devicespec-con"> 
<p>When you send a notification with sensitive information, be aware of the chance that the notification is hijacked by someone else. It is your responsibility to keep such sensitive information safe from malicious access. The following instructions are strongly recommended:</p>

<ul class="ul">
<li>Keep your push app ID confidential. <p>If it is exposed, hackers can try to hijack your notifications using a fake application with the exposed ID.</p></li>
<li>Do not store the registration ID on the device. <p>This ID can be seen as a destination address of the notifications. Without this ID, hackers cannot send fake notifications to your application.</p></li>
<li>Encrypt sensitive information. <p>When you send sensitive information, such as personal information and financial transactions, encrypt it and load it to the notification as a payload. Do not load the information to the message field of the notification. When the notification arrives at the device, your application decrypts the payload and retrieves the sensitive information.</p></li>
<li>Do not hardcode your AppSecret in your source code. <p>The AppSecret is a key to accessing the push server for sending notifications. If notifications are sent from your application server, your application does not need to know the AppSecret at all. Keep the AppSecret in the server and do not load any related information in your application. If you want device-to-device notification delivery without your application server, your application needs the AppSecret to send a notification from a device. In this case, it is your responsibility to keep the AppSecret safe.</p></li>
</ul>
	</div>
		</li>				
	</ul>	
</div>				
</div>
		  
<script type="text/javascript" src="../../scripts/jquery.zclip.min.js"></script>
<script type="text/javascript" src="../../scripts/showhide.js"></script>

</div></div></div>

<a class="top sms" href="#"><img src="../../images/btn_top.gif" alt="Go to top" /></a>

<div id="footer">
<p class="footer">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</p>
</div>

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

 </body>
</html>